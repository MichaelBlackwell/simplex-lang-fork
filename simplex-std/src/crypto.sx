// simplex-std::crypto - Cryptographic Utilities
//
// Cryptographic functions for hashing, encoding, random generation, and security.
//
// # Hashing
// - `sha256`, `sha512`: Secure hash functions
// - `hmac_sha256`: Message authentication codes
// - `fnv1a`: Fast non-cryptographic hash
//
// # Encoding
// - `bytes_to_hex`, `hex_to_bytes`: Hex encoding
// - `base64_encode`, `base64_decode`: Base64 encoding
//
// # Random
// - `random_bytes`: Cryptographically secure random bytes
//
// # Security
// - `constant_time_eq`: Timing-safe comparison
// - `hash_password`, `verify_password`: Password utilities

// =============================================================================
// SHA-256
// =============================================================================

/// Compute SHA-256 hash of data.
pub fn sha256(data: &[u8]) -> [u8; 32] {
    unsafe {
        let mut result = [0u8; 32];
        crypto_sha256(data.as_ptr(), data.len() as i64, result.as_mut_ptr());
        result
    }
}

/// Compute SHA-256 hash of a string.
pub fn sha256_str(s: &str) -> [u8; 32] {
    sha256(s.as_bytes())
}

/// Compute SHA-256 hash and return as hex string.
pub fn sha256_hex(data: &[u8]) -> String {
    let hash = sha256(data);
    bytes_to_hex(&hash)
}

// =============================================================================
// Hex Encoding
// =============================================================================

/// Convert bytes to hex string.
pub fn bytes_to_hex(bytes: &[u8]) -> String {
    const HEX_CHARS: &[u8] = b"0123456789abcdef";
    var result = String::with_capacity(bytes.len() * 2);
    for &b in bytes {
        result.push(HEX_CHARS[(b >> 4) as usize] as char);
        result.push(HEX_CHARS[(b & 0xf) as usize] as char);
    }
    result
}

/// Convert hex string to bytes.
pub fn hex_to_bytes(hex: &str) -> Option<Vec<u8>> {
    if hex.len() % 2 != 0 {
        return None;
    }

    var result = Vec::with_capacity(hex.len() / 2);
    var chars = hex.chars();

    while let (Some(hi), Some(lo)) = (chars.next(), chars.next()) {
        let hi_val = hex_char_to_val(hi)?;
        let lo_val = hex_char_to_val(lo)?;
        result.push((hi_val << 4) | lo_val);
    }

    Some(result)
}

fn hex_char_to_val(c: char) -> Option<u8> {
    match c {
        '0'..='9' => Some(c as u8 - b'0'),
        'a'..='f' => Some(c as u8 - b'a' + 10),
        'A'..='F' => Some(c as u8 - b'A' + 10),
        _ => None,
    }
}

// =============================================================================
// Simple Hash Functions
// =============================================================================

/// FNV-1a hash (fast, non-cryptographic).
pub fn fnv1a(data: &[u8]) -> u64 {
    const FNV_OFFSET: u64 = 14695981039346656037;
    const FNV_PRIME: u64 = 1099511628211;

    var hash = FNV_OFFSET;
    for &byte in data {
        hash ^= byte as u64;
        hash = hash.wrapping_mul(FNV_PRIME);
    }
    hash
}

/// FNV-1a hash of a string.
pub fn fnv1a_str(s: &str) -> u64 {
    fnv1a(s.as_bytes())
}

// =============================================================================
// SHA-512
// =============================================================================

/// Compute SHA-512 hash of data.
pub fn sha512(data: &[u8]) -> [u8; 64] {
    unsafe {
        let mut result = [0u8; 64];
        crypto_sha512(data.as_ptr(), data.len() as i64, result.as_mut_ptr());
        result
    }
}

/// Compute SHA-512 hash of a string.
pub fn sha512_str(s: &str) -> [u8; 64] {
    sha512(s.as_bytes())
}

/// Compute SHA-512 hash and return as hex string.
pub fn sha512_hex(data: &[u8]) -> String {
    let hash = sha512(data);
    bytes_to_hex(&hash)
}

// =============================================================================
// HMAC-SHA256
// =============================================================================

/// Compute HMAC-SHA256 message authentication code.
///
/// # Arguments
/// - `key`: The secret key
/// - `message`: The message to authenticate
///
/// # Example
/// ```simplex
/// let mac = hmac_sha256(b"secret", b"hello");
/// ```
pub fn hmac_sha256(key: &[u8], message: &[u8]) -> [u8; 32] {
    unsafe {
        let mut result = [0u8; 32];
        crypto_hmac_sha256(
            key.as_ptr(), key.len() as i64,
            message.as_ptr(), message.len() as i64,
            result.as_mut_ptr()
        );
        result
    }
}

/// Compute HMAC-SHA256 and return as hex string.
pub fn hmac_sha256_hex(key: &[u8], message: &[u8]) -> String {
    let mac = hmac_sha256(key, message);
    bytes_to_hex(&mac)
}

// =============================================================================
// Base64 Encoding
// =============================================================================

const BASE64_CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/// Encode bytes as Base64.
///
/// # Example
/// ```simplex
/// let encoded = base64_encode(b"hello");
/// assert_eq!(encoded, "aGVsbG8=");
/// ```
pub fn base64_encode(data: &[u8]) -> String {
    var result = String::new();
    var i = 0usize;
    let len = data.len();

    while i + 3 <= len {
        let b0 = data[i] as u32;
        let b1 = data[i + 1] as u32;
        let b2 = data[i + 2] as u32;

        let combined = (b0 << 16) | (b1 << 8) | b2;

        result.push(BASE64_CHARS[((combined >> 18) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[((combined >> 12) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[((combined >> 6) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[(combined & 0x3F) as usize] as char);

        i += 3;
    }

    // Handle remaining bytes
    let remaining = len - i;
    if remaining == 1 {
        let b0 = data[i] as u32;
        result.push(BASE64_CHARS[((b0 >> 2) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[((b0 << 4) & 0x3F) as usize] as char);
        result.push('=');
        result.push('=');
    } else if remaining == 2 {
        let b0 = data[i] as u32;
        let b1 = data[i + 1] as u32;
        result.push(BASE64_CHARS[((b0 >> 2) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[(((b0 << 4) | (b1 >> 4)) & 0x3F) as usize] as char);
        result.push(BASE64_CHARS[((b1 << 2) & 0x3F) as usize] as char);
        result.push('=');
    }

    result
}

/// Decode Base64 string to bytes.
///
/// Returns None if the input is invalid Base64.
pub fn base64_decode(encoded: &str) -> Option<Vec<u8>> {
    let bytes = encoded.as_bytes();
    let len = bytes.len();

    if len % 4 != 0 {
        return None;
    }

    var result = Vec::new();
    var i = 0usize;

    while i < len {
        let c0 = base64_char_value(bytes[i])?;
        let c1 = base64_char_value(bytes[i + 1])?;

        let b0 = (c0 << 2) | (c1 >> 4);
        result.push(b0);

        if bytes[i + 2] != b'=' {
            let c2 = base64_char_value(bytes[i + 2])?;
            let b1 = ((c1 & 0xF) << 4) | (c2 >> 2);
            result.push(b1);

            if bytes[i + 3] != b'=' {
                let c3 = base64_char_value(bytes[i + 3])?;
                let b2 = ((c2 & 0x3) << 6) | c3;
                result.push(b2);
            }
        }

        i += 4;
    }

    Some(result)
}

fn base64_char_value(c: u8) -> Option<u8> {
    match c {
        b'A'..=b'Z' => Some(c - b'A'),
        b'a'..=b'z' => Some(c - b'a' + 26),
        b'0'..=b'9' => Some(c - b'0' + 52),
        b'+' => Some(62),
        b'/' => Some(63),
        b'=' => Some(0), // Padding, handled separately
        _ => None,
    }
}

// =============================================================================
// Secure Random
// =============================================================================

/// Generate cryptographically secure random bytes.
///
/// # Example
/// ```simplex
/// let key = random_bytes(32);  // 256-bit key
/// ```
pub fn random_bytes(count: usize) -> Vec<u8> {
    var result = Vec::with_capacity(count);
    result.resize(count, 0u8);
    unsafe {
        crypto_random_bytes(result.as_mut_ptr(), count as i64);
    }
    result
}

/// Generate random bytes and return as hex string.
pub fn random_hex(count: usize) -> String {
    let bytes = random_bytes(count);
    bytes_to_hex(&bytes)
}

/// Generate random bytes and return as base64 string.
pub fn random_base64(count: usize) -> String {
    let bytes = random_bytes(count);
    base64_encode(&bytes)
}

// =============================================================================
// Constant-Time Comparison
// =============================================================================

/// Compare two byte slices in constant time.
///
/// This prevents timing attacks when comparing secrets like hashes or tokens.
///
/// # Example
/// ```simplex
/// let valid = constant_time_eq(&computed_hash, &expected_hash);
/// ```
pub fn constant_time_eq(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }

    var result = 0u8;
    for i in 0..a.len() {
        result |= a[i] ^ b[i];
    }
    result == 0
}

/// Compare two strings in constant time.
pub fn constant_time_eq_str(a: &str, b: &str) -> bool {
    constant_time_eq(a.as_bytes(), b.as_bytes())
}

// =============================================================================
// Password Hashing (Simple)
// =============================================================================

/// Hash a password with salt using SHA-256.
///
/// Note: For production, use a proper KDF like bcrypt or argon2.
/// This is a simple implementation for basic use cases.
///
/// # Example
/// ```simplex
/// let salt = random_hex(16);
/// let hash = hash_password("secret", &salt);
/// ```
pub fn hash_password(password: &str, salt: &str) -> String {
    var combined = String::from(salt);
    combined.push_str(password);
    sha256_hex(combined.as_bytes())
}

/// Verify a password against a hash.
pub fn verify_password(password: &str, salt: &str, expected_hash: &str) -> bool {
    let computed = hash_password(password, salt);
    constant_time_eq_str(&computed, expected_hash)
}

// =============================================================================
// Bcrypt Password Hashing
// =============================================================================

/// Hash a password using bcrypt.
///
/// # Arguments
/// - `password`: The password to hash
/// - `cost`: The work factor (4-31, recommended 10-12)
///
/// # Example
/// ```simplex
/// let hash = bcrypt_hash("secret", 12)?;
/// ```
pub fn bcrypt_hash(password: &str, cost: u32) -> Result<String, CryptoError> {
    unsafe {
        let mut result = [0u8; 60];  // Bcrypt hash is always 60 bytes
        let ret = crypto_bcrypt_hash(
            password.as_ptr(),
            password.len() as i64,
            cost,
            result.as_mut_ptr()
        );
        if ret < 0 {
            return Err(CryptoError::HashError("bcrypt hash failed".to_string()));
        }
        Ok(String::from_utf8_lossy(&result[..ret as usize]).to_string())
    }
}

/// Verify a password against a bcrypt hash.
///
/// # Arguments
/// - `password`: The password to verify
/// - `hash`: The bcrypt hash to verify against
///
/// # Example
/// ```simplex
/// if bcrypt_verify("secret", &hash)? {
///     println!("Password matches!");
/// }
/// ```
pub fn bcrypt_verify(password: &str, hash: &str) -> Result<bool, CryptoError> {
    unsafe {
        let ret = crypto_bcrypt_verify(
            password.as_ptr(),
            password.len() as i64,
            hash.as_ptr(),
            hash.len() as i64
        );
        if ret < 0 {
            return Err(CryptoError::VerifyError("bcrypt verify failed".to_string()));
        }
        Ok(ret == 1)
    }
}

// =============================================================================
// Token Generation
// =============================================================================

/// Generate a cryptographically secure random token.
///
/// Returns a hex-encoded string of the specified byte length.
///
/// # Arguments
/// - `byte_len`: Number of random bytes (token will be 2x this length in hex)
///
/// # Example
/// ```simplex
/// let token = generate_token(32);  // 64-char hex string
/// ```
pub fn generate_token(byte_len: usize) -> String {
    random_hex(byte_len)
}

// =============================================================================
// Error Types
// =============================================================================

#[derive(Debug, Clone)]
pub enum CryptoError {
    HashError(String),
    VerifyError(String),
}

impl std::fmt::Display for CryptoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CryptoError::HashError(msg) => write!(f, "hash error: {}", msg),
            CryptoError::VerifyError(msg) => write!(f, "verify error: {}", msg),
        }
    }
}

impl std::error::Error for CryptoError {}

// =============================================================================
// FFI Declarations
// =============================================================================

extern "C" {
    fn crypto_sha256(data: *const u8, len: i64, out: *mut u8);
    fn crypto_sha512(data: *const u8, len: i64, out: *mut u8);
    fn crypto_hmac_sha256(key: *const u8, key_len: i64, msg: *const u8, msg_len: i64, out: *mut u8);
    fn crypto_random_bytes(out: *mut u8, count: i64);
    fn crypto_bcrypt_hash(password: *const u8, password_len: i64, cost: u32, out: *mut u8) -> i64;
    fn crypto_bcrypt_verify(password: *const u8, password_len: i64, hash: *const u8, hash_len: i64) -> i64;
}
