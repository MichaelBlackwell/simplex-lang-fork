// simplex-std::fmt - Formatting and Printing
//
// Utilities for formatting values and printing output.
//
// # Functions
//
// - `print`, `println`: Basic printing
// - `printf`: Formatted printing with placeholders
// - `format!`: Format macro (returns String)
// - `write!`: Write formatted output to a buffer
//
// # Format Specifiers
//
// - `{}`: Default display formatting
// - `{:?}`: Debug formatting
// - `{:d}` or `{:i}`: Integer (decimal)
// - `{:x}`: Integer (lowercase hexadecimal)
// - `{:X}`: Integer (uppercase hexadecimal)
// - `{:o}`: Integer (octal)
// - `{:b}`: Integer (binary)
// - `{:f}`: Float (decimal)
// - `{:e}`: Float (scientific notation)
// - `{:s}`: String
// - `{:c}`: Character
// - `{:p}`: Pointer
// - `{:n}`: Named argument
//
// # Width and Precision
//
// - `{:10}`: Minimum width of 10
// - `{:.5}`: Precision of 5
// - `{:10.5}`: Width 10, precision 5
// - `{:<10}`: Left align
// - `{:>10}`: Right align (default)
// - `{:^10}`: Center align
// - `{:0>10}`: Pad with zeros
//
// # Example
//
// ```simplex
// println(&format!("Hello, {}!", name));
// printf("Value: {}, Hex: {:x}\n", value, value);
// ```

use super::collections::Vec;

// =============================================================================
// Basic Printing
// =============================================================================

/// Print a string without newline.
pub fn print(s: &str) {
    unsafe { io_print(s.as_ptr(), s.len() as i64) }
}

/// Print a string with newline.
pub fn println(s: &str) {
    print(s);
    print("\n");
}

/// Print an empty newline.
pub fn newline() {
    print("\n");
}

/// Eprint - print to stderr.
pub fn eprint(s: &str) {
    unsafe { io_eprint(s.as_ptr(), s.len() as i64) }
}

/// Eprintln - print to stderr with newline.
pub fn eprintln(s: &str) {
    eprint(s);
    eprint("\n");
}

// =============================================================================
// Printf - Formatted Printing
// =============================================================================

/// Printf with format specifiers.
///
/// Supported specifiers:
/// - `%s`: String
/// - `%d`, `%i`: Signed integer (decimal)
/// - `%u`: Unsigned integer (decimal)
/// - `%x`: Lowercase hexadecimal
/// - `%X`: Uppercase hexadecimal
/// - `%o`: Octal
/// - `%b`: Binary
/// - `%f`: Float (default 6 decimal places)
/// - `%e`, `%E`: Scientific notation
/// - `%c`: Character
/// - `%p`: Pointer (hex)
/// - `%%`: Literal percent sign
///
/// Width and precision: `%10d`, `%.5f`, `%10.5f`
/// Flags: `%-` (left align), `%+` (force sign), `%0` (zero pad), `% ` (space for positive)
pub fn printf(fmt: &str, args: &[&dyn Formattable]) {
    let result = sprintf(fmt, args);
    print(&result);
}

/// Sprintf - format to a string.
pub fn sprintf(fmt: &str, args: &[&dyn Formattable]) -> String {
    let mut result = String::new();
    let mut arg_index = 0;
    let chars: Vec<char> = fmt.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        if chars[i] == '%' && i + 1 < chars.len() {
            i += 1;

            // Check for %%
            if chars[i] == '%' {
                result.push('%');
                i += 1;
                continue;
            }

            // Parse format specifier
            let spec = parse_format_spec(&chars, &mut i);

            if arg_index < args.len() {
                let formatted = args[arg_index].format_with(&spec);
                result.push_str(&formatted);
                arg_index += 1;
            }
        } else {
            result.push(chars[i]);
            i += 1;
        }
    }

    result
}

/// Format specifier parsed from format string.
pub struct FormatSpec {
    /// Type specifier: 's', 'd', 'x', 'f', etc.
    pub spec_type: char,
    /// Minimum width
    pub width: Option<i64>,
    /// Precision (for floats: decimal places, for strings: max length)
    pub precision: Option<i64>,
    /// Left align (default is right)
    pub left_align: bool,
    /// Pad with zeros
    pub zero_pad: bool,
    /// Show sign for positive numbers
    pub show_sign: bool,
    /// Use space for positive numbers
    pub space_sign: bool,
    /// Alternate form (#)
    pub alternate: bool,
    /// Uppercase (for hex)
    pub uppercase: bool,
}

impl FormatSpec {
    pub fn default() -> FormatSpec {
        FormatSpec {
            spec_type: 's',
            width: None,
            precision: None,
            left_align: false,
            zero_pad: false,
            show_sign: false,
            space_sign: false,
            alternate: false,
            uppercase: false,
        }
    }
}

fn parse_format_spec(chars: &[char], i: &mut usize) -> FormatSpec {
    let mut spec = FormatSpec::default();

    // Parse flags
    while *i < chars.len() {
        match chars[*i] {
            '-' => { spec.left_align = true; *i += 1; }
            '+' => { spec.show_sign = true; *i += 1; }
            ' ' => { spec.space_sign = true; *i += 1; }
            '#' => { spec.alternate = true; *i += 1; }
            '0' => { spec.zero_pad = true; *i += 1; }
            _ => break,
        }
    }

    // Parse width
    if *i < chars.len() && chars[*i].is_ascii_digit() && chars[*i] != '0' {
        let mut width = 0i64;
        while *i < chars.len() && chars[*i].is_ascii_digit() {
            width = width * 10 + (chars[*i] as i64 - '0' as i64);
            *i += 1;
        }
        spec.width = Some(width);
    }

    // Parse precision
    if *i < chars.len() && chars[*i] == '.' {
        *i += 1;
        let mut precision = 0i64;
        while *i < chars.len() && chars[*i].is_ascii_digit() {
            precision = precision * 10 + (chars[*i] as i64 - '0' as i64);
            *i += 1;
        }
        spec.precision = Some(precision);
    }

    // Parse type specifier
    if *i < chars.len() {
        spec.spec_type = chars[*i];
        if spec.spec_type == 'X' || spec.spec_type == 'E' {
            spec.uppercase = true;
        }
        *i += 1;
    }

    spec
}

// =============================================================================
// Formattable Trait
// =============================================================================

/// Trait for types that can be formatted.
pub trait Formattable {
    fn format_with(&self, spec: &FormatSpec) -> String;
}

impl Formattable for i64 {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let formatted = match spec.spec_type {
            'd' | 'i' => int_to_string_signed(*self, spec),
            'u' => int_to_string_unsigned(*self as u64, 10, false, spec),
            'x' => int_to_string_unsigned(*self as u64, 16, false, spec),
            'X' => int_to_string_unsigned(*self as u64, 16, true, spec),
            'o' => int_to_string_unsigned(*self as u64, 8, false, spec),
            'b' => int_to_string_unsigned(*self as u64, 2, false, spec),
            _ => int_to_string(*self),
        };
        apply_width_and_align(&formatted, spec)
    }
}

impl Formattable for f64 {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let precision = spec.precision.unwrap_or(6);
        let formatted = match spec.spec_type {
            'f' => float_to_string_precision(*self, precision as i32),
            'e' => float_to_scientific(*self, precision as i32, false),
            'E' => float_to_scientific(*self, precision as i32, true),
            _ => float_to_string(*self),
        };
        apply_width_and_align(&formatted, spec)
    }
}

impl Formattable for bool {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let formatted = bool_to_string(*self);
        apply_width_and_align(&formatted, spec)
    }
}

impl Formattable for &str {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let mut s = self.to_string();
        if let Some(precision) = spec.precision {
            if s.len() > precision as usize {
                s.truncate(precision as usize);
            }
        }
        apply_width_and_align(&s, spec)
    }
}

impl Formattable for String {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let mut s = self.clone();
        if let Some(precision) = spec.precision {
            if s.len() > precision as usize {
                s.truncate(precision as usize);
            }
        }
        apply_width_and_align(&s, spec)
    }
}

impl Formattable for char {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let mut s = String::new();
        s.push(*self);
        apply_width_and_align(&s, spec)
    }
}

impl<T> Formattable for *const T {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let addr = *self as u64;
        let hex = int_to_string_unsigned(addr, 16, false, &FormatSpec::default());
        let formatted = format!("0x{}", hex);
        apply_width_and_align(&formatted, spec)
    }
}

impl<T> Formattable for *mut T {
    fn format_with(&self, spec: &FormatSpec) -> String {
        let addr = *self as u64;
        let hex = int_to_string_unsigned(addr, 16, false, &FormatSpec::default());
        let formatted = format!("0x{}", hex);
        apply_width_and_align(&formatted, spec)
    }
}

fn apply_width_and_align(s: &str, spec: &FormatSpec) -> String {
    if let Some(width) = spec.width {
        let width = width as usize;
        if s.len() >= width {
            return s.to_string();
        }

        let pad_len = width - s.len();
        let pad_char = if spec.zero_pad && !spec.left_align { '0' } else { ' ' };

        if spec.left_align {
            let mut result = s.to_string();
            for _ in 0..pad_len {
                result.push(pad_char);
            }
            result
        } else {
            let mut result = String::new();
            for _ in 0..pad_len {
                result.push(pad_char);
            }
            result.push_str(s);
            result
        }
    } else {
        s.to_string()
    }
}

// =============================================================================
// Integer Formatting
// =============================================================================

fn int_to_string_signed(n: i64, spec: &FormatSpec) -> String {
    let mut result = String::new();

    if n < 0 {
        result.push('-');
        result.push_str(&int_to_string_unsigned((-n) as u64, 10, false, &FormatSpec::default()));
    } else {
        if spec.show_sign {
            result.push('+');
        } else if spec.space_sign {
            result.push(' ');
        }
        result.push_str(&int_to_string_unsigned(n as u64, 10, false, &FormatSpec::default()));
    }

    result
}

fn int_to_string_unsigned(mut n: u64, base: u64, uppercase: bool, spec: &FormatSpec) -> String {
    if n == 0 {
        return "0".to_string();
    }

    let digits = if uppercase {
        "0123456789ABCDEF"
    } else {
        "0123456789abcdef"
    };

    let mut result = Vec::new();
    while n > 0 {
        let digit = (n % base) as usize;
        result.push(digits.chars().nth(digit).unwrap());
        n /= base;
    }

    // Add prefix if alternate form
    if spec.alternate {
        match base {
            16 => {
                result.push(if uppercase { 'X' } else { 'x' });
                result.push('0');
            }
            8 => result.push('0'),
            2 => {
                result.push('b');
                result.push('0');
            }
            _ => {}
        }
    }

    // Reverse
    let mut s = String::new();
    for i in (0..result.len()).rev() {
        s.push(result[i]);
    }
    s
}

/// Format an integer as a string.
pub fn int_to_string(n: i64) -> String {
    if n == 0 {
        return "0".to_string();
    }

    let mut num = n;
    let mut negative = false;
    if num < 0 {
        negative = true;
        num = -num;
    }

    let mut digits = Vec::new();
    while num > 0 {
        digits.push(((num % 10) as u8 + b'0') as char);
        num /= 10;
    }

    if negative {
        digits.push('-');
    }

    // Reverse
    let mut result = String::new();
    for i in (0..digits.len()).rev() {
        result.push(digits[i]);
    }
    result
}

/// Format an unsigned integer as hexadecimal.
pub fn int_to_hex(n: u64, uppercase: bool) -> String {
    int_to_string_unsigned(n, 16, uppercase, &FormatSpec::default())
}

/// Format an unsigned integer as binary.
pub fn int_to_binary(n: u64) -> String {
    int_to_string_unsigned(n, 2, false, &FormatSpec::default())
}

/// Format an unsigned integer as octal.
pub fn int_to_octal(n: u64) -> String {
    int_to_string_unsigned(n, 8, false, &FormatSpec::default())
}

// =============================================================================
// Float Formatting
// =============================================================================

/// Format a float as a string.
pub fn float_to_string(f: f64) -> String {
    float_to_string_precision(f, 6)
}

/// Format a float with given precision.
pub fn float_to_string_precision(f: f64, precision: i32) -> String {
    unsafe {
        let mut buf = [0u8; 64];
        let len = float_format_precision(f, buf.as_mut_ptr(), 64, precision);
        String::from_utf8_lossy(&buf[..len as usize]).to_string()
    }
}

/// Format a float in scientific notation.
pub fn float_to_scientific(f: f64, precision: i32, uppercase: bool) -> String {
    unsafe {
        let mut buf = [0u8; 64];
        let len = float_format_scientific(f, buf.as_mut_ptr(), 64, precision, if uppercase { 1 } else { 0 });
        String::from_utf8_lossy(&buf[..len as usize]).to_string()
    }
}

// =============================================================================
// Boolean Formatting
// =============================================================================

/// Format a boolean as a string.
pub fn bool_to_string(b: bool) -> String {
    if b { "true".to_string() } else { "false".to_string() }
}

// =============================================================================
// Generic Formatting
// =============================================================================

/// Format a value as a string using Display.
pub fn format<T: Display>(value: &T) -> String {
    value.fmt()
}

/// Format a value as a debug string.
pub fn debug<T: Debug>(value: &T) -> String {
    value.debug_fmt()
}

// =============================================================================
// Vec Printing (Convenience Functions)
// =============================================================================

/// Print a vector of integers.
pub fn print_vec_i64(v: &[i64]) {
    print("[");
    for (i, item) in v.iter().enumerate() {
        if i > 0 { print(", "); }
        print(&int_to_string(*item));
    }
    println("]");
}

/// Print a vector of floats.
pub fn print_vec_f64(v: &[f64]) {
    print("[");
    for (i, item) in v.iter().enumerate() {
        if i > 0 { print(", "); }
        print(&float_to_string(*item));
    }
    println("]");
}

/// Print a vector of strings.
pub fn print_vec_str(v: &[String]) {
    print("[");
    for (i, item) in v.iter().enumerate() {
        if i > 0 { print(", "); }
        print("\"");
        print(item);
        print("\"");
    }
    println("]");
}

/// Print a vector of booleans.
pub fn print_vec_bool(v: &[bool]) {
    print("[");
    for (i, item) in v.iter().enumerate() {
        if i > 0 { print(", "); }
        print(&bool_to_string(*item));
    }
    println("]");
}

// =============================================================================
// Display Trait
// =============================================================================

/// Trait for types that can be displayed as strings.
pub trait Display {
    fn fmt(&self) -> String;
}

impl Display for i64 {
    fn fmt(&self) -> String { int_to_string(*self) }
}

impl Display for i32 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for i16 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for i8 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for u64 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for u32 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for u16 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for u8 {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for usize {
    fn fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Display for f64 {
    fn fmt(&self) -> String { float_to_string(*self) }
}

impl Display for f32 {
    fn fmt(&self) -> String { float_to_string(*self as f64) }
}

impl Display for bool {
    fn fmt(&self) -> String { bool_to_string(*self) }
}

impl Display for char {
    fn fmt(&self) -> String {
        let mut s = String::new();
        s.push(*self);
        s
    }
}

impl Display for &str {
    fn fmt(&self) -> String { self.to_string() }
}

impl Display for String {
    fn fmt(&self) -> String { self.clone() }
}

// =============================================================================
// Debug Trait
// =============================================================================

/// Trait for types that can be debug-formatted.
pub trait Debug {
    fn debug_fmt(&self) -> String;
}

impl Debug for i64 {
    fn debug_fmt(&self) -> String { int_to_string(*self) }
}

impl Debug for i32 {
    fn debug_fmt(&self) -> String { int_to_string(*self as i64) }
}

impl Debug for f64 {
    fn debug_fmt(&self) -> String { float_to_string(*self) }
}

impl Debug for f32 {
    fn debug_fmt(&self) -> String { float_to_string(*self as f64) }
}

impl Debug for bool {
    fn debug_fmt(&self) -> String { bool_to_string(*self) }
}

impl Debug for char {
    fn debug_fmt(&self) -> String {
        let mut s = String::from("'");
        s.push(*self);
        s.push('\'');
        s
    }
}

impl Debug for &str {
    fn debug_fmt(&self) -> String {
        let mut s = String::from("\"");
        s.push_str(self);
        s.push('"');
        s
    }
}

impl Debug for String {
    fn debug_fmt(&self) -> String {
        let mut s = String::from("\"");
        s.push_str(self);
        s.push('"');
        s
    }
}

impl<T: Debug> Debug for Vec<T> {
    fn debug_fmt(&self) -> String {
        let mut s = String::from("[");
        for (i, item) in self.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(&item.debug_fmt());
        }
        s.push(']');
        s
    }
}

impl<T: Debug> Debug for Option<T> {
    fn debug_fmt(&self) -> String {
        match self {
            Some(v) => {
                let mut s = String::from("Some(");
                s.push_str(&v.debug_fmt());
                s.push(')');
                s
            }
            None => String::from("None"),
        }
    }
}

impl<T: Debug, E: Debug> Debug for Result<T, E> {
    fn debug_fmt(&self) -> String {
        match self {
            Ok(v) => {
                let mut s = String::from("Ok(");
                s.push_str(&v.debug_fmt());
                s.push(')');
                s
            }
            Err(e) => {
                let mut s = String::from("Err(");
                s.push_str(&e.debug_fmt());
                s.push(')');
                s
            }
        }
    }
}

// =============================================================================
// Write Trait (for buffered output)
// =============================================================================

/// Trait for types that can be written to.
pub trait Write {
    fn write_str(&mut self, s: &str) -> Result<(), WriteError>;

    fn write_char(&mut self, c: char) -> Result<(), WriteError> {
        let mut buf = [0u8; 4];
        let s = c.encode_utf8(&mut buf);
        self.write_str(s)
    }

    fn write_fmt(&mut self, args: &Arguments) -> Result<(), WriteError> {
        self.write_str(&args.to_string())
    }
}

/// Error type for write operations.
pub struct WriteError;

impl Write for String {
    fn write_str(&mut self, s: &str) -> Result<(), WriteError> {
        self.push_str(s);
        Ok(())
    }
}

impl Write for Vec<u8> {
    fn write_str(&mut self, s: &str) -> Result<(), WriteError> {
        for b in s.bytes() {
            self.push(b);
        }
        Ok(())
    }
}

/// Format arguments holder.
pub struct Arguments {
    pieces: Vec<String>,
}

impl Arguments {
    pub fn new() -> Arguments {
        Arguments { pieces: Vec::new() }
    }

    pub fn push(&mut self, s: String) {
        self.pieces.push(s);
    }

    pub fn to_string(&self) -> String {
        let mut result = String::new();
        for piece in self.pieces.iter() {
            result.push_str(piece);
        }
        result
    }
}

// =============================================================================
// Formatter (for custom formatting)
// =============================================================================

/// Formatter for building formatted output.
pub struct Formatter<'a> {
    buf: &'a mut dyn Write,
    spec: FormatSpec,
}

impl<'a> Formatter<'a> {
    pub fn new(buf: &'a mut dyn Write) -> Formatter<'a> {
        Formatter {
            buf,
            spec: FormatSpec::default(),
        }
    }

    pub fn write_str(&mut self, s: &str) -> Result<(), WriteError> {
        self.buf.write_str(s)
    }

    pub fn write_fmt(&mut self, args: &Arguments) -> Result<(), WriteError> {
        self.buf.write_fmt(args)
    }

    pub fn width(&self) -> Option<usize> {
        self.spec.width.map(|w| w as usize)
    }

    pub fn precision(&self) -> Option<usize> {
        self.spec.precision.map(|p| p as usize)
    }

    pub fn align(&self) -> Alignment {
        if self.spec.left_align {
            Alignment::Left
        } else {
            Alignment::Right
        }
    }

    pub fn fill(&self) -> char {
        if self.spec.zero_pad { '0' } else { ' ' }
    }
}

/// Text alignment.
pub enum Alignment {
    Left,
    Right,
    Center,
}

// =============================================================================
// FFI Declarations
// =============================================================================

extern "C" {
    fn io_print(s: *const u8, len: i64);
    fn io_eprint(s: *const u8, len: i64);
    fn float_format(f: f64, buf: *mut u8, max_len: i64) -> i64;
    fn float_format_precision(f: f64, buf: *mut u8, max_len: i64, precision: i32) -> i64;
    fn float_format_scientific(f: f64, buf: *mut u8, max_len: i64, precision: i32, uppercase: i32) -> i64;
}

// Import from parent module
use super::{Option, Result};
use super::Option::{Some, None};
use super::Result::{Ok, Err};
