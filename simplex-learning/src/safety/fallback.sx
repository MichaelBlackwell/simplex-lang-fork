// Fallback strategies for when learning fails or constraints are violated
//
// Ensures the system always produces valid output.

use crate::tensor::Tensor;

/// Safety-related errors
#[derive(Debug, Clone)]
pub enum SafetyError {
    /// No fallback output available after failures
    NoFallbackAvailable { failures: usize },
    /// Validation failed
    ValidationFailed { reason: String },
    /// Maximum failures exceeded
    MaxFailuresExceeded { max: usize, actual: usize },
    /// Checkpoint restore failed
    CheckpointRestoreFailed,
}

impl std::fmt::Display for SafetyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SafetyError::NoFallbackAvailable { failures } =>
                write!(f, "No fallback available after {} failures", failures),
            SafetyError::ValidationFailed { reason } =>
                write!(f, "Validation failed: {}", reason),
            SafetyError::MaxFailuresExceeded { max, actual } =>
                write!(f, "Max failures exceeded: {} > {}", actual, max),
            SafetyError::CheckpointRestoreFailed =>
                write!(f, "Checkpoint restore failed"),
        }
    }
}

impl std::error::Error for SafetyError {}

/// Fallback strategy
pub enum FallbackStrategy {
    /// Return default output
    Default,

    /// Return last known good output
    LastGood,

    /// Execute fallback function
    Function,

    /// Revert to checkpoint
    Checkpoint,

    /// Skip learning update
    SkipUpdate,
}

/// Safe fallback handler
pub struct SafeFallback<I, O> {
    /// Strategy to use
    strategy: FallbackStrategy,

    /// Default output
    default_output: Option<O>,

    /// Last good output
    last_good: Option<(I, O)>,

    /// Fallback function
    fallback_fn: Option<Box<dyn Fn(&I) -> O>>,

    /// Checkpoint state
    checkpoint: Option<Vec<Tensor>>,

    /// Number of fallbacks executed
    fallback_count: u64,
}

impl<I: Clone, O: Clone> SafeFallback<I, O> {
    /// Create with default strategy
    pub fn new() -> Self {
        SafeFallback {
            strategy: FallbackStrategy::LastGood,
            default_output: None,
            last_good: None,
            fallback_fn: None,
            checkpoint: None,
            fallback_count: 0,
        }
    }

    /// Create with default output
    pub fn with_default(default: O) -> Self {
        SafeFallback {
            strategy: FallbackStrategy::Default,
            default_output: Some(default),
            last_good: None,
            fallback_fn: None,
            checkpoint: None,
            fallback_count: 0,
        }
    }

    /// Create with fallback function
    pub fn with_function<F: Fn(&I) -> O + 'static>(f: F) -> Self {
        SafeFallback {
            strategy: FallbackStrategy::Function,
            default_output: None,
            last_good: None,
            fallback_fn: Some(Box::new(f)),
            checkpoint: None,
            fallback_count: 0,
        }
    }

    /// Record a good input/output pair
    pub fn record_good(&mut self, input: I, output: O) {
        self.last_good = Some((input, output));
    }

    /// Save checkpoint
    pub fn save_checkpoint(&mut self, params: &[Tensor]) {
        self.checkpoint = Some(params.iter().map(|p| p.clone()).collect());
    }

    /// Get fallback output
    pub fn fallback(&mut self, input: &I) -> Option<O> {
        self.fallback_count += 1;

        match self.strategy {
            FallbackStrategy::Default => {
                self.default_output.clone()
            }
            FallbackStrategy::LastGood => {
                self.last_good.as_ref().map(|(_, o)| o.clone())
            }
            FallbackStrategy::Function => {
                self.fallback_fn.as_ref().map(|f| f(input))
            }
            FallbackStrategy::Checkpoint | FallbackStrategy::SkipUpdate => {
                // These don't provide output
                None
            }
        }
    }

    /// Restore checkpoint if available
    pub fn restore_checkpoint(&self, params: &mut [Tensor]) -> bool {
        match &self.checkpoint {
            Some(checkpoint) => {
                for (param, saved) in params.iter_mut().zip(checkpoint.iter()) {
                    for i in 0..param.numel() {
                        param.set(i, saved.get(i));
                    }
                }
                true
            }
            None => false,
        }
    }

    /// Get fallback count
    pub fn fallback_count(&self) -> u64 {
        self.fallback_count
    }

    /// Set strategy
    pub fn set_strategy(&mut self, strategy: FallbackStrategy) {
        self.strategy = strategy;
    }
}

/// Safe wrapper for learning operations
pub struct SafeLearner<I, O, L> {
    /// Inner learner
    inner: L,

    /// Fallback handler
    fallback: SafeFallback<I, O>,

    /// Validation function
    validator: Option<Box<dyn Fn(&O) -> bool>>,

    /// Maximum consecutive failures before fallback
    max_failures: usize,

    /// Current failure count
    failures: usize,
}

impl<I: Clone, O: Clone, L> SafeLearner<I, O, L> {
    /// Create safe wrapper
    pub fn new(inner: L, fallback: SafeFallback<I, O>) -> Self {
        SafeLearner {
            inner,
            fallback,
            validator: None,
            max_failures: 3,
            failures: 0,
        }
    }

    /// Set output validator
    pub fn with_validator<F: Fn(&O) -> bool + 'static>(mut self, f: F) -> Self {
        self.validator = Some(Box::new(f));
        self
    }

    /// Set max failures
    pub fn max_failures(mut self, max: usize) -> Self {
        self.max_failures = max;
        self
    }

    /// Check if output is valid
    fn is_valid(&self, output: &O) -> bool {
        match &self.validator {
            Some(v) => v(output),
            None => true,
        }
    }

    /// Process with safety checks, returning Result
    pub fn try_process<F>(&mut self, input: &I, compute: F) -> Result<O, SafetyError>
    where
        F: FnOnce(&mut L, &I) -> Option<O>,
    {
        // Try to compute
        match compute(&mut self.inner, input) {
            Some(output) if self.is_valid(&output) => {
                // Valid output
                self.failures = 0;
                self.fallback.record_good(input.clone(), output.clone());
                Ok(output)
            }
            _ => {
                // Invalid or failed
                self.failures += 1;

                if self.failures >= self.max_failures {
                    // Use fallback
                    match self.fallback.fallback(input) {
                        Some(fallback_output) => Ok(fallback_output),
                        None => {
                            Err(SafetyError::NoFallbackAvailable {
                                failures: self.failures,
                            })
                        }
                    }
                } else {
                    // Retry or return last good
                    match self.fallback.fallback(input) {
                        Some(fallback_output) => Ok(fallback_output),
                        None => Err(SafetyError::NoFallbackAvailable {
                            failures: self.failures,
                        }),
                    }
                }
            }
        }
    }

    /// Process with safety checks
    ///
    /// Note: Prefer try_process() for better error handling.
    /// This method will return a fallback or log an error and return whatever is available.
    pub fn process<F>(&mut self, input: &I, compute: F) -> Option<O>
    where
        F: FnOnce(&mut L, &I) -> Option<O>,
    {
        match self.try_process(input, compute) {
            Ok(output) => Some(output),
            Err(e) => {
                eprintln!("[SafeLearner] Error: {}", e);
                // Last resort: try to get any fallback
                self.fallback.fallback(input)
            }
        }
    }

    /// Get inner learner
    pub fn inner(&self) -> &L {
        &self.inner
    }

    /// Get mutable inner learner
    pub fn inner_mut(&mut self) -> &mut L {
        &mut self.inner
    }
}

/// Anomaly detector for learning signals
pub struct AnomalyDetector {
    /// Running mean
    mean: f64,

    /// Running variance
    var: f64,

    /// Sample count
    count: u64,

    /// Threshold (number of standard deviations)
    threshold: f64,

    /// Minimum samples before detection
    min_samples: u64,
}

impl AnomalyDetector {
    /// Create new anomaly detector
    pub fn new(threshold: f64) -> Self {
        AnomalyDetector {
            mean: 0.0,
            var: 0.0,
            count: 0,
            threshold,
            min_samples: 100,
        }
    }

    /// Update with new value and check for anomaly
    pub fn update(&mut self, value: f64) -> bool {
        self.count += 1;

        if self.count < self.min_samples {
            // Still in warmup - just update statistics
            let delta = value - self.mean;
            self.mean += delta / self.count as f64;
            let delta2 = value - self.mean;
            self.var += delta * delta2;
            return false;
        }

        // Check for anomaly
        let std = (self.var / (self.count - 1) as f64).sqrt();
        let z_score = (value - self.mean).abs() / (std + 1e-8);
        let is_anomaly = z_score > self.threshold;

        // Update statistics
        let delta = value - self.mean;
        self.mean += delta / self.count as f64;
        let delta2 = value - self.mean;
        self.var += delta * delta2;

        is_anomaly
    }

    /// Get current mean
    pub fn mean(&self) -> f64 {
        self.mean
    }

    /// Get current std
    pub fn std(&self) -> f64 {
        if self.count < 2 {
            0.0
        } else {
            (self.var / (self.count - 1) as f64).sqrt()
        }
    }

    /// Reset
    pub fn reset(&mut self) {
        self.mean = 0.0;
        self.var = 0.0;
        self.count = 0;
    }
}
