// Online calibration for streaming data
//
// Updates calibration parameters in real-time as new data arrives.

use super::metrics::{ECE, BrierScore};
use super::temperature::LearnableTemperature;
use crate::tensor::Tensor;

/// Online calibration state
pub struct CalibrationState {
    /// Current ECE (updated online)
    ece: f64,

    /// Current Brier score (updated online)
    brier: f64,

    /// ECE tracker
    ece_tracker: ECE,

    /// Brier tracker
    brier_tracker: BrierScore,

    /// Learnable temperature
    temperature: LearnableTemperature,

    /// Samples seen
    samples_seen: u64,

    /// Target ECE
    target_ece: f64,

    /// Window size for online metrics
    window_size: usize,

    /// Recent predictions for windowed metrics
    recent_predictions: std::collections::VecDeque<(f64, bool)>,
}

impl CalibrationState {
    /// Create new calibration state
    pub fn new(target_ece: f64) -> Self {
        CalibrationState {
            ece: 0.0,
            brier: 0.0,
            ece_tracker: ECE::new(10),
            brier_tracker: BrierScore::new(),
            temperature: LearnableTemperature::new(1.0, 0.01),
            samples_seen: 0,
            target_ece,
            window_size: 1000,
            recent_predictions: std::collections::VecDeque::with_capacity(1000),
        }
    }

    /// Update with a new prediction
    pub fn update(&mut self, confidence: f64, correct: bool) {
        self.samples_seen += 1;

        // Add to trackers
        self.ece_tracker.add(confidence, correct);
        self.brier_tracker.add(confidence, correct);

        // Add to recent window
        self.recent_predictions.push_back((confidence, correct));
        if self.recent_predictions.len() > self.window_size {
            self.recent_predictions.pop_front();
        }

        // Update metrics periodically
        if self.samples_seen % 100 == 0 {
            self.ece = self.compute_windowed_ece();
            self.brier = self.brier_tracker.compute();
        }
    }

    /// Compute ECE over recent window
    fn compute_windowed_ece(&self) -> f64 {
        let mut windowed_ece = ECE::new(10);

        for &(conf, correct) in &self.recent_predictions {
            windowed_ece.add(conf, correct);
        }

        windowed_ece.compute()
    }

    /// Get current ECE
    pub fn ece(&self) -> f64 {
        self.ece
    }

    /// Get current Brier score
    pub fn brier(&self) -> f64 {
        self.brier
    }

    /// Get current temperature
    pub fn temperature(&self) -> f64 {
        self.temperature.temperature()
    }

    /// Check if calibration meets target
    pub fn is_calibrated(&self) -> bool {
        self.ece < self.target_ece
    }

    /// Get samples seen
    pub fn samples_seen(&self) -> u64 {
        self.samples_seen
    }

    /// Apply temperature calibration to logits
    pub fn calibrate(&self, logits: &Tensor) -> Tensor {
        self.temperature.calibrate(logits)
    }

    /// Update temperature based on recent performance
    pub fn update_temperature(&mut self, logits: &Tensor, targets: &Tensor) {
        self.temperature.backward(logits, targets);
    }

    /// Reset state
    pub fn reset(&mut self) {
        self.ece_tracker.reset();
        self.brier_tracker.reset();
        self.recent_predictions.clear();
        self.samples_seen = 0;
        self.ece = 0.0;
        self.brier = 0.0;
    }
}

/// Online calibration with adaptive binning
pub struct OnlineCalibration {
    /// Calibration state
    state: CalibrationState,

    /// Update frequency for temperature
    update_freq: usize,

    /// Warmup steps before temperature updates
    warmup_steps: u64,

    /// Logging callback
    log_fn: Option<Box<dyn Fn(&CalibrationState)>>,
}

impl OnlineCalibration {
    /// Create new online calibrator
    pub fn new(target_ece: f64) -> Self {
        OnlineCalibration {
            state: CalibrationState::new(target_ece),
            update_freq: 100,
            warmup_steps: 1000,
            log_fn: None,
        }
    }

    /// Set update frequency
    pub fn update_frequency(mut self, freq: usize) -> Self {
        self.update_freq = freq;
        self
    }

    /// Set warmup steps
    pub fn warmup(mut self, steps: u64) -> Self {
        self.warmup_steps = steps;
        self
    }

    /// Set logging callback
    pub fn on_log<F: Fn(&CalibrationState) + 'static>(mut self, f: F) -> Self {
        self.log_fn = Some(Box::new(f));
        self
    }

    /// Process a batch of predictions
    pub fn process_batch(
        &mut self,
        logits: &Tensor,
        targets: &Tensor,
    ) -> Tensor {
        // Apply current calibration
        let calibrated = self.state.calibrate(logits);

        // Update statistics
        // (Simplified: assuming batch of binary predictions)
        let batch_size = logits.numel();
        for i in 0..batch_size {
            let conf = calibrated.get(i);
            let correct = (conf > 0.5) == (targets.get(i) > 0.5);
            self.state.update(conf, correct);
        }

        // Update temperature if past warmup
        if self.state.samples_seen > self.warmup_steps
            && self.state.samples_seen as usize % self.update_freq == 0
        {
            self.state.update_temperature(logits, targets);

            // Log if callback set
            if let Some(ref log_fn) = self.log_fn {
                log_fn(&self.state);
            }
        }

        calibrated
    }

    /// Get current state
    pub fn state(&self) -> &CalibrationState {
        &self.state
    }

    /// Get mutable state
    pub fn state_mut(&mut self) -> &mut CalibrationState {
        &mut self.state
    }
}

/// Isotonic regression for calibration
pub struct IsotonicCalibration {
    /// Fitted isotonic mapping
    mapping: Vec<(f64, f64)>,
}

impl IsotonicCalibration {
    /// Create new (unfitted) isotonic calibrator
    pub fn new() -> Self {
        IsotonicCalibration {
            mapping: Vec::new(),
        }
    }

    /// Fit isotonic regression
    pub fn fit(&mut self, predictions: &[f64], targets: &[bool]) {
        // Sort by prediction
        let mut pairs: Vec<(f64, f64)> = predictions.iter()
            .zip(targets.iter())
            .map(|(&p, &t)| (p, if t { 1.0 } else { 0.0 }))
            .collect();

        pairs.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());

        // Pool adjacent violators algorithm (PAVA)
        let mut result: Vec<(f64, f64, usize)> = Vec::new();

        for (pred, target) in pairs {
            result.push((pred, target, 1));

            // Merge blocks that violate monotonicity
            while result.len() >= 2 {
                let n = result.len();
                let (_, y1, c1) = result[n - 2];
                let (_, y2, c2) = result[n - 1];

                if y1 > y2 {
                    // Merge last two blocks
                    let merged_y = (y1 * c1 as f64 + y2 * c2 as f64) / (c1 + c2) as f64;
                    let merged_x = result[n - 2].0; // Keep first x
                    result.pop();
                    result.pop();
                    result.push((merged_x, merged_y, c1 + c2));
                } else {
                    break;
                }
            }
        }

        // Store mapping
        self.mapping = result.iter().map(|&(x, y, _)| (x, y)).collect();
    }

    /// Calibrate a prediction
    pub fn calibrate(&self, prediction: f64) -> f64 {
        if self.mapping.is_empty() {
            return prediction;
        }

        // Find appropriate segment
        let mut prev = (0.0, 0.0);
        for &(x, y) in &self.mapping {
            if prediction <= x {
                if x == prev.0 {
                    return y;
                }
                // Linear interpolation
                let t = (prediction - prev.0) / (x - prev.0);
                return prev.1 + t * (y - prev.1);
            }
            prev = (x, y);
        }

        // Beyond range
        self.mapping.last().map(|&(_, y)| y).unwrap_or(prediction)
    }
}
