// TASK-014: Epistemic Module Tests
//
// Integration tests for epistemic annealing, monitors, skeptic, and meta-optimizer.

use simplex_learning::epistemic::{
    EpistemicMonitors, HealthMetric, EpistemicHealth,
    EpistemicSchedule, LearnableSchedule, AnnealingParams,
    DissentConfig, DissentWindow, DissentPhase,
    CounterfactualProber, CounterfactualScenario, BeliefRevision,
    Skeptic, SkepticConfig, SkepticRunner, SkepticStats, ChallengeRecord,
    EpistemicIntegration, EpistemicIntegrationConfig, EpistemicStepResult,
    EpistemicMetaOptimizer, MetaOptimizerConfig, MetaOptimizerStats,
};
use simplex_learning::belief::{
    GroundedBelief, BeliefProvenance, CalibratedConfidence,
};
use simplex_learning::safety::{
    NoLearnZone, NoGradientZone, Invariant, ZoneRegistry,
    InvariantAction, ZoneEnforcement, ZoneStats,
};
use std::time::Duration;

// =============================================================================
// HealthMetric Tests
// =============================================================================

#[test]
fn test_health_metric_creation() {
    let metric = HealthMetric::new("test_metric", 0.5, (0.3, 0.8));

    assert!(metric.is_healthy());
    assert_eq!(metric.unhealthiness(), 0.0);
    assert!((metric.value.val - 0.5).abs() < 0.01);
}

#[test]
fn test_health_metric_update() {
    let mut metric = HealthMetric::new("test", 0.5, (0.3, 0.8));

    metric.update(0.7);
    assert!((metric.value.val - 0.7).abs() < 0.01);
    assert!(metric.is_healthy());
}

#[test]
fn test_health_metric_unhealthy_below_range() {
    let mut metric = HealthMetric::new("test", 0.5, (0.3, 0.8));

    metric.update(0.2);
    assert!(!metric.is_healthy());
    assert!((metric.unhealthiness() - 0.1).abs() < 0.01);
}

#[test]
fn test_health_metric_unhealthy_above_range() {
    let mut metric = HealthMetric::new("test", 0.5, (0.3, 0.8));

    metric.update(0.95);
    assert!(!metric.is_healthy());
    assert!((metric.unhealthiness() - 0.15).abs() < 0.01);
}

#[test]
fn test_health_metric_trend_detection() {
    let mut metric = HealthMetric::new("test", 0.5, (0.0, 1.0));

    // Add improving trend
    for i in 0..15 {
        metric.update(0.5 + (i as f64) * 0.02);
    }

    assert!(metric.trend() >= 0); // Should detect improvement
}

#[test]
fn test_health_metric_ema() {
    let mut metric = HealthMetric::new("test", 0.5, (0.0, 1.0));

    for _ in 0..10 {
        metric.update(0.8);
    }

    // Smoothed value should be between initial and new
    let smoothed = metric.smoothed();
    assert!(smoothed >= 0.5);
    assert!(smoothed <= 0.8);
}

// =============================================================================
// EpistemicMonitors Tests
// =============================================================================

#[test]
fn test_epistemic_monitors_creation() {
    let monitors = EpistemicMonitors::new();

    // Initial state should be healthy
    assert!(monitors.overall_health() > 0.5);
    assert!(!monitors.has_critical_issue());
}

#[test]
fn test_monitors_prediction_tracking() {
    let mut monitors = EpistemicMonitors::new();

    // Good predictions
    for _ in 0..20 {
        monitors.record_prediction(true, 0.7);
    }

    assert!(monitors.overall_health() > 0.5);
    assert!(monitors.predictive_accuracy.value.val > 0.5);
}

#[test]
fn test_monitors_poor_predictions_reduce_health() {
    let mut monitors = EpistemicMonitors::new();

    // Poor predictions
    for _ in 0..30 {
        monitors.record_prediction(false, 0.9);
    }

    assert!(monitors.overall_health() < 0.8);
    assert!(monitors.get_issues().len() > 0);
}

#[test]
fn test_monitors_confidence_velocity() {
    let mut monitors = EpistemicMonitors::new();

    // High confidence velocity is unhealthy
    monitors.update_confidence_velocity(0.25);

    assert!(!monitors.confidence_velocity.is_healthy());
    assert!(monitors.get_issues().iter().any(|i| i.contains("Confidence")));
}

#[test]
fn test_monitors_source_agreement() {
    let mut monitors = EpistemicMonitors::new();

    // Low source agreement
    monitors.update_source_agreement(0.3);

    assert!(!monitors.source_agreement.is_healthy());
    assert!(monitors.get_issues().len() > 0);
}

#[test]
fn test_monitors_critical_issue_detection() {
    let mut monitors = EpistemicMonitors::new();

    // Very low source agreement is critical
    monitors.update_source_agreement(0.2);

    assert!(monitors.has_critical_issue());
}

#[test]
fn test_monitors_reset() {
    let mut monitors = EpistemicMonitors::new();

    // Make unhealthy
    monitors.update_confidence_velocity(0.3);
    monitors.update_source_agreement(0.2);

    assert!(monitors.has_critical_issue());

    // Reset
    monitors.reset();

    assert!(!monitors.has_critical_issue());
    assert!(monitors.overall_health() > 0.5);
}

#[test]
fn test_epistemic_health_snapshot() {
    let monitors = EpistemicMonitors::new();
    let health = EpistemicHealth::from_monitors(&monitors);

    assert!(health.score > 0.5);
    assert!(!health.has_critical_issue);
    assert!(health.is_healthy());
}

// =============================================================================
// DissentWindow Tests
// =============================================================================

#[test]
fn test_dissent_window_creation() {
    let config = DissentConfig::step_based(100, 20);
    let window = DissentWindow::new(config);

    // Should start inactive
    assert!(!window.is_active());
    assert_eq!(window.phase(), DissentPhase::Normal);
}

#[test]
fn test_dissent_window_activation() {
    let config = DissentConfig::step_based(100, 20);
    let mut window = DissentWindow::new(config);

    // Step until dissent starts
    for _ in 0..15 {
        window.step();
    }

    // Should now be active
    assert!(window.is_active());
    assert!(window.current_heat() > 0.0);
}

#[test]
fn test_dissent_phases() {
    let config = DissentConfig::step_based(50, 30);
    let mut window = DissentWindow::new(config);

    let mut saw_normal = false;
    let mut saw_entering = false;
    let mut saw_active = false;
    let mut saw_exiting = false;

    // Step through full cycle
    for _ in 0..80 {
        window.step();
        match window.phase() {
            DissentPhase::Normal => saw_normal = true,
            DissentPhase::EnteringDissent => saw_entering = true,
            DissentPhase::ActiveDissent => saw_active = true,
            DissentPhase::ExitingDissent => saw_exiting = true,
        }
    }

    // Should have seen active or entering dissent phases
    assert!(saw_active || saw_entering);
}

#[test]
fn test_dissent_heat_curve() {
    let config = DissentConfig::step_based(100, 40);
    let mut window = DissentWindow::new(config);

    let mut max_heat = 0.0;

    // Step through dissent window
    for _ in 0..50 {
        window.step();
        max_heat = max_heat.max(window.current_heat());
    }

    // Should have reached some heat
    assert!(max_heat > 0.0);
}

#[test]
fn test_dissent_challenge_threshold() {
    let config = DissentConfig::step_based(100, 30);
    let mut window = DissentWindow::new(config);

    // Step into active phase
    for _ in 0..20 {
        window.step();
    }

    // Challenge threshold should be reasonable
    let threshold = window.challenge_threshold();
    assert!(threshold >= 0.0 && threshold <= 1.0);
}

// =============================================================================
// Skeptic Tests
// =============================================================================

#[test]
fn test_skeptic_creation() {
    let skeptic = Skeptic::new();

    assert!(!skeptic.is_active());
    assert_eq!(skeptic.stats().total_challenges, 0);
}

#[test]
fn test_skeptic_config_presets() {
    let aggressive = SkepticConfig::aggressive();
    let conservative = SkepticConfig::conservative();

    assert!(aggressive.min_confidence_to_challenge < conservative.min_confidence_to_challenge);
    assert!(aggressive.max_challenges_per_window > conservative.max_challenges_per_window);
}

#[test]
fn test_skeptic_activation_cycle() {
    let dissent_config = DissentConfig::step_based(100, 20);
    let mut skeptic = Skeptic::with_config(SkepticConfig::default(), dissent_config);

    // Should start inactive
    assert!(!skeptic.is_active());

    // Step into dissent window
    for _ in 0..15 {
        skeptic.step();
    }

    // Should now be active
    assert!(skeptic.is_active());
    assert!(skeptic.current_heat() > 0.0);
}

#[test]
fn test_skeptic_challenge_belief() {
    let dissent_config = DissentConfig::step_based(10, 8);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.5,
        challenge_cooldown: 0,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..5 {
        skeptic.step();
    }

    // Create a high-confidence belief
    let belief: GroundedBelief<String> = GroundedBelief::observed(
        "test_belief",
        "Test claim".to_string(),
        "test_source",
        0.9,
    );

    // Challenge
    let observations = vec![
        ("accuracy".to_string(), 0.3),
        ("latency".to_string(), 100.0),
    ];

    let _revision = skeptic.challenge(&belief, &observations);

    assert_eq!(skeptic.stats().total_challenges, 1);
    assert!(skeptic.get_challenge_history("test_belief").is_some());
}

#[test]
fn test_skeptic_cooldown() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.5,
        challenge_cooldown: 10,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..15 {
        skeptic.step();
    }

    let belief: GroundedBelief<String> = GroundedBelief::observed(
        "test",
        "claim".to_string(),
        "source",
        0.9,
    );

    // First challenge should work
    assert!(skeptic.can_challenge("test"));
    skeptic.challenge(&belief, &[]);

    // Immediate second challenge should be blocked
    assert!(!skeptic.can_challenge("test"));

    // After cooldown, should work again
    for _ in 0..15 {
        skeptic.step();
    }
    assert!(skeptic.can_challenge("test"));
}

#[test]
fn test_skeptic_max_challenges_per_window() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.5,
        max_challenges_per_window: 2,
        challenge_cooldown: 0,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..15 {
        skeptic.step();
    }

    // Create multiple beliefs
    for i in 0..5 {
        let belief: GroundedBelief<String> = GroundedBelief::observed(
            &format!("belief_{}", i),
            format!("claim {}", i),
            "source",
            0.9,
        );
        skeptic.challenge(&belief, &[]);
    }

    // Should only have challenged max
    assert_eq!(skeptic.stats().total_challenges, 2);
}

#[test]
fn test_skeptic_batch_challenge() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.5,
        max_challenges_per_window: 5,
        challenge_cooldown: 0,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..15 {
        skeptic.step();
    }

    // Create beliefs
    let beliefs: Vec<GroundedBelief<String>> = (0..3)
        .map(|i| {
            GroundedBelief::observed(
                &format!("b{}", i),
                format!("claim {}", i),
                "source",
                0.7 + (i as f64) * 0.1,
            )
        })
        .collect();

    let _revisions = skeptic.challenge_batch(&beliefs, &[]);

    assert!(skeptic.stats().total_challenges > 0);
}

#[test]
fn test_skeptic_selection() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.7,
        max_challenges_per_window: 2,
        challenge_cooldown: 0,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..15 {
        skeptic.step();
    }

    // Mix of high and low confidence beliefs
    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("low", "Low conf".to_string(), "s", 0.3),
        GroundedBelief::observed("med", "Med conf".to_string(), "s", 0.6),
        GroundedBelief::observed("high", "High conf".to_string(), "s", 0.9),
    ];

    let selected = skeptic.select_beliefs_to_challenge(&beliefs);

    // Should only select high confidence
    assert!(selected.iter().all(|b| b.confidence_value() >= 0.7));
}

#[test]
fn test_skeptic_clear() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let mut skeptic = Skeptic::with_config(SkepticConfig::default(), dissent_config);

    // Do some challenges
    for _ in 0..20 {
        skeptic.step();
    }

    let belief: GroundedBelief<String> = GroundedBelief::observed(
        "test",
        "test".to_string(),
        "s",
        0.9,
    );
    skeptic.challenge(&belief, &[]);

    assert!(skeptic.stats().total_challenges > 0);

    // Clear
    skeptic.clear();

    assert_eq!(skeptic.stats().total_challenges, 0);
    assert!(skeptic.get_challenge_history("test").is_none());
}

// =============================================================================
// SkepticRunner Tests
// =============================================================================

#[test]
fn test_skeptic_runner_integration() {
    let mut runner = SkepticRunner::new();

    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("b1", "claim 1".to_string(), "s", 0.8),
    ];
    let observations = vec![("metric".to_string(), 0.5)];

    // Run a few steps
    for _ in 0..20 {
        let _revisions = runner.step(&beliefs, &observations);
    }

    // Should have done something
    assert!(runner.skeptic.stats().windows_completed > 0 || runner.skeptic.stats().total_challenges >= 0);
}

#[test]
fn test_skeptic_runner_with_callback() {
    let mut runner = SkepticRunner::with_config(
        SkepticConfig::aggressive(),
        DissentConfig::step_based(20, 15),
    );

    let mut applied_count = 0;
    runner.on_revision(move |_rev| {
        // Would apply revision here
        true
    });

    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("test", "claim".to_string(), "s", 0.95),
    ];

    for _ in 0..30 {
        runner.step(&beliefs, &[]);
    }

    // Callback was set
    assert!(runner.skeptic.stats().total_challenges >= 0);
}

// =============================================================================
// EpistemicSchedule Tests
// =============================================================================

#[test]
fn test_epistemic_schedule_creation() {
    let params = AnnealingParams::default();
    let schedule = EpistemicSchedule::new(params);

    // Initial temperature should be positive
    assert!(schedule.current_temperature() > 0.0);
}

#[test]
fn test_schedule_temperature_response_to_health() {
    let params = AnnealingParams::default();
    let mut schedule = EpistemicSchedule::new(params);
    let mut monitors = EpistemicMonitors::new();

    // Get initial temp
    let initial_temp = schedule.current_temperature();

    // Make monitors unhealthy
    monitors.update_source_agreement(0.2);
    monitors.update_confidence_velocity(0.3);

    // Update schedule with unhealthy monitors
    schedule.update(&monitors);

    // Temperature should increase with poor health
    // (This depends on implementation - adjust assertion as needed)
    let new_temp = schedule.current_temperature();
    assert!(new_temp >= initial_temp * 0.9); // At minimum, shouldn't decrease much
}

#[test]
fn test_learnable_schedule() {
    let schedule = LearnableSchedule::new();

    // Initial parameters should exist
    assert!(schedule.current_temperature() > 0.0);
}

// =============================================================================
// Safety Zones Integration Tests
// =============================================================================

#[test]
fn test_no_learn_zone_creation() {
    let zone = NoLearnZone::new("frozen_layer")
        .with_indices(&[0, 1, 2, 3])
        .with_enforcement(ZoneEnforcement::Block);

    assert_eq!(zone.name, "frozen_layer");
    assert_eq!(zone.params.len(), 4);
}

#[test]
fn test_no_gradient_zone() {
    let zone = NoGradientZone::new("detach_zone")
        .with_params(&["embedding_0", "embedding_1"])
        .with_indices(&[0, 1, 2]);

    assert_eq!(zone.name, "detach_zone");
    assert!(zone.params.contains(&"embedding_0".to_string()));
}

#[test]
fn test_invariant_all_finite() {
    let mut invariant = Invariant::all_finite("params_finite")
        .with_action(InvariantAction::Revert);

    assert_eq!(invariant.name, "params_finite");

    // Test with finite values
    let params = vec![1.0, 2.0, 3.0];
    assert!(invariant.check(&params));
}

#[test]
fn test_invariant_all_finite_rejects_nan() {
    let mut invariant = Invariant::all_finite("no_nan");

    // Test with NaN
    let params = vec![1.0, f64::NAN, 3.0];
    assert!(!invariant.check(&params));
}

#[test]
fn test_invariant_in_range() {
    let mut invariant = Invariant::in_range("bounded", -1.0, 1.0);

    // Within range
    let good_params = vec![0.5, -0.3, 0.8];
    assert!(invariant.check(&good_params));

    // Out of range
    let bad_params = vec![0.5, 2.0, 0.8];
    assert!(!invariant.check(&bad_params));
}

#[test]
fn test_invariant_non_negative() {
    let mut invariant = Invariant::non_negative("positive_weights");

    let good = vec![0.0, 1.0, 2.0];
    assert!(invariant.check(&good));

    let bad = vec![0.5, -0.1, 0.8];
    assert!(!invariant.check(&bad));
}

#[test]
fn test_invariant_norm_bounded() {
    let mut invariant = Invariant::norm_bounded("norm_constraint", 1.0);

    // Small vector (norm < 1)
    let small = vec![0.3, 0.3, 0.3];
    assert!(invariant.check(&small));

    // Large vector (norm > 1)
    let large = vec![3.0, 4.0]; // norm = 5
    assert!(!invariant.check(&large));
}

#[test]
fn test_zone_registry() {
    let mut registry = ZoneRegistry::new();

    registry.add_no_learn(NoLearnZone::new("frozen").with_indices(&[0, 1]));
    registry.add_no_gradient(NoGradientZone::new("detached").with_params(&["emb"]));
    registry.add_invariant(Invariant::all_finite("finite"));

    // Check zone counts indirectly via allows_update
    assert!(!registry.allows_update_index(0)); // Should be blocked
    assert!(!registry.allows_update_index(1)); // Should be blocked
    assert!(registry.allows_update_index(5));  // Not in any zone
}

#[test]
fn test_zone_registry_allows_update() {
    let mut registry = ZoneRegistry::new();

    registry.no_learn_indices("zone1", &[0, 1, 2]);
    registry.no_learn_indices("zone2", &[10, 11]);

    // Blocked indices
    assert!(!registry.allows_update_index(0));
    assert!(!registry.allows_update_index(1));
    assert!(!registry.allows_update_index(2));
    assert!(!registry.allows_update_index(10));
    assert!(!registry.allows_update_index(11));

    // Allowed indices
    assert!(registry.allows_update_index(3));
    assert!(registry.allows_update_index(5));
    assert!(registry.allows_update_index(100));
}

#[test]
fn test_zone_registry_invariants() {
    let mut registry = ZoneRegistry::new();
    registry.add_invariant(Invariant::all_finite("finite"));

    let params = vec![1.0, 2.0, 3.0];

    // Should pass
    let check = registry.check_invariants(&params);
    assert!(check.all_hold);
}

// =============================================================================
// Meta-Optimizer Tests
// =============================================================================

#[test]
fn test_meta_optimizer_config_presets() {
    let production = MetaOptimizerConfig::production();
    let development = MetaOptimizerConfig::development();
    let research = MetaOptimizerConfig::research();

    // Production should be most conservative
    assert!(production.skeptic.min_confidence_to_challenge >= development.skeptic.min_confidence_to_challenge);
}

#[test]
fn test_meta_optimizer_creation() {
    let config = MetaOptimizerConfig::development();
    let optimizer = EpistemicMetaOptimizer::new(config);

    // Should start in healthy state
    assert!(optimizer.monitors.overall_health() > 0.5);
}

#[test]
fn test_meta_optimizer_step() {
    let config = MetaOptimizerConfig::development();
    let mut optimizer = EpistemicMetaOptimizer::new(config);

    // Step multiple times
    for _ in 0..10 {
        optimizer.step();
    }

    let stats = optimizer.stats();
    assert_eq!(stats.total_steps, 10);
}

#[test]
fn test_meta_optimizer_freeze_indices() {
    let config = MetaOptimizerConfig::development();
    let mut optimizer = EpistemicMetaOptimizer::new(config);

    optimizer.freeze_indices("layer1", &[0, 1, 2]);

    // Test via prepare_update - frozen indices should be blocked
    let mut gradients = vec![1.0, 2.0, 3.0, 4.0, 5.0];

    // Mask gradients should zero frozen indices
    optimizer.mask_gradients(&mut gradients);

    // Frozen indices (0, 1, 2) should be zeroed
    assert_eq!(gradients[0], 0.0);
    assert_eq!(gradients[1], 0.0);
    assert_eq!(gradients[2], 0.0);
    // Non-frozen indices should remain
    assert_eq!(gradients[3], 4.0);
    assert_eq!(gradients[4], 5.0);
}

#[test]
fn test_meta_optimizer_add_invariant() {
    let config = MetaOptimizerConfig::development();
    let mut optimizer = EpistemicMetaOptimizer::new(config);

    optimizer.add_invariant(Invariant::all_finite("test_invariant"));

    // The optimizer already has default invariants, but we can verify it works
    // by checking that finalize_update checks invariants
    let params = vec![1.0, 2.0, 3.0];
    let result = optimizer.finalize_update(&params);
    assert!(result.is_ok() || result.is_err()); // Either outcome is valid
}

#[test]
fn test_meta_optimizer_gradient_masking() {
    let config = MetaOptimizerConfig::development();
    let mut optimizer = EpistemicMetaOptimizer::new(config);

    // Block gradients for first 2 indices
    optimizer.block_gradients("test", &[0, 1]);

    // Create gradients as f64 array
    let mut gradients = vec![1.0, 2.0, 3.0, 4.0];

    // Mask using the public method
    optimizer.mask_gradients(&mut gradients);

    // First two should be zeroed
    assert_eq!(gradients[0], 0.0);
    assert_eq!(gradients[1], 0.0);
    // Rest should be unchanged
    assert_eq!(gradients[2], 3.0);
    assert_eq!(gradients[3], 4.0);
}

// =============================================================================
// Integration Tests
// =============================================================================

#[test]
fn test_full_epistemic_integration() {
    let config = EpistemicIntegrationConfig::default();
    let mut integration = EpistemicIntegration::new(config);

    // Create some beliefs
    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("b1", "Claim 1".to_string(), "source", 0.85),
        GroundedBelief::observed("b2", "Claim 2".to_string(), "source", 0.9),
    ];

    // Run some steps
    for _ in 0..50 {
        let result = integration.step(&beliefs, &[]);
        // Check result is valid
        assert!(result.temperature > 0.0);
        assert!(result.health_score >= 0.0 && result.health_score <= 1.0);
    }

    let stats = integration.stats();
    assert!(stats.steps_completed > 0);
}

#[test]
fn test_epistemic_step_result() {
    let config = EpistemicIntegrationConfig::default();
    let mut integration = EpistemicIntegration::new(config);

    let beliefs: Vec<GroundedBelief<String>> = vec![];
    let result = integration.step(&beliefs, &[]);

    // Result should have all fields populated
    assert!(result.temperature > 0.0);
    assert!(result.health_score >= 0.0);
    assert!(result.revisions.is_empty() || result.revisions.len() > 0);
}

#[test]
fn test_epistemic_aware_trait() {
    // Test that we can implement EpistemicAware
    struct TestHive {
        integration: EpistemicIntegration,
    }

    impl TestHive {
        fn new() -> Self {
            TestHive {
                integration: EpistemicIntegration::new(EpistemicIntegrationConfig::default()),
            }
        }

        fn get_temperature(&self) -> f64 {
            self.integration.current_temperature()
        }

        fn is_healthy(&self) -> bool {
            self.integration.is_healthy()
        }
    }

    let hive = TestHive::new();
    assert!(hive.get_temperature() > 0.0);
    assert!(hive.is_healthy());
}

// =============================================================================
// Edge Cases
// =============================================================================

#[test]
fn test_empty_beliefs_list() {
    let mut runner = SkepticRunner::new();

    let beliefs: Vec<GroundedBelief<String>> = vec![];
    let revisions = runner.step(&beliefs, &[]);

    // Should handle empty gracefully
    assert!(revisions.is_empty());
}

#[test]
fn test_very_low_confidence_beliefs() {
    let dissent_config = DissentConfig::step_based(10, 8);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.7,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    for _ in 0..10 {
        skeptic.step();
    }

    // Low confidence beliefs should not be challenged
    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("low", "Low conf".to_string(), "s", 0.3),
    ];

    let selected = skeptic.select_beliefs_to_challenge(&beliefs);
    assert!(selected.is_empty());
}

#[test]
fn test_monitors_extreme_values() {
    let mut monitors = EpistemicMonitors::new();

    // Extreme but valid values
    monitors.update_source_agreement(0.0);
    monitors.update_predictive_accuracy(0.0);
    monitors.update_confidence_velocity(1.0);

    // Should not panic, just be very unhealthy
    assert!(monitors.has_critical_issue());
    assert!(monitors.overall_health() < 0.5);
}

#[test]
fn test_invariant_empty_params() {
    let mut invariant = Invariant::all_finite("empty_check");

    // Empty params should pass
    let empty: Vec<f64> = vec![];
    assert!(invariant.check(&empty));
}

#[test]
fn test_zone_registry_empty() {
    let registry = ZoneRegistry::new();

    // Empty registry should allow all updates
    assert!(registry.allows_update_index(0));
    assert!(registry.allows_update_index(100));
}

// =============================================================================
// TASK-014 Specified Test Cases
// =============================================================================

/// TASK-014 Test 1: Confirmation Bias Resistance
/// Verifies that the system doesn't lock onto early misleading evidence
#[test]
fn test_resists_confirmation_bias() {
    let mut monitors = EpistemicMonitors::new();
    let config = DissentConfig::step_based(50, 20);
    let mut window = DissentWindow::new(config);

    // Simulate early misleading confidence
    monitors.update_source_agreement(0.9);  // Initially sources agree (on wrong answer)

    // Record predictions - system is initially confident but wrong
    for _ in 0..20 {
        monitors.record_prediction(false, 0.9);  // High confidence, wrong predictions
    }

    // Health should degrade due to poor predictions
    assert!(monitors.predictive_accuracy.value.val < 0.5);
    assert!(monitors.overall_health() < 0.7);

    // Dissent window should trigger exploration
    for _ in 0..30 {
        window.step();
    }

    // During dissent, should be exploring
    if window.is_active() {
        assert!(window.heat_multiplier() > 0.0);
    }

    // After many wrong predictions, confidence velocity should be checked
    // System should NOT remain confident when predictions fail
    assert!(monitors.get_issues().len() > 0);
}

/// TASK-014 Test 2: Calibration Under Pressure
/// Verifies that calibration tracking remains accurate
#[test]
fn test_maintains_calibration_under_pressure() {
    use simplex_learning::belief::CalibrationRecord;

    let mut record = CalibrationRecord::new();

    // Simulate 1000 predictions with varying confidence levels
    // Perfectly calibrated system
    let confidence_levels = [0.5, 0.6, 0.7, 0.8, 0.9];

    for conf in confidence_levels.iter() {
        // For each confidence level, outcomes should match
        let correct_count = (*conf * 100.0) as usize;
        let incorrect_count = 100 - correct_count;

        for _ in 0..correct_count {
            record.record(*conf, true);
        }
        for _ in 0..incorrect_count {
            record.record(*conf, false);
        }
    }

    // ECE should be low for well-calibrated predictions
    let ece = record.compute_ece();
    assert!(ece < 0.1, "ECE should be < 10% for calibrated system, got {}", ece);

    // Brier score should also be reasonable
    let brier = record.compute_brier();
    assert!(brier < 0.3, "Brier score should be reasonable, got {}", brier);
}

/// TASK-014 Test 3: No-Learn Zone Enforcement
/// Verifies that protected regions cannot be modified
#[test]
fn test_no_learn_zones_enforced() {
    let mut registry = ZoneRegistry::new();

    // Create a no-learn zone for safety-critical parameters
    registry.no_learn_indices("safety_weights", &[0, 1, 2, 3, 4]);

    // Attempt to check if update is allowed
    let check = registry.check_before_update(&[0, 1, 2, 5, 6]);

    // Updates to indices 0, 1, 2 should be blocked
    assert!(!check.allowed, "Updates to no-learn zone should be blocked");
    assert!(check.reason.is_some());

    // Index 5, 6 are not protected, but blocked due to shared update
    // Verify the blocking message mentions the protected zone
    let reason = check.reason.unwrap();
    assert!(reason.contains("no-learn") || reason.contains("safety_weights"));
}

/// TASK-014 Test 3b: Gradient Masking in No-Learn Zones
#[test]
fn test_gradients_zeroed_in_protected_zones() {
    let mut registry = ZoneRegistry::new();

    // Block gradients for specific indices
    registry.no_gradient_indices("frozen_layer", &[0, 2, 4]);

    // Create gradients
    let mut gradients = vec![1.0, 2.0, 3.0, 4.0, 5.0];

    // Apply mask
    registry.apply_gradient_mask(&mut gradients);

    // Protected indices should be zeroed
    assert_eq!(gradients[0], 0.0, "Index 0 should be zeroed");
    assert_eq!(gradients[2], 0.0, "Index 2 should be zeroed");
    assert_eq!(gradients[4], 0.0, "Index 4 should be zeroed");

    // Unprotected indices should remain
    assert_eq!(gradients[1], 2.0, "Index 1 should remain unchanged");
    assert_eq!(gradients[3], 4.0, "Index 3 should remain unchanged");
}

/// TASK-014 Test 4: Skeptic Catches Overconfidence
/// Verifies that high-confidence beliefs without evidence are flagged
#[test]
fn test_skeptic_catches_overconfidence() {
    // Create a high-confidence belief with NO evidence
    let belief: GroundedBelief<String> = GroundedBelief::observed(
        "overconfident_claim",
        "The system is definitely safe".to_string(),
        "unknown_source",
        0.99,  // Very high confidence
    );
    // Note: No evidence added!

    // Skeptic should flag this
    let dissent_config = DissentConfig::step_based(10, 8);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.8,
        challenge_cooldown: 0,
        max_challenges_per_window: 10,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active dissent
    for _ in 0..5 {
        skeptic.step();
    }

    // Challenge the belief
    let revision = skeptic.challenge(&belief, &[("evidence_count".to_string(), 0.0)]);

    // Should recommend some action due to high confidence without evidence
    assert!(revision.is_some() || belief.evidence.is_empty(),
            "Skeptic should flag high confidence with no evidence");
}

/// TASK-014 Test 4b: Skeptic Prioritizes High-Confidence Beliefs
#[test]
fn test_skeptic_prioritizes_high_confidence() {
    let dissent_config = DissentConfig::step_based(100, 50);
    let skeptic_config = SkepticConfig {
        min_confidence_to_challenge: 0.6,
        max_challenges_per_window: 2,
        challenge_cooldown: 0,
        ..Default::default()
    };
    let mut skeptic = Skeptic::with_config(skeptic_config, dissent_config);

    // Step into active phase
    for _ in 0..15 {
        skeptic.step();
    }

    // Create beliefs with varying confidence
    let beliefs: Vec<GroundedBelief<String>> = vec![
        GroundedBelief::observed("low", "Low".to_string(), "s", 0.3),
        GroundedBelief::observed("med", "Med".to_string(), "s", 0.65),
        GroundedBelief::observed("high", "High".to_string(), "s", 0.95),
        GroundedBelief::observed("very_high", "VeryHigh".to_string(), "s", 0.99),
    ];

    // Select beliefs to challenge
    let selected = skeptic.select_beliefs_to_challenge(&beliefs);

    // Should select the highest confidence beliefs first
    assert!(selected.len() <= 2);
    for belief in &selected {
        assert!(belief.confidence_value() >= 0.6,
                "Selected belief should have confidence >= threshold");
    }

    // Highest confidence should be preferred
    if selected.len() >= 1 {
        assert!(selected[0].confidence_value() >= 0.9,
                "Highest confidence belief should be selected first");
    }
}

/// Test invariant violation detection
#[test]
fn test_invariant_violations_detected() {
    let mut registry = ZoneRegistry::new();

    // Add invariants
    registry.add_invariant(Invariant::all_finite("no_nan"));
    registry.add_invariant(Invariant::in_range("bounded", -1.0, 1.0));

    // Valid params should pass
    let valid = vec![0.5, -0.3, 0.8];
    let check1 = registry.check_invariants(&valid);
    assert!(check1.all_hold, "Valid params should pass all invariants");

    // Params with NaN should fail
    let with_nan = vec![0.5, f64::NAN, 0.8];
    let check2 = registry.check_invariants(&with_nan);
    assert!(!check2.all_hold, "NaN params should fail all_finite invariant");
    assert!(check2.violations.iter().any(|v| v.name == "no_nan"));

    // Params out of range should fail
    let out_of_range = vec![0.5, 2.0, 0.8];
    let check3 = registry.check_invariants(&out_of_range);
    assert!(!check3.all_hold, "Out of range params should fail in_range invariant");
    assert!(check3.violations.iter().any(|v| v.name == "bounded"));
}

/// Test epistemic health computation
#[test]
fn test_epistemic_health_computation() {
    let mut monitors = EpistemicMonitors::new();

    // Healthy state
    monitors.update_source_agreement(0.9);
    monitors.update_predictive_accuracy(0.85);
    monitors.update_confidence_velocity(0.05);

    let health = EpistemicHealth::from_monitors(&monitors);
    assert!(health.is_healthy());
    assert!(health.score > 0.7);

    // Unhealthy state
    monitors.update_source_agreement(0.2);
    monitors.update_predictive_accuracy(0.3);
    monitors.update_confidence_velocity(0.5);

    let unhealthy = EpistemicHealth::from_monitors(&monitors);
    assert!(!unhealthy.is_healthy());
    assert!(unhealthy.score < 0.5);
    assert!(unhealthy.has_critical_issue);
}

/// Test belief provenance trust weights
#[test]
fn test_provenance_trust_ordering() {
    use simplex_learning::belief::BeliefProvenance;

    let observed = BeliefProvenance::observed("sensor");
    let authoritative = BeliefProvenance::authoritative("expert", 0.8);
    let learned = BeliefProvenance::learned("hash", "v1", 0.75);
    let inferred = BeliefProvenance::inferred(
        vec!["premise1".to_string()],
        simplex_learning::belief::InferenceRule::ModusPonens,
        0.9,
    );
    let prior = BeliefProvenance::prior("assumption");

    // Verify trust weight ordering
    // Observed should have highest trust
    assert!(observed.trust_weight() > authoritative.trust_weight());
    assert!(observed.trust_weight() > learned.trust_weight());
    assert!(observed.trust_weight() > prior.trust_weight());

    // Prior should have lowest trust
    assert!(prior.trust_weight() < authoritative.trust_weight());
    assert!(prior.trust_weight() < learned.trust_weight());
}

/// Test dissent window heat curve
#[test]
fn test_dissent_heat_follows_curve() {
    let config = DissentConfig::step_based(100, 30)
        .with_ramps(5, 5);
    let mut window = DissentWindow::new(config);

    let mut heat_values = Vec::new();

    // Step through full cycle
    for _ in 0..40 {
        window.step();
        heat_values.push(window.heat_multiplier());
    }

    // Should have ramped up
    let max_heat = heat_values.iter().cloned().fold(0.0, f64::max);
    assert!(max_heat > 0.0, "Should reach non-zero heat");

    // Should start at 0
    assert_eq!(heat_values[0], 0.0, "Should start with no heat");

    // Should ramp up gradually
    let ramp_section: Vec<f64> = heat_values[1..6].to_vec();
    for i in 1..ramp_section.len() {
        assert!(ramp_section[i] >= ramp_section[i-1],
                "Heat should increase during ramp-up");
    }
}

/// Test meta-optimizer safe update flow
#[test]
fn test_meta_optimizer_safe_update_flow() {
    let config = MetaOptimizerConfig::development();
    let mut optimizer = EpistemicMetaOptimizer::new(config);

    // Freeze some parameters
    optimizer.freeze_indices("safety", &[0, 1]);

    // Add norm constraint
    optimizer.require_norm_bounded("weights", 10.0);

    // Prepare update
    let params = vec![0.5, 0.5, 0.5, 0.5];
    optimizer.prepare_update(&params);

    // Create gradients
    let mut grads = vec![1.0, 1.0, 1.0, 1.0];

    // Mask should zero frozen indices
    optimizer.mask_gradients(&mut grads);
    assert_eq!(grads[0], 0.0);
    assert_eq!(grads[1], 0.0);
    assert_eq!(grads[2], 1.0);
    assert_eq!(grads[3], 1.0);

    // Finalize with valid params
    let new_params = vec![0.5, 0.5, 0.6, 0.6];
    let result = optimizer.finalize_update(&new_params);
    assert!(result.is_ok() || result.is_err()); // Either is valid
}

/// Test counterfactual scenario generation
#[test]
fn test_counterfactual_scenarios() {
    use simplex_learning::epistemic::CounterfactualProber;

    let prober = CounterfactualProber::new(0.5);

    let belief: GroundedBelief<String> = GroundedBelief::observed(
        "test_belief",
        "Test claim".to_string(),
        "source",
        0.8,
    );

    // Generate counterfactual scenarios
    let scenarios = prober.generate_scenarios(&belief);

    // Should generate at least negation and reduced confidence scenarios
    assert!(scenarios.len() >= 2);

    // Check scenario types
    let has_negation = scenarios.iter().any(|s| s.name.contains("negation"));
    let has_reduced = scenarios.iter().any(|s| s.name.contains("reduced") || s.name.contains("confidence"));

    assert!(has_negation || has_reduced,
            "Should generate basic counterfactual scenarios");
}
