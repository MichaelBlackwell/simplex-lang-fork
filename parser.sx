// Simplex Parser
// Self-hosted parser supporting full language features:
// - impl blocks, self keyword, for loops, match expressions
// - traits and impl Trait for Type
// - generic functions with type parameters
// - struct literals with lookahead disambiguation
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under MIT License - see LICENSE file
// https://github.com/senuamedia/simplex-lang

// Token types enum - duplicated from lexer.sx for standalone compilation
enum TokenKind {
    Eof,
    Ident,
    Int,
    Float,
    String,
    FString,   // f"..." interpolated string
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    DotDot,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub,
    KwStruct,
    KwImpl,
    KwSelf,
    KwMatch,
    FatArrow,
    Underscore,
    AmpAmp,
    PipePipe,
    Percent,
    Amp,
    Pipe,
    Caret,
    LtLt,
    GtGt,
    KwBreak,
    KwContinue,
    Question,
    KwTrait,
    KwType,
    KwUse,
    KwMod,
    KwConst,
    KwAsync,
    KwAwait,
    KwYield,
    KwDyn,
    // Actor model keywords
    KwActor,
    KwReceive,
    KwInit,
    // AI/Cognitive keywords
    KwSpecialist,
    KwInfer,
    KwHive,
    KwAnima,
    // Mutable binding
    KwVar,
    // Spawn expression
    KwSpawn,
    // Neural IR keywords
    KwNeuralGate,
    KwRequires,
    KwEnsures,
    KwInvariant,
    KwFallback,
    // Hardware targeting annotations
    KwCpu,
    KwGpu,
    KwNpu,
    // Annotation symbol
    At
}

// AST node tags - using i64 since stage1 doesn't have proper enums for everything
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }
fn TAG_TRAIT() -> i64 { 4 }
fn TAG_IMPL_TRAIT() -> i64 { 5 }  // impl Trait for Type
fn TAG_MOD() -> i64 { 6 }         // mod name;
fn TAG_USE() -> i64 { 7 }         // use name::item;
fn TAG_ACTOR() -> i64 { 8 }       // actor definition
fn TAG_SPECIALIST() -> i64 { 9 }  // AI specialist
fn TAG_HIVE() -> i64 { 10 }       // cognitive hive
fn TAG_ANIMA() -> i64 { 11 }         // cognitive soul
fn TAG_TYPE_ALIAS() -> i64 { 12 }    // type alias: type Name = Type;
fn TAG_NEURAL_GATE() -> i64 { 13 }   // neural gate with differentiable control flow

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }
fn EXPR_TRY() -> i64 { 16 }  // expr? - early return on error
fn EXPR_AWAIT() -> i64 { 17 }  // expr.await - await future
fn EXPR_FSTRING() -> i64 { 18 }  // f"..." - interpolated string
fn EXPR_YIELD() -> i64 { 19 }    // yield expr - generator yield
fn EXPR_SPAWN() -> i64 { 20 }    // spawn Type - spawn actor/specialist
fn EXPR_ARRAY() -> i64 { 21 }    // [a, b, c] - array literal
fn EXPR_FLOAT() -> i64 { 22 }    // floating point literal
fn EXPR_CLOSURE() -> i64 { 23 }  // (params) => expr - closure/lambda
fn EXPR_INFER() -> i64 { 24 }    // infer(prompt) - AI inference

// Parser state - we pass this to all functions
fn parser_new(tokens: i64) -> i64 {
    // Allocate parser: tokens(0), pos(1), len(2), errors(3)
    let parser: i64 = malloc(32);
    store_ptr(parser, 0, tokens);
    store_i64(parser, 1, 0);
    let len: i64 = vec_len(tokens);
    store_i64(parser, 2, len);
    store_i64(parser, 3, 0);
    parser
}

fn parser_error_count(parser: i64) -> i64 {
    load_i64(parser, 3)
}

fn parser_add_error(parser: i64, msg: i64) -> i64 {
    let count: i64 = load_i64(parser, 3);
    store_i64(parser, 3, count + 1);
    println(string_concat(string_from("Parse error: "), msg));
    0
}

fn parser_tokens(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn parser_pos(parser: i64) -> i64 {
    load_i64(parser, 1)
}

fn parser_len(parser: i64) -> i64 {
    load_i64(parser, 2)
}

fn parser_at_end(parser: i64) -> bool {
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    pos >= len
}

fn parser_current(parser: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    vec_get(tokens, pos)
}

// Peek ahead n tokens (0 = current, 1 = next, etc.)
fn parser_peek(parser: i64, n: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    if pos + n >= len {
        return 0;  // Return null for out of bounds
    }
    vec_get(tokens, pos + n)
}

// Check if token at offset n has the given kind
fn parser_peek_check(parser: i64, n: i64, kind: i64) -> bool {
    let tok: i64 = parser_peek(parser, n);
    if tok == 0 { return false; }
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_advance(parser: i64) -> i64 {
    let tok: i64 = parser_current(parser);
    let pos: i64 = parser_pos(parser);
    store_i64(parser, 1, pos + 1);
    tok
}

fn parser_check(parser: i64, kind: i64) -> bool {
    if parser_at_end(parser) { return false; }
    let tok: i64 = parser_current(parser);
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_match(parser: i64, kind: i64) -> bool {
    if parser_check(parser, kind) {
        parser_advance(parser);
        return true;
    }
    false
}

fn parser_expect(parser: i64, kind: i64) -> i64 {
    if parser_check(parser, kind) {
        return parser_advance(parser);
    }
    // Error - report and continue
    parser_add_error(parser, string_from("unexpected token"));
    0
}

// AST node constructors

// Item: FnDef
// Layout: tag(0), name(1), type_params(2), params(3), ret_ty(4), body(5)
fn ast_fn_def(name: i64, type_params: i64, params: i64, ret_ty: i64, body: i64, is_async: i64) -> i64 {
    let node: i64 = malloc(56);
    store_i64(node, 0, TAG_FN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);  // vec of type param names, or 0 for non-generic
    store_ptr(node, 3, params);
    store_ptr(node, 4, ret_ty);
    store_ptr(node, 5, body);
    store_i64(node, 6, is_async);     // 1 if async fn, 0 otherwise
    node
}

fn ast_fn_is_async(node: i64) -> i64 {
    load_i64(node, 6)
}

// Item: EnumDef
// Layout: tag(0), name(1), variants(2)
fn ast_enum_def(name: i64, variants: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_ENUM());
    store_ptr(node, 1, name);
    store_ptr(node, 2, variants);
    node
}

// Stmt: Let
// Layout: tag(0), name(1), ty(2), init_expr(3)
fn ast_let(name: i64, ty: i64, init_expr: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, STMT_LET());
    store_ptr(node, 1, name);
    store_ptr(node, 2, ty);
    store_ptr(node, 3, init_expr);
    node
}

// Stmt: Expr
// Layout: tag(0), expr(1)
fn ast_expr_stmt(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_EXPR());
    store_ptr(node, 1, expr);
    node
}

// Stmt: Return
// Layout: tag(0), expr(1)
fn ast_return(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_RETURN());
    store_ptr(node, 1, expr);
    node
}

fn ast_break() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_BREAK());
    node
}

fn ast_continue() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_CONTINUE());
    node
}

// Stmt: Assign
// Layout: tag(0), name(1), value(2)
fn ast_assign(name: i64, value: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, STMT_ASSIGN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, value);
    node
}

// Expr: Int literal
// Layout: tag(0), value(1)
fn ast_int(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INT());
    store_i64(node, 1, value);
    node
}

// Expr: Bool literal
// Layout: tag(0), value(1)
fn ast_bool(value: bool) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BOOL());
    store_i64(node, 1, value);
    node
}

// Expr: String literal
// Layout: tag(0), value(1)
fn ast_string(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_STRING());
    store_ptr(node, 1, value);
    node
}

// Expr: FString (interpolated string)
// Layout: tag(0), parts(1), exprs(2)
// parts is a vec of string segments, exprs is a vec of expressions
fn ast_fstring(parts: i64, exprs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FSTRING());
    store_ptr(node, 1, parts);
    store_ptr(node, 2, exprs);
    node
}

// Expr: Identifier
// Layout: tag(0), name(1)
fn ast_ident(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_IDENT());
    store_ptr(node, 1, name);
    node
}

// Expr: Path (Type::Variant)
// Layout: tag(0), segments(1)
fn ast_path(segments: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_PATH());
    store_ptr(node, 1, segments);
    node
}

// Expr: Call
// Layout: tag(0), callee(1), args(2), type_args(3)
fn ast_call(callee: i64, args: i64) -> i64 {
    ast_call_generic(callee, args, 0)
}

fn ast_call_generic(callee: i64, args: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_CALL());
    store_ptr(node, 1, callee);
    store_ptr(node, 2, args);
    store_ptr(node, 3, type_args);  // vec of type names, or 0 for non-generic
    node
}

// Expr: Binary
// Layout: tag(0), op(1), left(2), right(3)
fn ast_binary(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_BINARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, left);
    store_ptr(node, 3, right);
    node
}

// Expr: Unary
// Layout: tag(0), op(1), operand(2)
fn ast_unary(op: i64, operand: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_UNARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, operand);
    node
}

// Expr: If
// Layout: tag(0), cond(1), then_block(2), else_block(3)
fn ast_if(cond: i64, then_block: i64, else_block: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_IF());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, then_block);
    store_ptr(node, 3, else_block);
    node
}

// Expr: While
// Layout: tag(0), cond(1), body(2)
fn ast_while(cond: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_WHILE());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, body);
    node
}

// Expr: For (range-based)
// Layout: tag(0), var_name(1), start(2), end(3), body(4)
fn ast_for(var_name: i64, start: i64, end: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, EXPR_FOR());
    store_ptr(node, 1, var_name);
    store_ptr(node, 2, start);
    store_ptr(node, 3, end);
    store_ptr(node, 4, body);
    node
}

// Expr: Match
// Layout: tag(0), scrutinee(1), arms(2)
// Each arm is (pattern, result) where pattern is an expr (Ident for wildcards, Path for enum variants)
fn ast_match(scrutinee: i64, arms: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_MATCH());
    store_ptr(node, 1, scrutinee);
    store_ptr(node, 2, arms);
    node
}

// Match arm: pattern(0), result(1)
fn ast_match_arm(pattern: i64, result: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, pattern);
    store_ptr(node, 1, result);
    node
}

// Expr: Block
// Layout: tag(0), stmts(1), result(2)
fn ast_block(stmts: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_BLOCK());
    store_ptr(node, 1, stmts);
    store_ptr(node, 2, result);
    node
}

// Item: StructDef
// Layout: tag(0), name(1), type_params(2), fields(3)
// type_params is vec of type param names, or 0 for non-generic
// fields is vec of (name, type) pairs
fn ast_struct_def(name: i64, type_params: i64, fields: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_STRUCT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);
    store_ptr(node, 3, fields);
    node
}

// Item: Impl block
// Layout: tag(0), type_name(1), methods(2)
fn ast_impl(type_name: i64, methods: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_IMPL());
    store_ptr(node, 1, type_name);
    store_ptr(node, 2, methods);
    node
}

// Item: Trait definition
// Layout: tag(0), name(1), method_sigs(2)
fn ast_trait(name: i64, method_sigs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_TRAIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, method_sigs);  // vec of fn signatures (name, params, ret_ty)
    node
}

// Item: Impl Trait for Type
// Layout: tag(0), trait_name(1), type_name(2), methods(3), assoc_types(4)
fn ast_impl_trait(trait_name: i64, type_name: i64, methods: i64, assoc_types: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_IMPL_TRAIT());
    store_ptr(node, 1, trait_name);
    store_ptr(node, 2, type_name);
    store_ptr(node, 3, methods);
    store_ptr(node, 4, assoc_types);  // vec of (name, type) pairs
    node
}

// Associated type mapping
// Layout: name(0), type(1)
fn ast_assoc_type(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Method signature (for traits)
// Layout: name(0), params(1), ret_ty(2)
fn ast_method_sig(name: i64, params: i64, ret_ty: i64) -> i64 {
    let node: i64 = malloc(24);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    node
}

// Default method (trait method with body)
// Layout: name(0), params(1), ret_ty(2), fn_def(3)
fn ast_default_method(name: i64, params: i64, ret_ty: i64, fn_def: i64) -> i64 {
    let node: i64 = malloc(32);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    store_ptr(node, 3, fn_def);
    node
}

// Item: Module declaration (mod name;)
// Layout: tag(0), name(1)
fn ast_mod(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_MOD());
    store_ptr(node, 1, name);
    node
}

// Item: Use statement (use path::item;)
// Layout: tag(0), path(1)  -- path is vec of strings
fn ast_use(path: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_USE());
    store_ptr(node, 1, path);
    node
}

// Item: Type alias (type Name = Type;)
// Layout: tag(0), name(1), target_type(2)
fn ast_type_alias(name: i64, target_type: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_TYPE_ALIAS());
    store_ptr(node, 1, name);
    store_ptr(node, 2, target_type);
    node
}

fn ast_type_alias_name(node: i64) -> i64 {
    load_ptr(node, 1)
}

fn ast_type_alias_target(node: i64) -> i64 {
    load_ptr(node, 2)
}

// Item: Actor definition
// Layout: tag(0), name(1), state_fields(2), receive_handlers(3), init_fn(4)
fn ast_actor(name: i64, state_fields: i64, handlers: i64, init_fn: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_ACTOR());
    store_ptr(node, 1, name);
    store_ptr(node, 2, state_fields);
    store_ptr(node, 3, handlers);
    store_ptr(node, 4, init_fn);
    node
}

// Item: AI Specialist definition
// Layout: tag(0), name(1), capabilities(2), knowledge(3), methods(4)
fn ast_specialist(name: i64, config: i64, state_fields: i64, handlers: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_SPECIALIST());
    store_ptr(node, 1, name);
    store_ptr(node, 2, config);
    store_ptr(node, 3, state_fields);
    store_ptr(node, 4, handlers);
    node
}

// Item: Cognitive Hive definition
// Layout: tag(0), name(1), specialists(2), routing(3)
fn ast_hive(name: i64, specialists: i64, routing: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_HIVE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, specialists);
    store_ptr(node, 3, routing);
    node
}

// Item: Cognitive Hive with mnemonic definition
// Layout: tag(0), name(1), specialists(2), routing(3), mnemonic(4)
fn ast_hive_with_mnemonic(name: i64, specialists: i64, routing: i64, mnemonic: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_HIVE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, specialists);
    store_ptr(node, 3, routing);
    store_ptr(node, 4, mnemonic);  // vec of mnemonic block configs
    node
}

// Item: Anima (Cognitive Soul) definition
// Layout: tag(0), name(1), identity(2), memory(3), beliefs(4), slm(5), persistence(6)
fn ast_anima(name: i64, identity: i64, memory: i64, beliefs: i64, slm: i64, persistence: i64) -> i64 {
    let node: i64 = malloc(56);
    store_i64(node, 0, TAG_ANIMA());
    store_ptr(node, 1, name);
    store_ptr(node, 2, identity);    // vec of key-value pairs
    store_ptr(node, 3, memory);      // vec of key-value pairs
    store_ptr(node, 4, beliefs);     // vec of key-value pairs
    store_ptr(node, 5, slm);         // vec of key-value pairs
    store_ptr(node, 6, persistence); // vec of key-value pairs
    node
}

// Item: Neural Gate definition (differentiable control flow)
// Layout: tag(0), name(1), params(2), ret_ty(3), body(4),
//         requires(5), ensures(6), invariant(7), fallback(8),
//         hardware_target(9), anima_binding(10)
//
// Neural gates are functions that compile differently in training vs inference mode:
// - Training: soft/differentiable (sigmoid, Gumbel-softmax)
// - Inference: discrete/hard (standard conditionals)
//
// The requires/ensures/invariant clauses enable probabilistic formal verification.
// The anima_binding connects gate parameters to the belief system.
fn ast_neural_gate(name: i64, params: i64, ret_ty: i64, body: i64,
                   requires: i64, ensures: i64, invariant: i64, fallback: i64,
                   hardware_target: i64, anima_binding: i64) -> i64 {
    let node: i64 = malloc(88);
    store_i64(node, 0, TAG_NEURAL_GATE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, params);          // vec of (name, type) pairs
    store_ptr(node, 3, ret_ty);          // return type (usually bool or enum)
    store_ptr(node, 4, body);            // the gate condition/expression
    store_ptr(node, 5, requires);        // precondition expression, or 0
    store_ptr(node, 6, ensures);         // postcondition expression, or 0
    store_ptr(node, 7, invariant);       // invariant expression, or 0
    store_ptr(node, 8, fallback);        // fallback block, or 0
    store_i64(node, 9, hardware_target); // 0=auto, 1=cpu, 2=gpu, 3=npu
    store_ptr(node, 10, anima_binding);  // anima name to bind parameters as beliefs, or 0
    node
}

// Hardware target constants for neural gates
fn HW_TARGET_AUTO() -> i64 { 0 }
fn HW_TARGET_CPU() -> i64 { 1 }
fn HW_TARGET_GPU() -> i64 { 2 }
fn HW_TARGET_NPU() -> i64 { 3 }

// Accessors for neural gate AST nodes
fn ast_neural_gate_name(node: i64) -> i64 { load_ptr(node, 1) }
fn ast_neural_gate_params(node: i64) -> i64 { load_ptr(node, 2) }
fn ast_neural_gate_ret_ty(node: i64) -> i64 { load_ptr(node, 3) }
fn ast_neural_gate_body(node: i64) -> i64 { load_ptr(node, 4) }
fn ast_neural_gate_requires(node: i64) -> i64 { load_ptr(node, 5) }
fn ast_neural_gate_ensures(node: i64) -> i64 { load_ptr(node, 6) }
fn ast_neural_gate_invariant(node: i64) -> i64 { load_ptr(node, 7) }
fn ast_neural_gate_fallback(node: i64) -> i64 { load_ptr(node, 8) }
fn ast_neural_gate_hw_target(node: i64) -> i64 { load_i64(node, 9) }
fn ast_neural_gate_anima(node: i64) -> i64 { load_ptr(node, 10) }

// Contract clause: expr with optional label
// Layout: label(0), expr(1)
fn ast_contract_clause(label: i64, expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, label);  // optional label string, or 0
    store_ptr(node, 1, expr);   // the condition expression
    node
}

fn ast_contract_label(node: i64) -> i64 { load_ptr(node, 0) }
fn ast_contract_expr(node: i64) -> i64 { load_ptr(node, 1) }

// Expr: StructLit
// Layout: tag(0), name(1), field_inits(2), type_args(3)
// field_inits is vec of (name, expr) pairs
fn ast_struct_lit(name: i64, field_inits: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_STRUCT_LIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, field_inits);
    store_ptr(node, 3, type_args);
    node
}

// Expr: FieldAccess
// Layout: tag(0), object(1), field_name(2)
fn ast_field_access(object: i64, field_name: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FIELD());
    store_ptr(node, 1, object);
    store_ptr(node, 2, field_name);
    node
}

// Expr: MethodCall
// Layout: tag(0), object(1), method_name(2), args(3)
fn ast_method_call(object: i64, method_name: i64, args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_METHOD_CALL());
    store_ptr(node, 1, object);
    store_ptr(node, 2, method_name);
    store_ptr(node, 3, args);
    node
}

// Expr: Try (? operator)
// Layout: tag(0), inner(1)
fn ast_try(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_TRY());
    store_ptr(node, 1, inner);
    node
}

// Expr: Await (.await)
// Layout: tag(0), inner(1)
fn ast_await(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_AWAIT());
    store_ptr(node, 1, inner);
    node
}

// Expr: Yield (yield expr)
// Layout: tag(0), inner(1)
fn ast_yield(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_YIELD());
    store_ptr(node, 1, inner);
    node
}

// Expr: Spawn (spawn TypeName)
// Layout: tag(0), type_name(1)
fn ast_spawn(type_name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_SPAWN());
    store_ptr(node, 1, type_name);
    node
}

// Expr: Array literal [a, b, c]
// Layout: tag(0), elements(1)
fn ast_array(elements: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_ARRAY());
    store_ptr(node, 1, elements);
    node
}

// Expr: Float literal
// Layout: tag(0), text(1) - store as string for precision
fn ast_float(text: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_FLOAT());
    store_ptr(node, 1, text);
    node
}

// Expr: Infer - AI model inference
// Layout: tag(0), prompt(1)
fn ast_infer(prompt: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INFER());
    store_ptr(node, 1, prompt);
    node
}

// Param: name, type
// Layout: name(0), ty(1)
fn ast_param(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Closure: (params) => body
// Layout: tag(0), params(1), body(2)
fn ast_closure(params: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_CLOSURE());
    store_ptr(node, 1, params);
    store_ptr(node, 2, body);
    node
}

// Binary operator codes
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }

// Unary operator codes
fn OP_NEG() -> i64 { 0 }
fn OP_NOT() -> i64 { 1 }

// Parse f-string content into parts and expressions
// Content like "Hello {name}, you are {age} years old" becomes:
// parts = ["Hello ", ", you are ", " years old"]
// exprs = [ident(name), ident(age)]
fn parse_fstring(parser: i64, content: i64) -> i64 {
    let parts: i64 = vec_new();
    let exprs: i64 = vec_new();
    let current: i64 = string_from("");
    let len: i64 = string_len(content);
    let i: i64 = 0;

    while i < len {
        let c: i64 = string_char_at(content, i);
        if c == 123 {  // '{'
            // Found expression start
            vec_push(parts, current);
            current = string_from("");
            i = i + 1;

            // Extract expression text until '}'
            let expr_text: i64 = string_from("");
            let depth: i64 = 1;
            while i < len {
                let ec: i64 = string_char_at(content, i);
                if ec == 123 {
                    depth = depth + 1;
                    expr_text = string_concat(expr_text, string_from_char(ec));
                } else {
                    if ec == 125 {  // '}'
                        depth = depth - 1;
                        if depth == 0 {
                            i = i + 1;
                            break;
                        }
                        expr_text = string_concat(expr_text, string_from_char(ec));
                    } else {
                        expr_text = string_concat(expr_text, string_from_char(ec));
                    }
                }
                i = i + 1;
            }

            // Parse the expression text
            // For now, just treat it as an identifier for simple cases
            // TODO: Full expression parsing inside f-strings
            vec_push(exprs, ast_ident(expr_text));
        } else {
            current = string_concat(current, string_from_char(c));
            i = i + 1;
        }
    }

    // Add remaining part
    vec_push(parts, current);

    return ast_fstring(parts, exprs);
}

// Parse primary expression
fn parse_primary(parser: i64) -> i64 {
    // Float literal (check before Int to handle properly)
    if parser_check(parser, TokenKind::Float) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_float(text);
    }

    // Integer literal
    if parser_check(parser, TokenKind::Int) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        let value: i64 = string_to_int(text);
        return ast_int(value);
    }

    // Boolean literals
    if parser_check(parser, TokenKind::KwTrue) {
        parser_advance(parser);
        return ast_bool(true);
    }
    if parser_check(parser, TokenKind::KwFalse) {
        parser_advance(parser);
        return ast_bool(false);
    }

    // String literal
    if parser_check(parser, TokenKind::String) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_string(text);
    }

    // FString literal (interpolated string)
    if parser_check(parser, TokenKind::FString) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return parse_fstring(parser, text);
    }

    // Yield expression (for generators)
    if parser_check(parser, TokenKind::KwYield) {
        parser_advance(parser);
        let inner: i64 = parse_expr(parser);
        return ast_yield(inner);
    }

    // Spawn expression (spawn TypeName)
    if parser_check(parser, TokenKind::KwSpawn) {
        parser_advance(parser);
        let type_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_tok);
        return ast_spawn(type_name);
    }

    // Infer expression (infer(prompt)) - AI model inference
    if parser_check(parser, TokenKind::KwInfer) {
        parser_advance(parser);
        parser_expect(parser, TokenKind::LParen);
        let prompt: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return ast_infer(prompt);
    }

    // Array literal [a, b, c]
    if parser_check(parser, TokenKind::LBracket) {
        parser_advance(parser);
        let elements: i64 = vec_new();
        if parser_check(parser, TokenKind::RBracket) == false {
            let first: i64 = parse_expr(parser);
            vec_push(elements, first);
            while parser_match(parser, TokenKind::Comma) {
                let elem: i64 = parse_expr(parser);
                vec_push(elements, elem);
            }
        }
        parser_expect(parser, TokenKind::RBracket);
        return ast_array(elements);
    }

    // 'self' keyword as identifier
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        return ast_ident(string_from("self"));
    }

    // Identifier or path
    if parser_check(parser, TokenKind::Ident) {
        let tok: i64 = parser_advance(parser);
        let name: i64 = token_text(tok);

        // Check for turbofish syntax: foo::<T1, T2>(args)
        // Must check before path handling because :: followed by < is turbofish, not path
        let call_type_args: i64 = 0;
        if parser_check(parser, TokenKind::DoubleColon) {
            // Peek ahead: if next is < then it's turbofish, otherwise it's a path
            // We need to consume :: and check
            parser_advance(parser);
            if parser_check(parser, TokenKind::Lt) {
                // Turbofish!
                parser_advance(parser);
                call_type_args = vec_new();
                // Parse type arguments (can be Ident or Int for const generics)
                if parser_check(parser, TokenKind::Ident) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else if parser_check(parser, TokenKind::Int) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else {
                    parser_add_error(parser, "Expected type or const value");
                }
                while parser_match(parser, TokenKind::Comma) {
                    if parser_check(parser, TokenKind::Ident) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else if parser_check(parser, TokenKind::Int) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else {
                        parser_add_error(parser, "Expected type or const value");
                    }
                }
                parser_expect(parser, TokenKind::Gt);
            } else {
                // Path - could be Type::Variant or Type::function()
                if parser_check(parser, TokenKind::Ident) {
                    let seg_tok: i64 = parser_advance(parser);
                    let seg_name: i64 = token_text(seg_tok);

                    // Check if followed by ( for associated function call
                    if parser_check(parser, TokenKind::LParen) {
                        // Type::function(args) - mangle to Type_function
                        let mangled_name: i64 = string_concat(name, "_");
                        mangled_name = string_concat(mangled_name, seg_name);
                        parser_advance(parser);  // consume (
                        let args: i64 = vec_new();
                        if parser_check(parser, TokenKind::RParen) == false {
                            let first_arg: i64 = parse_expr(parser);
                            vec_push(args, first_arg);
                            while parser_match(parser, TokenKind::Comma) {
                                let arg: i64 = parse_expr(parser);
                                vec_push(args, arg);
                            }
                        }
                        parser_expect(parser, TokenKind::RParen);
                        return ast_call(ast_ident(mangled_name), args);
                    }

                    // Path: Name::Variant (possibly with more segments)
                    let segments: i64 = vec_new();
                    vec_push(segments, name);
                    vec_push(segments, seg_name);

                    while parser_match(parser, TokenKind::DoubleColon) {
                        if parser_check(parser, TokenKind::Ident) {
                            let next_seg: i64 = parser_advance(parser);
                            vec_push(segments, token_text(next_seg));
                        }
                    }
                    return ast_path(segments);
                }
            }
        }

        // Check for function call
        if parser_check(parser, TokenKind::LParen) {
            parser_advance(parser);
            let args: i64 = vec_new();

            if parser_check(parser, TokenKind::RParen) {
                // Empty args
            } else {
                let first_arg: i64 = parse_expr(parser);
                vec_push(args, first_arg);

                while parser_match(parser, TokenKind::Comma) {
                    let arg: i64 = parse_expr(parser);
                    vec_push(args, arg);
                }
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_call_generic(ast_ident(name), args, call_type_args);
        }

        // Struct literal syntax: Name { field: value, ... }
        // Disambiguate from `if cond { ... }` by checking if { is followed by:
        // - `}` (empty struct literal)
        // - `Ident :` (field initialization)
        if parser_check(parser, TokenKind::LBrace) {
            // Look ahead to see if this is a struct literal
            let is_struct_lit: bool = false;

            // Check for empty struct: Name { }
            if parser_peek_check(parser, 1, TokenKind::RBrace) {
                is_struct_lit = true;
            }
            // Check for field init: Name { field: value }
            if parser_peek_check(parser, 1, TokenKind::Ident) {
                if parser_peek_check(parser, 2, TokenKind::Colon) {
                    is_struct_lit = true;
                }
            }

            if is_struct_lit {
                parser_advance(parser);  // consume {
                let field_inits: i64 = vec_new();

                while parser_check(parser, TokenKind::RBrace) == false {
                    // Parse field: name: value
                    let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let field_name: i64 = token_text(field_name_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let field_value: i64 = parse_expr(parser);

                    // Create field init pair (name, value)
                    let field_init: i64 = malloc(16);
                    store_ptr(field_init, 0, field_name);
                    store_ptr(field_init, 1, field_value);
                    vec_push(field_inits, field_init);

                    // Optional comma
                    if parser_check(parser, TokenKind::RBrace) == false {
                        parser_match(parser, TokenKind::Comma);
                    }
                }

                parser_expect(parser, TokenKind::RBrace);
                return ast_struct_lit(name, field_inits, call_type_args);
            }
        }

        return ast_ident(name);
    }

    // Parenthesized expression or closure: (expr) or (params) => body
    if parser_check(parser, TokenKind::LParen) {
        // Check if this is a closure: () => body or (x: i64) => body
        // Lookahead: if we see ) => or ident : after (, it's likely a closure
        let is_closure: bool = false;

        // () => body  - empty params closure
        if parser_peek_check(parser, 1, TokenKind::RParen) {
            if parser_peek_check(parser, 2, TokenKind::FatArrow) {
                is_closure = true;
            }
        }
        // (ident : type) => body  - closure with params
        if parser_peek_check(parser, 1, TokenKind::Ident) {
            if parser_peek_check(parser, 2, TokenKind::Colon) {
                is_closure = true;
            }
        }

        if is_closure {
            parser_advance(parser);  // consume (
            let params: i64 = vec_new();

            // Parse params if not empty
            if parser_check(parser, TokenKind::RParen) == false {
                // Parse first param: name : type
                let p_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let p_name: i64 = token_text(p_name_tok);
                parser_expect(parser, TokenKind::Colon);
                let p_type: i64 = parse_type(parser);
                vec_push(params, ast_param(p_name, p_type));

                // Parse more params
                while parser_match(parser, TokenKind::Comma) {
                    let pn_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let pn: i64 = token_text(pn_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let pt: i64 = parse_type(parser);
                    vec_push(params, ast_param(pn, pt));
                }
            }

            parser_expect(parser, TokenKind::RParen);
            parser_expect(parser, TokenKind::FatArrow);
            let body: i64 = parse_expr(parser);
            return ast_closure(params, body);
        }

        // Not a closure - parenthesized expression
        parser_advance(parser);  // consume (
        let expr: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return expr;
    }

    // If expression
    if parser_check(parser, TokenKind::KwIf) {
        return parse_if(parser);
    }

    // While expression
    if parser_check(parser, TokenKind::KwWhile) {
        return parse_while(parser);
    }

    // For expression
    if parser_check(parser, TokenKind::KwFor) {
        return parse_for(parser);
    }

    // Match expression
    if parser_check(parser, TokenKind::KwMatch) {
        return parse_match(parser);
    }

    // Block expression
    if parser_check(parser, TokenKind::LBrace) {
        return parse_block(parser);
    }

    // Error - advance past unrecognized token to prevent infinite loop
    if parser_at_end(parser) == false {
        parser_advance(parser);
    }
    0
}

// Parse postfix expression (field access: expr.field, method call: expr.method(args), try: expr?, await: expr.await)
fn parse_postfix(parser: i64) -> i64 {
    let expr: i64 = parse_primary(parser);

    while true {
        if parser_match(parser, TokenKind::Dot) {
            // Check for .await keyword
            if parser_check(parser, TokenKind::KwAwait) {
                parser_advance(parser);
                expr = ast_await(expr);
            } else {
                let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let name: i64 = token_text(name_tok);

                // Check if this is a method call (followed by '(')
                if parser_check(parser, TokenKind::LParen) {
                    parser_advance(parser);
                    let args: i64 = vec_new();

                    if parser_check(parser, TokenKind::RParen) {
                        // Empty args
                    } else {
                        let first_arg: i64 = parse_expr(parser);
                        vec_push(args, first_arg);

                        while parser_match(parser, TokenKind::Comma) {
                            let arg: i64 = parse_expr(parser);
                            vec_push(args, arg);
                        }
                    }

                    parser_expect(parser, TokenKind::RParen);
                    expr = ast_method_call(expr, name, args);
                } else {
                    // Field access
                    expr = ast_field_access(expr, name);
                }
            }
        } else {
            // Try operator: expr?
            if parser_match(parser, TokenKind::Question) {
                expr = ast_try(expr);
            } else {
                return expr;
            }
        }
    }

    expr
}

// Parse unary expression
fn parse_unary(parser: i64) -> i64 {
    if parser_match(parser, TokenKind::Minus) {
        // Optimize: if next token is a numeric literal, negate directly
        // This fixes issues with negative float bit representations
        if parser_check(parser, TokenKind::Float) {
            let tok: i64 = parser_advance(parser);
            let text: i64 = token_text(tok);
            let neg_text: i64 = string_concat(string_from("-"), text);
            return ast_float(neg_text);
        }
        if parser_check(parser, TokenKind::Int) {
            let tok: i64 = parser_advance(parser);
            let text: i64 = token_text(tok);
            let value: i64 = string_to_int(text);
            return ast_int(0 - value);
        }
        // Otherwise, create unary negation expression
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NEG(), operand);
    }
    if parser_match(parser, TokenKind::Bang) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NOT(), operand);
    }
    parse_postfix(parser)
}

// Parse multiplicative expression
fn parse_multiplicative(parser: i64) -> i64 {
    let left: i64 = parse_unary(parser);

    while true {
        if parser_match(parser, TokenKind::Star) {
            let right: i64 = parse_unary(parser);
            left = ast_binary(OP_MUL(), left, right);
        } else {
            if parser_match(parser, TokenKind::Slash) {
                let right: i64 = parse_unary(parser);
                left = ast_binary(OP_DIV(), left, right);
            } else {
                if parser_match(parser, TokenKind::Percent) {
                    let right: i64 = parse_unary(parser);
                    left = ast_binary(OP_MOD(), left, right);
                } else {
                    return left;
                }
            }
        }
    }
    left
}

// Parse additive expression
fn parse_additive(parser: i64) -> i64 {
    let left: i64 = parse_multiplicative(parser);

    while true {
        if parser_match(parser, TokenKind::Plus) {
            let right: i64 = parse_multiplicative(parser);
            left = ast_binary(OP_ADD(), left, right);
        } else {
            if parser_match(parser, TokenKind::Minus) {
                let right: i64 = parse_multiplicative(parser);
                left = ast_binary(OP_SUB(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse shift expression (<< >>)
fn parse_shift(parser: i64) -> i64 {
    let left: i64 = parse_additive(parser);

    while true {
        if parser_match(parser, TokenKind::LtLt) {
            let right: i64 = parse_additive(parser);
            left = ast_binary(OP_SHL(), left, right);
        } else {
            if parser_match(parser, TokenKind::GtGt) {
                let right: i64 = parse_additive(parser);
                left = ast_binary(OP_SHR(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse comparison expression
fn parse_comparison(parser: i64) -> i64 {
    let left: i64 = parse_shift(parser);

    if parser_match(parser, TokenKind::EqEq) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_EQ(), left, right);
    }
    if parser_match(parser, TokenKind::Ne) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_NE(), left, right);
    }
    if parser_match(parser, TokenKind::Lt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LT(), left, right);
    }
    if parser_match(parser, TokenKind::Gt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GT(), left, right);
    }
    if parser_match(parser, TokenKind::Le) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LE(), left, right);
    }
    if parser_match(parser, TokenKind::Ge) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GE(), left, right);
    }
    left
}

// Parse bitwise AND expression (&)
fn parse_bitand(parser: i64) -> i64 {
    let left: i64 = parse_comparison(parser);

    while parser_match(parser, TokenKind::Amp) {
        let right: i64 = parse_comparison(parser);
        left = ast_binary(OP_BITAND(), left, right);
    }
    left
}

// Parse bitwise XOR expression (^)
fn parse_bitxor(parser: i64) -> i64 {
    let left: i64 = parse_bitand(parser);

    while parser_match(parser, TokenKind::Caret) {
        let right: i64 = parse_bitand(parser);
        left = ast_binary(OP_BITXOR(), left, right);
    }
    left
}

// Parse bitwise OR expression (|)
fn parse_bitor(parser: i64) -> i64 {
    let left: i64 = parse_bitxor(parser);

    while parser_match(parser, TokenKind::Pipe) {
        let right: i64 = parse_bitxor(parser);
        left = ast_binary(OP_BITOR(), left, right);
    }
    left
}

// Parse logical AND expression (&&)
fn parse_and(parser: i64) -> i64 {
    let left: i64 = parse_bitor(parser);

    while parser_match(parser, TokenKind::AmpAmp) {
        let right: i64 = parse_bitor(parser);
        left = ast_binary(OP_AND(), left, right);
    }
    left
}

// Parse logical OR expression (||)
fn parse_or(parser: i64) -> i64 {
    let left: i64 = parse_and(parser);

    while parser_match(parser, TokenKind::PipePipe) {
        let right: i64 = parse_and(parser);
        left = ast_binary(OP_OR(), left, right);
    }
    left
}

// Parse expression
fn parse_expr(parser: i64) -> i64 {
    parse_or(parser)
}

// Parse block
fn parse_block(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::LBrace);
    let stmts: i64 = vec_new();
    let result: i64 = 0;

    while true {
        // Check for EOF to prevent infinite loop on incomplete input
        if parser_at_end(parser) {
            return ast_block(stmts, result);
        }

        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_block(stmts, result);
        }

        // Check for statement vs expression
        if parser_check(parser, TokenKind::KwLet) {
            let stmt: i64 = parse_let(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwVar) {
            // var is like let but for mutable bindings
            let stmt: i64 = parse_var(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwReturn) {
            let stmt: i64 = parse_return(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwBreak) {
            parser_advance(parser);
            parser_expect(parser, TokenKind::Semi);
            let stmt: i64 = ast_break();
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwContinue) {
            parser_advance(parser);
            parser_expect(parser, TokenKind::Semi);
            let stmt: i64 = ast_continue();
            vec_push(stmts, stmt);
        } else {
            // Expression - could be statement, assignment, or result
            let expr: i64 = parse_expr(parser);

            // Check for assignment: ident = expr;
            if parser_match(parser, TokenKind::Eq) {
                // This is an assignment statement
                // expr should be an identifier
                let expr_tag: i64 = load_i64(expr, 0);
                if expr_tag == EXPR_IDENT() {
                    let name: i64 = load_ptr(expr, 1);
                    let value: i64 = parse_expr(parser);
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_assign(name, value));
                } else {
                    // Invalid assignment target, treat as expression
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_expr_stmt(expr));
                }
            } else {
                if parser_match(parser, TokenKind::Semi) {
                    // Expression statement with explicit semicolon
                    vec_push(stmts, ast_expr_stmt(expr));
                } else {
                    // No semicolon - check if more statements follow
                    if parser_check(parser, TokenKind::RBrace) {
                        // Next is }, so this is the result expression
                        result = expr;
                    } else {
                        // More statements follow, so this is an implicit statement
                        // (if/while don't need semicolons when followed by more code)
                        vec_push(stmts, ast_expr_stmt(expr));
                    }
                }
            }
        }
        }
        }
        }
        }
    }

    ast_block(stmts, result)
}

// Parse var statement (mutable binding)
fn parse_var(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwVar);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse if expression
fn parse_if(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwIf);
    let cond: i64 = parse_expr(parser);
    let then_block: i64 = parse_block(parser);
    let else_block: i64 = 0;

    if parser_match(parser, TokenKind::KwElse) {
        // Check if it's else-if or else block
        if parser_check(parser, TokenKind::KwIf) {
            else_block = parse_if(parser);
        } else {
            else_block = parse_block(parser);
        }
    }

    ast_if(cond, then_block, else_block)
}

// Parse while expression
fn parse_while(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwWhile);
    let cond: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_while(cond, body)
}

// Parse for expression: for i in start..end { body }
fn parse_for(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFor);
    let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let var_name: i64 = token_text(var_tok);
    parser_expect(parser, TokenKind::KwIn);
    let start: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::DotDot);
    let end: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_for(var_name, start, end, body)
}

// Parse match expression: match expr { pattern => result, ... }
fn parse_match(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMatch);
    let scrutinee: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::LBrace);

    let arms: i64 = vec_new();

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_match(scrutinee, arms);
        }

        // Parse pattern - could be:
        // - Underscore: wildcard
        // - Path: EnumName::Variant
        // - Ident: variable or enum variant
        let pattern: i64 = 0;
        if parser_match(parser, TokenKind::Underscore) {
            // Wildcard pattern - use null to indicate wildcard
            pattern = 0;
        } else {
            // Parse as expression (will handle paths and identifiers)
            pattern = parse_expr(parser);
        }

        parser_expect(parser, TokenKind::FatArrow);

        // Parse arm result (could be block or expression)
        let result: i64 = 0;
        if parser_check(parser, TokenKind::LBrace) {
            result = parse_block(parser);
        } else {
            result = parse_expr(parser);
        }

        vec_push(arms, ast_match_arm(pattern, result));

        // Optional comma between arms
        parser_match(parser, TokenKind::Comma);
    }

    ast_match(scrutinee, arms)
}

// Parse let statement
fn parse_let(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwLet);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse return statement
fn parse_return(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwReturn);
    let expr: i64 = 0;

    if parser_check(parser, TokenKind::Semi) {
        // return;
    } else {
        expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_return(expr)
}

// Parse type: handles simple idents, Self, Self::AssocType, and dyn Trait
fn parse_type(parser: i64) -> i64 {
    // Check for dyn keyword (dynamic trait object)
    if parser_check(parser, TokenKind::KwDyn) {
        parser_advance(parser);  // consume 'dyn'
        let trait_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let trait_name: i64 = token_text(trait_tok);
        // Return "dyn:TraitName" as the type string - will be resolved in codegen
        return string_concat(string_from("dyn:"), trait_name);
    }
    // Check for Self keyword
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        // Check for Self::AssocType syntax
        if parser_check(parser, TokenKind::DoubleColon) {
            parser_advance(parser);  // consume ::
            let assoc_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let assoc_name: i64 = token_text(assoc_tok);
            // Return "Self::TypeName" as the type string - will be resolved in codegen
            return string_concat(string_from("Self::"), assoc_name);
        }
        // Just Self - refers to the implementing type
        return string_from("Self");
    }
    // Regular identifier type
    let tok: i64 = parser_expect(parser, TokenKind::Ident);
    let type_name: i64 = token_text(tok);

    // Phase 36: Handle generic type arguments like Option<i64>, Result<T, E>, Vec<T>
    if parser_check(parser, TokenKind::Lt) {
        parser_advance(parser);  // consume <
        let type_args: i64 = vec_new();

        // First type argument
        let first_arg: i64 = parse_type(parser);
        vec_push(type_args, first_arg);

        // Additional type arguments
        while parser_match(parser, TokenKind::Comma) {
            let arg: i64 = parse_type(parser);
            vec_push(type_args, arg);
        }

        parser_expect(parser, TokenKind::Gt);

        // Build type string: Name<Arg1, Arg2, ...>
        let result: i64 = string_concat(type_name, string_from("<"));
        let n: i64 = vec_len(type_args);
        let i: i64 = 0;
        while i < n {
            if i > 0 {
                result = string_concat(result, string_from(", "));
            }
            result = string_concat(result, vec_get(type_args, i));
            i = i + 1;
        }
        result = string_concat(result, string_from(">"));
        return result;
    }

    type_name
}

// Parse function parameters
fn parse_params(parser: i64) -> i64 {
    let params: i64 = vec_new();
    parser_expect(parser, TokenKind::LParen);

    if parser_check(parser, TokenKind::RParen) {
        parser_advance(parser);
        return params;
    }

    // First param - accept either Ident or 'self' keyword
    let name: i64 = 0;
    let ty: i64 = 0;
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        name = string_from("self");
        // Check if self has explicit type (self: Type) or implicit (bare self)
        if parser_check(parser, TokenKind::Colon) {
            parser_advance(parser);
            ty = parse_type(parser);
        } else {
            // Bare self - type is implicit (Self)
            ty = string_from("Self");
        }
    } else {
        let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        name = token_text(name_tok);
        parser_expect(parser, TokenKind::Colon);
        ty = parse_type(parser);
    }
    vec_push(params, ast_param(name, ty));

    // More params
    while parser_match(parser, TokenKind::Comma) {
        let pname: i64 = 0;
        let pty: i64 = 0;
        if parser_check(parser, TokenKind::KwSelf) {
            parser_advance(parser);
            pname = string_from("self");
            if parser_check(parser, TokenKind::Colon) {
                parser_advance(parser);
                pty = parse_type(parser);
            } else {
                pty = string_from("Self");
            }
        } else {
            let pname_tok: i64 = parser_expect(parser, TokenKind::Ident);
            pname = token_text(pname_tok);
            parser_expect(parser, TokenKind::Colon);
            pty = parse_type(parser);
        }
        vec_push(params, ast_param(pname, pty));
    }

    parser_expect(parser, TokenKind::RParen);
    params
}

// Parse type parameters: <T, U, V> or <T: Trait, U: Bound>
// Returns a vec of type param strings. For bounded params, stores as "name:bound"
// For const params, stores as "const:name"
fn parse_type_params(parser: i64) -> i64 {
    if parser_check(parser, TokenKind::Lt) == false {
        return 0;  // No type params
    }
    parser_advance(parser);  // consume <

    let type_params: i64 = vec_new();

    // First type param (may be const or type with optional bound)
    if parser_check(parser, TokenKind::KwConst) {
        // const N: Type
        parser_advance(parser);
        let tok: i64 = parser_expect(parser, TokenKind::Ident);
        parser_expect(parser, TokenKind::Colon);
        parse_type(parser);  // Skip the type for now
        // Store with "const:" prefix to distinguish
        vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
    } else {
        if parser_check(parser, TokenKind::Ident) {
            let tok: i64 = parser_advance(parser);
            let param_name: i64 = token_text(tok);
            // Check for trait bound: T: Trait
            if parser_match(parser, TokenKind::Colon) {
                if parser_check(parser, TokenKind::Ident) {
                    let bound_tok: i64 = parser_advance(parser);
                    // Store as "T:Trait" - type param with bound
                    param_name = string_concat(param_name, ":");
                    param_name = string_concat(param_name, token_text(bound_tok));
                    // Handle additional bounds with + (e.g., T: A + B)
                    while parser_match(parser, TokenKind::Plus) {
                        if parser_check(parser, TokenKind::Ident) {
                            let extra_bound: i64 = parser_advance(parser);
                            param_name = string_concat(param_name, "+");
                            param_name = string_concat(param_name, token_text(extra_bound));
                        }
                    }
                }
            }
            vec_push(type_params, param_name);
        }
    }

    // Additional type params
    while parser_match(parser, TokenKind::Comma) {
        if parser_check(parser, TokenKind::KwConst) {
            parser_advance(parser);
            let tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Colon);
            parse_type(parser);
            vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
        } else {
            if parser_check(parser, TokenKind::Ident) {
                let tok: i64 = parser_advance(parser);
                let param_name: i64 = token_text(tok);
                // Check for trait bound
                if parser_match(parser, TokenKind::Colon) {
                    if parser_check(parser, TokenKind::Ident) {
                        let bound_tok: i64 = parser_advance(parser);
                        param_name = string_concat(param_name, ":");
                        param_name = string_concat(param_name, token_text(bound_tok));
                        while parser_match(parser, TokenKind::Plus) {
                            if parser_check(parser, TokenKind::Ident) {
                                let extra_bound: i64 = parser_advance(parser);
                                param_name = string_concat(param_name, "+");
                                param_name = string_concat(param_name, token_text(extra_bound));
                            }
                        }
                    }
                }
                vec_push(type_params, param_name);
            }
        }
    }

    parser_expect(parser, TokenKind::Gt);
    type_params
}

// Parse function definition (is_async: 1 if preceded by async keyword)
fn parse_fn(parser: i64, is_async: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFn);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let params: i64 = parse_params(parser);

    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    let body: i64 = parse_block(parser);
    ast_fn_def(name, type_params, params, ret_ty, body, is_async)
}

// Parse enum definition
fn parse_enum(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwEnum);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let variants: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_enum_def(name, variants);
        }

        let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let var_name: i64 = token_text(var_tok);
        vec_push(variants, var_name);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_enum_def(name, variants)
}

// Parse struct definition with optional type parameters
// struct Name<T, U> { field: T, ... }
fn parse_struct(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwStruct);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let fields: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_struct_def(name, type_params, fields);
        }

        // Parse field: name: Type
        let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let field_name: i64 = token_text(field_name_tok);
        parser_expect(parser, TokenKind::Colon);
        let field_ty: i64 = parse_type(parser);

        // Create field pair (name, type)
        let field: i64 = malloc(16);
        store_ptr(field, 0, field_name);
        store_ptr(field, 1, field_ty);
        vec_push(fields, field);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_struct_def(name, type_params, fields)
}

// Parse trait definition: trait Name { type AssocType; fn method(...) -> Type; }
fn parse_trait(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwTrait);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let method_sigs: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_trait(name, method_sigs);
        }

        // Check for associated type: type Name;
        if parser_check(parser, TokenKind::KwType) {
            parser_advance(parser);
            let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Semi);
            // Store associated type as a method sig with null params (to distinguish)
            vec_push(method_sigs, ast_method_sig(token_text(type_name_tok), 0, 0));
        } else {
            // Parse method signature: fn name(params) -> Type;
            // OR default method: fn name(params) -> Type { body }
            let is_async: i64 = 0;
            if parser_check(parser, TokenKind::KwAsync) {
                parser_advance(parser);
                is_async = 1;
            }
            parser_expect(parser, TokenKind::KwFn);
            let method_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let method_name: i64 = token_text(method_name_tok);
            let params: i64 = parse_params(parser);

            let ret_ty: i64 = 0;
            if parser_match(parser, TokenKind::Arrow) {
                ret_ty = parse_type(parser);
            }

            // Check for semicolon (signature only) or brace (default impl)
            if parser_check(parser, TokenKind::Semi) {
                parser_advance(parser);
                vec_push(method_sigs, ast_method_sig(method_name, params, ret_ty));
            } else if parser_check(parser, TokenKind::LBrace) {
                // Default method implementation - parse full function
                let body: i64 = parse_block(parser);
                let default_fn: i64 = ast_fn_def(method_name, 0, params, ret_ty, body, is_async);
                // Store default method (with body field set)
                vec_push(method_sigs, ast_default_method(method_name, params, ret_ty, default_fn));
            }
        }
    }

    ast_trait(name, method_sigs)
}

// Parse impl block: impl TypeName { ... } or impl TraitName for TypeName { ... }
fn parse_impl(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwImpl);
    let first_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let first_name: i64 = token_text(first_name_tok);

    // Check if this is "impl Trait for Type" syntax
    if parser_check(parser, TokenKind::KwFor) {
        parser_advance(parser);  // consume 'for'
        let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_name_tok);

        let methods: i64 = vec_new();
        let assoc_types: i64 = vec_new();
        parser_expect(parser, TokenKind::LBrace);

        while parser_check(parser, TokenKind::RBrace) == false {
            parser_match(parser, TokenKind::KwPub);
            // Check for associated type definition: type Name = Type;
            if parser_check(parser, TokenKind::KwType) {
                parser_advance(parser);
                let assoc_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let assoc_name: i64 = token_text(assoc_name_tok);
                parser_expect(parser, TokenKind::Eq);     // =
                let assoc_ty: i64 = parse_type(parser);   // Type
                parser_expect(parser, TokenKind::Semi);   // ;
                // Store the associated type mapping
                vec_push(assoc_types, ast_assoc_type(assoc_name, assoc_ty));
            } else {
                // Check for async fn
                let is_async: i64 = 0;
                if parser_check(parser, TokenKind::KwAsync) {
                    parser_advance(parser);
                    is_async = 1;
                }
                let method: i64 = parse_fn(parser, is_async);
                vec_push(methods, method);
            }
        }
        parser_advance(parser);  // consume }

        return ast_impl_trait(first_name, type_name, methods, assoc_types);
    }

    // Regular impl block: impl TypeName { ... }
    let methods: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_impl(first_name, methods);
        }

        // Skip pub keyword if present
        parser_match(parser, TokenKind::KwPub);

        // Check for async fn
        let is_async: i64 = 0;
        if parser_check(parser, TokenKind::KwAsync) {
            parser_advance(parser);
            is_async = 1;
        }

        // Parse method (must be fn)
        if parser_check(parser, TokenKind::KwFn) {
            let method: i64 = parse_fn(parser, is_async);
            vec_push(methods, method);
        }
    }

    ast_impl(first_name, methods)
}

// Parse mod declaration: mod name;
fn parse_mod(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMod);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Semi);
    ast_mod(name)
}

// Parse use statement: use name::item;
fn parse_use(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwUse);
    let path: i64 = vec_new();

    // Parse first segment
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    vec_push(path, token_text(name_tok));

    // Parse remaining segments (::name)
    while parser_match(parser, TokenKind::DoubleColon) {
        let seg_tok: i64 = parser_expect(parser, TokenKind::Ident);
        vec_push(path, token_text(seg_tok));
    }

    parser_expect(parser, TokenKind::Semi);
    ast_use(path)
}

// Parse type alias: type Name = Type;
fn parse_type_alias(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwType);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Eq);
    let target_type: i64 = parse_type(parser);
    parser_expect(parser, TokenKind::Semi);
    ast_type_alias(name, target_type)
}

// Parse actor definition
// actor Name { var field: Type = init, init(params) { }, receive MsgName(params) -> RetType { } }
fn parse_actor(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwActor);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();
    let init_fn: i64 = 0;

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in actor"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for init block
        if parser_check(parser, TokenKind::KwInit) {
            parser_advance(parser);
            // parse_params handles LParen and RParen internally
            let init_params: i64 = parse_params(parser);
            let body: i64 = parse_block(parser);
            let init_node: i64 = malloc(16);
            store_ptr(init_node, 0, init_params);
            store_ptr(init_node, 1, body);
            init_fn = init_node;
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            let body: i64 = parse_block(parser);
            let handler: i64 = malloc(32);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            vec_push(handlers, handler);
        } else {
            parser_add_error(parser, string_from("Unexpected token in actor"));
            parser_advance(parser);
        }
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_actor(name, state_fields, handlers, init_fn)
}

// Parse specialist definition (like actor but with model config)
// specialist Name { model: "str", var field: Type = init, receive MsgName(params) -> RetType { } }
fn parse_specialist(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwSpecialist);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let config: i64 = vec_new();  // model config key-value pairs
    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in specialist"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            let body: i64 = parse_block(parser);
            let handler: i64 = malloc(32);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            vec_push(handlers, handler);
        } else {
            // Config property: name: value (string or number)
            let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let prop_name: i64 = token_text(prop_tok);
            parser_expect(parser, TokenKind::Colon);
            let prop_val: i64 = parse_expr(parser);
            let prop: i64 = malloc(16);
            store_ptr(prop, 0, prop_name);
            store_ptr(prop, 1, prop_val);
            vec_push(config, prop);
            parser_match(parser, TokenKind::Comma);
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_specialist(name, config, state_fields, handlers)
}

// Parse hive definition
// hive Name { specialists: [...], router: X, strategy: Y, mnemonic { ... } }
fn parse_hive(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwHive);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let specialists: i64 = vec_new();
    let routing: i64 = vec_new();
    let mnemonic: i64 = vec_new();  // mnemonic config blocks

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in hive"));
            return 0;
        }

        let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let prop_name: i64 = token_text(prop_tok);

        // Check for mnemonic block (no colon, just brace)
        if string_eq(prop_name, string_from("mnemonic")) {
            if parser_check(parser, TokenKind::LBrace) {
                // Parse mnemonic sub-blocks: episodic, semantic, beliefs
                parser_advance(parser);
                while parser_check(parser, TokenKind::RBrace) == false {
                    let block_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let block_name: i64 = token_text(block_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let block_config: i64 = parse_config_block(parser);
                    let block: i64 = malloc(16);
                    store_ptr(block, 0, block_name);
                    store_ptr(block, 1, block_config);
                    vec_push(mnemonic, block);
                    parser_match(parser, TokenKind::Comma);
                }
                parser_expect(parser, TokenKind::RBrace);
            }
        } else {
            parser_expect(parser, TokenKind::Colon);

            // Parse array of specialist names or identifier value
            if parser_check(parser, TokenKind::LBracket) {
                parser_advance(parser);
                let items: i64 = vec_new();
                while parser_check(parser, TokenKind::RBracket) == false {
                    let item_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    vec_push(items, token_text(item_tok));
                    parser_match(parser, TokenKind::Comma);
                }
                parser_expect(parser, TokenKind::RBracket);

                if string_eq(prop_name, string_from("specialists")) {
                    specialists = items;
                }
            } else {
                // Simple identifier value (router, strategy, etc.)
                if parser_check(parser, TokenKind::Ident) {
                    let val_tok: i64 = parser_advance(parser);
                    let val: i64 = token_text(val_tok);
                    // Store in routing for now (we can extend later)
                    vec_push(routing, prop_name);
                    vec_push(routing, val);
                }
            }
        }
        parser_match(parser, TokenKind::Comma);
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_hive_with_mnemonic(name, specialists, routing, mnemonic)
}

// Parse a block of key-value pairs { key: value, ... }
fn parse_config_block(parser: i64) -> i64 {
    let config: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            return config;
        }

        let key_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let key: i64 = token_text(key_tok);
        parser_expect(parser, TokenKind::Colon);

        // Parse value - can be string, array, or expression
        let val: i64 = 0;
        if parser_check(parser, TokenKind::LBracket) {
            // Array of strings
            parser_advance(parser);
            let items: i64 = vec_new();
            while parser_check(parser, TokenKind::RBracket) == false {
                if parser_check(parser, TokenKind::String) {
                    let s_tok: i64 = parser_advance(parser);
                    vec_push(items, token_text(s_tok));
                } else {
                    if parser_check(parser, TokenKind::Ident) {
                        let i_tok: i64 = parser_advance(parser);
                        vec_push(items, token_text(i_tok));
                    } else {
                        parser_advance(parser);
                    }
                }
                parser_match(parser, TokenKind::Comma);
            }
            parser_expect(parser, TokenKind::RBracket);
            val = items;
        } else {
            val = parse_expr(parser);
        }

        let pair: i64 = malloc(16);
        store_ptr(pair, 0, key);
        store_ptr(pair, 1, val);
        vec_push(config, pair);
        parser_match(parser, TokenKind::Comma);
    }

    parser_expect(parser, TokenKind::RBrace);
    config
}

// Parse anima definition (cognitive soul)
// anima Name { identity { ... } memory { ... } beliefs { ... } slm { ... } persistence { ... } }
fn parse_anima(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwAnima);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let identity: i64 = vec_new();
    let memory: i64 = vec_new();
    let beliefs: i64 = vec_new();
    let slm: i64 = vec_new();
    let persistence: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in anima"));
            return 0;
        }

        let block_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let block_name: i64 = token_text(block_tok);

        if string_eq(block_name, string_from("identity")) {
            identity = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("memory")) {
            memory = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("beliefs")) {
            beliefs = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("slm")) {
            slm = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("persistence")) {
            persistence = parse_config_block(parser);
        } else {
            parser_add_error(parser, string_concat(string_from("Unknown anima block: "), block_name));
            // Skip unknown block
            if parser_check(parser, TokenKind::LBrace) {
                parser_advance(parser);
                let depth: i64 = 1;
                while depth > 0 {
                    if parser_check(parser, TokenKind::LBrace) {
                        depth = depth + 1;
                    }
                    if parser_check(parser, TokenKind::RBrace) {
                        depth = depth - 1;
                    }
                    parser_advance(parser);
                }
            }
        }
        }
        }
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_anima(name, identity, memory, beliefs, slm, persistence)
}

// Parse neural gate definition with contracts and hardware targeting
// Syntax:
//   @gpu  // optional hardware target
//   neural_gate name(param: Type, ...) -> ReturnType
//       requires condition
//       ensures postcondition
//       invariant property
//       fallback { alternative_body }
//   {
//       body_expression
//   }
//
// The contracts (requires, ensures, invariant, fallback) are all optional.
// Hardware target (@cpu, @gpu, @npu) can precede the neural_gate keyword.
fn parse_neural_gate(parser: i64, hardware_target: i64) -> i64 {
    parser_expect(parser, TokenKind::KwNeuralGate);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse parameters
    let params: i64 = parse_params(parser);

    // Parse return type
    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    // Parse optional contract clauses (before the body)
    let requires: i64 = 0;
    let ensures: i64 = 0;
    let invariant: i64 = 0;
    let fallback: i64 = 0;
    let anima_binding: i64 = 0;

    // Contract clauses can appear in any order before the body
    while parser_check(parser, TokenKind::LBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in neural_gate"));
            return 0;
        }

        if parser_check(parser, TokenKind::KwRequires) {
            parser_advance(parser);
            requires = parse_expr(parser);
        } else {
        if parser_check(parser, TokenKind::KwEnsures) {
            parser_advance(parser);
            // Parse: ensures result => condition
            // For now, just parse the expression
            ensures = parse_expr(parser);
        } else {
        if parser_check(parser, TokenKind::KwInvariant) {
            parser_advance(parser);
            invariant = parse_expr(parser);
        } else {
        if parser_check(parser, TokenKind::KwFallback) {
            parser_advance(parser);
            fallback = parse_block(parser);
        } else {
        // Check for anima binding: binds AnimalName
        if parser_check(parser, TokenKind::Ident) {
            let tok: i64 = parser_current(parser);
            let text: i64 = token_text(tok);
            if string_eq(text, string_from("binds")) {
                parser_advance(parser);
                let anima_tok: i64 = parser_expect(parser, TokenKind::Ident);
                anima_binding = token_text(anima_tok);
            } else {
                // Unknown token before body
                parser_add_error(parser, string_concat(string_from("Unexpected token in neural_gate: "), text));
                parser_advance(parser);
            }
        } else {
            // Unknown token
            parser_add_error(parser, string_from("Unexpected token in neural_gate"));
            parser_advance(parser);
        }
        }
        }
        }
        }
    }

    // Parse body
    let body: i64 = parse_block(parser);

    ast_neural_gate(name, params, ret_ty, body, requires, ensures, invariant, fallback, hardware_target, anima_binding)
}

// Parse a single item (fn, enum, or struct)
fn parse_item(parser: i64) -> i64 {
    // Skip pub keyword if present
    parser_match(parser, TokenKind::KwPub);

    // Check for @ annotation (hardware targeting for neural gates)
    let hardware_target: i64 = HW_TARGET_AUTO();
    if parser_check(parser, TokenKind::At) {
        parser_advance(parser);
        // Parse hardware target: @cpu, @gpu, @npu
        if parser_check(parser, TokenKind::KwCpu) {
            parser_advance(parser);
            hardware_target = HW_TARGET_CPU();
        } else {
        if parser_check(parser, TokenKind::KwGpu) {
            parser_advance(parser);
            hardware_target = HW_TARGET_GPU();
        } else {
        if parser_check(parser, TokenKind::KwNpu) {
            parser_advance(parser);
            hardware_target = HW_TARGET_NPU();
        } else {
            // Also support @cpu/@gpu/@npu as identifiers for flexibility
            if parser_check(parser, TokenKind::Ident) {
                let tok: i64 = parser_advance(parser);
                let text: i64 = token_text(tok);
                if string_eq(text, string_from("cpu")) {
                    hardware_target = HW_TARGET_CPU();
                } else {
                if string_eq(text, string_from("gpu")) {
                    hardware_target = HW_TARGET_GPU();
                } else {
                if string_eq(text, string_from("npu")) {
                    hardware_target = HW_TARGET_NPU();
                } else {
                    parser_add_error(parser, string_concat(string_from("Unknown hardware target: @"), text));
                }
                }
                }
            } else {
                parser_add_error(parser, string_from("Expected hardware target after @"));
            }
        }
        }
        }
    }

    // Check for async fn
    if parser_check(parser, TokenKind::KwAsync) {
        parser_advance(parser);
        if parser_check(parser, TokenKind::KwFn) {
            return parse_fn(parser, 1);  // async fn
        }
        // async without fn - error
        parser_add_error(parser, string_from("expected 'fn' after 'async'"));
        return 0;
    }

    // Neural gate (differentiable control flow)
    if parser_check(parser, TokenKind::KwNeuralGate) {
        return parse_neural_gate(parser, hardware_target);
    }

    if parser_check(parser, TokenKind::KwFn) {
        return parse_fn(parser, 0);  // regular fn
    }
    if parser_check(parser, TokenKind::KwEnum) {
        return parse_enum(parser);
    }
    if parser_check(parser, TokenKind::KwStruct) {
        return parse_struct(parser);
    }
    if parser_check(parser, TokenKind::KwImpl) {
        return parse_impl(parser);
    }
    if parser_check(parser, TokenKind::KwTrait) {
        return parse_trait(parser);
    }
    if parser_check(parser, TokenKind::KwMod) {
        return parse_mod(parser);
    }
    if parser_check(parser, TokenKind::KwUse) {
        return parse_use(parser);
    }
    if parser_check(parser, TokenKind::KwType) {
        return parse_type_alias(parser);
    }
    if parser_check(parser, TokenKind::KwActor) {
        return parse_actor(parser);
    }
    if parser_check(parser, TokenKind::KwSpecialist) {
        return parse_specialist(parser);
    }
    if parser_check(parser, TokenKind::KwHive) {
        return parse_hive(parser);
    }
    if parser_check(parser, TokenKind::KwAnima) {
        return parse_anima(parser);
    }

    // Unknown item
    0
}

// Parse result: items(0), error_count(1)
fn parse_result_new(items: i64, error_count: i64) -> i64 {
    let result: i64 = malloc(16);
    store_ptr(result, 0, items);
    store_i64(result, 1, error_count);
    result
}

fn parse_result_items(result: i64) -> i64 {
    load_ptr(result, 0)
}

fn parse_result_errors(result: i64) -> i64 {
    load_i64(result, 1)
}

// Parse entire program
fn parse_program(tokens: i64) -> i64 {
    let parser: i64 = parser_new(tokens);
    let items: i64 = vec_new();

    while true {
        if parser_at_end(parser) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        // Skip EOF tokens
        if parser_check(parser, TokenKind::Eof) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        let item: i64 = parse_item(parser);
        if item != 0 {
            vec_push(items, item);
        } else {
            // Unknown item - skip token and report error
            parser_add_error(parser, string_from("unexpected token at top level"));
            parser_advance(parser);
        }
    }

    let errors: i64 = parser_error_count(parser);
    parse_result_new(items, errors)
}
