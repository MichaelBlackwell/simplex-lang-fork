// Edge Hive - Production Hardening
// Security, crash recovery, performance optimization, and compliance
//
// Phase 5: Production Hardening
// - Security audit integration (TASK-010 ASan/UBSan patterns)
// - Privacy compliance (GDPR, CCPA) with no-learn zones
// - Performance optimization with safe_malloc patterns
// - Crash recovery with checkpoint rollback
// - Update mechanism with signed beliefs

// =============================================================================
// Security Levels
// =============================================================================

fn SECURITY_MINIMAL() -> i64 { 0 }     // Development only
fn SECURITY_STANDARD() -> i64 { 1 }    // Normal user operation
fn SECURITY_ELEVATED() -> i64 { 2 }    // Sensitive data handling
fn SECURITY_MAXIMUM() -> i64 { 3 }     // Financial/health data

// Audit event types
fn AUDIT_LOGIN() -> i64 { 1 }
fn AUDIT_LOGOUT() -> i64 { 2 }
fn AUDIT_REQUEST() -> i64 { 3 }
fn AUDIT_SYNC() -> i64 { 4 }
fn AUDIT_BELIEF_CHANGE() -> i64 { 5 }
fn AUDIT_SECURITY_EVENT() -> i64 { 6 }
fn AUDIT_ERROR() -> i64 { 7 }
fn AUDIT_RECOVERY() -> i64 { 8 }

// Privacy compliance flags
fn PRIVACY_GDPR() -> i64 { 1 }
fn PRIVACY_CCPA() -> i64 { 2 }
fn PRIVACY_HIPAA() -> i64 { 4 }

// =============================================================================
// SecurityManager Structure
// =============================================================================
// Slot 0: security_level
// Slot 1: audit_log (vec of audit entries)
// Slot 2: max_audit_entries
// Slot 3: privacy_flags
// Slot 4: no_learn_types (vec of belief types that cannot be modified)
// Slot 5: rate_limiter (request count per interval)
// Slot 6: rate_limit_window_ms
// Slot 7: rate_limit_max
// Slot 8: failed_auth_count
// Slot 9: lockout_until

fn security_manager_new(level: i64) -> i64 {
    let sm: i64 = vec_new();
    vec_push(sm, level);              // Slot 0
    vec_push(sm, vec_new());          // Slot 1: audit log
    vec_push(sm, 10000);              // Slot 2: max audit entries
    vec_push(sm, 0);                  // Slot 3: no privacy flags yet
    vec_push(sm, vec_new());          // Slot 4: no-learn types
    vec_push(sm, 0);                  // Slot 5: rate counter
    vec_push(sm, 60000);              // Slot 6: 1 minute window
    vec_push(sm, 100);                // Slot 7: 100 requests/min default
    vec_push(sm, 0);                  // Slot 8: failed auth count
    vec_push(sm, 0);                  // Slot 9: no lockout

    // Add default no-learn types for maximum security
    if level >= SECURITY_ELEVATED() {
        let no_learn: i64 = vec_get(sm, 4);
        vec_push(no_learn, NO_LEARN_PERMISSION());
        vec_push(no_learn, NO_LEARN_SECURITY());
        vec_push(no_learn, NO_LEARN_IDENTITY());
        vec_push(no_learn, NO_LEARN_AUDIT());
    }

    sm
}

// Accessors
fn security_level(sm: i64) -> i64 { vec_get(sm, 0) }
fn security_audit_log(sm: i64) -> i64 { vec_get(sm, 1) }
fn security_privacy_flags(sm: i64) -> i64 { vec_get(sm, 3) }
fn security_no_learn_types(sm: i64) -> i64 { vec_get(sm, 4) }
fn security_failed_auth(sm: i64) -> i64 { vec_get(sm, 8) }
fn security_lockout_until(sm: i64) -> i64 { vec_get(sm, 9) }

fn security_set_level(sm: i64, level: i64) -> i64 {
    vec_set(sm, 0, level);
    security_audit(sm, AUDIT_SECURITY_EVENT(), string_from("Security level changed"));
    0
}

fn security_enable_privacy(sm: i64, flag: i64) -> i64 {
    let current: i64 = vec_get(sm, 3);
    vec_set(sm, 3, current + flag);
    security_audit(sm, AUDIT_SECURITY_EVENT(), string_from("Privacy mode enabled"));
    0
}

fn security_add_no_learn_type(sm: i64, belief_type: i64) -> i64 {
    let no_learn: i64 = vec_get(sm, 4);
    // Check if already present
    let len: i64 = vec_len(no_learn);
    let i: i64 = 0;
    while i < len {
        if vec_get(no_learn, i) == belief_type {
            return 0;  // Already protected
        }
        i = i + 1;
    }
    vec_push(no_learn, belief_type);
    1
}

fn security_is_no_learn(sm: i64, belief_type: i64) -> i64 {
    let no_learn: i64 = vec_get(sm, 4);
    let len: i64 = vec_len(no_learn);
    let i: i64 = 0;
    while i < len {
        if vec_get(no_learn, i) == belief_type {
            return 1;
        }
        i = i + 1;
    }
    0
}

// =============================================================================
// Audit Logging
// =============================================================================

fn security_audit(sm: i64, event_type: i64, details: i64) -> i64 {
    let log: i64 = security_audit_log(sm);
    let max_entries: i64 = vec_get(sm, 2);

    // Evict oldest if full
    if vec_len(log) >= max_entries {
        audit_evict_oldest(log);
    }

    // Create audit entry
    let entry: i64 = vec_new();
    vec_push(entry, event_type);
    vec_push(entry, time_now());
    vec_push(entry, details);
    vec_push(entry, compute_entry_hash(event_type, details));

    vec_push(log, entry);
    0
}

fn audit_evict_oldest(log: i64) -> i64 {
    // Remove first entry (FIFO)
    let new_log: i64 = vec_new();
    let len: i64 = vec_len(log);
    let i: i64 = 1;
    while i < len {
        vec_push(new_log, vec_get(log, i));
        i = i + 1;
    }
    // Copy back
    let j: i64 = 0;
    while j < vec_len(new_log) {
        vec_set(log, j, vec_get(new_log, j));
        j = j + 1;
    }
    // Note: In real impl would resize the vec
    0
}

fn compute_entry_hash(event_type: i64, details: i64) -> i64 {
    // Simple hash for tamper detection
    let hash: i64 = event_type * 31;
    hash = hash ^ string_hash(details);
    hash = hash ^ time_now();
    hash
}

fn audit_export(sm: i64) -> i64 {
    // Export audit log for compliance reporting
    let log: i64 = security_audit_log(sm);
    let export: i64 = vec_new();
    let len: i64 = vec_len(log);

    let i: i64 = 0;
    while i < len {
        let entry: i64 = vec_get(log, i);
        // Verify hash for tampering
        let stored_hash: i64 = vec_get(entry, 3);
        let computed_hash: i64 = compute_entry_hash(vec_get(entry, 0), vec_get(entry, 2));
        // Note: Hash won't match due to different timestamp - would need to store original time

        vec_push(export, entry);
        i = i + 1;
    }
    export
}

// =============================================================================
// Rate Limiting
// =============================================================================

fn security_check_rate_limit(sm: i64) -> i64 {
    let count: i64 = vec_get(sm, 5);
    let max_rate: i64 = vec_get(sm, 7);

    // Check if in lockout
    let lockout: i64 = vec_get(sm, 9);
    if lockout > 0 && time_now() < lockout {
        return 0;  // Locked out
    }

    // Reset lockout if expired
    if lockout > 0 && time_now() >= lockout {
        vec_set(sm, 9, 0);
        vec_set(sm, 5, 0);
    }

    if count >= max_rate {
        return 0;  // Rate limited
    }

    vec_set(sm, 5, count + 1);
    1  // Allowed
}

fn security_reset_rate_counter(sm: i64) -> i64 {
    vec_set(sm, 5, 0);
    0
}

fn security_record_auth_failure(sm: i64) -> i64 {
    let failures: i64 = vec_get(sm, 8);
    vec_set(sm, 8, failures + 1);

    // Lockout after 5 failures
    if failures + 1 >= 5 {
        let lockout_duration: i64 = 300;  // 5 minutes
        vec_set(sm, 9, time_now() + lockout_duration);
        security_audit(sm, AUDIT_SECURITY_EVENT(), string_from("Account locked due to failed auth"));
    }

    security_audit(sm, AUDIT_SECURITY_EVENT(), string_from("Authentication failure"));
    failures + 1
}

fn security_clear_auth_failures(sm: i64) -> i64 {
    vec_set(sm, 8, 0);
    vec_set(sm, 9, 0);
    0
}

// =============================================================================
// CheckpointManager - Crash Recovery
// =============================================================================
// Slot 0: checkpoints (vec of checkpoint refs)
// Slot 1: max_checkpoints
// Slot 2: checkpoint_interval_ms
// Slot 3: last_checkpoint_time
// Slot 4: current_checkpoint_id

fn checkpoint_manager_new() -> i64 {
    let cm: i64 = vec_new();
    vec_push(cm, vec_new());          // Slot 0: checkpoints
    vec_push(cm, 10);                 // Slot 1: keep last 10
    vec_push(cm, 300000);             // Slot 2: 5 min interval
    vec_push(cm, 0);                  // Slot 3: last checkpoint
    vec_push(cm, 0);                  // Slot 4: checkpoint id
    cm
}

fn checkpoint_checkpoints(cm: i64) -> i64 { vec_get(cm, 0) }
fn checkpoint_max(cm: i64) -> i64 { vec_get(cm, 1) }
fn checkpoint_interval(cm: i64) -> i64 { vec_get(cm, 2) }
fn checkpoint_last_time(cm: i64) -> i64 { vec_get(cm, 3) }
fn checkpoint_current_id(cm: i64) -> i64 { vec_get(cm, 4) }

fn checkpoint_should_save(cm: i64) -> i64 {
    let last: i64 = checkpoint_last_time(cm);
    let interval: i64 = checkpoint_interval(cm);
    if time_now() - last >= interval / 1000 {
        return 1;
    }
    0
}

fn checkpoint_create(cm: i64, belief_store: i64, identity: i64) -> i64 {
    let checkpoints: i64 = checkpoint_checkpoints(cm);
    let max_cp: i64 = checkpoint_max(cm);

    // Evict oldest if full
    if vec_len(checkpoints) >= max_cp {
        checkpoint_evict_oldest(checkpoints);
    }

    // Create checkpoint
    let cp_id: i64 = checkpoint_current_id(cm) + 1;
    vec_set(cm, 4, cp_id);

    let checkpoint: i64 = vec_new();
    vec_push(checkpoint, cp_id);                    // ID
    vec_push(checkpoint, time_now());               // Timestamp
    vec_push(checkpoint, belief_store_serialize(belief_store)); // Serialized beliefs

    // If we have identity, encrypt the checkpoint
    if identity != 0 {
        let encrypted: i64 = encrypt_checkpoint(checkpoint, identity);
        vec_push(checkpoints, encrypted);
    } else {
        vec_push(checkpoints, checkpoint);
    }

    vec_set(cm, 3, time_now());
    cp_id
}

fn checkpoint_evict_oldest(checkpoints: i64) -> i64 {
    if vec_len(checkpoints) == 0 {
        return 0;
    }

    // Remove first (oldest)
    let new_list: i64 = vec_new();
    let len: i64 = vec_len(checkpoints);
    let i: i64 = 1;
    while i < len {
        vec_push(new_list, vec_get(checkpoints, i));
        i = i + 1;
    }

    // Clear and refill
    let j: i64 = 0;
    while j < vec_len(new_list) {
        if j < vec_len(checkpoints) {
            vec_set(checkpoints, j, vec_get(new_list, j));
        }
        j = j + 1;
    }
    // Pop the last one
    vec_pop(checkpoints);
    1
}

fn checkpoint_restore(cm: i64, checkpoint_id: i64, belief_store: i64, identity: i64) -> i64 {
    let checkpoints: i64 = checkpoint_checkpoints(cm);
    let len: i64 = vec_len(checkpoints);

    let i: i64 = 0;
    while i < len {
        let cp: i64 = vec_get(checkpoints, i);

        // Decrypt if needed
        let decrypted: i64 = cp;
        if identity != 0 {
            decrypted = decrypt_checkpoint(cp, identity);
            if decrypted == 0 {
                i = i + 1;
                continue;  // Decryption failed
            }
        }

        let cp_id: i64 = vec_get(decrypted, 0);
        if cp_id == checkpoint_id {
            // Found it - restore
            let serialized: i64 = vec_get(decrypted, 2);
            return belief_store_deserialize(belief_store, serialized);
        }
        i = i + 1;
    }
    0  // Not found
}

fn checkpoint_restore_latest(cm: i64, belief_store: i64, identity: i64) -> i64 {
    let checkpoints: i64 = checkpoint_checkpoints(cm);
    let len: i64 = vec_len(checkpoints);

    if len == 0 {
        return 0;  // No checkpoints
    }

    // Get latest (last in list)
    let latest: i64 = vec_get(checkpoints, len - 1);

    // Decrypt if needed
    let decrypted: i64 = latest;
    if identity != 0 {
        decrypted = decrypt_checkpoint(latest, identity);
        if decrypted == 0 {
            return 0;  // Decryption failed
        }
    }

    let cp_id: i64 = vec_get(decrypted, 0);
    let serialized: i64 = vec_get(decrypted, 2);
    belief_store_deserialize(belief_store, serialized);
    cp_id
}

fn encrypt_checkpoint(checkpoint: i64, identity: i64) -> i64 {
    // Use identity's encryption key to encrypt checkpoint data
    // Returns encrypted blob
    let key: i64 = identity_get_encryption_key(identity);
    if key == 0 {
        return checkpoint;  // No key, return unencrypted
    }

    let encrypted: i64 = vec_new();
    vec_push(encrypted, 1);  // Marker: encrypted
    vec_push(encrypted, vec_get(checkpoint, 0));  // ID (plaintext for indexing)

    // Encrypt the rest
    let plaintext: i64 = vec_new();
    vec_push(plaintext, vec_get(checkpoint, 1));  // timestamp
    vec_push(plaintext, vec_get(checkpoint, 2));  // serialized beliefs

    let ciphertext: i64 = symmetric_encrypt(plaintext, key);
    vec_push(encrypted, ciphertext);

    encrypted
}

fn decrypt_checkpoint(encrypted: i64, identity: i64) -> i64 {
    // Check if encrypted
    if vec_get(encrypted, 0) != 1 {
        return encrypted;  // Not encrypted
    }

    let key: i64 = identity_get_encryption_key(identity);
    if key == 0 {
        return 0;  // No key, cannot decrypt
    }

    let ciphertext: i64 = vec_get(encrypted, 2);
    let plaintext: i64 = symmetric_decrypt(ciphertext, key);
    if plaintext == 0 {
        return 0;  // Decryption failed
    }

    let checkpoint: i64 = vec_new();
    vec_push(checkpoint, vec_get(encrypted, 1));  // ID
    vec_push(checkpoint, vec_get(plaintext, 0));  // timestamp
    vec_push(checkpoint, vec_get(plaintext, 1));  // serialized beliefs

    checkpoint
}

// =============================================================================
// UpdateManager - Signed Updates
// =============================================================================
// Slot 0: current_version
// Slot 1: trusted_keys (vec of public keys)
// Slot 2: pending_update
// Slot 3: last_update_check

fn update_manager_new(version: i64) -> i64 {
    let um: i64 = vec_new();
    vec_push(um, version);            // Slot 0
    vec_push(um, vec_new());          // Slot 1: trusted keys
    vec_push(um, 0);                  // Slot 2: no pending update
    vec_push(um, 0);                  // Slot 3: never checked
    um
}

fn update_current_version(um: i64) -> i64 { vec_get(um, 0) }
fn update_trusted_keys(um: i64) -> i64 { vec_get(um, 1) }
fn update_pending(um: i64) -> i64 { vec_get(um, 2) }

fn update_add_trusted_key(um: i64, public_key: i64) -> i64 {
    let keys: i64 = update_trusted_keys(um);
    vec_push(keys, public_key);
    1
}

fn update_verify_signature(um: i64, data: i64, signature: i64) -> i64 {
    let keys: i64 = update_trusted_keys(um);
    let len: i64 = vec_len(keys);

    let i: i64 = 0;
    while i < len {
        let key: i64 = vec_get(keys, i);
        if verify_signature(data, signature, key) == 1 {
            return 1;  // Valid signature from trusted key
        }
        i = i + 1;
    }
    0  // No valid signature
}

fn update_check_and_apply(um: i64, update_data: i64, signature: i64) -> i64 {
    // Verify signature
    if update_verify_signature(um, update_data, signature) != 1 {
        return 0 - 1;  // Invalid signature
    }

    // Parse update
    let new_version: i64 = vec_get(update_data, 0);
    let current: i64 = update_current_version(um);

    if new_version <= current {
        return 0 - 2;  // Not a newer version
    }

    // Store as pending
    vec_set(um, 2, update_data);
    vec_set(um, 3, time_now());

    new_version
}

fn update_apply_pending(um: i64) -> i64 {
    let pending: i64 = update_pending(um);
    if pending == 0 {
        return 0;  // No pending update
    }

    let new_version: i64 = vec_get(pending, 0);
    vec_set(um, 0, new_version);
    vec_set(um, 2, 0);  // Clear pending

    new_version
}

// =============================================================================
// HumanSignedBelief - Beliefs with human approval
// =============================================================================
// From TASK-014: Some beliefs require human sign-off

fn HUMAN_SIGN_REQUIRED() -> i64 { 1 }
fn HUMAN_SIGN_APPROVED() -> i64 { 2 }
fn HUMAN_SIGN_REJECTED() -> i64 { 3 }

fn human_signed_belief_new(belief: i64, requires_human: i64) -> i64 {
    let hsb: i64 = vec_new();
    vec_push(hsb, belief);            // Slot 0: underlying belief
    vec_push(hsb, requires_human);    // Slot 1: requires human sign-off
    vec_push(hsb, 0);                 // Slot 2: sign-off status
    vec_push(hsb, 0);                 // Slot 3: signed_by (user id)
    vec_push(hsb, 0);                 // Slot 4: signed_at (timestamp)
    vec_push(hsb, 0);                 // Slot 5: signature
    hsb
}

fn hsb_belief(hsb: i64) -> i64 { vec_get(hsb, 0) }
fn hsb_requires_human(hsb: i64) -> i64 { vec_get(hsb, 1) }
fn hsb_status(hsb: i64) -> i64 { vec_get(hsb, 2) }
fn hsb_signed_by(hsb: i64) -> i64 { vec_get(hsb, 3) }
fn hsb_signed_at(hsb: i64) -> i64 { vec_get(hsb, 4) }
fn hsb_signature(hsb: i64) -> i64 { vec_get(hsb, 5) }

fn hsb_is_valid(hsb: i64) -> i64 {
    if hsb_requires_human(hsb) == 0 {
        return 1;  // No human sign-off required
    }
    if hsb_status(hsb) == HUMAN_SIGN_APPROVED() {
        return 1;  // Approved
    }
    0  // Not yet approved or rejected
}

fn hsb_approve(hsb: i64, user_id: i64, signature: i64) -> i64 {
    vec_set(hsb, 2, HUMAN_SIGN_APPROVED());
    vec_set(hsb, 3, user_id);
    vec_set(hsb, 4, time_now());
    vec_set(hsb, 5, signature);
    1
}

fn hsb_reject(hsb: i64, user_id: i64, reason: i64) -> i64 {
    vec_set(hsb, 2, HUMAN_SIGN_REJECTED());
    vec_set(hsb, 3, user_id);
    vec_set(hsb, 4, time_now());
    // Could store reason in slot 5
    vec_set(hsb, 5, reason);
    1
}

// =============================================================================
// PerformanceMonitor - Safe memory patterns from TASK-010
// =============================================================================
// Slot 0: allocation_count
// Slot 1: deallocation_count
// Slot 2: peak_memory_mb
// Slot 3: current_memory_mb
// Slot 4: response_times (ring buffer of last N)
// Slot 5: error_count
// Slot 6: start_time

fn performance_monitor_new() -> i64 {
    let pm: i64 = vec_new();
    vec_push(pm, 0);                  // Slot 0: allocations
    vec_push(pm, 0);                  // Slot 1: deallocations
    vec_push(pm, 0);                  // Slot 2: peak memory
    vec_push(pm, 0);                  // Slot 3: current memory
    vec_push(pm, vec_new());          // Slot 4: response times
    vec_push(pm, 0);                  // Slot 5: errors
    vec_push(pm, time_now());         // Slot 6: start time
    pm
}

fn perf_record_allocation(pm: i64, size_bytes: i64) -> i64 {
    let count: i64 = vec_get(pm, 0);
    vec_set(pm, 0, count + 1);

    let current: i64 = vec_get(pm, 3);
    let new_current: i64 = current + size_bytes / 1048576;  // Convert to MB
    vec_set(pm, 3, new_current);

    let peak: i64 = vec_get(pm, 2);
    if new_current > peak {
        vec_set(pm, 2, new_current);
    }
    0
}

fn perf_record_deallocation(pm: i64, size_bytes: i64) -> i64 {
    let count: i64 = vec_get(pm, 1);
    vec_set(pm, 1, count + 1);

    let current: i64 = vec_get(pm, 3);
    let new_current: i64 = current - size_bytes / 1048576;
    if new_current < 0 { new_current = 0; }
    vec_set(pm, 3, new_current);
    0
}

fn perf_record_response_time(pm: i64, duration_ms: i64) -> i64 {
    let times: i64 = vec_get(pm, 4);
    let max_samples: i64 = 100;

    // Ring buffer behavior
    if vec_len(times) >= max_samples {
        // Remove oldest
        let new_times: i64 = vec_new();
        let i: i64 = 1;
        while i < vec_len(times) {
            vec_push(new_times, vec_get(times, i));
            i = i + 1;
        }
        vec_set(pm, 4, new_times);
    }

    let times_updated: i64 = vec_get(pm, 4);
    vec_push(times_updated, duration_ms);
    0
}

fn perf_record_error(pm: i64) -> i64 {
    let count: i64 = vec_get(pm, 5);
    vec_set(pm, 5, count + 1);
    0
}

fn perf_avg_response_time(pm: i64) -> i64 {
    let times: i64 = vec_get(pm, 4);
    let len: i64 = vec_len(times);
    if len == 0 {
        return 0;
    }

    let sum: i64 = 0;
    let i: i64 = 0;
    while i < len {
        sum = sum + vec_get(times, i);
        i = i + 1;
    }
    sum / len
}

fn perf_p99_response_time(pm: i64) -> i64 {
    let times: i64 = vec_get(pm, 4);
    let len: i64 = vec_len(times);
    if len == 0 {
        return 0;
    }

    // Simple approximation: return max
    // Real impl would sort and take 99th percentile
    let max_time: i64 = 0;
    let i: i64 = 0;
    while i < len {
        let t: i64 = vec_get(times, i);
        if t > max_time {
            max_time = t;
        }
        i = i + 1;
    }
    max_time
}

fn perf_memory_leak_check(pm: i64) -> i64 {
    // Check for potential memory leaks
    let allocs: i64 = vec_get(pm, 0);
    let deallocs: i64 = vec_get(pm, 1);

    let delta: i64 = allocs - deallocs;

    // Warning if more than 1000 unmatched allocations
    if delta > 1000 {
        return delta;  // Return leak size
    }
    0  // No significant leak
}

fn perf_print_stats(pm: i64) -> i64 {
    println(string_from("Performance Stats:"));

    print(string_from("  Allocations: "));
    print_i64(vec_get(pm, 0));
    println(string_from(""));

    print(string_from("  Deallocations: "));
    print_i64(vec_get(pm, 1));
    println(string_from(""));

    print(string_from("  Peak memory: "));
    print_i64(vec_get(pm, 2));
    println(string_from(" MB"));

    print(string_from("  Current memory: "));
    print_i64(vec_get(pm, 3));
    println(string_from(" MB"));

    print(string_from("  Avg response time: "));
    print_i64(perf_avg_response_time(pm));
    println(string_from(" ms"));

    print(string_from("  P99 response time: "));
    print_i64(perf_p99_response_time(pm));
    println(string_from(" ms"));

    print(string_from("  Errors: "));
    print_i64(vec_get(pm, 5));
    println(string_from(""));

    let leak: i64 = perf_memory_leak_check(pm);
    if leak > 0 {
        print(string_from("  WARNING: Potential memory leak: "));
        print_i64(leak);
        println(string_from(" unmatched allocations"));
    }

    0
}

// =============================================================================
// Privacy Compliance
// =============================================================================

fn privacy_is_pii(data_type: i64) -> i64 {
    // Check if data type is Personally Identifiable Information
    if data_type == DATA_TYPE_NAME() { return 1; }
    if data_type == DATA_TYPE_EMAIL() { return 1; }
    if data_type == DATA_TYPE_PHONE() { return 1; }
    if data_type == DATA_TYPE_ADDRESS() { return 1; }
    if data_type == DATA_TYPE_LOCATION() { return 1; }
    if data_type == DATA_TYPE_HEALTH() { return 1; }
    if data_type == DATA_TYPE_FINANCIAL() { return 1; }
    0
}

fn privacy_can_store(sm: i64, data_type: i64) -> i64 {
    let flags: i64 = security_privacy_flags(sm);

    // GDPR: PII requires explicit consent
    if (flags / PRIVACY_GDPR()) % 2 == 1 {
        if privacy_is_pii(data_type) == 1 {
            // Would need to check consent - for now, disallow
            return 0;
        }
    }

    // HIPAA: Health data requires special handling
    if (flags / PRIVACY_HIPAA()) % 2 == 1 {
        if data_type == DATA_TYPE_HEALTH() {
            // Require maximum security level
            if security_level(sm) < SECURITY_MAXIMUM() {
                return 0;
            }
        }
    }

    1
}

fn privacy_anonymize(data: i64, data_type: i64) -> i64 {
    // Return anonymized version of data
    if data_type == DATA_TYPE_NAME() {
        return string_from("[REDACTED]");
    }
    if data_type == DATA_TYPE_EMAIL() {
        return string_from("***@***.***");
    }
    if data_type == DATA_TYPE_PHONE() {
        return string_from("***-***-****");
    }
    // For other types, hash the data
    string_hash(data)
}

fn privacy_export_user_data(sm: i64, belief_store: i64) -> i64 {
    // GDPR/CCPA right to data portability
    let export: i64 = vec_new();
    let beliefs: i64 = belief_store_beliefs(belief_store);
    let len: i64 = vec_len(beliefs);

    let i: i64 = 0;
    while i < len {
        let belief: i64 = vec_get(beliefs, i);
        // Clone belief for export
        let entry: i64 = vec_new();
        vec_push(entry, belief_get_type(belief));
        vec_push(entry, belief_get_key_hash(belief));
        vec_push(entry, belief_get_value(belief));
        vec_push(entry, belief_get_confidence(belief));
        vec_push(entry, belief_get_timestamp(belief));
        vec_push(export, entry);
        i = i + 1;
    }

    export
}

fn privacy_delete_user_data(sm: i64, belief_store: i64) -> i64 {
    // GDPR/CCPA right to deletion
    // Clear all beliefs and audit the action
    let beliefs: i64 = belief_store_beliefs(belief_store);
    let deleted_count: i64 = vec_len(beliefs);

    // Clear beliefs (simplified - real impl would properly free memory)
    vec_set(belief_store, 0, vec_new());

    // Audit the deletion
    security_audit(sm, AUDIT_SECURITY_EVENT(), string_from("User data deleted per privacy request"));

    deleted_count
}

// Data type constants for privacy
fn DATA_TYPE_NAME() -> i64 { 1 }
fn DATA_TYPE_EMAIL() -> i64 { 2 }
fn DATA_TYPE_PHONE() -> i64 { 3 }
fn DATA_TYPE_ADDRESS() -> i64 { 4 }
fn DATA_TYPE_LOCATION() -> i64 { 5 }
fn DATA_TYPE_HEALTH() -> i64 { 6 }
fn DATA_TYPE_FINANCIAL() -> i64 { 7 }
fn DATA_TYPE_PREFERENCE() -> i64 { 8 }
fn DATA_TYPE_BEHAVIOR() -> i64 { 9 }

// =============================================================================
// Print Security Status
// =============================================================================

fn security_print_status(sm: i64, cm: i64, pm: i64) -> i64 {
    println(string_from(""));
    println(string_from("── Security & Compliance ──"));

    print(string_from("  Security level: "));
    let level: i64 = security_level(sm);
    if level == SECURITY_MINIMAL() { println(string_from("minimal")); }
    else if level == SECURITY_STANDARD() { println(string_from("standard")); }
    else if level == SECURITY_ELEVATED() { println(string_from("elevated")); }
    else { println(string_from("maximum")); }

    let flags: i64 = security_privacy_flags(sm);
    print(string_from("  Privacy compliance: "));
    if flags == 0 {
        println(string_from("none"));
    } else {
        if (flags / PRIVACY_GDPR()) % 2 == 1 { print(string_from("GDPR ")); }
        if (flags / PRIVACY_CCPA()) % 2 == 1 { print(string_from("CCPA ")); }
        if (flags / PRIVACY_HIPAA()) % 2 == 1 { print(string_from("HIPAA ")); }
        println(string_from(""));
    }

    let no_learn: i64 = security_no_learn_types(sm);
    print(string_from("  No-learn zone types: "));
    print_i64(vec_len(no_learn));
    println(string_from(""));

    let log: i64 = security_audit_log(sm);
    print(string_from("  Audit log entries: "));
    print_i64(vec_len(log));
    println(string_from(""));

    print(string_from("  Rate limit: "));
    print_i64(vec_get(sm, 5));
    print(string_from("/"));
    print_i64(vec_get(sm, 7));
    println(string_from(""));

    let lockout: i64 = security_lockout_until(sm);
    if lockout > time_now() {
        print(string_from("  ACCOUNT LOCKED until: "));
        print_i64(lockout);
        println(string_from(""));
    }

    println(string_from(""));
    println(string_from("── Checkpoints ──"));
    let checkpoints: i64 = checkpoint_checkpoints(cm);
    print(string_from("  Stored checkpoints: "));
    print_i64(vec_len(checkpoints));
    print(string_from("/"));
    print_i64(checkpoint_max(cm));
    println(string_from(""));

    print(string_from("  Last checkpoint: "));
    let last: i64 = checkpoint_last_time(cm);
    if last == 0 {
        println(string_from("never"));
    } else {
        print_i64(time_now() - last);
        println(string_from(" seconds ago"));
    }

    println(string_from(""));
    perf_print_stats(pm);

    0
}

// =============================================================================
// Extern Declarations
// =============================================================================

// No-learn zone types (from epistemic.sx)
extern fn NO_LEARN_PERMISSION() -> i64;
extern fn NO_LEARN_SECURITY() -> i64;
extern fn NO_LEARN_IDENTITY() -> i64;
extern fn NO_LEARN_AUDIT() -> i64;

// Belief store
extern fn belief_store_beliefs(store: i64) -> i64;
extern fn belief_store_serialize(store: i64) -> i64;
extern fn belief_store_deserialize(store: i64, data: i64) -> i64;
extern fn belief_get_type(entry: i64) -> i64;
extern fn belief_get_key_hash(entry: i64) -> i64;
extern fn belief_get_value(entry: i64) -> i64;
extern fn belief_get_confidence(entry: i64) -> i64;
extern fn belief_get_timestamp(entry: i64) -> i64;

// Security
extern fn identity_get_encryption_key(identity: i64) -> i64;
extern fn symmetric_encrypt(plaintext: i64, key: i64) -> i64;
extern fn symmetric_decrypt(ciphertext: i64, key: i64) -> i64;
extern fn verify_signature(data: i64, signature: i64, public_key: i64) -> i64;

// From runtime
extern fn vec_new() -> i64;
extern fn vec_push(v: i64, val: i64) -> i64;
extern fn vec_get(v: i64, idx: i64) -> i64;
extern fn vec_set(v: i64, idx: i64, val: i64) -> i64;
extern fn vec_len(v: i64) -> i64;
extern fn vec_pop(v: i64) -> i64;
extern fn string_from(s: &str) -> i64;
extern fn string_hash(s: i64) -> i64;
extern fn print(s: i64) -> i64;
extern fn println(s: i64) -> i64;
extern fn print_i64(n: i64) -> i64;
extern fn time_now() -> i64;
