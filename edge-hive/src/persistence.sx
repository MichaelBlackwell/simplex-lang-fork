// Edge Hive - Persistence Layer (Secure)
// Encrypted file-based storage for BeliefStore and configuration
//
// Security Features:
// - AES-256-GCM encryption at rest
// - User-isolated data directories
// - File integrity verification (via GCM authentication tag)
// - Secure file permissions (owner-only)
//
// This module requires:
// - security.sx (encryption, user identity)
//
// Encrypted file format:
// [version(1), nonce(12), ciphertext(N), auth_tag(16)]
//
// File locations (per-user, platform-specific):
// - macOS: ~/Library/Application Support/EdgeHive/users/<user_id>/
// - Linux: ~/.local/share/edgehive/users/<user_id>/
// - Windows: %APPDATA%\EdgeHive\users\<user_id>\

// =============================================================================
// Belief Serialization Format (Pre-Encryption)
// =============================================================================

// Magic bytes: "EHBS" (Edge Hive Belief Store)
fn MAGIC_BYTES() -> i64 { 1162170437 }  // 0x45484253
fn FORMAT_VERSION() -> i64 { 2 }         // v2 = encrypted format

// Serialize belief store to binary format (will be encrypted)
fn serialize_beliefs_to_bytes(store: i64) -> i64 {
    let beliefs: i64 = belief_store_beliefs(store);
    let count: i64 = vec_len(beliefs);

    // Create output buffer
    let buffer: i64 = vec_new();

    // Write header
    vec_push(buffer, MAGIC_BYTES());
    vec_push(buffer, FORMAT_VERSION());
    vec_push(buffer, count);

    // Write checksum placeholder (will be computed after serialization)
    let checksum_pos: i64 = vec_len(buffer);
    vec_push(buffer, 0);

    // Write each belief entry
    let i: i64 = 0;
    let checksum: i64 = 0;
    while i < count {
        let entry: i64 = vec_get(beliefs, i);

        // Write entry fields
        let entry_type: i64 = belief_get_type(entry);
        let key_hash: i64 = belief_get_key_hash(entry);
        let value: i64 = belief_get_value(entry);
        let confidence: i64 = belief_get_confidence(entry);
        let timestamp: i64 = belief_get_timestamp(entry);

        vec_push(buffer, entry_type);
        vec_push(buffer, key_hash);
        vec_push(buffer, value);
        vec_push(buffer, confidence);
        vec_push(buffer, timestamp);

        // Update checksum (simple XOR for integrity check within encrypted blob)
        checksum = checksum + entry_type + key_hash + value + confidence + timestamp;

        i = i + 1;
    }

    // Write checksum
    vec_set(buffer, checksum_pos, checksum);

    buffer
}

// Deserialize beliefs from binary format (after decryption)
fn deserialize_beliefs_from_bytes(buffer: i64, store: i64) -> i64 {
    let len: i64 = vec_len(buffer);

    // Check minimum size (header = 4 values)
    if len < 4 {
        return 0;  // Invalid format
    }

    // Verify magic and version
    let magic: i64 = vec_get(buffer, 0);
    let version: i64 = vec_get(buffer, 1);
    let count: i64 = vec_get(buffer, 2);
    let stored_checksum: i64 = vec_get(buffer, 3);

    if magic != MAGIC_BYTES() {
        return 0;  // Invalid magic - file corrupted or wrong format
    }

    if version > FORMAT_VERSION() {
        return 0;  // Unsupported version
    }

    // Read entries and verify checksum
    let beliefs: i64 = belief_store_beliefs(store);
    let offset: i64 = 4;
    let loaded: i64 = 0;
    let computed_checksum: i64 = 0;

    while loaded < count {
        if offset + 5 > len {
            // Truncated file
            return 0;  // Return 0 on corruption, not partial load
        }

        // Read entry fields
        let entry_type: i64 = vec_get(buffer, offset);
        let key_hash: i64 = vec_get(buffer, offset + 1);
        let value: i64 = vec_get(buffer, offset + 2);
        let confidence: i64 = vec_get(buffer, offset + 3);
        let timestamp: i64 = vec_get(buffer, offset + 4);

        // Update checksum
        computed_checksum = computed_checksum + entry_type + key_hash + value + confidence + timestamp;

        // Create and add entry
        let entry: i64 = vec_new();
        vec_push(entry, entry_type);
        vec_push(entry, key_hash);
        vec_push(entry, value);
        vec_push(entry, confidence);
        vec_push(entry, timestamp);
        vec_push(beliefs, entry);

        offset = offset + 5;
        loaded = loaded + 1;
    }

    // Verify checksum
    if computed_checksum != stored_checksum {
        // Data corruption detected - clear loaded beliefs
        let i: i64 = 0;
        while i < loaded {
            vec_pop(beliefs);
            i = i + 1;
        }
        return 0;
    }

    loaded
}

// =============================================================================
// Secure File I/O Operations
// =============================================================================

fn save_belief_store_secure(identity: i64, store: i64) -> i64 {
    ensure_user_directory(identity);

    let path: i64 = get_user_beliefs_path(identity);
    let data: i64 = serialize_beliefs_to_bytes(store);

    // Encrypt and write
    let result: i64 = secure_write_file(identity, path, data);

    if result == 1 {
        belief_store_mark_clean(store);
        return 1;
    }

    0  // Failed
}

fn load_belief_store_secure(identity: i64, store: i64) -> i64 {
    let path: i64 = get_user_beliefs_path(identity);

    // Check if file exists
    if file_exists(path) == 0 {
        return 0;  // No saved data
    }

    // Read and decrypt
    let data: i64 = secure_read_file(identity, path);
    if data == 0 {
        return 0;  // Read/decrypt failed (wrong password or tampered file)
    }

    // Deserialize
    let loaded: i64 = deserialize_beliefs_from_bytes(data, store);

    if loaded > 0 {
        belief_store_mark_clean(store);
    }

    loaded
}

// =============================================================================
// Salt Persistence (Unencrypted - Required for Key Derivation)
// =============================================================================

fn save_user_salt(identity: i64) -> i64 {
    ensure_user_directory(identity);
    let path: i64 = get_user_salt_path(identity);
    let salt: i64 = identity_salt(identity);

    // Salt is stored unencrypted (needed to derive key)
    file_write_vec(path, salt)
}

fn load_user_salt(user_id_hex: i64) -> i64 {
    let base: i64 = get_base_data_directory();
    let path: i64 = string_concat(base, string_from("/users/"));
    path = string_concat(path, user_id_hex);
    path = string_concat(path, string_from("/salt.dat"));

    if file_exists(path) == 0 {
        return 0;  // No salt = new user
    }

    file_read_vec(path)
}

// =============================================================================
// Configuration Persistence (Secure)
// =============================================================================

fn save_hive_config_secure(identity: i64, config: i64) -> i64 {
    ensure_user_directory(identity);
    let path: i64 = get_user_config_path(identity);

    // Serialize config
    let buffer: i64 = vec_new();
    vec_push(buffer, MAGIC_BYTES());
    vec_push(buffer, 2);  // Config format version

    let len: i64 = vec_len(config);
    vec_push(buffer, len);

    let i: i64 = 0;
    while i < len {
        vec_push(buffer, vec_get(config, i));
        i = i + 1;
    }

    // Encrypt and write
    secure_write_file(identity, path, buffer)
}

fn load_hive_config_secure(identity: i64, config: i64) -> i64 {
    let path: i64 = get_user_config_path(identity);

    if file_exists(path) == 0 {
        return 0;
    }

    let buffer: i64 = secure_read_file(identity, path);
    if buffer == 0 {
        return 0;  // Decryption failed
    }

    if vec_len(buffer) < 3 {
        return 0;
    }

    let magic: i64 = vec_get(buffer, 0);
    if magic != MAGIC_BYTES() {
        return 0;
    }

    let count: i64 = vec_get(buffer, 2);
    let i: i64 = 0;
    while i < count {
        if i < vec_len(config) {
            vec_set(config, i, vec_get(buffer, 3 + i));
        }
        i = i + 1;
    }

    1
}

// =============================================================================
// Cache Management (Secure)
// =============================================================================

fn save_cached_response_secure(identity: i64, request_hash: i64, response: i64, ttl: i64) -> i64 {
    ensure_user_directory(identity);

    let filename: i64 = string_concat(
        string_from("cache_"),
        i64_to_string(request_hash)
    );
    let path: i64 = string_concat(
        string_concat(get_user_cache_directory(identity), string_from("/")),
        filename
    );

    let buffer: i64 = vec_new();
    vec_push(buffer, time_now());  // Timestamp
    vec_push(buffer, ttl);         // TTL
    vec_push(buffer, response);    // Response

    // Encrypt cache entries too (they may contain sensitive data)
    secure_write_file(identity, path, buffer)
}

fn load_cached_response_secure(identity: i64, request_hash: i64) -> i64 {
    let filename: i64 = string_concat(
        string_from("cache_"),
        i64_to_string(request_hash)
    );
    let path: i64 = string_concat(
        string_concat(get_user_cache_directory(identity), string_from("/")),
        filename
    );

    if file_exists(path) == 0 {
        return 0;
    }

    let buffer: i64 = secure_read_file(identity, path);
    if buffer == 0 {
        return 0;
    }

    if vec_len(buffer) < 3 {
        return 0;
    }

    // Check TTL
    let timestamp: i64 = vec_get(buffer, 0);
    let ttl: i64 = vec_get(buffer, 1);

    if time_now() - timestamp > ttl {
        // Expired - securely delete cache file
        secure_delete_file(path);
        return 0;
    }

    vec_get(buffer, 2)  // Return cached response
}

fn clear_cache_secure(identity: i64) -> i64 {
    let cache_dir: i64 = get_user_cache_directory(identity);

    // List all files in cache directory
    let files: i64 = list_directory(cache_dir);
    if files == 0 {
        return 0;
    }

    let len: i64 = vec_len(files);
    let deleted: i64 = 0;
    let i: i64 = 0;

    while i < len {
        let filename: i64 = vec_get(files, i);

        // Only delete cache_* files
        if string_starts_with(filename, string_from("cache_")) == 1 {
            let path: i64 = string_concat(
                string_concat(cache_dir, string_from("/")),
                filename
            );
            secure_delete_file(path);
            deleted = deleted + 1;
        }

        i = i + 1;
    }

    deleted
}

// =============================================================================
// Secure File Deletion
// =============================================================================

fn secure_delete_file(path: i64) -> i64 {
    // Overwrite file contents before deleting
    if file_exists(path) == 0 {
        return 0;
    }

    // Read file size
    let size: i64 = file_size(path);
    if size > 0 {
        // Overwrite with random data
        let random_data: i64 = crypto_random_bytes(size);
        file_write_vec(path, random_data);

        // Overwrite with zeros
        let zeros: i64 = vec_new();
        let i: i64 = 0;
        while i < size {
            vec_push(zeros, 0);
            i = i + 1;
        }
        file_write_vec(path, zeros);
    }

    // Now delete the file
    file_delete(path)
}

// =============================================================================
// Auto-Save Timer
// =============================================================================

fn AUTO_SAVE_INTERVAL() -> i64 { 300 }  // 5 minutes

fn should_auto_save(last_save_time: i64) -> i64 {
    let now: i64 = time_now();
    if now - last_save_time > AUTO_SAVE_INTERVAL() {
        1
    } else {
        0
    }
}

// =============================================================================
// Legacy Functions (Deprecated - Use Secure Versions)
// =============================================================================

// These functions are kept for backwards compatibility but should not be used.
// They write unencrypted data and are insecure.

fn get_data_directory() -> i64 {
    // DEPRECATED: Use get_user_data_directory(identity) instead
    get_base_data_directory()
}

fn save_belief_store(store: i64) -> i64 {
    // DEPRECATED: Use save_belief_store_secure(identity, store)
    // This writes unencrypted data!
    0  // Return failure - force use of secure version
}

fn load_belief_store(store: i64) -> i64 {
    // DEPRECATED: Use load_belief_store_secure(identity, store)
    0  // Return failure - force use of secure version
}

// =============================================================================
// Runtime Declarations
// =============================================================================

// From security.sx
extern fn ensure_user_directory(identity: i64) -> i64;
extern fn get_user_beliefs_path(identity: i64) -> i64;
extern fn get_user_config_path(identity: i64) -> i64;
extern fn get_user_salt_path(identity: i64) -> i64;
extern fn get_user_cache_directory(identity: i64) -> i64;
extern fn get_base_data_directory() -> i64;
extern fn secure_write_file(identity: i64, path: i64, data: i64) -> i64;
extern fn secure_read_file(identity: i64, path: i64) -> i64;
extern fn identity_salt(identity: i64) -> i64;

// Crypto operations
extern fn crypto_random_bytes(length: i64) -> i64;

// File operations
extern fn file_exists(path: i64) -> i64;
extern fn file_read_vec(path: i64) -> i64;
extern fn file_write_vec(path: i64, data: i64) -> i64;
extern fn file_delete(path: i64) -> i64;
extern fn file_size(path: i64) -> i64;
extern fn list_directory(path: i64) -> i64;

// String operations
extern fn string_from(s: &str) -> i64;
extern fn string_concat(a: i64, b: i64) -> i64;
extern fn string_starts_with(s: i64, prefix: i64) -> i64;
extern fn i64_to_string(n: i64) -> i64;

// Vector operations
extern fn vec_new() -> i64;
extern fn vec_push(v: i64, val: i64) -> i64;
extern fn vec_get(v: i64, idx: i64) -> i64;
extern fn vec_set(v: i64, idx: i64, val: i64) -> i64;
extern fn vec_len(v: i64) -> i64;
extern fn vec_pop(v: i64) -> i64;

// Time
extern fn time_now() -> i64;

// Belief accessors (from beliefs.sx)
extern fn belief_store_beliefs(store: i64) -> i64;
extern fn belief_store_mark_clean(store: i64) -> i64;
extern fn belief_get_type(entry: i64) -> i64;
extern fn belief_get_key_hash(entry: i64) -> i64;
extern fn belief_get_value(entry: i64) -> i64;
extern fn belief_get_confidence(entry: i64) -> i64;
extern fn belief_get_timestamp(entry: i64) -> i64;
