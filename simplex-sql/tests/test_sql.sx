// Test file for SQL/SQLite Library
// Tests: sql_open_memory, sql_execute, sql_prepare, sql_step, etc.

fn test_open_memory() -> i64 {
    let db: i64 = sql_open_memory()

    if db == 0 {
        println("FAIL: sql_open_memory should not return 0")
        return 1
    }

    sql_close(db)
    println("PASS: test_open_memory")
    0
}

fn test_create_table() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    let result: i64 = sql_execute(db, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)")

    if result != 0 {
        println("FAIL: CREATE TABLE should return 0")
        sql_close(db)
        return 1
    }

    sql_close(db)
    println("PASS: test_create_table")
    0
}

fn test_insert_and_query() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    // Create table
    sql_execute(db, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)")

    // Insert using prepared statement
    let insert_stmt: i64 = sql_prepare(db, "INSERT INTO users (name, age) VALUES (?, ?)")
    if insert_stmt == 0 {
        println("FAIL: sql_prepare for INSERT returned 0")
        sql_close(db)
        return 1
    }

    sql_bind_text(insert_stmt, 1, "Alice")
    sql_bind_int(insert_stmt, 2, 30)
    let step_result: i64 = sql_step(insert_stmt)
    sql_finalize(insert_stmt)

    if step_result == -1 {
        println("FAIL: INSERT step returned error")
        sql_close(db)
        return 1
    }

    // Check last insert id
    let last_id: i64 = sql_last_insert_id(db)
    if last_id != 1 {
        println("FAIL: last_insert_id should be 1")
        sql_close(db)
        return 1
    }

    // Query the data
    let query_stmt: i64 = sql_prepare(db, "SELECT id, name, age FROM users WHERE id = ?")
    if query_stmt == 0 {
        println("FAIL: sql_prepare for SELECT returned 0")
        sql_close(db)
        return 1
    }

    sql_bind_int(query_stmt, 1, 1)
    let has_row: i64 = sql_step(query_stmt)

    if has_row != 1 {
        println("FAIL: SELECT should return a row")
        sql_finalize(query_stmt)
        sql_close(db)
        return 1
    }

    let id: i64 = sql_column_int(query_stmt, 0)
    let name: String = sql_column_text(query_stmt, 1)
    let age: i64 = sql_column_int(query_stmt, 2)

    sql_finalize(query_stmt)

    if id != 1 {
        println("FAIL: id should be 1")
        sql_close(db)
        return 1
    }

    if !string_eq(name, "Alice") {
        print("FAIL: name should be 'Alice', got: ")
        println(name)
        sql_close(db)
        return 1
    }

    if age != 30 {
        println("FAIL: age should be 30")
        sql_close(db)
        return 1
    }

    sql_close(db)
    println("PASS: test_insert_and_query")
    0
}

fn test_transaction() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    sql_execute(db, "CREATE TABLE test (val INTEGER)")

    // Begin transaction
    if sql_begin(db) != 0 {
        println("FAIL: sql_begin should return 0")
        sql_close(db)
        return 1
    }

    // Insert a value
    sql_execute(db, "INSERT INTO test (val) VALUES (42)")

    // Commit
    if sql_commit(db) != 0 {
        println("FAIL: sql_commit should return 0")
        sql_close(db)
        return 1
    }

    // Verify the value is there
    let stmt: i64 = sql_prepare(db, "SELECT val FROM test")
    if sql_step(stmt) != 1 {
        println("FAIL: should have a row after commit")
        sql_finalize(stmt)
        sql_close(db)
        return 1
    }

    let val: i64 = sql_column_int(stmt, 0)
    sql_finalize(stmt)

    if val != 42 {
        println("FAIL: value should be 42")
        sql_close(db)
        return 1
    }

    sql_close(db)
    println("PASS: test_transaction")
    0
}

fn test_rollback() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    sql_execute(db, "CREATE TABLE test (val INTEGER)")
    sql_execute(db, "INSERT INTO test (val) VALUES (1)")

    // Begin transaction
    sql_begin(db)

    // Insert another value
    sql_execute(db, "INSERT INTO test (val) VALUES (2)")

    // Rollback
    sql_rollback(db)

    // Verify only first value exists
    let stmt: i64 = sql_prepare(db, "SELECT COUNT(*) FROM test")
    sql_step(stmt)
    let count: i64 = sql_column_int(stmt, 0)
    sql_finalize(stmt)

    if count != 1 {
        println("FAIL: count should be 1 after rollback")
        sql_close(db)
        return 1
    }

    sql_close(db)
    println("PASS: test_rollback")
    0
}

fn test_column_info() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    sql_execute(db, "CREATE TABLE test (id INTEGER, name TEXT, value REAL)")
    sql_execute(db, "INSERT INTO test VALUES (1, 'test', 3.14)")

    let stmt: i64 = sql_prepare(db, "SELECT * FROM test")
    sql_step(stmt)

    let col_count: i64 = sql_column_count(stmt)
    if col_count != 3 {
        println("FAIL: column count should be 3")
        sql_finalize(stmt)
        sql_close(db)
        return 1
    }

    // Check column types
    let type0: i64 = sql_column_type(stmt, 0)
    let type1: i64 = sql_column_type(stmt, 1)
    let type2: i64 = sql_column_type(stmt, 2)

    if type0 != 1 {  // SQL_TYPE_INTEGER
        println("FAIL: column 0 should be INTEGER type")
        sql_finalize(stmt)
        sql_close(db)
        return 1
    }

    if type1 != 3 {  // SQL_TYPE_TEXT
        println("FAIL: column 1 should be TEXT type")
        sql_finalize(stmt)
        sql_close(db)
        return 1
    }

    if type2 != 2 {  // SQL_TYPE_REAL
        println("FAIL: column 2 should be REAL type")
        sql_finalize(stmt)
        sql_close(db)
        return 1
    }

    sql_finalize(stmt)
    sql_close(db)
    println("PASS: test_column_info")
    0
}

fn test_changes() -> i64 {
    let db: i64 = sql_open_memory()
    if db == 0 {
        println("FAIL: could not open memory database")
        return 1
    }

    sql_execute(db, "CREATE TABLE test (val INTEGER)")
    sql_execute(db, "INSERT INTO test VALUES (1)")
    sql_execute(db, "INSERT INTO test VALUES (2)")
    sql_execute(db, "INSERT INTO test VALUES (3)")

    // Update all rows
    sql_execute(db, "UPDATE test SET val = val + 10")

    let changes: i64 = sql_changes(db)
    if changes != 3 {
        println("FAIL: changes should be 3")
        sql_close(db)
        return 1
    }

    sql_close(db)
    println("PASS: test_changes")
    0
}

fn main() -> i64 {
    println("=== SQL Tests ===")
    println("")

    var failures: i64 = 0

    failures = failures + test_open_memory()
    failures = failures + test_create_table()
    failures = failures + test_insert_and_query()
    failures = failures + test_transaction()
    failures = failures + test_rollback()
    failures = failures + test_column_info()
    failures = failures + test_changes()

    println("")
    if failures == 0 {
        println("All SQL tests passed!")
    } else {
        print("SQL tests failed: ")
        println(int_to_string(failures))
    }

    failures
}
