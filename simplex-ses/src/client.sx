// SES Client implementation
// AWS SES v2 API

use simplex_std::collections::HashMap;
use simplex_http::client::{HttpClient, ClientConfig, ClientError};
use simplex_http::json::{JsonValue, to_json, parse};
use crate::email::{Email, EmailAddress};
use crate::auth::{AwsCredentials, sign_request};

/// SES Configuration
pub struct SesConfig {
    pub region: String,
    pub access_key_id: String,
    pub secret_access_key: String,
    pub endpoint: Option<String>,
}

impl SesConfig {
    pub fn new(region: &str, access_key_id: &str, secret_access_key: &str) -> Self {
        SesConfig {
            region: region.to_string(),
            access_key_id: access_key_id.to_string(),
            secret_access_key: secret_access_key.to_string(),
            endpoint: None,
        }
    }

    pub fn ap_southeast_2(access_key_id: &str, secret_access_key: &str) -> Self {
        Self::new("ap-southeast-2", access_key_id, secret_access_key)
    }

    pub fn endpoint(mut self, endpoint: &str) -> Self {
        self.endpoint = Some(endpoint.to_string());
        self
    }
}

/// SES Client
pub struct SesClient {
    config: SesConfig,
    http: HttpClient,
}

impl SesClient {
    pub fn new(config: SesConfig) -> Self {
        let http_config = ClientConfig::new().timeout(30000);
        let http = HttpClient::new(http_config);

        SesClient { config, http }
    }

    /// Get the SES endpoint URL
    fn endpoint(&self) -> String {
        self.config.endpoint.clone()
            .unwrap_or_else(|| format!("https://email.{}.amazonaws.com", self.config.region))
    }

    /// Send an email
    pub async fn send_email(&self, email: &Email) -> Result<SendEmailResponse, SesError> {
        let url = format!("{}/v2/email/outbound-emails", self.endpoint());

        let body = self.build_send_email_request(email);
        let body_str = to_json(&body);

        let credentials = AwsCredentials {
            access_key_id: self.config.access_key_id.clone(),
            secret_access_key: self.config.secret_access_key.clone(),
            region: self.config.region.clone(),
            service: "ses".to_string(),
        };

        let headers = sign_request(
            "POST",
            &url,
            &body_str,
            &credentials,
        )?;

        let response = self.http
            .header("Content-Type", "application/json")
            .headers(headers)
            .post(&url, &body)
            .await
            .map_err(|e| SesError::HttpError(format!("{:?}", e)))?;

        if response.is_success() {
            let json: JsonValue = response.json()
                .map_err(|e| SesError::ParseError(format!("{:?}", e)))?;

            Ok(SendEmailResponse {
                message_id: json.get("MessageId")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string(),
            })
        } else {
            let body = response.body_string().unwrap_or_default();
            Err(SesError::ApiError(response.status_code, body))
        }
    }

    /// Send a templated email
    pub async fn send_templated_email(
        &self,
        to: &[EmailAddress],
        template_name: &str,
        template_data: &HashMap<String, String>,
    ) -> Result<SendEmailResponse, SesError> {
        let url = format!("{}/v2/email/outbound-emails", self.endpoint());

        let body = JsonValue::object([
            ("Destination", JsonValue::object([
                ("ToAddresses", JsonValue::Array(
                    to.iter().map(|a| JsonValue::string(&a.to_string())).collect()
                )),
            ])),
            ("Content", JsonValue::object([
                ("Template", JsonValue::object([
                    ("TemplateName", JsonValue::string(template_name)),
                    ("TemplateData", JsonValue::string(&to_json(template_data))),
                ])),
            ])),
        ]);

        let body_str = to_json(&body);

        let credentials = AwsCredentials {
            access_key_id: self.config.access_key_id.clone(),
            secret_access_key: self.config.secret_access_key.clone(),
            region: self.config.region.clone(),
            service: "ses".to_string(),
        };

        let headers = sign_request("POST", &url, &body_str, &credentials)?;

        let response = self.http
            .header("Content-Type", "application/json")
            .headers(headers)
            .post(&url, &body)
            .await
            .map_err(|e| SesError::HttpError(format!("{:?}", e)))?;

        if response.is_success() {
            let json: JsonValue = response.json()
                .map_err(|e| SesError::ParseError(format!("{:?}", e)))?;

            Ok(SendEmailResponse {
                message_id: json.get("MessageId")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string(),
            })
        } else {
            let body = response.body_string().unwrap_or_default();
            Err(SesError::ApiError(response.status_code, body))
        }
    }

    /// Send a simple text email (convenience method)
    pub async fn send_text(
        &self,
        from: &str,
        to: &str,
        subject: &str,
        body: &str,
    ) -> Result<SendEmailResponse, SesError> {
        let email = Email::new()
            .from(from)
            .to(to)
            .subject(subject)
            .text(body);

        self.send_email(&email).await
    }

    /// Send an HTML email (convenience method)
    pub async fn send_html(
        &self,
        from: &str,
        to: &str,
        subject: &str,
        html: &str,
    ) -> Result<SendEmailResponse, SesError> {
        let email = Email::new()
            .from(from)
            .to(to)
            .subject(subject)
            .html(html);

        self.send_email(&email).await
    }

    /// Create an email template
    pub async fn create_template(
        &self,
        name: &str,
        subject: &str,
        html: &str,
        text: Option<&str>,
    ) -> Result<(), SesError> {
        let url = format!("{}/v2/email/templates", self.endpoint());

        let mut template = JsonValue::object([
            ("TemplateName", JsonValue::string(name)),
            ("TemplateContent", JsonValue::object([
                ("Subject", JsonValue::string(subject)),
                ("Html", JsonValue::string(html)),
            ])),
        ]);

        if let Some(text) = text {
            if let JsonValue::Object(ref mut obj) = template {
                if let Some(JsonValue::Object(ref mut content)) = obj.get_mut("TemplateContent") {
                    content.insert("Text".to_string(), JsonValue::string(text));
                }
            }
        }

        let body_str = to_json(&template);

        let credentials = AwsCredentials {
            access_key_id: self.config.access_key_id.clone(),
            secret_access_key: self.config.secret_access_key.clone(),
            region: self.config.region.clone(),
            service: "ses".to_string(),
        };

        let headers = sign_request("POST", &url, &body_str, &credentials)?;

        let response = self.http
            .header("Content-Type", "application/json")
            .headers(headers)
            .post(&url, &template)
            .await
            .map_err(|e| SesError::HttpError(format!("{:?}", e)))?;

        if response.is_success() {
            Ok(())
        } else {
            let body = response.body_string().unwrap_or_default();
            Err(SesError::ApiError(response.status_code, body))
        }
    }

    /// Delete a template
    pub async fn delete_template(&self, name: &str) -> Result<(), SesError> {
        let url = format!("{}/v2/email/templates/{}", self.endpoint(), name);

        let credentials = AwsCredentials {
            access_key_id: self.config.access_key_id.clone(),
            secret_access_key: self.config.secret_access_key.clone(),
            region: self.config.region.clone(),
            service: "ses".to_string(),
        };

        let headers = sign_request("DELETE", &url, "", &credentials)?;

        let response = self.http
            .headers(headers)
            .delete(&url)
            .await
            .map_err(|e| SesError::HttpError(format!("{:?}", e)))?;

        if response.is_success() {
            Ok(())
        } else {
            let body = response.body_string().unwrap_or_default();
            Err(SesError::ApiError(response.status_code, body))
        }
    }

    /// Verify an email address
    pub async fn verify_email(&self, email: &str) -> Result<(), SesError> {
        let url = format!("{}/v2/email/identities", self.endpoint());

        let body = JsonValue::object([
            ("EmailIdentity", JsonValue::string(email)),
        ]);

        let body_str = to_json(&body);

        let credentials = AwsCredentials {
            access_key_id: self.config.access_key_id.clone(),
            secret_access_key: self.config.secret_access_key.clone(),
            region: self.config.region.clone(),
            service: "ses".to_string(),
        };

        let headers = sign_request("POST", &url, &body_str, &credentials)?;

        let response = self.http
            .header("Content-Type", "application/json")
            .headers(headers)
            .post(&url, &body)
            .await
            .map_err(|e| SesError::HttpError(format!("{:?}", e)))?;

        if response.is_success() {
            Ok(())
        } else {
            let body = response.body_string().unwrap_or_default();
            Err(SesError::ApiError(response.status_code, body))
        }
    }

    fn build_send_email_request(&self, email: &Email) -> JsonValue {
        let mut destination = HashMap::new();

        if !email.to.is_empty() {
            destination.insert("ToAddresses".to_string(),
                JsonValue::Array(email.to.iter().map(|a| JsonValue::string(&a.to_string())).collect()));
        }
        if !email.cc.is_empty() {
            destination.insert("CcAddresses".to_string(),
                JsonValue::Array(email.cc.iter().map(|a| JsonValue::string(&a.to_string())).collect()));
        }
        if !email.bcc.is_empty() {
            destination.insert("BccAddresses".to_string(),
                JsonValue::Array(email.bcc.iter().map(|a| JsonValue::string(&a.to_string())).collect()));
        }

        let mut body_content = HashMap::new();
        if let Some(ref text) = email.text_body {
            body_content.insert("Text".to_string(), JsonValue::object([
                ("Data", JsonValue::string(text)),
                ("Charset", JsonValue::string("UTF-8")),
            ]));
        }
        if let Some(ref html) = email.html_body {
            body_content.insert("Html".to_string(), JsonValue::object([
                ("Data", JsonValue::string(html)),
                ("Charset", JsonValue::string("UTF-8")),
            ]));
        }

        let mut content = HashMap::new();
        content.insert("Simple".to_string(), JsonValue::object([
            ("Subject", JsonValue::object([
                ("Data", JsonValue::string(&email.subject)),
                ("Charset", JsonValue::string("UTF-8")),
            ])),
            ("Body", JsonValue::Object(body_content)),
        ]));

        let mut request = HashMap::new();
        request.insert("FromEmailAddress".to_string(), JsonValue::string(&email.from.to_string()));
        request.insert("Destination".to_string(), JsonValue::Object(destination));
        request.insert("Content".to_string(), JsonValue::Object(content));

        if let Some(ref reply_to) = email.reply_to {
            request.insert("ReplyToAddresses".to_string(),
                JsonValue::Array(vec![JsonValue::string(&reply_to.to_string())]));
        }

        JsonValue::Object(request)
    }
}

pub struct SendEmailResponse {
    pub message_id: String,
}

#[derive(Debug)]
pub enum SesError {
    HttpError(String),
    ApiError(u16, String),
    ParseError(String),
    SigningError(String),
}
