<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>core - Simplex API Reference</title>
  <meta name="description" content="API documentation for the Simplex programming language">
  <link rel="stylesheet" href="../assets/docs.css">
  <script src="../assets/nav.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "core - Simplex API Reference",
  "description": "API documentation for the Simplex programming language",
  "programmingLanguage": {
    "@type": "ComputerLanguage",
    "name": "Simplex",
    "url": "https://github.com/senuamedia/simplex"
  },
  "isPartOf": {
    "@type": "WebSite",
    "name": "Simplex Documentation",
    "url": "https://simplex.senuamedia.com/api/"
  },
  "articleSection": "std"
}
</script>
</head>
<body>
<div class="doc-wrapper">
  <nav class="sidebar" id="sidebar">
    <div class="sidebar-header"><a href="../index.html">Simplex API</a></div>
    <div class="search-box">
      <input type="text" id="search" placeholder="Search...">
    </div>
    <div id="nav-content">Loading...</div>
  </nav>
  <main class="content">
    <nav class="breadcrumb">
      <a href="../index.html">API Reference</a> &raquo;       <span class="current-category">std</span> &raquo; core
    </nav>
    <h1>Module: core</h1>
<div class="toc">
<strong>Contents</strong>
<ul>
<li><a href="#clone">fn clone</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#new">fn new</a></li>
<li><a href="#into_raw">fn into_raw</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#get_mut">fn get_mut</a></li>
<li><a href="#as_ptr">fn as_ptr</a></li>
<li><a href="#as_mut_ptr">fn as_mut_ptr</a></li>
<li><a href="#leak">fn leak</a></li>
<li><a href="#deref">fn deref</a></li>
<li><a href="#deref_mut">fn deref_mut</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#into_inner">fn into_inner</a></li>
<li><a href="#get_mut">fn get_mut</a></li>
<li><a href="#raw_get">fn raw_get</a></li>
<li><a href="#into_inner">fn into_inner</a></li>
<li><a href="#deref">fn deref</a></li>
<li><a href="#deref_mut">fn deref_mut</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#write">fn write</a></li>
<li><a href="#as_ptr">fn as_ptr</a></li>
<li><a href="#as_mut_ptr">fn as_mut_ptr</a></li>
<li><a href="#size_of">fn size_of</a></li>
<li><a href="#align_of">fn align_of</a></li>
<li><a href="#forget">fn forget</a></li>
<li><a href="#swap">fn swap</a></li>
<li><a href="#replace">fn replace</a></li>
<li><a href="#take">fn take</a></li>
<li><a href="#spin_loop">fn spin_loop</a></li>
<li><a href="#unlikely">fn unlikely</a></li>
<li><a href="#likely">fn likely</a></li>
<li><a href="#breakpoint">fn breakpoint</a></li>
<li><a href="#deref">fn deref</a></li>
<li><a href="#deref_mut">fn deref_mut</a></li>
<li><a href="#is_null">fn is_null</a></li>
<li><a href="#alloc">fn alloc</a></li>
<li><a href="#alloc_zeroed">fn alloc_zeroed</a></li>
<li><a href="#ffi_alloc">fn ffi_alloc</a></li>
<li><a href="#ffi_dealloc">fn ffi_dealloc</a></li>
<li><a href="#ffi_realloc">fn ffi_realloc</a></li>
<li><a href="#intrinsic_size_of">fn intrinsic_size_of</a></li>
<li><a href="#intrinsic_align_of">fn intrinsic_align_of</a></li>
<li><a href="#intrinsic_forget">fn intrinsic_forget</a></li>
<li><a href="#intrinsic_read">fn intrinsic_read</a></li>
<li><a href="#intrinsic_write">fn intrinsic_write</a></li>
<li><a href="#intrinsic_drop_in_place">fn intrinsic_drop_in_place</a></li>
<li><a href="#intrinsic_copy">fn intrinsic_copy</a></li>
<li><a href="#intrinsic_copy_nonoverlapping">fn intrinsic_copy_nonoverlapping</a></li>
<li><a href="#intrinsic_write_bytes">fn intrinsic_write_bytes</a></li>
<li><a href="#intrinsic_unreachable">fn intrinsic_unreachable</a></li>
<li><a href="#cpu_spin_hint">fn cpu_spin_hint</a></li>
<li><a href="#debug_breakpoint">fn debug_breakpoint</a></li>
</ul>
</div>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; Self {</pre>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="new">fn new</h2>
<pre class="signature">fn new(value: T) -&gt; Box&lt;T&gt; {</pre>
<p class="doc">Allocate a new value on the heap.</p>
<h2 id="into_raw">fn into_raw</h2>
<pre class="signature">fn into_raw(self) -&gt; *mut T {</pre>
<p class="doc">Consume the box and return the raw pointer.

The caller is responsible for deallocating the memory.</p>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self) -&gt; &amp;T {</pre>
<p class="doc">Get a reference to the boxed value.</p>
<h2 id="get_mut">fn get_mut</h2>
<pre class="signature">fn get_mut(&amp;mut self) -&gt; &amp;mut T {</pre>
<p class="doc">Get a mutable reference to the boxed value.</p>
<h2 id="as_ptr">fn as_ptr</h2>
<pre class="signature">fn as_ptr(&amp;self) -&gt; *const T {</pre>
<p class="doc">Get the raw pointer without consuming the box.</p>
<h2 id="as_mut_ptr">fn as_mut_ptr</h2>
<pre class="signature">fn as_mut_ptr(&amp;mut self) -&gt; *mut T {</pre>
<p class="doc">Get the raw mutable pointer without consuming the box.</p>
<h2 id="leak">fn leak</h2>
<pre class="signature">fn leak(b: Box&lt;T&gt;) -&gt; &amp;'static mut T {</pre>
<p class="doc">Leak the box, returning a mutable reference with a static lifetime.

This intentionally leaks memory. Use sparingly.</p>
<h2 id="deref">fn deref</h2>
<pre class="signature">fn deref(&amp;self) -&gt; &amp;T {</pre>
<h2 id="deref_mut">fn deref_mut</h2>
<pre class="signature">fn deref_mut(&amp;mut self) -&gt; &amp;mut T {</pre>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; Box&lt;T&gt; {</pre>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self) -&gt; *mut T {</pre>
<p class="doc">Get a raw pointer to the underlying value.

This can be cast to a mutable pointer to mutate the value,
even through a shared reference to the UnsafeCell.</p>
<h2 id="into_inner">fn into_inner</h2>
<pre class="signature">fn into_inner(self) -&gt; T {</pre>
<p class="doc">Get the underlying value, consuming the cell.</p>
<h2 id="get_mut">fn get_mut</h2>
<pre class="signature">fn get_mut(&amp;mut self) -&gt; &amp;mut T {</pre>
<p class="doc">Get a mutable reference to the underlying value.

This is safe because having a mutable reference to the cell
means we have exclusive access.</p>
<h2 id="raw_get">fn raw_get</h2>
<pre class="signature">fn raw_get(this: *const Self) -&gt; *mut T {</pre>
<p class="doc">Returns a raw pointer to the underlying value.</p>
<h2 id="into_inner">fn into_inner</h2>
<pre class="signature">fn into_inner(slot: ManuallyDrop&lt;T&gt;) -&gt; T {</pre>
<p class="doc">Extract the value, allowing it to be dropped normally.</p>
<h2 id="deref">fn deref</h2>
<pre class="signature">fn deref(&amp;self) -&gt; &amp;T {</pre>
<h2 id="deref_mut">fn deref_mut</h2>
<pre class="signature">fn deref_mut(&amp;mut self) -&gt; &amp;mut T {</pre>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; ManuallyDrop&lt;T&gt; {</pre>
<h2 id="write">fn write</h2>
<pre class="signature">fn write(&amp;mut self, value: T) -&gt; &amp;mut T {</pre>
<p class="doc">Write a value, overwriting any previous contents without dropping.</p>
<h2 id="as_ptr">fn as_ptr</h2>
<pre class="signature">fn as_ptr(&amp;self) -&gt; *const T {</pre>
<p class="doc">Get a pointer to the contained value.</p>
<h2 id="as_mut_ptr">fn as_mut_ptr</h2>
<pre class="signature">fn as_mut_ptr(&amp;mut self) -&gt; *mut T {</pre>
<p class="doc">Get a mutable pointer to the contained value.</p>
<h2 id="size_of">fn size_of</h2>
<pre class="signature">fn size_of&lt;T&gt;() -&gt; usize {</pre>
<p class="doc">Get the size of a type in bytes.</p>
<h2 id="align_of">fn align_of</h2>
<pre class="signature">fn align_of&lt;T&gt;() -&gt; usize {</pre>
<p class="doc">Get the alignment of a type in bytes.</p>
<h2 id="forget">fn forget</h2>
<pre class="signature">fn forget&lt;T&gt;(value: T) {</pre>
<p class="doc">Forget a value without running its destructor.

This leaks any resources the value owns.</p>
<h2 id="swap">fn swap</h2>
<pre class="signature">fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T) {</pre>
<p class="doc">Swap two values.</p>
<h2 id="replace">fn replace</h2>
<pre class="signature">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T {</pre>
<p class="doc">Replace a value, returning the old one.</p>
<h2 id="take">fn take</h2>
<pre class="signature">fn take&lt;T: Default&gt;(dest: &amp;mut T) -&gt; T {</pre>
<p class="doc">Take ownership of a value, leaving the default in its place.</p>
<h2 id="spin_loop">fn spin_loop</h2>
<pre class="signature">fn spin_loop() {</pre>
<p class="doc">Hint to the CPU that we're in a spin loop.

This can improve performance by reducing power consumption
and allowing hyperthreading siblings to proceed.</p>
<h2 id="unlikely">fn unlikely</h2>
<pre class="signature">fn unlikely(cond: bool) -&gt; bool {</pre>
<p class="doc">Hint that a condition is unlikely.</p>
<h2 id="likely">fn likely</h2>
<pre class="signature">fn likely(cond: bool) -&gt; bool {</pre>
<p class="doc">Hint that a condition is likely.</p>
<h2 id="breakpoint">fn breakpoint</h2>
<pre class="signature">fn breakpoint() {</pre>
<p class="doc">Trigger a breakpoint for debugging.</p>
<h2 id="deref">fn deref</h2>
<pre class="signature">fn deref(&amp;self) -&gt; &amp;Self::Target;</pre>
<h2 id="deref_mut">fn deref_mut</h2>
<pre class="signature">fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;</pre>
<h2 id="is_null">fn is_null</h2>
<pre class="signature">fn is_null&lt;T&gt;(ptr: *const T) -&gt; bool {</pre>
<p class="doc">Returns true if the pointer is null.</p>
<h2 id="alloc">fn alloc</h2>
<pre class="signature">fn alloc(size: usize) -&gt; *mut u8 {</pre>
<p class="doc">Allocate memory.

Returns a pointer to the allocated memory, or 0 on failure.</p>
<h2 id="alloc_zeroed">fn alloc_zeroed</h2>
<pre class="signature">fn alloc_zeroed(size: usize) -&gt; *mut u8 {</pre>
<p class="doc">Allocate zeroed memory.</p>
<h2 id="ffi_alloc">fn ffi_alloc</h2>
<pre class="signature">fn ffi_alloc(size: i64) -&gt; i64;</pre>
<h2 id="ffi_dealloc">fn ffi_dealloc</h2>
<pre class="signature">fn ffi_dealloc(ptr: i64);</pre>
<h2 id="ffi_realloc">fn ffi_realloc</h2>
<pre class="signature">fn ffi_realloc(ptr: i64, old_size: i64, new_size: i64) -&gt; i64;</pre>
<h2 id="intrinsic_size_of">fn intrinsic_size_of</h2>
<pre class="signature">fn intrinsic_size_of&lt;T&gt;() -&gt; usize;</pre>
<h2 id="intrinsic_align_of">fn intrinsic_align_of</h2>
<pre class="signature">fn intrinsic_align_of&lt;T&gt;() -&gt; usize;</pre>
<h2 id="intrinsic_forget">fn intrinsic_forget</h2>
<pre class="signature">fn intrinsic_forget&lt;T&gt;(value: T);</pre>
<h2 id="intrinsic_read">fn intrinsic_read</h2>
<pre class="signature">fn intrinsic_read&lt;T&gt;(src: *const T) -&gt; T;</pre>
<h2 id="intrinsic_write">fn intrinsic_write</h2>
<pre class="signature">fn intrinsic_write&lt;T&gt;(dst: *mut T, src: T);</pre>
<h2 id="intrinsic_drop_in_place">fn intrinsic_drop_in_place</h2>
<pre class="signature">fn intrinsic_drop_in_place&lt;T&gt;(ptr: *mut T);</pre>
<h2 id="intrinsic_copy">fn intrinsic_copy</h2>
<pre class="signature">fn intrinsic_copy&lt;T&gt;(src: *const T, dst: *mut T, count: usize);</pre>
<h2 id="intrinsic_copy_nonoverlapping">fn intrinsic_copy_nonoverlapping</h2>
<pre class="signature">fn intrinsic_copy_nonoverlapping&lt;T&gt;(src: *const T, dst: *mut T, count: usize);</pre>
<h2 id="intrinsic_write_bytes">fn intrinsic_write_bytes</h2>
<pre class="signature">fn intrinsic_write_bytes&lt;T&gt;(dst: *mut T, val: u8, count: usize);</pre>
<h2 id="intrinsic_unreachable">fn intrinsic_unreachable</h2>
<pre class="signature">fn intrinsic_unreachable() -&gt; !;</pre>
<h2 id="cpu_spin_hint">fn cpu_spin_hint</h2>
<pre class="signature">fn cpu_spin_hint();</pre>
<h2 id="debug_breakpoint">fn debug_breakpoint</h2>
<pre class="signature">fn debug_breakpoint();</pre>

    <hr>
    <p><em>Generated by sxdoc</em></p>
  </main>
</div>
</body>
</html>
