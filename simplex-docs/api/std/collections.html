<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>collections - Simplex API Reference</title>
  <meta name="description" content="Create a new empty vector.">
  <link rel="stylesheet" href="../assets/docs.css">
  <script src="../assets/nav.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "collections - Simplex API Reference",
  "description": "Create a new empty vector.",
  "programmingLanguage": {
    "@type": "ComputerLanguage",
    "name": "Simplex",
    "url": "https://github.com/senuamedia/simplex"
  },
  "isPartOf": {
    "@type": "WebSite",
    "name": "Simplex Documentation",
    "url": "https://simplex.senuamedia.com/api/"
  },
  "articleSection": "std"
}
</script>
</head>
<body>
<div class="doc-wrapper">
  <nav class="sidebar" id="sidebar">
    <div class="sidebar-header"><a href="../index.html">Simplex API</a></div>
    <div class="search-box">
      <input type="text" id="search" placeholder="Search...">
    </div>
    <div id="nav-content">Loading...</div>
  </nav>
  <main class="content">
    <nav class="breadcrumb">
      <a href="../index.html">API Reference</a> &raquo;       <span class="current-category">std</span> &raquo; collections
    </nav>
    <h1>Module: collections</h1>
<div class="toc">
<strong>Contents</strong>
<ul>
<li><a href="#new">fn new</a></li>
<li><a href="#with_capacity">fn with_capacity</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#capacity">fn capacity</a></li>
<li><a href="#reserve">fn reserve</a></li>
<li><a href="#shrink_to_fit">fn shrink_to_fit</a></li>
<li><a href="#push">fn push</a></li>
<li><a href="#pop">fn pop</a></li>
<li><a href="#insert">fn insert</a></li>
<li><a href="#remove">fn remove</a></li>
<li><a href="#swap_remove">fn swap_remove</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#get_mut">fn get_mut</a></li>
<li><a href="#first">fn first</a></li>
<li><a href="#last">fn last</a></li>
<li><a href="#clear">fn clear</a></li>
<li><a href="#truncate">fn truncate</a></li>
<li><a href="#iter">fn iter</a></li>
<li><a href="#iter_mut">fn iter_mut</a></li>
<li><a href="#map">fn map</a></li>
<li><a href="#filter">fn filter</a></li>
<li><a href="#fold">fn fold</a></li>
<li><a href="#find">fn find</a></li>
<li><a href="#position">fn position</a></li>
<li><a href="#any">fn any</a></li>
<li><a href="#all">fn all</a></li>
<li><a href="#count">fn count</a></li>
<li><a href="#reverse">fn reverse</a></li>
<li><a href="#sort">fn sort</a></li>
<li><a href="#sort_by">fn sort_by</a></li>
<li><a href="#contains">fn contains</a></li>
<li><a href="#append">fn append</a></li>
<li><a href="#extend">fn extend</a></li>
<li><a href="#from_slice">fn from_slice</a></li>
<li><a href="#as_slice">fn as_slice</a></li>
<li><a href="#as_mut_slice">fn as_mut_slice</a></li>
<li><a href="#split_off">fn split_off</a></li>
<li><a href="#retain">fn retain</a></li>
<li><a href="#dedup">fn dedup</a></li>
<li><a href="#dedup_by">fn dedup_by</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#resize_default">fn resize_default</a></li>
<li><a href="#resize">fn resize</a></li>
<li><a href="#resize_with">fn resize_with</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#size_hint">fn size_hint</a></li>
<li><a href="#enumerate">fn enumerate</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#quicksort_slice">fn quicksort_slice</a></li>
<li><a href="#partition">fn partition</a></li>
<li><a href="#new">fn new</a></li>
<li><a href="#with_capacity">fn with_capacity</a></li>
<li><a href="#insert">fn insert</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#get_mut">fn get_mut</a></li>
<li><a href="#remove">fn remove</a></li>
<li><a href="#contains_key">fn contains_key</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#capacity">fn capacity</a></li>
<li><a href="#clear">fn clear</a></li>
<li><a href="#entry">fn entry</a></li>
<li><a href="#iter">fn iter</a></li>
<li><a href="#keys">fn keys</a></li>
<li><a href="#values">fn values</a></li>
<li><a href="#values_mut">fn values_mut</a></li>
<li><a href="#retain">fn retain</a></li>
<li><a href="#get_or_insert_with">fn get_or_insert_with</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#or_insert">fn or_insert</a></li>
<li><a href="#or_insert_with">fn or_insert_with</a></li>
<li><a href="#or_default">fn or_default</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#get_mut">fn get_mut</a></li>
<li><a href="#into_mut">fn into_mut</a></li>
<li><a href="#insert">fn insert</a></li>
<li><a href="#remove">fn remove</a></li>
<li><a href="#insert">fn insert</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#new">fn new</a></li>
<li><a href="#with_capacity">fn with_capacity</a></li>
<li><a href="#insert">fn insert</a></li>
<li><a href="#contains">fn contains</a></li>
<li><a href="#remove">fn remove</a></li>
<li><a href="#take">fn take</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#clear">fn clear</a></li>
<li><a href="#iter">fn iter</a></li>
<li><a href="#retain">fn retain</a></li>
<li><a href="#union">fn union</a></li>
<li><a href="#intersection">fn intersection</a></li>
<li><a href="#difference">fn difference</a></li>
<li><a href="#symmetric_difference">fn symmetric_difference</a></li>
<li><a href="#is_subset">fn is_subset</a></li>
<li><a href="#is_superset">fn is_superset</a></li>
<li><a href="#is_disjoint">fn is_disjoint</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#new">fn new</a></li>
<li><a href="#with_capacity">fn with_capacity</a></li>
<li><a href="#push_back">fn push_back</a></li>
<li><a href="#push_front">fn push_front</a></li>
<li><a href="#pop_back">fn pop_back</a></li>
<li><a href="#pop_front">fn pop_front</a></li>
<li><a href="#front">fn front</a></li>
<li><a href="#back">fn back</a></li>
<li><a href="#front_mut">fn front_mut</a></li>
<li><a href="#back_mut">fn back_mut</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#capacity">fn capacity</a></li>
<li><a href="#clear">fn clear</a></li>
<li><a href="#rotate_left">fn rotate_left</a></li>
<li><a href="#rotate_right">fn rotate_right</a></li>
<li><a href="#iter">fn iter</a></li>
<li><a href="#make_contiguous">fn make_contiguous</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#new">fn new</a></li>
<li><a href="#with_capacity">fn with_capacity</a></li>
<li><a href="#push">fn push</a></li>
<li><a href="#pop">fn pop</a></li>
<li><a href="#peek">fn peek</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#clear">fn clear</a></li>
<li><a href="#sift_up">fn sift_up</a></li>
<li><a href="#sift_down">fn sift_down</a></li>
<li><a href="#into_sorted_vec">fn into_sorted_vec</a></li>
<li><a href="#default">fn default</a></li>
<li><a href="#vec_new">fn vec_new</a></li>
<li><a href="#vec_with_capacity">fn vec_with_capacity</a></li>
<li><a href="#vec_len">fn vec_len</a></li>
<li><a href="#vec_capacity">fn vec_capacity</a></li>
<li><a href="#vec_reserve">fn vec_reserve</a></li>
<li><a href="#vec_shrink_to_fit">fn vec_shrink_to_fit</a></li>
<li><a href="#vec_push">fn vec_push</a></li>
<li><a href="#vec_pop">fn vec_pop</a></li>
<li><a href="#vec_insert">fn vec_insert</a></li>
<li><a href="#vec_remove">fn vec_remove</a></li>
<li><a href="#vec_swap_remove">fn vec_swap_remove</a></li>
<li><a href="#vec_get">fn vec_get</a></li>
<li><a href="#vec_clear">fn vec_clear</a></li>
<li><a href="#vec_truncate">fn vec_truncate</a></li>
<li><a href="#vec_reverse">fn vec_reverse</a></li>
<li><a href="#vec_as_ptr">fn vec_as_ptr</a></li>
<li><a href="#vec_drop">fn vec_drop</a></li>
<li><a href="#hashmap_new">fn hashmap_new</a></li>
<li><a href="#hashmap_with_capacity">fn hashmap_with_capacity</a></li>
<li><a href="#hashmap_insert">fn hashmap_insert</a></li>
<li><a href="#hashmap_get">fn hashmap_get</a></li>
<li><a href="#hashmap_remove">fn hashmap_remove</a></li>
<li><a href="#hashmap_len">fn hashmap_len</a></li>
<li><a href="#hashmap_capacity">fn hashmap_capacity</a></li>
<li><a href="#hashmap_clear">fn hashmap_clear</a></li>
<li><a href="#hashmap_iter_next">fn hashmap_iter_next</a></li>
<li><a href="#hashmap_retain">fn hashmap_retain</a></li>
<li><a href="#hashmap_drop">fn hashmap_drop</a></li>
<li><a href="#hashset_new">fn hashset_new</a></li>
<li><a href="#hashset_with_capacity">fn hashset_with_capacity</a></li>
<li><a href="#hashset_insert">fn hashset_insert</a></li>
<li><a href="#hashset_contains">fn hashset_contains</a></li>
<li><a href="#hashset_remove">fn hashset_remove</a></li>
<li><a href="#hashset_take">fn hashset_take</a></li>
<li><a href="#hashset_len">fn hashset_len</a></li>
<li><a href="#hashset_clear">fn hashset_clear</a></li>
<li><a href="#hashset_iter_next">fn hashset_iter_next</a></li>
<li><a href="#hashset_retain">fn hashset_retain</a></li>
<li><a href="#hashset_drop">fn hashset_drop</a></li>
<li><a href="#vecdeque_new">fn vecdeque_new</a></li>
<li><a href="#vecdeque_with_capacity">fn vecdeque_with_capacity</a></li>
<li><a href="#vecdeque_push_back">fn vecdeque_push_back</a></li>
<li><a href="#vecdeque_push_front">fn vecdeque_push_front</a></li>
<li><a href="#vecdeque_pop_back">fn vecdeque_pop_back</a></li>
<li><a href="#vecdeque_pop_front">fn vecdeque_pop_front</a></li>
<li><a href="#vecdeque_front">fn vecdeque_front</a></li>
<li><a href="#vecdeque_back">fn vecdeque_back</a></li>
<li><a href="#vecdeque_get">fn vecdeque_get</a></li>
<li><a href="#vecdeque_len">fn vecdeque_len</a></li>
<li><a href="#vecdeque_capacity">fn vecdeque_capacity</a></li>
<li><a href="#vecdeque_clear">fn vecdeque_clear</a></li>
<li><a href="#vecdeque_make_contiguous">fn vecdeque_make_contiguous</a></li>
<li><a href="#vecdeque_as_ptr">fn vecdeque_as_ptr</a></li>
<li><a href="#vecdeque_drop">fn vecdeque_drop</a></li>
<li><a href="#panic">fn panic</a></li>
</ul>
</div>
<h2 id="new">fn new</h2>
<pre class="signature">fn new() -&gt; Vec&lt;T&gt; {</pre>
<p class="doc">Create a new empty vector.</p>
<h2 id="with_capacity">fn with_capacity</h2>
<pre class="signature">fn with_capacity(capacity: usize) -&gt; Vec&lt;T&gt; {</pre>
<p class="doc">Create a vector with the given capacity.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the number of elements.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if empty.</p>
<h2 id="capacity">fn capacity</h2>
<pre class="signature">fn capacity(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the capacity.</p>
<h2 id="reserve">fn reserve</h2>
<pre class="signature">fn reserve(&amp;mut self, additional: usize) {</pre>
<p class="doc">Reserve capacity for at least `additional` more elements.</p>
<h2 id="shrink_to_fit">fn shrink_to_fit</h2>
<pre class="signature">fn shrink_to_fit(&amp;mut self) {</pre>
<p class="doc">Shrink capacity to fit current length.</p>
<h2 id="push">fn push</h2>
<pre class="signature">fn push(&amp;mut self, value: T) {</pre>
<p class="doc">Push an element to the end.</p>
<h2 id="pop">fn pop</h2>
<pre class="signature">fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {</pre>
<p class="doc">Pop an element from the end.</p>
<h2 id="insert">fn insert</h2>
<pre class="signature">fn insert(&amp;mut self, index: usize, value: T) {</pre>
<p class="doc">Insert an element at the given index.</p>
<h2 id="remove">fn remove</h2>
<pre class="signature">fn remove(&amp;mut self, index: usize) -&gt; T {</pre>
<p class="doc">Remove and return the element at the given index.</p>
<h2 id="swap_remove">fn swap_remove</h2>
<pre class="signature">fn swap_remove(&amp;mut self, index: usize) -&gt; T {</pre>
<p class="doc">Swap-remove the element at the given index (O(1) but doesn't preserve order).</p>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get an element by index.</p>
<h2 id="get_mut">fn get_mut</h2>
<pre class="signature">fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt; {</pre>
<p class="doc">Get a mutable element by index.</p>
<h2 id="first">fn first</h2>
<pre class="signature">fn first(&amp;self) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get the first element.</p>
<h2 id="last">fn last</h2>
<pre class="signature">fn last(&amp;self) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get the last element.</p>
<h2 id="clear">fn clear</h2>
<pre class="signature">fn clear(&amp;mut self) {</pre>
<p class="doc">Clear all elements.</p>
<h2 id="truncate">fn truncate</h2>
<pre class="signature">fn truncate(&amp;mut self, len: usize) {</pre>
<p class="doc">Truncate to the given length.</p>
<h2 id="iter">fn iter</h2>
<pre class="signature">fn iter(&amp;self) -&gt; VecIter&lt;T&gt; {</pre>
<p class="doc">Iterate over elements.</p>
<h2 id="iter_mut">fn iter_mut</h2>
<pre class="signature">fn iter_mut(&amp;mut self) -&gt; VecIterMut&lt;T&gt; {</pre>
<p class="doc">Iterate mutably over elements.</p>
<h2 id="map">fn map</h2>
<pre class="signature">fn map&lt;U, F: Fn(&amp;T) -&gt; U&gt;(&amp;self, f: F) -&gt; Vec&lt;U&gt; {</pre>
<p class="doc">Map a function over elements.</p>
<h2 id="filter">fn filter</h2>
<pre class="signature">fn filter&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; Vec&lt;T&gt;</pre>
<p class="doc">Filter elements by predicate.</p>
<h2 id="fold">fn fold</h2>
<pre class="signature">fn fold&lt;U, F: Fn(U, &amp;T) -&gt; U&gt;(&amp;self, init: U, f: F) -&gt; U {</pre>
<p class="doc">Fold elements with accumulator.</p>
<h2 id="find">fn find</h2>
<pre class="signature">fn find&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Find the first element matching a predicate.</p>
<h2 id="position">fn position</h2>
<pre class="signature">fn position&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; Option&lt;usize&gt; {</pre>
<p class="doc">Find the index of the first element matching a predicate.</p>
<h2 id="any">fn any</h2>
<pre class="signature">fn any&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; bool {</pre>
<p class="doc">Check if any element matches a predicate.</p>
<h2 id="all">fn all</h2>
<pre class="signature">fn all&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; bool {</pre>
<p class="doc">Check if all elements match a predicate.</p>
<h2 id="count">fn count</h2>
<pre class="signature">fn count&lt;F: Fn(&amp;T) -&gt; bool&gt;(&amp;self, pred: F) -&gt; usize {</pre>
<p class="doc">Count elements matching a predicate.</p>
<h2 id="reverse">fn reverse</h2>
<pre class="signature">fn reverse(&amp;mut self) {</pre>
<p class="doc">Reverse the vector in place.</p>
<h2 id="sort">fn sort</h2>
<pre class="signature">fn sort(&amp;mut self) where T: Ord {</pre>
<p class="doc">Sort the vector (requires Ord).</p>
<h2 id="sort_by">fn sort_by</h2>
<pre class="signature">fn sort_by&lt;F: FnMut(&amp;T, &amp;T) -&gt; Ordering&gt;(&amp;mut self, mut compare: F) {</pre>
<p class="doc">Sort by a comparison function.</p>
<h2 id="contains">fn contains</h2>
<pre class="signature">fn contains(&amp;self, value: &amp;T) -&gt; bool where T: Eq {</pre>
<p class="doc">Check if the vector contains an element.</p>
<h2 id="append">fn append</h2>
<pre class="signature">fn append(&amp;mut self, other: &amp;mut Vec&lt;T&gt;) {</pre>
<p class="doc">Append another vector to this one.</p>
<h2 id="extend">fn extend</h2>
<pre class="signature">fn extend&lt;I: Iterator&lt;Item = T&gt;&gt;(&amp;mut self, iter: I) {</pre>
<p class="doc">Extend from an iterator.</p>
<h2 id="from_slice">fn from_slice</h2>
<pre class="signature">fn from_slice(slice: &amp;[T]) -&gt; Vec&lt;T&gt; where T: Clone {</pre>
<p class="doc">Create a vector from a slice.</p>
<h2 id="as_slice">fn as_slice</h2>
<pre class="signature">fn as_slice(&amp;self) -&gt; &amp;[T] {</pre>
<p class="doc">Convert to a slice.</p>
<h2 id="as_mut_slice">fn as_mut_slice</h2>
<pre class="signature">fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {</pre>
<p class="doc">Convert to a mutable slice.</p>
<h2 id="split_off">fn split_off</h2>
<pre class="signature">fn split_off(&amp;mut self, at: usize) -&gt; Vec&lt;T&gt; {</pre>
<p class="doc">Split the vector at the given index.</p>
<h2 id="retain">fn retain</h2>
<pre class="signature">fn retain&lt;F: FnMut(&amp;T) -&gt; bool&gt;(&amp;mut self, mut pred: F) {</pre>
<p class="doc">Retain only elements matching a predicate.</p>
<h2 id="dedup">fn dedup</h2>
<pre class="signature">fn dedup(&amp;mut self) where T: Eq {</pre>
<p class="doc">Deduplicate consecutive elements (requires Eq).</p>
<h2 id="dedup_by">fn dedup_by</h2>
<pre class="signature">fn dedup_by&lt;F: FnMut(&amp;T, &amp;T) -&gt; bool&gt;(&amp;mut self, mut same: F) {</pre>
<p class="doc">Deduplicate consecutive elements by a comparison function.</p>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; Vec&lt;T&gt; {</pre>
<h2 id="resize_default">fn resize_default</h2>
<pre class="signature">fn resize_default(&amp;mut self, new_len: usize) {</pre>
<p class="doc">Resize the vector to the given length, using default values.</p>
<h2 id="resize">fn resize</h2>
<pre class="signature">fn resize(&amp;mut self, new_len: usize, value: T) {</pre>
<p class="doc">Resize the vector to the given length, using the given value.</p>
<h2 id="resize_with">fn resize_with</h2>
<pre class="signature">fn resize_with&lt;F: FnMut() -&gt; T&gt;(&amp;mut self, new_len: usize, mut f: F) {</pre>
<p class="doc">Resize the vector to the given length, using a function to generate values.</p>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="size_hint">fn size_hint</h2>
<pre class="signature">fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {</pre>
<h2 id="enumerate">fn enumerate</h2>
<pre class="signature">fn enumerate(self) -&gt; Enumerate&lt;Self&gt; {</pre>
<p class="doc">Enumerate the iterator.</p>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="quicksort_slice">fn quicksort_slice</h2>
<pre class="signature">fn quicksort_slice&lt;T, F: FnMut(&amp;T, &amp;T) -&gt; Ordering&gt;(v: &amp;mut Vec&lt;T&gt;, low: usize, high: usize, compare: &amp;mut F) {</pre>
<h2 id="partition">fn partition</h2>
<pre class="signature">fn partition&lt;T, F: FnMut(&amp;T, &amp;T) -&gt; Ordering&gt;(v: &amp;mut Vec&lt;T&gt;, low: usize, high: usize, compare: &amp;mut F) -&gt; usize {</pre>
<h2 id="new">fn new</h2>
<pre class="signature">fn new() -&gt; HashMap&lt;K, V&gt; {</pre>
<p class="doc">Create a new empty hash map.</p>
<h2 id="with_capacity">fn with_capacity</h2>
<pre class="signature">fn with_capacity(capacity: usize) -&gt; HashMap&lt;K, V&gt; {</pre>
<p class="doc">Create a hash map with the given capacity.</p>
<h2 id="insert">fn insert</h2>
<pre class="signature">fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt; {</pre>
<p class="doc">Insert a key-value pair.</p>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; {</pre>
<p class="doc">Get a value by key.</p>
<h2 id="get_mut">fn get_mut</h2>
<pre class="signature">fn get_mut(&amp;mut self, key: &amp;K) -&gt; Option&lt;&amp;mut V&gt; {</pre>
<p class="doc">Get a mutable value by key.</p>
<h2 id="remove">fn remove</h2>
<pre class="signature">fn remove(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; {</pre>
<p class="doc">Remove a key-value pair.</p>
<h2 id="contains_key">fn contains_key</h2>
<pre class="signature">fn contains_key(&amp;self, key: &amp;K) -&gt; bool {</pre>
<p class="doc">Check if key exists.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the number of entries.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if empty.</p>
<h2 id="capacity">fn capacity</h2>
<pre class="signature">fn capacity(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the capacity.</p>
<h2 id="clear">fn clear</h2>
<pre class="signature">fn clear(&amp;mut self) {</pre>
<p class="doc">Clear all entries.</p>
<h2 id="entry">fn entry</h2>
<pre class="signature">fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; {</pre>
<p class="doc">Get or insert a value with a default.</p>
<h2 id="iter">fn iter</h2>
<pre class="signature">fn iter(&amp;self) -&gt; HashMapIter&lt;K, V&gt; {</pre>
<p class="doc">Iterate over key-value pairs.</p>
<h2 id="keys">fn keys</h2>
<pre class="signature">fn keys(&amp;self) -&gt; HashMapKeys&lt;K, V&gt; {</pre>
<p class="doc">Iterate over keys.</p>
<h2 id="values">fn values</h2>
<pre class="signature">fn values(&amp;self) -&gt; HashMapValues&lt;K, V&gt; {</pre>
<p class="doc">Iterate over values.</p>
<h2 id="values_mut">fn values_mut</h2>
<pre class="signature">fn values_mut(&amp;mut self) -&gt; HashMapValuesMut&lt;K, V&gt; {</pre>
<p class="doc">Iterate mutably over values.</p>
<h2 id="retain">fn retain</h2>
<pre class="signature">fn retain&lt;F: FnMut(&amp;K, &amp;mut V) -&gt; bool&gt;(&amp;mut self, mut pred: F) {</pre>
<p class="doc">Retain only entries matching a predicate.</p>
<h2 id="get_or_insert_with">fn get_or_insert_with</h2>
<pre class="signature">fn get_or_insert_with&lt;F: FnOnce() -&gt; V&gt;(&amp;mut self, key: K, f: F) -&gt; &amp;mut V {</pre>
<p class="doc">Get or insert with a function.</p>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="or_insert">fn or_insert</h2>
<pre class="signature">fn or_insert(self, default: V) -&gt; &amp;'a mut V {</pre>
<p class="doc">Get or insert a default value.</p>
<h2 id="or_insert_with">fn or_insert_with</h2>
<pre class="signature">fn or_insert_with&lt;F: FnOnce() -&gt; V&gt;(self, f: F) -&gt; &amp;'a mut V {</pre>
<p class="doc">Get or insert with a function.</p>
<h2 id="or_default">fn or_default</h2>
<pre class="signature">fn or_default(self) -&gt; &amp;'a mut V where V: Default {</pre>
<p class="doc">Get or insert a default value (requires Default).</p>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self) -&gt; &amp;V {</pre>
<p class="doc">Get a reference to the value.</p>
<h2 id="get_mut">fn get_mut</h2>
<pre class="signature">fn get_mut(&amp;mut self) -&gt; &amp;mut V {</pre>
<p class="doc">Get a mutable reference to the value.</p>
<h2 id="into_mut">fn into_mut</h2>
<pre class="signature">fn into_mut(self) -&gt; &amp;'a mut V {</pre>
<p class="doc">Convert to a mutable reference.</p>
<h2 id="insert">fn insert</h2>
<pre class="signature">fn insert(&amp;mut self, value: V) -&gt; V {</pre>
<p class="doc">Insert a new value, returning the old.</p>
<h2 id="remove">fn remove</h2>
<pre class="signature">fn remove(self) -&gt; V {</pre>
<p class="doc">Remove the entry.</p>
<h2 id="insert">fn insert</h2>
<pre class="signature">fn insert(self, value: V) -&gt; &amp;'a mut V {</pre>
<p class="doc">Insert a value into the vacant entry.</p>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="new">fn new</h2>
<pre class="signature">fn new() -&gt; HashSet&lt;T&gt; {</pre>
<p class="doc">Create a new empty hash set.</p>
<h2 id="with_capacity">fn with_capacity</h2>
<pre class="signature">fn with_capacity(capacity: usize) -&gt; HashSet&lt;T&gt; {</pre>
<p class="doc">Create a hash set with the given capacity.</p>
<h2 id="insert">fn insert</h2>
<pre class="signature">fn insert(&amp;mut self, value: T) -&gt; bool {</pre>
<p class="doc">Insert a value. Returns true if the value was not already present.</p>
<h2 id="contains">fn contains</h2>
<pre class="signature">fn contains(&amp;self, value: &amp;T) -&gt; bool {</pre>
<p class="doc">Check if value exists.</p>
<h2 id="remove">fn remove</h2>
<pre class="signature">fn remove(&amp;mut self, value: &amp;T) -&gt; bool {</pre>
<p class="doc">Remove a value. Returns true if the value was present.</p>
<h2 id="take">fn take</h2>
<pre class="signature">fn take(&amp;mut self, value: &amp;T) -&gt; Option&lt;T&gt; {</pre>
<p class="doc">Take a value from the set.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the number of elements.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if empty.</p>
<h2 id="clear">fn clear</h2>
<pre class="signature">fn clear(&amp;mut self) {</pre>
<p class="doc">Clear all elements.</p>
<h2 id="iter">fn iter</h2>
<pre class="signature">fn iter(&amp;self) -&gt; HashSetIter&lt;T&gt; {</pre>
<p class="doc">Iterate over elements.</p>
<h2 id="retain">fn retain</h2>
<pre class="signature">fn retain&lt;F: FnMut(&amp;T) -&gt; bool&gt;(&amp;mut self, mut pred: F) {</pre>
<p class="doc">Retain only elements matching a predicate.</p>
<h2 id="union">fn union</h2>
<pre class="signature">fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; where T: Clone {</pre>
<p class="doc">Compute the union with another set.</p>
<h2 id="intersection">fn intersection</h2>
<pre class="signature">fn intersection&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; where T: Clone {</pre>
<p class="doc">Compute the intersection with another set.</p>
<h2 id="difference">fn difference</h2>
<pre class="signature">fn difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; where T: Clone {</pre>
<p class="doc">Compute the difference with another set.</p>
<h2 id="symmetric_difference">fn symmetric_difference</h2>
<pre class="signature">fn symmetric_difference&lt;'a&gt;(&amp;'a self, other: &amp;'a HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; where T: Clone {</pre>
<p class="doc">Compute the symmetric difference with another set.</p>
<h2 id="is_subset">fn is_subset</h2>
<pre class="signature">fn is_subset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {</pre>
<p class="doc">Check if this set is a subset of another.</p>
<h2 id="is_superset">fn is_superset</h2>
<pre class="signature">fn is_superset(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {</pre>
<p class="doc">Check if this set is a superset of another.</p>
<h2 id="is_disjoint">fn is_disjoint</h2>
<pre class="signature">fn is_disjoint(&amp;self, other: &amp;HashSet&lt;T&gt;) -&gt; bool {</pre>
<p class="doc">Check if this set is disjoint from another.</p>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; HashSet&lt;T&gt; {</pre>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="new">fn new</h2>
<pre class="signature">fn new() -&gt; VecDeque&lt;T&gt; {</pre>
<p class="doc">Create a new empty deque.</p>
<h2 id="with_capacity">fn with_capacity</h2>
<pre class="signature">fn with_capacity(capacity: usize) -&gt; VecDeque&lt;T&gt; {</pre>
<p class="doc">Create a deque with the given capacity.</p>
<h2 id="push_back">fn push_back</h2>
<pre class="signature">fn push_back(&amp;mut self, value: T) {</pre>
<p class="doc">Push to the back.</p>
<h2 id="push_front">fn push_front</h2>
<pre class="signature">fn push_front(&amp;mut self, value: T) {</pre>
<p class="doc">Push to the front.</p>
<h2 id="pop_back">fn pop_back</h2>
<pre class="signature">fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {</pre>
<p class="doc">Pop from the back.</p>
<h2 id="pop_front">fn pop_front</h2>
<pre class="signature">fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {</pre>
<p class="doc">Pop from the front.</p>
<h2 id="front">fn front</h2>
<pre class="signature">fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get front element.</p>
<h2 id="back">fn back</h2>
<pre class="signature">fn back(&amp;self) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get back element.</p>
<h2 id="front_mut">fn front_mut</h2>
<pre class="signature">fn front_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {</pre>
<p class="doc">Get front element mutably.</p>
<h2 id="back_mut">fn back_mut</h2>
<pre class="signature">fn back_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {</pre>
<p class="doc">Get back element mutably.</p>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Get element by index.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get length.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if empty.</p>
<h2 id="capacity">fn capacity</h2>
<pre class="signature">fn capacity(&amp;self) -&gt; usize {</pre>
<p class="doc">Get capacity.</p>
<h2 id="clear">fn clear</h2>
<pre class="signature">fn clear(&amp;mut self) {</pre>
<p class="doc">Clear all elements.</p>
<h2 id="rotate_left">fn rotate_left</h2>
<pre class="signature">fn rotate_left(&amp;mut self, n: usize) {</pre>
<p class="doc">Rotate the deque left by n positions.</p>
<h2 id="rotate_right">fn rotate_right</h2>
<pre class="signature">fn rotate_right(&amp;mut self, n: usize) {</pre>
<p class="doc">Rotate the deque right by n positions.</p>
<h2 id="iter">fn iter</h2>
<pre class="signature">fn iter(&amp;self) -&gt; VecDequeIter&lt;T&gt; {</pre>
<p class="doc">Iterate over elements.</p>
<h2 id="make_contiguous">fn make_contiguous</h2>
<pre class="signature">fn make_contiguous(&amp;mut self) -&gt; &amp;mut [T] {</pre>
<p class="doc">Make contiguous (useful for converting to slices).</p>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; VecDeque&lt;T&gt; {</pre>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</pre>
<h2 id="new">fn new</h2>
<pre class="signature">fn new() -&gt; BinaryHeap&lt;T&gt; {</pre>
<p class="doc">Create a new empty heap.</p>
<h2 id="with_capacity">fn with_capacity</h2>
<pre class="signature">fn with_capacity(capacity: usize) -&gt; BinaryHeap&lt;T&gt; {</pre>
<p class="doc">Create a heap with the given capacity.</p>
<h2 id="push">fn push</h2>
<pre class="signature">fn push(&amp;mut self, value: T) {</pre>
<p class="doc">Push an element onto the heap.</p>
<h2 id="pop">fn pop</h2>
<pre class="signature">fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {</pre>
<p class="doc">Pop the largest element from the heap.</p>
<h2 id="peek">fn peek</h2>
<pre class="signature">fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {</pre>
<p class="doc">Peek at the largest element.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the length.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if empty.</p>
<h2 id="clear">fn clear</h2>
<pre class="signature">fn clear(&amp;mut self) {</pre>
<p class="doc">Clear the heap.</p>
<h2 id="sift_up">fn sift_up</h2>
<pre class="signature">fn sift_up(&amp;mut self, mut pos: usize) {</pre>
<h2 id="sift_down">fn sift_down</h2>
<pre class="signature">fn sift_down(&amp;mut self, mut pos: usize) {</pre>
<h2 id="into_sorted_vec">fn into_sorted_vec</h2>
<pre class="signature">fn into_sorted_vec(mut self) -&gt; Vec&lt;T&gt; {</pre>
<p class="doc">Convert to a sorted vector.</p>
<h2 id="default">fn default</h2>
<pre class="signature">fn default() -&gt; Self {</pre>
<h2 id="vec_new">fn vec_new</h2>
<pre class="signature">fn vec_new() -&gt; i64;</pre>
<h2 id="vec_with_capacity">fn vec_with_capacity</h2>
<pre class="signature">fn vec_with_capacity(cap: i64) -&gt; i64;</pre>
<h2 id="vec_len">fn vec_len</h2>
<pre class="signature">fn vec_len(v: i64) -&gt; i64;</pre>
<h2 id="vec_capacity">fn vec_capacity</h2>
<pre class="signature">fn vec_capacity(v: i64) -&gt; i64;</pre>
<h2 id="vec_reserve">fn vec_reserve</h2>
<pre class="signature">fn vec_reserve(v: i64, additional: i64);</pre>
<h2 id="vec_shrink_to_fit">fn vec_shrink_to_fit</h2>
<pre class="signature">fn vec_shrink_to_fit(v: i64);</pre>
<h2 id="vec_push">fn vec_push</h2>
<pre class="signature">fn vec_push(v: i64, item: i64);</pre>
<h2 id="vec_pop">fn vec_pop</h2>
<pre class="signature">fn vec_pop(v: i64) -&gt; i64;</pre>
<h2 id="vec_insert">fn vec_insert</h2>
<pre class="signature">fn vec_insert(v: i64, index: i64, item: i64);</pre>
<h2 id="vec_remove">fn vec_remove</h2>
<pre class="signature">fn vec_remove(v: i64, index: i64) -&gt; i64;</pre>
<h2 id="vec_swap_remove">fn vec_swap_remove</h2>
<pre class="signature">fn vec_swap_remove(v: i64, index: i64) -&gt; i64;</pre>
<h2 id="vec_get">fn vec_get</h2>
<pre class="signature">fn vec_get(v: i64, index: i64) -&gt; i64;</pre>
<h2 id="vec_clear">fn vec_clear</h2>
<pre class="signature">fn vec_clear(v: i64);</pre>
<h2 id="vec_truncate">fn vec_truncate</h2>
<pre class="signature">fn vec_truncate(v: i64, len: i64);</pre>
<h2 id="vec_reverse">fn vec_reverse</h2>
<pre class="signature">fn vec_reverse(v: i64);</pre>
<h2 id="vec_as_ptr">fn vec_as_ptr</h2>
<pre class="signature">fn vec_as_ptr(v: i64) -&gt; i64;</pre>
<h2 id="vec_drop">fn vec_drop</h2>
<pre class="signature">fn vec_drop(v: i64);</pre>
<h2 id="hashmap_new">fn hashmap_new</h2>
<pre class="signature">fn hashmap_new() -&gt; i64;</pre>
<h2 id="hashmap_with_capacity">fn hashmap_with_capacity</h2>
<pre class="signature">fn hashmap_with_capacity(cap: i64) -&gt; i64;</pre>
<h2 id="hashmap_insert">fn hashmap_insert</h2>
<pre class="signature">fn hashmap_insert(m: i64, key: i64, value: i64) -&gt; i64;</pre>
<h2 id="hashmap_get">fn hashmap_get</h2>
<pre class="signature">fn hashmap_get(m: i64, key: i64) -&gt; i64;</pre>
<h2 id="hashmap_remove">fn hashmap_remove</h2>
<pre class="signature">fn hashmap_remove(m: i64, key: i64) -&gt; i64;</pre>
<h2 id="hashmap_len">fn hashmap_len</h2>
<pre class="signature">fn hashmap_len(m: i64) -&gt; i64;</pre>
<h2 id="hashmap_capacity">fn hashmap_capacity</h2>
<pre class="signature">fn hashmap_capacity(m: i64) -&gt; i64;</pre>
<h2 id="hashmap_clear">fn hashmap_clear</h2>
<pre class="signature">fn hashmap_clear(m: i64);</pre>
<h2 id="hashmap_iter_next">fn hashmap_iter_next</h2>
<pre class="signature">fn hashmap_iter_next(m: i64, index: *mut i64) -&gt; (i64, i64);</pre>
<h2 id="hashmap_retain">fn hashmap_retain</h2>
<pre class="signature">fn hashmap_retain(m: i64, pred: fn(i64, i64) -&gt; bool);</pre>
<h2 id="hashmap_drop">fn hashmap_drop</h2>
<pre class="signature">fn hashmap_drop(m: i64);</pre>
<h2 id="hashset_new">fn hashset_new</h2>
<pre class="signature">fn hashset_new() -&gt; i64;</pre>
<h2 id="hashset_with_capacity">fn hashset_with_capacity</h2>
<pre class="signature">fn hashset_with_capacity(cap: i64) -&gt; i64;</pre>
<h2 id="hashset_insert">fn hashset_insert</h2>
<pre class="signature">fn hashset_insert(s: i64, value: i64) -&gt; i64;</pre>
<h2 id="hashset_contains">fn hashset_contains</h2>
<pre class="signature">fn hashset_contains(s: i64, value: i64) -&gt; i64;</pre>
<h2 id="hashset_remove">fn hashset_remove</h2>
<pre class="signature">fn hashset_remove(s: i64, value: i64) -&gt; i64;</pre>
<h2 id="hashset_take">fn hashset_take</h2>
<pre class="signature">fn hashset_take(s: i64, value: i64) -&gt; i64;</pre>
<h2 id="hashset_len">fn hashset_len</h2>
<pre class="signature">fn hashset_len(s: i64) -&gt; i64;</pre>
<h2 id="hashset_clear">fn hashset_clear</h2>
<pre class="signature">fn hashset_clear(s: i64);</pre>
<h2 id="hashset_iter_next">fn hashset_iter_next</h2>
<pre class="signature">fn hashset_iter_next(s: i64, index: *mut i64) -&gt; i64;</pre>
<h2 id="hashset_retain">fn hashset_retain</h2>
<pre class="signature">fn hashset_retain(s: i64, pred: fn(i64) -&gt; bool);</pre>
<h2 id="hashset_drop">fn hashset_drop</h2>
<pre class="signature">fn hashset_drop(s: i64);</pre>
<h2 id="vecdeque_new">fn vecdeque_new</h2>
<pre class="signature">fn vecdeque_new() -&gt; i64;</pre>
<h2 id="vecdeque_with_capacity">fn vecdeque_with_capacity</h2>
<pre class="signature">fn vecdeque_with_capacity(cap: i64) -&gt; i64;</pre>
<h2 id="vecdeque_push_back">fn vecdeque_push_back</h2>
<pre class="signature">fn vecdeque_push_back(d: i64, value: i64);</pre>
<h2 id="vecdeque_push_front">fn vecdeque_push_front</h2>
<pre class="signature">fn vecdeque_push_front(d: i64, value: i64);</pre>
<h2 id="vecdeque_pop_back">fn vecdeque_pop_back</h2>
<pre class="signature">fn vecdeque_pop_back(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_pop_front">fn vecdeque_pop_front</h2>
<pre class="signature">fn vecdeque_pop_front(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_front">fn vecdeque_front</h2>
<pre class="signature">fn vecdeque_front(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_back">fn vecdeque_back</h2>
<pre class="signature">fn vecdeque_back(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_get">fn vecdeque_get</h2>
<pre class="signature">fn vecdeque_get(d: i64, index: i64) -&gt; i64;</pre>
<h2 id="vecdeque_len">fn vecdeque_len</h2>
<pre class="signature">fn vecdeque_len(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_capacity">fn vecdeque_capacity</h2>
<pre class="signature">fn vecdeque_capacity(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_clear">fn vecdeque_clear</h2>
<pre class="signature">fn vecdeque_clear(d: i64);</pre>
<h2 id="vecdeque_make_contiguous">fn vecdeque_make_contiguous</h2>
<pre class="signature">fn vecdeque_make_contiguous(d: i64);</pre>
<h2 id="vecdeque_as_ptr">fn vecdeque_as_ptr</h2>
<pre class="signature">fn vecdeque_as_ptr(d: i64) -&gt; i64;</pre>
<h2 id="vecdeque_drop">fn vecdeque_drop</h2>
<pre class="signature">fn vecdeque_drop(d: i64);</pre>
<h2 id="panic">fn panic</h2>
<pre class="signature">fn panic(msg: &amp;str) -&gt; ! {</pre>

    <hr>
    <p><em>Generated by sxdoc</em></p>
  </main>
</div>
</body>
</html>
