{
  "category": "std",
  "modules": [
    {
      "name": "sync",
      "file": "sync.html",
      "items": [
        {"kind": "fn", "name": "load", "signature": "fn load(&self, order: Ordering) -> bool {", "doc": "Load the value atomically."},
        {"kind": "fn", "name": "store", "signature": "fn store(&self, value: bool, order: Ordering) {", "doc": "Store a value atomically."},
        {"kind": "fn", "name": "swap", "signature": "fn swap(&self, value: bool, order: Ordering) -> bool {", "doc": "Swap the value atomically, returning the old value."},
        {"kind": "fn", "name": "compare_exchange", "signature": "fn compare_exchange(&self, current: bool, new: bool,", "doc": "Compare and swap atomically.\nReturns Ok(old) if successful, Err(current) if failed."},
        {"kind": "fn", "name": "compare_exchange_weak", "signature": "fn compare_exchange_weak(&self, current: bool, new: bool,", "doc": "Weak compare and swap (may fail spuriously)."},
        {"kind": "fn", "name": "load", "signature": "fn load(&self, order: Ordering) -> i64 {", "doc": "Load the value atomically."},
        {"kind": "fn", "name": "store", "signature": "fn store(&self, value: i64, order: Ordering) {", "doc": "Store a value atomically."},
        {"kind": "fn", "name": "swap", "signature": "fn swap(&self, value: i64, order: Ordering) -> i64 {", "doc": "Swap the value atomically, returning the old value."},
        {"kind": "fn", "name": "fetch_add", "signature": "fn fetch_add(&self, value: i64, order: Ordering) -> i64 {", "doc": "Add to the value atomically, returning the old value."},
        {"kind": "fn", "name": "fetch_sub", "signature": "fn fetch_sub(&self, value: i64, order: Ordering) -> i64 {", "doc": "Subtract from the value atomically, returning the old value."},
        {"kind": "fn", "name": "fetch_and", "signature": "fn fetch_and(&self, value: i64, order: Ordering) -> i64 {", "doc": "Bitwise AND atomically, returning the old value."},
        {"kind": "fn", "name": "fetch_or", "signature": "fn fetch_or(&self, value: i64, order: Ordering) -> i64 {", "doc": "Bitwise OR atomically, returning the old value."},
        {"kind": "fn", "name": "fetch_xor", "signature": "fn fetch_xor(&self, value: i64, order: Ordering) -> i64 {", "doc": "Bitwise XOR atomically, returning the old value."},
        {"kind": "fn", "name": "compare_exchange", "signature": "fn compare_exchange(&self, current: i64, new: i64,", "doc": "Compare and swap atomically."},
        {"kind": "fn", "name": "compare_exchange_weak", "signature": "fn compare_exchange_weak(&self, current: i64, new: i64,", "doc": "Weak compare and swap."},
        {"kind": "fn", "name": "fetch_update", "signature": "fn fetch_update<F>(&self, set_order: Ordering, fetch_order: Ordering,", "doc": "Fetch and update with a function."},
        {"kind": "fn", "name": "load", "signature": "fn load(&self, order: Ordering) -> *mut T {", "doc": "Load the pointer atomically."},
        {"kind": "fn", "name": "store", "signature": "fn store(&self, ptr: *mut T, order: Ordering) {", "doc": "Store a pointer atomically."},
        {"kind": "fn", "name": "swap", "signature": "fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {", "doc": "Swap the pointer atomically."},
        {"kind": "fn", "name": "compare_exchange", "signature": "fn compare_exchange(&self, current: *mut T, new: *mut T,", "doc": "Compare and swap atomically."},
        {"kind": "struct", "name": "ArcInner"}
      ]
    },
    {
      "name": "time",
      "file": "time.html",
      "items": [
        {"kind": "fn", "name": "from_secs", "signature": "fn from_secs(secs: i64) -> Duration {", "doc": "Create a duration from seconds."},
        {"kind": "fn", "name": "from_millis", "signature": "fn from_millis(millis: i64) -> Duration {", "doc": "Create a duration from milliseconds."},
        {"kind": "fn", "name": "from_micros", "signature": "fn from_micros(micros: i64) -> Duration {", "doc": "Create a duration from microseconds."},
        {"kind": "fn", "name": "from_nanos", "signature": "fn from_nanos(nanos: i64) -> Duration {", "doc": "Create a duration from nanoseconds."},
        {"kind": "fn", "name": "as_secs", "signature": "fn as_secs(&self) -> i64 {", "doc": "Get as seconds (truncated)."},
        {"kind": "fn", "name": "as_millis", "signature": "fn as_millis(&self) -> i64 {", "doc": "Get as milliseconds (truncated)."},
        {"kind": "fn", "name": "as_micros", "signature": "fn as_micros(&self) -> i64 {", "doc": "Get as microseconds (truncated)."},
        {"kind": "fn", "name": "as_nanos", "signature": "fn as_nanos(&self) -> i64 {", "doc": "Get as nanoseconds."},
        {"kind": "fn", "name": "as_secs_f64", "signature": "fn as_secs_f64(&self) -> f64 {", "doc": "Get as seconds with fractional part."},
        {"kind": "fn", "name": "zero", "signature": "fn zero() -> Duration {", "doc": "Zero duration."},
        {"kind": "fn", "name": "is_zero", "signature": "fn is_zero(&self) -> bool {", "doc": "Check if zero."},
        {"kind": "fn", "name": "add", "signature": "fn add(self, other: Duration) -> Duration {"},
        {"kind": "fn", "name": "sub", "signature": "fn sub(self, other: Duration) -> Duration {"},
        {"kind": "fn", "name": "now", "signature": "fn now() -> Instant {", "doc": "Get the current instant."},
        {"kind": "fn", "name": "elapsed", "signature": "fn elapsed(&self) -> Duration {", "doc": "Get duration since this instant."},
        {"kind": "fn", "name": "duration_since", "signature": "fn duration_since(&self, earlier: Instant) -> Duration {", "doc": "Get duration from this instant to another."},
        {"kind": "fn", "name": "now_unix_ms", "signature": "fn now_unix_ms() -> i64 {", "doc": "Get current Unix timestamp in milliseconds."},
        {"kind": "fn", "name": "now_unix_secs", "signature": "fn now_unix_secs() -> i64 {", "doc": "Get current Unix timestamp in seconds."},
        {"kind": "fn", "name": "now_nanos", "signature": "fn now_nanos() -> i64 {", "doc": "Get current monotonic time in nanoseconds."},
        {"kind": "fn", "name": "sleep", "signature": "fn sleep(duration: Duration) {", "doc": "Sleep for the given duration (blocking)."},
        {"kind": "fn", "name": "sleep_ms", "signature": "fn sleep_ms(millis: i64) {", "doc": "Sleep for the given number of milliseconds."},
        {"kind": "fn", "name": "time_unix_ms", "signature": "fn time_unix_ms() -> i64;"},
        {"kind": "fn", "name": "time_nanos", "signature": "fn time_nanos() -> i64;"},
        {"kind": "fn", "name": "time_sleep_nanos", "signature": "fn time_sleep_nanos(nanos: i64);"}
      ]
    },
    {
      "name": "task",
      "file": "task.html",
      "items": [
        {"kind": "fn", "name": "spawn", "signature": "fn spawn<F, T>(future: F) -> JoinHandle<T>", "doc": "Spawn an async task to run concurrently.\n\nReturns a JoinHandle that can be awaited to get the result..."},
        {"kind": "fn", "name": "is_finished", "signature": "fn is_finished(&self) -> bool {", "doc": "Check if the task has completed."},
        {"kind": "fn", "name": "abort", "signature": "fn abort(&self) {", "doc": "Abort the task."},
        {"kind": "fn", "name": "poll", "signature": "fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {"},
        {"kind": "struct", "name": "YieldNow"}
      ]
    },
    {
      "name": "fmt",
      "file": "fmt.html",
      "items": [
        {"kind": "fn", "name": "print", "signature": "fn print(s: &str) {", "doc": "Print a string without newline."},
        {"kind": "fn", "name": "println", "signature": "fn println(s: &str) {", "doc": "Print a string with newline."},
        {"kind": "fn", "name": "newline", "signature": "fn newline() {", "doc": "Print an empty newline."},
        {"kind": "fn", "name": "eprint", "signature": "fn eprint(s: &str) {", "doc": "Eprint - print to stderr."},
        {"kind": "fn", "name": "eprintln", "signature": "fn eprintln(s: &str) {", "doc": "Eprintln - print to stderr with newline."},
        {"kind": "fn", "name": "printf", "signature": "fn printf(fmt: &str, args: &[&dyn Formattable]) {", "doc": "Printf with format specifiers.\n\nSupported specifiers:\n- `%s`: String\n- `%d`, `%i`: Signed integer (d..."},
        {"kind": "fn", "name": "sprintf", "signature": "fn sprintf(fmt: &str, args: &[&dyn Formattable]) -> String {", "doc": "Sprintf - format to a string."},
        {"kind": "fn", "name": "default", "signature": "fn default() -> FormatSpec {"},
        {"kind": "fn", "name": "parse_format_spec", "signature": "fn parse_format_spec(chars: &[char], i: &mut usize) -> FormatSpec {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String;"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "format_with", "signature": "fn format_with(&self, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "apply_width_and_align", "signature": "fn apply_width_and_align(s: &str, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "int_to_string_signed", "signature": "fn int_to_string_signed(n: i64, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "int_to_string_unsigned", "signature": "fn int_to_string_unsigned(mut n: u64, base: u64, uppercase: bool, spec: &FormatSpec) -> String {"},
        {"kind": "fn", "name": "int_to_string", "signature": "fn int_to_string(n: i64) -> String {", "doc": "Format an integer as a string."},
        {"kind": "fn", "name": "int_to_hex", "signature": "fn int_to_hex(n: u64, uppercase: bool) -> String {", "doc": "Format an unsigned integer as hexadecimal."},
        {"kind": "fn", "name": "int_to_binary", "signature": "fn int_to_binary(n: u64) -> String {", "doc": "Format an unsigned integer as binary."},
        {"kind": "fn", "name": "int_to_octal", "signature": "fn int_to_octal(n: u64) -> String {", "doc": "Format an unsigned integer as octal."},
        {"kind": "fn", "name": "float_to_string", "signature": "fn float_to_string(f: f64) -> String {", "doc": "Format a float as a string."},
        {"kind": "fn", "name": "float_to_string_precision", "signature": "fn float_to_string_precision(f: f64, precision: i32) -> String {", "doc": "Format a float with given precision."},
        {"kind": "fn", "name": "float_to_scientific", "signature": "fn float_to_scientific(f: f64, precision: i32, uppercase: bool) -> String {", "doc": "Format a float in scientific notation."},
        {"kind": "fn", "name": "bool_to_string", "signature": "fn bool_to_string(b: bool) -> String {", "doc": "Format a boolean as a string."},
        {"kind": "fn", "name": "format", "signature": "fn format<T: Display>(value: &T) -> String {", "doc": "Format a value as a string using Display."},
        {"kind": "fn", "name": "debug", "signature": "fn debug<T: Debug>(value: &T) -> String {", "doc": "Format a value as a debug string."},
        {"kind": "fn", "name": "print_vec_i64", "signature": "fn print_vec_i64(v: &[i64]) {", "doc": "Print a vector of integers."},
        {"kind": "fn", "name": "print_vec_f64", "signature": "fn print_vec_f64(v: &[f64]) {", "doc": "Print a vector of floats."},
        {"kind": "fn", "name": "print_vec_str", "signature": "fn print_vec_str(v: &[String]) {", "doc": "Print a vector of strings."},
        {"kind": "fn", "name": "print_vec_bool", "signature": "fn print_vec_bool(v: &[bool]) {", "doc": "Print a vector of booleans."},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String;"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { float_to_string(*self) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { float_to_string(*self as f64) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { bool_to_string(*self) }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String {"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { self.to_string() }"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String { self.clone() }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String;"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String { int_to_string(*self) }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String { int_to_string(*self as i64) }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String { float_to_string(*self) }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String { float_to_string(*self as f64) }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String { bool_to_string(*self) }"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String {"},
        {"kind": "fn", "name": "write_str", "signature": "fn write_str(&mut self, s: &str) -> Result<(), WriteError>;"},
        {"kind": "fn", "name": "write_char", "signature": "fn write_char(&mut self, c: char) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "write_fmt", "signature": "fn write_fmt(&mut self, args: &Arguments) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "write_str", "signature": "fn write_str(&mut self, s: &str) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "write_str", "signature": "fn write_str(&mut self, s: &str) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> Arguments {"},
        {"kind": "fn", "name": "push", "signature": "fn push(&mut self, s: String) {"},
        {"kind": "fn", "name": "to_string", "signature": "fn to_string(&self) -> String {"},
        {"kind": "fn", "name": "new", "signature": "fn new(buf: &'a mut dyn Write) -> Formatter<'a> {"},
        {"kind": "fn", "name": "write_str", "signature": "fn write_str(&mut self, s: &str) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "write_fmt", "signature": "fn write_fmt(&mut self, args: &Arguments) -> Result<(), WriteError> {"},
        {"kind": "fn", "name": "width", "signature": "fn width(&self) -> Option<usize> {"},
        {"kind": "fn", "name": "precision", "signature": "fn precision(&self) -> Option<usize> {"},
        {"kind": "fn", "name": "align", "signature": "fn align(&self) -> Alignment {"},
        {"kind": "fn", "name": "fill", "signature": "fn fill(&self) -> char {"},
        {"kind": "fn", "name": "io_print", "signature": "fn io_print(s: *const u8, len: i64);"},
        {"kind": "fn", "name": "io_eprint", "signature": "fn io_eprint(s: *const u8, len: i64);"},
        {"kind": "fn", "name": "float_format", "signature": "fn float_format(f: f64, buf: *mut u8, max_len: i64) -> i64;"},
        {"kind": "fn", "name": "float_format_precision", "signature": "fn float_format_precision(f: f64, buf: *mut u8, max_len: i64, precision: i32) -> i64;"},
        {"kind": "fn", "name": "float_format_scientific", "signature": "fn float_format_scientific(f: f64, buf: *mut u8, max_len: i64, precision: i32, uppercase: i32) -> i64;"}
      ]
    },
    {
      "name": "env",
      "file": "env.html",
      "items": [
        {"kind": "fn", "name": "var", "signature": "fn var(key: &str) -> Result<String, VarError> {", "doc": "Get an environment variable.\n\n# Arguments\n* `key` - The environment variable name\n\n# Returns\nThe val..."},
        {"kind": "fn", "name": "set_var", "signature": "fn set_var(key: &str, value: &str) {", "doc": "Set an environment variable.\n\n# Arguments\n* `key` - The environment variable name\n* `value` - The va..."},
        {"kind": "fn", "name": "remove_var", "signature": "fn remove_var(key: &str) {", "doc": "Remove an environment variable.\n\n# Arguments\n* `key` - The environment variable name to remove"},
        {"kind": "fn", "name": "var_is_set", "signature": "fn var_is_set(key: &str) -> bool {", "doc": "Check if an environment variable is set.\n\n# Arguments\n* `key` - The environment variable name\n\n# Ret..."},
        {"kind": "fn", "name": "current_dir", "signature": "fn current_dir() -> Result<String, VarError> {", "doc": "Get current working directory."},
        {"kind": "fn", "name": "set_current_dir", "signature": "fn set_current_dir(path: &str) -> Result<(), VarError> {", "doc": "Set current working directory."},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "env_get_var", "signature": "fn env_get_var(key: *const u8, key_len: i64, out: *mut u8, out_cap: i64) -> i64;"},
        {"kind": "fn", "name": "env_set_var", "signature": "fn env_set_var(key: *const u8, key_len: i64, value: *const u8, value_len: i64);"},
        {"kind": "fn", "name": "env_remove_var", "signature": "fn env_remove_var(key: *const u8, key_len: i64);"},
        {"kind": "fn", "name": "env_getcwd", "signature": "fn env_getcwd(out: *mut u8, out_cap: i64) -> i64;"},
        {"kind": "fn", "name": "env_chdir", "signature": "fn env_chdir(path: *const u8, path_len: i64) -> i64;"}
      ]
    },
    {
      "name": "signal",
      "file": "signal.html",
      "items": [
        {"kind": "fn", "name": "to_signum", "signature": "fn to_signum(self) -> i32 {"},
        {"kind": "struct", "name": "SignalFuture", "doc": "Future that completes when a signal is received"}
      ]
    },
    {
      "name": "log",
      "file": "log.html",
      "items": [
        {"kind": "fn", "name": "name", "signature": "fn name(&self) -> &'static str {", "doc": "Get the level name as a string."},
        {"kind": "fn", "name": "from_i64", "signature": "fn from_i64(n: i64) -> Level {", "doc": "Get the level from an integer."},
        {"kind": "fn", "name": "set_level", "signature": "fn set_level(level: Level) {", "doc": "Set the minimum log level.\n\nMessages below this level will be suppressed.\n\n# Example\n```simplex\nset_..."},
        {"kind": "fn", "name": "get_level", "signature": "fn get_level() -> Level {", "doc": "Get the current log level."},
        {"kind": "fn", "name": "is_enabled", "signature": "fn is_enabled(level: Level) -> bool {", "doc": "Check if a level is enabled."},
        {"kind": "fn", "name": "set_show_timestamp", "signature": "fn set_show_timestamp(show: bool) {", "doc": "Enable or disable timestamps in log output."},
        {"kind": "fn", "name": "set_show_level", "signature": "fn set_show_level(show: bool) {", "doc": "Enable or disable level names in log output."},
        {"kind": "fn", "name": "log", "signature": "fn log(level: Level, message: &str) {", "doc": "Log a message at the specified level."},
        {"kind": "fn", "name": "trace", "signature": "fn trace(message: &str) {", "doc": "Log at TRACE level."},
        {"kind": "fn", "name": "debug", "signature": "fn debug(message: &str) {", "doc": "Log at DEBUG level."},
        {"kind": "fn", "name": "info", "signature": "fn info(message: &str) {", "doc": "Log at INFO level."},
        {"kind": "fn", "name": "warn", "signature": "fn warn(message: &str) {", "doc": "Log at WARN level."},
        {"kind": "fn", "name": "error", "signature": "fn error(message: &str) {", "doc": "Log at ERROR level."},
        {"kind": "fn", "name": "logf", "signature": "fn logf(level: Level, format: &str, args: &[&str]) {", "doc": "Log with a format string (replaces {} with args)."},
        {"kind": "fn", "name": "tracef", "signature": "fn tracef(format: &str, args: &[&str]) {", "doc": "Trace with format string."},
        {"kind": "fn", "name": "debugf", "signature": "fn debugf(format: &str, args: &[&str]) {", "doc": "Debug with format string."},
        {"kind": "fn", "name": "infof", "signature": "fn infof(format: &str, args: &[&str]) {", "doc": "Info with format string."},
        {"kind": "fn", "name": "warnf", "signature": "fn warnf(format: &str, args: &[&str]) {", "doc": "Warn with format string."},
        {"kind": "fn", "name": "errorf", "signature": "fn errorf(format: &str, args: &[&str]) {", "doc": "Error with format string."},
        {"kind": "fn", "name": "log_ctx", "signature": "fn log_ctx(level: Level, message: &str, context: &[(&str, &str)]) {", "doc": "Log with structured key-value context.\n\n# Example\n```simplex\ninfo_ctx(\"Request completed\", &[\n    (\"..."},
        {"kind": "fn", "name": "trace_ctx", "signature": "fn trace_ctx(message: &str, context: &[(&str, &str)]) {", "doc": "Trace with context."},
        {"kind": "fn", "name": "debug_ctx", "signature": "fn debug_ctx(message: &str, context: &[(&str, &str)]) {", "doc": "Debug with context."},
        {"kind": "fn", "name": "info_ctx", "signature": "fn info_ctx(message: &str, context: &[(&str, &str)]) {", "doc": "Info with context."},
        {"kind": "fn", "name": "warn_ctx", "signature": "fn warn_ctx(message: &str, context: &[(&str, &str)]) {", "doc": "Warn with context."},
        {"kind": "fn", "name": "error_ctx", "signature": "fn error_ctx(message: &str, context: &[(&str, &str)]) {", "doc": "Error with context."},
        {"kind": "fn", "name": "enable_debug", "signature": "fn enable_debug() {", "doc": "Enable verbose logging (DEBUG level)."},
        {"kind": "fn", "name": "enable_trace", "signature": "fn enable_trace() {", "doc": "Enable trace logging (most verbose)."},
        {"kind": "fn", "name": "errors_only", "signature": "fn errors_only() {", "doc": "Show only errors."},
        {"kind": "fn", "name": "disable", "signature": "fn disable() {", "doc": "Disable all logging."},
        {"kind": "fn", "name": "new", "signature": "fn new(prefix: &str) -> Logger {", "doc": "Create a new logger with a prefix.\n\n# Example\n```simplex\nlet log = Logger::new(\"http\");\nlog.info(\"Se..."},
        {"kind": "fn", "name": "with_level", "signature": "fn with_level(prefix: &str, level: Level) -> Logger {", "doc": "Create a logger with a specific level."},
        {"kind": "fn", "name": "is_enabled", "signature": "fn is_enabled(&self, level: Level) -> bool {", "doc": "Check if a level is enabled for this logger."},
        {"kind": "fn", "name": "log", "signature": "fn log(&self, level: Level, message: &str) {", "doc": "Log a message."},
        {"kind": "fn", "name": "trace", "signature": "fn trace(&self, message: &str) { self.log(Level::Trace, message); }"},
        {"kind": "fn", "name": "debug", "signature": "fn debug(&self, message: &str) { self.log(Level::Debug, message); }"},
        {"kind": "fn", "name": "info", "signature": "fn info(&self, message: &str) { self.log(Level::Info, message); }"},
        {"kind": "fn", "name": "warn", "signature": "fn warn(&self, message: &str) { self.log(Level::Warn, message); }"},
        {"kind": "fn", "name": "error", "signature": "fn error(&self, message: &str) { self.log(Level::Error, message); }"},
        {"kind": "fn", "name": "child", "signature": "fn child(&self, name: &str) -> Logger {", "doc": "Create a child logger with additional prefix."},
        {"kind": "fn", "name": "timestamp", "signature": "fn timestamp() -> String {"},
        {"kind": "fn", "name": "slog_set_level", "signature": "fn slog_set_level(level: i64) {", "doc": "Set log level (slog compatibility)."},
        {"kind": "fn", "name": "slog_get_level", "signature": "fn slog_get_level() -> i64 {", "doc": "Get log level (slog compatibility)."},
        {"kind": "fn", "name": "slog_trace", "signature": "fn slog_trace(msg: &str) { trace(msg); }", "doc": "Trace (slog compatibility)."},
        {"kind": "fn", "name": "slog_debug", "signature": "fn slog_debug(msg: &str) { debug(msg); }", "doc": "Debug (slog compatibility)."},
        {"kind": "fn", "name": "slog_info", "signature": "fn slog_info(msg: &str) { info(msg); }", "doc": "Info (slog compatibility)."},
        {"kind": "fn", "name": "slog_warn", "signature": "fn slog_warn(msg: &str) { warn(msg); }", "doc": "Warn (slog compatibility)."},
        {"kind": "fn", "name": "slog_error", "signature": "fn slog_error(msg: &str) { error(msg); }", "doc": "Error (slog compatibility)."},
        {"kind": "fn", "name": "slog_info_ctx", "signature": "fn slog_info_ctx(msg: &str, key: &str, value: &str) {", "doc": "Info with single context (slog compatibility)."},
        {"kind": "fn", "name": "slog_fmt", "signature": "fn slog_fmt(level: i64, format: &str, arg: &str) {", "doc": "Format log (slog compatibility)."},
        {"kind": "fn", "name": "slog_infof", "signature": "fn slog_infof(format: &str, arg: &str) {", "doc": "Info with format (slog compatibility)."},
        {"kind": "fn", "name": "slog_errorf", "signature": "fn slog_errorf(format: &str, arg: &str) {", "doc": "Error with format (slog compatibility)."},
        {"kind": "fn", "name": "slog_debugf", "signature": "fn slog_debugf(format: &str, arg: &str) {", "doc": "Debug with format (slog compatibility)."},
        {"kind": "fn", "name": "slog_warnf", "signature": "fn slog_warnf(format: &str, arg: &str) {", "doc": "Warn with format (slog compatibility)."},
        {"kind": "fn", "name": "slog_enable_debug", "signature": "fn slog_enable_debug() { enable_debug(); }", "doc": "Enable debug (slog compatibility)."},
        {"kind": "fn", "name": "slog_enable_trace", "signature": "fn slog_enable_trace() { enable_trace(); }", "doc": "Enable trace (slog compatibility)."},
        {"kind": "fn", "name": "slog_errors_only", "signature": "fn slog_errors_only() { errors_only(); }", "doc": "Errors only (slog compatibility)."}
      ]
    },
    {
      "name": "net",
      "file": "net.html",
      "items": [
        {"kind": "fn", "name": "new", "signature": "fn new(ip: &str, port: u16) -> Self {", "doc": "Create from IP and port"},
        {"kind": "fn", "name": "parse", "signature": "fn parse(addr: &str) -> Result<Self, IoError> {", "doc": "Parse from \"ip:port\" string"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "local_addr", "signature": "fn local_addr(&self) -> &SocketAddr {", "doc": "Get local address"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "peer_addr", "signature": "fn peer_addr(&self) -> &SocketAddr {", "doc": "Get peer address"},
        {"kind": "fn", "name": "set_read_timeout", "signature": "fn set_read_timeout(&self, timeout_ms: Option<u64>) {", "doc": "Set read timeout"},
        {"kind": "fn", "name": "set_write_timeout", "signature": "fn set_write_timeout(&self, timeout_ms: Option<u64>) {", "doc": "Set write timeout"},
        {"kind": "fn", "name": "set_nodelay", "signature": "fn set_nodelay(&self, nodelay: bool) {", "doc": "Set TCP nodelay (disable Nagle's algorithm)"},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Self {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "tcp_listener_bind", "signature": "fn tcp_listener_bind(addr: &str) -> Result<i64, IoError>;", "doc": "Bind TCP listener"},
        {"kind": "fn", "name": "tcp_listener_close", "signature": "fn tcp_listener_close(handle: i64);", "doc": "Close listener"},
        {"kind": "fn", "name": "tcp_stream_clone", "signature": "fn tcp_stream_clone(handle: i64) -> i64;", "doc": "Clone stream handle"},
        {"kind": "fn", "name": "tcp_stream_close", "signature": "fn tcp_stream_close(handle: i64);", "doc": "Close stream"},
        {"kind": "fn", "name": "tcp_stream_set_read_timeout", "signature": "fn tcp_stream_set_read_timeout(handle: i64, timeout_ms: Option<u64>);", "doc": "Set read timeout"},
        {"kind": "fn", "name": "tcp_stream_set_write_timeout", "signature": "fn tcp_stream_set_write_timeout(handle: i64, timeout_ms: Option<u64>);", "doc": "Set write timeout"},
        {"kind": "fn", "name": "tcp_stream_set_nodelay", "signature": "fn tcp_stream_set_nodelay(handle: i64, nodelay: bool);", "doc": "Set TCP nodelay"}
      ]
    },
    {
      "name": "io",
      "file": "io.html",
      "items": [
        {"kind": "fn", "name": "new", "signature": "fn new(inner: R) -> Self {", "doc": "Create new buffered reader with default buffer size (8KB)"},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize, inner: R) -> Self {", "doc": "Create buffered reader with specified buffer size"},
        {"kind": "fn", "name": "get_ref", "signature": "fn get_ref(&self) -> &R {", "doc": "Get reference to inner reader"},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self) -> &mut R {", "doc": "Get mutable reference to inner reader"},
        {"kind": "fn", "name": "into_inner", "signature": "fn into_inner(self) -> R {", "doc": "Consume and return inner reader"},
        {"kind": "fn", "name": "new", "signature": "fn new(inner: W) -> Self {", "doc": "Create new buffered writer with default buffer size (8KB)"},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize, inner: W) -> Self {", "doc": "Create buffered writer with specified buffer size"},
        {"kind": "fn", "name": "get_ref", "signature": "fn get_ref(&self) -> &W {", "doc": "Get reference to inner writer"},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self) -> &mut W {", "doc": "Get mutable reference to inner writer"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"}
      ]
    },
    {
      "name": "core",
      "file": "core.html",
      "items": [
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Self {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "new", "signature": "fn new(value: T) -> Box<T> {", "doc": "Allocate a new value on the heap."},
        {"kind": "fn", "name": "into_raw", "signature": "fn into_raw(self) -> *mut T {", "doc": "Consume the box and return the raw pointer.\n\nThe caller is responsible for deallocating the memory."},
        {"kind": "fn", "name": "get", "signature": "fn get(&self) -> &T {", "doc": "Get a reference to the boxed value."},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self) -> &mut T {", "doc": "Get a mutable reference to the boxed value."},
        {"kind": "fn", "name": "as_ptr", "signature": "fn as_ptr(&self) -> *const T {", "doc": "Get the raw pointer without consuming the box."},
        {"kind": "fn", "name": "as_mut_ptr", "signature": "fn as_mut_ptr(&mut self) -> *mut T {", "doc": "Get the raw mutable pointer without consuming the box."},
        {"kind": "fn", "name": "leak", "signature": "fn leak(b: Box<T>) -> &'static mut T {", "doc": "Leak the box, returning a mutable reference with a static lifetime.\n\nThis intentionally leaks memory..."},
        {"kind": "fn", "name": "deref", "signature": "fn deref(&self) -> &T {"},
        {"kind": "fn", "name": "deref_mut", "signature": "fn deref_mut(&mut self) -> &mut T {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Box<T> {"},
        {"kind": "fn", "name": "get", "signature": "fn get(&self) -> *mut T {", "doc": "Get a raw pointer to the underlying value.\n\nThis can be cast to a mutable pointer to mutate the valu..."},
        {"kind": "fn", "name": "into_inner", "signature": "fn into_inner(self) -> T {", "doc": "Get the underlying value, consuming the cell."},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self) -> &mut T {", "doc": "Get a mutable reference to the underlying value.\n\nThis is safe because having a mutable reference to..."},
        {"kind": "fn", "name": "raw_get", "signature": "fn raw_get(this: *const Self) -> *mut T {", "doc": "Returns a raw pointer to the underlying value."},
        {"kind": "fn", "name": "into_inner", "signature": "fn into_inner(slot: ManuallyDrop<T>) -> T {", "doc": "Extract the value, allowing it to be dropped normally."},
        {"kind": "fn", "name": "deref", "signature": "fn deref(&self) -> &T {"},
        {"kind": "fn", "name": "deref_mut", "signature": "fn deref_mut(&mut self) -> &mut T {"},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> ManuallyDrop<T> {"},
        {"kind": "fn", "name": "write", "signature": "fn write(&mut self, value: T) -> &mut T {", "doc": "Write a value, overwriting any previous contents without dropping."},
        {"kind": "fn", "name": "as_ptr", "signature": "fn as_ptr(&self) -> *const T {", "doc": "Get a pointer to the contained value."},
        {"kind": "fn", "name": "as_mut_ptr", "signature": "fn as_mut_ptr(&mut self) -> *mut T {", "doc": "Get a mutable pointer to the contained value."},
        {"kind": "fn", "name": "size_of", "signature": "fn size_of<T>() -> usize {", "doc": "Get the size of a type in bytes."},
        {"kind": "fn", "name": "align_of", "signature": "fn align_of<T>() -> usize {", "doc": "Get the alignment of a type in bytes."},
        {"kind": "fn", "name": "forget", "signature": "fn forget<T>(value: T) {", "doc": "Forget a value without running its destructor.\n\nThis leaks any resources the value owns."},
        {"kind": "fn", "name": "swap", "signature": "fn swap<T>(a: &mut T, b: &mut T) {", "doc": "Swap two values."},
        {"kind": "fn", "name": "replace", "signature": "fn replace<T>(dest: &mut T, src: T) -> T {", "doc": "Replace a value, returning the old one."},
        {"kind": "fn", "name": "take", "signature": "fn take<T: Default>(dest: &mut T) -> T {", "doc": "Take ownership of a value, leaving the default in its place."},
        {"kind": "fn", "name": "spin_loop", "signature": "fn spin_loop() {", "doc": "Hint to the CPU that we're in a spin loop.\n\nThis can improve performance by reducing power consumpti..."},
        {"kind": "fn", "name": "unlikely", "signature": "fn unlikely(cond: bool) -> bool {", "doc": "Hint that a condition is unlikely."},
        {"kind": "fn", "name": "likely", "signature": "fn likely(cond: bool) -> bool {", "doc": "Hint that a condition is likely."},
        {"kind": "fn", "name": "breakpoint", "signature": "fn breakpoint() {", "doc": "Trigger a breakpoint for debugging."},
        {"kind": "fn", "name": "deref", "signature": "fn deref(&self) -> &Self::Target;"},
        {"kind": "fn", "name": "deref_mut", "signature": "fn deref_mut(&mut self) -> &mut Self::Target;"},
        {"kind": "fn", "name": "is_null", "signature": "fn is_null<T>(ptr: *const T) -> bool {", "doc": "Returns true if the pointer is null."},
        {"kind": "fn", "name": "alloc", "signature": "fn alloc(size: usize) -> *mut u8 {", "doc": "Allocate memory.\n\nReturns a pointer to the allocated memory, or 0 on failure."},
        {"kind": "fn", "name": "alloc_zeroed", "signature": "fn alloc_zeroed(size: usize) -> *mut u8 {", "doc": "Allocate zeroed memory."},
        {"kind": "fn", "name": "ffi_alloc", "signature": "fn ffi_alloc(size: i64) -> i64;"},
        {"kind": "fn", "name": "ffi_dealloc", "signature": "fn ffi_dealloc(ptr: i64);"},
        {"kind": "fn", "name": "ffi_realloc", "signature": "fn ffi_realloc(ptr: i64, old_size: i64, new_size: i64) -> i64;"},
        {"kind": "fn", "name": "intrinsic_size_of", "signature": "fn intrinsic_size_of<T>() -> usize;"},
        {"kind": "fn", "name": "intrinsic_align_of", "signature": "fn intrinsic_align_of<T>() -> usize;"},
        {"kind": "fn", "name": "intrinsic_forget", "signature": "fn intrinsic_forget<T>(value: T);"},
        {"kind": "fn", "name": "intrinsic_read", "signature": "fn intrinsic_read<T>(src: *const T) -> T;"},
        {"kind": "fn", "name": "intrinsic_write", "signature": "fn intrinsic_write<T>(dst: *mut T, src: T);"},
        {"kind": "fn", "name": "intrinsic_drop_in_place", "signature": "fn intrinsic_drop_in_place<T>(ptr: *mut T);"},
        {"kind": "fn", "name": "intrinsic_copy", "signature": "fn intrinsic_copy<T>(src: *const T, dst: *mut T, count: usize);"},
        {"kind": "fn", "name": "intrinsic_copy_nonoverlapping", "signature": "fn intrinsic_copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);"},
        {"kind": "fn", "name": "intrinsic_write_bytes", "signature": "fn intrinsic_write_bytes<T>(dst: *mut T, val: u8, count: usize);"},
        {"kind": "fn", "name": "intrinsic_unreachable", "signature": "fn intrinsic_unreachable() -> !;"},
        {"kind": "fn", "name": "cpu_spin_hint", "signature": "fn cpu_spin_hint();"},
        {"kind": "fn", "name": "debug_breakpoint", "signature": "fn debug_breakpoint();"}
      ]
    },
    {
      "name": "dual",
      "file": "dual.html",
      "items": [
        {"kind": "fn", "name": "constant", "signature": "fn constant(value: f64) -> dual {"},
        {"kind": "fn", "name": "variable", "signature": "fn variable(value: f64) -> dual {"},
        {"kind": "fn", "name": "new", "signature": "fn new(val: f64, der: f64) -> dual {"},
        {"kind": "fn", "name": "zero", "signature": "fn zero() -> dual {"},
        {"kind": "fn", "name": "one", "signature": "fn one() -> dual {"},
        {"kind": "fn", "name": "add", "signature": "fn add(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "sub", "signature": "fn sub(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "mul", "signature": "fn mul(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "div", "signature": "fn div(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "neg", "signature": "fn neg(self) -> dual {"},
        {"kind": "fn", "name": "exp", "signature": "fn exp(self) -> dual {"},
        {"kind": "fn", "name": "ln", "signature": "fn ln(self) -> dual {"},
        {"kind": "fn", "name": "pow", "signature": "fn pow(self, n: dual) -> dual {"},
        {"kind": "fn", "name": "powi", "signature": "fn powi(self, n: i32) -> dual {"},
        {"kind": "fn", "name": "sqrt", "signature": "fn sqrt(self) -> dual {"},
        {"kind": "fn", "name": "sin", "signature": "fn sin(self) -> dual {"},
        {"kind": "fn", "name": "cos", "signature": "fn cos(self) -> dual {"},
        {"kind": "fn", "name": "tan", "signature": "fn tan(self) -> dual {"},
        {"kind": "fn", "name": "sinh", "signature": "fn sinh(self) -> dual {"},
        {"kind": "fn", "name": "cosh", "signature": "fn cosh(self) -> dual {"},
        {"kind": "fn", "name": "tanh", "signature": "fn tanh(self) -> dual {"},
        {"kind": "fn", "name": "sigmoid", "signature": "fn sigmoid(self) -> dual {"},
        {"kind": "fn", "name": "relu", "signature": "fn relu(self) -> dual {"},
        {"kind": "fn", "name": "leaky_relu", "signature": "fn leaky_relu(self, alpha: f64) -> dual {"},
        {"kind": "fn", "name": "softplus", "signature": "fn softplus(self) -> dual {"},
        {"kind": "fn", "name": "abs", "signature": "fn abs(self) -> dual {"},
        {"kind": "fn", "name": "min", "signature": "fn min(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "max", "signature": "fn max(self, other: dual) -> dual {"},
        {"kind": "fn", "name": "clamp", "signature": "fn clamp(self, min_val: f64, max_val: f64) -> dual {"},
        {"kind": "fn", "name": "is_constant", "signature": "fn is_constant(&self) -> bool {"},
        {"kind": "fn", "name": "value", "signature": "fn value(&self) -> f64 {"},
        {"kind": "fn", "name": "derivative", "signature": "fn derivative(&self) -> f64 {"},
        {"kind": "fn", "name": "detach", "signature": "fn detach(&self) -> dual {"},
        {"kind": "fn", "name": "add", "signature": "fn add(self, other: dual) -> dual { self.add(other) }"},
        {"kind": "fn", "name": "add", "signature": "fn add(self, other: f64) -> dual { self.add(dual::constant(other)) }"},
        {"kind": "fn", "name": "sub", "signature": "fn sub(self, other: dual) -> dual { self.sub(other) }"},
        {"kind": "fn", "name": "sub", "signature": "fn sub(self, other: f64) -> dual { self.sub(dual::constant(other)) }"},
        {"kind": "fn", "name": "mul", "signature": "fn mul(self, other: dual) -> dual { self.mul(other) }"},
        {"kind": "fn", "name": "mul", "signature": "fn mul(self, other: f64) -> dual { self.mul(dual::constant(other)) }"},
        {"kind": "fn", "name": "div", "signature": "fn div(self, other: dual) -> dual { self.div(other) }"},
        {"kind": "fn", "name": "div", "signature": "fn div(self, other: f64) -> dual { self.div(dual::constant(other)) }"},
        {"kind": "fn", "name": "neg", "signature": "fn neg(self) -> dual { self.neg() }"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> dual {"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String {"},
        {"kind": "fn", "name": "eq", "signature": "fn eq(&self, other: &dual) -> bool {"},
        {"kind": "fn", "name": "dot", "signature": "fn dot(a: &[dual], b: &[dual]) -> dual {", "doc": "Dot product of dual vectors"},
        {"kind": "fn", "name": "sum", "signature": "fn sum(v: &[dual]) -> dual {", "doc": "Sum of dual vector"},
        {"kind": "fn", "name": "mean", "signature": "fn mean(v: &[dual]) -> dual {", "doc": "Mean of dual vector"},
        {"kind": "fn", "name": "variance", "signature": "fn variance(v: &[dual]) -> dual {", "doc": "Variance of dual vector"},
        {"kind": "fn", "name": "softmax", "signature": "fn softmax(v: &[dual]) -> Vec<dual> {", "doc": "Softmax of dual vector"}
      ]
    },
    {
      "name": "assert",
      "file": "assert.html",
      "items": [
        {"kind": "fn", "name": "panic", "signature": "fn panic(message: &str) -> ! {", "doc": "Panic with a message, halting execution.\n\n# Example\n```simplex\nif critical_error {\n    panic(\"Critic..."},
        {"kind": "fn", "name": "panic_fmt", "signature": "fn panic_fmt(args: &[&str]) -> ! {", "doc": "Panic with a formatted message."},
        {"kind": "fn", "name": "assert", "signature": "fn assert(condition: bool) {", "doc": "Assert that a condition is true.\n\nPanics with a message if the condition is false.\n\n# Example\n```sim..."},
        {"kind": "fn", "name": "assert_msg", "signature": "fn assert_msg(condition: bool, message: &str) {", "doc": "Assert with a custom message.\n\n# Example\n```simplex\nassert_msg(x > 0, \"x must be positive\");\n```"},
        {"kind": "fn", "name": "assert_eq", "signature": "fn assert_eq<T: Eq + Debug>(left: T, right: T) {", "doc": "Assert that two values are equal.\n\n# Example\n```simplex\nassert_eq(2 + 2, 4);\nassert_eq(foo, expected..."},
        {"kind": "fn", "name": "assert_eq_msg", "signature": "fn assert_eq_msg<T: Eq + Debug>(left: T, right: T, message: &str) {", "doc": "Assert that two values are equal with a custom message."},
        {"kind": "fn", "name": "assert_ne", "signature": "fn assert_ne<T: Eq + Debug>(left: T, right: T) {", "doc": "Assert that two values are not equal.\n\n# Example\n```simplex\nassert_ne(result, 0);\nassert_ne(a, b);\n`..."},
        {"kind": "fn", "name": "assert_ne_msg", "signature": "fn assert_ne_msg<T: Eq + Debug>(left: T, right: T, message: &str) {", "doc": "Assert that two values are not equal with a custom message."},
        {"kind": "fn", "name": "assert_lt", "signature": "fn assert_lt<T: Ord + Debug>(left: T, right: T) {", "doc": "Assert that left is less than right.\n\n# Example\n```simplex\nassert_lt(1, 2);\nassert_lt(small, large);..."},
        {"kind": "fn", "name": "assert_le", "signature": "fn assert_le<T: Ord + Debug>(left: T, right: T) {", "doc": "Assert that left is less than or equal to right."},
        {"kind": "fn", "name": "assert_gt", "signature": "fn assert_gt<T: Ord + Debug>(left: T, right: T) {", "doc": "Assert that left is greater than right."},
        {"kind": "fn", "name": "assert_ge", "signature": "fn assert_ge<T: Ord + Debug>(left: T, right: T) {", "doc": "Assert that left is greater than or equal to right."},
        {"kind": "fn", "name": "assert_some", "signature": "fn assert_some<T>(opt: Option<T>) -> T {", "doc": "Assert that an Option is Some.\n\n# Example\n```simplex\nlet value = assert_some(maybe_value);\n```"},
        {"kind": "fn", "name": "assert_none", "signature": "fn assert_none<T: Debug>(opt: Option<T>) {", "doc": "Assert that an Option is None."},
        {"kind": "fn", "name": "assert_ok", "signature": "fn assert_ok<T, E: Debug>(result: Result<T, E>) -> T {", "doc": "Assert that a Result is Ok.\n\n# Example\n```simplex\nlet value = assert_ok(result);\n```"},
        {"kind": "fn", "name": "assert_err", "signature": "fn assert_err<T: Debug, E>(result: Result<T, E>) -> E {", "doc": "Assert that a Result is Err."},
        {"kind": "fn", "name": "assert_approx_eq", "signature": "fn assert_approx_eq(left: f64, right: f64) {", "doc": "Assert that two floats are approximately equal.\n\nUses a default epsilon of 1e-10.\n\n# Example\n```simp..."},
        {"kind": "fn", "name": "assert_approx_eq_eps", "signature": "fn assert_approx_eq_eps(left: f64, right: f64, epsilon: f64) {", "doc": "Assert that two floats are approximately equal within epsilon.\n\n# Example\n```simplex\nassert_approx_e..."},
        {"kind": "fn", "name": "assert_nan", "signature": "fn assert_nan(value: f64) {", "doc": "Assert that a float is NaN."},
        {"kind": "fn", "name": "assert_not_nan", "signature": "fn assert_not_nan(value: f64) {", "doc": "Assert that a float is not NaN."},
        {"kind": "fn", "name": "assert_finite", "signature": "fn assert_finite(value: f64) {", "doc": "Assert that a float is finite (not infinite or NaN)."},
        {"kind": "fn", "name": "debug_assert", "signature": "fn debug_assert(condition: bool) {"},
        {"kind": "fn", "name": "debug_assert", "signature": "fn debug_assert(condition: bool) {"},
        {"kind": "fn", "name": "debug_assert_msg", "signature": "fn debug_assert_msg(condition: bool, message: &str) {"},
        {"kind": "fn", "name": "debug_assert_msg", "signature": "fn debug_assert_msg(condition: bool, message: &str) {"},
        {"kind": "fn", "name": "debug_assert_eq", "signature": "fn debug_assert_eq<T: Eq + Debug>(left: T, right: T) {"},
        {"kind": "fn", "name": "debug_assert_eq", "signature": "fn debug_assert_eq<T: Eq + Debug>(left: T, right: T) {"},
        {"kind": "fn", "name": "debug_assert_ne", "signature": "fn debug_assert_ne<T: Eq + Debug>(left: T, right: T) {"},
        {"kind": "fn", "name": "debug_assert_ne", "signature": "fn debug_assert_ne<T: Eq + Debug>(left: T, right: T) {"},
        {"kind": "fn", "name": "unreachable", "signature": "fn unreachable(message: &str) -> ! {", "doc": "Mark code as unreachable.\n\nPanics if executed, indicating a logic error.\n\n# Example\n```simplex\nmatch..."},
        {"kind": "fn", "name": "unreachable_unchecked", "signature": "fn unreachable_unchecked() -> ! {", "doc": "Mark code as unreachable with a default message."},
        {"kind": "fn", "name": "run_test", "signature": "fn run_test(name: &str, test: fn() -> bool) -> bool {", "doc": "Helper to run a test and report success/failure."},
        {"kind": "fn", "name": "run_tests", "signature": "fn run_tests(tests: &[(&str, fn() -> bool)]) -> bool {", "doc": "Run multiple tests and report summary."},
        {"kind": "fn", "name": "assertion_count", "signature": "fn assertion_count() -> i64 {", "doc": "Get the number of assertions made."},
        {"kind": "fn", "name": "passed_count", "signature": "fn passed_count() -> i64 {", "doc": "Get the number of passed assertions."},
        {"kind": "fn", "name": "failed_count", "signature": "fn failed_count() -> i64 {", "doc": "Get the number of failed assertions."},
        {"kind": "fn", "name": "reset_counters", "signature": "fn reset_counters() {", "doc": "Reset all test counters."},
        {"kind": "fn", "name": "reset_assertion_count", "signature": "fn reset_assertion_count() {", "doc": "Reset the assertion counter (legacy)."},
        {"kind": "fn", "name": "count_assertion", "signature": "fn count_assertion() {", "doc": "Increment assertion counter (called by assert functions)."},
        {"kind": "fn", "name": "record_pass", "signature": "fn record_pass() {", "doc": "Record a passed test."},
        {"kind": "fn", "name": "record_fail", "signature": "fn record_fail() {", "doc": "Record a failed test."},
        {"kind": "fn", "name": "all_passed", "signature": "fn all_passed() -> bool {", "doc": "Check if all tests passed."},
        {"kind": "fn", "name": "test_summary", "signature": "fn test_summary() {", "doc": "Print a summary of test results."},
        {"kind": "fn", "name": "tfw_reset", "signature": "fn tfw_reset() {", "doc": "Reset test framework counters (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_passed_count", "signature": "fn tfw_passed_count() -> i64 {", "doc": "Get passed count (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_failed_count", "signature": "fn tfw_failed_count() -> i64 {", "doc": "Get failed count (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_summary", "signature": "fn tfw_summary() {", "doc": "Print test summary (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_assert", "signature": "fn tfw_assert(condition: bool, msg: &str) -> bool {", "doc": "Assert with tracking (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_assert_eq_i64", "signature": "fn tfw_assert_eq_i64(expected: i64, actual: i64, msg: &str) -> bool {", "doc": "Assert equal i64 (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_assert_eq_str", "signature": "fn tfw_assert_eq_str(expected: &str, actual: &str, msg: &str) -> bool {", "doc": "Assert equal strings (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_assert_ne_i64", "signature": "fn tfw_assert_ne_i64(a: i64, b: i64, msg: &str) -> bool {", "doc": "Assert not equal i64 (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_fail", "signature": "fn tfw_fail(msg: &str) {", "doc": "Explicitly fail a test (tfw compatibility)."},
        {"kind": "fn", "name": "tfw_all_passed", "signature": "fn tfw_all_passed() -> bool {", "doc": "Check if all tests passed (tfw compatibility)."},
        {"kind": "fn", "name": "abort", "signature": "fn abort() -> !;"}
      ]
    },
    {
      "name": "runtime",
      "file": "runtime.html",
      "items": [
        {"kind": "fn", "name": "block_on", "signature": "fn block_on<F, T>(future: F) -> T", "doc": "Run an async function to completion on the current thread.\n\nThis is the main entry point for async p..."},
        {"kind": "fn", "name": "spawn", "signature": "fn spawn<F>(future: F) -> JoinHandle<F::Output>", "doc": "Spawn an async task to run concurrently.\n\nThe task will run on the runtime's thread pool.\n\n# Example..."},
        {"kind": "fn", "name": "poll", "signature": "fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "runtime_block_on", "signature": "fn runtime_block_on<F, T>(future: F) -> T where F: Future<Output = T>;"},
        {"kind": "fn", "name": "runtime_spawn", "signature": "fn runtime_spawn<F>(future: F) -> i64 where F: Future + Send + 'static;"},
        {"kind": "fn", "name": "runtime_join_poll", "signature": "fn runtime_join_poll(handle: i64) -> i32;"},
        {"kind": "fn", "name": "runtime_join_result", "signature": "fn runtime_join_result<T>(handle: i64) -> T;"},
        {"kind": "fn", "name": "runtime_join_drop", "signature": "fn runtime_join_drop(handle: i64);"}
      ]
    },
    {
      "name": "crypto",
      "file": "crypto.html",
      "items": [
        {"kind": "fn", "name": "sha256", "signature": "fn sha256(data: &[u8]) -> [u8; 32] {", "doc": "Compute SHA-256 hash of data."},
        {"kind": "fn", "name": "sha256_str", "signature": "fn sha256_str(s: &str) -> [u8; 32] {", "doc": "Compute SHA-256 hash of a string."},
        {"kind": "fn", "name": "sha256_hex", "signature": "fn sha256_hex(data: &[u8]) -> String {", "doc": "Compute SHA-256 hash and return as hex string."},
        {"kind": "fn", "name": "bytes_to_hex", "signature": "fn bytes_to_hex(bytes: &[u8]) -> String {", "doc": "Convert bytes to hex string."},
        {"kind": "fn", "name": "hex_to_bytes", "signature": "fn hex_to_bytes(hex: &str) -> Option<Vec<u8>> {", "doc": "Convert hex string to bytes."},
        {"kind": "fn", "name": "hex_char_to_val", "signature": "fn hex_char_to_val(c: char) -> Option<u8> {"},
        {"kind": "fn", "name": "fnv1a", "signature": "fn fnv1a(data: &[u8]) -> u64 {", "doc": "FNV-1a hash (fast, non-cryptographic)."},
        {"kind": "fn", "name": "fnv1a_str", "signature": "fn fnv1a_str(s: &str) -> u64 {", "doc": "FNV-1a hash of a string."},
        {"kind": "fn", "name": "sha512", "signature": "fn sha512(data: &[u8]) -> [u8; 64] {", "doc": "Compute SHA-512 hash of data."},
        {"kind": "fn", "name": "sha512_str", "signature": "fn sha512_str(s: &str) -> [u8; 64] {", "doc": "Compute SHA-512 hash of a string."},
        {"kind": "fn", "name": "sha512_hex", "signature": "fn sha512_hex(data: &[u8]) -> String {", "doc": "Compute SHA-512 hash and return as hex string."},
        {"kind": "fn", "name": "hmac_sha256", "signature": "fn hmac_sha256(key: &[u8], message: &[u8]) -> [u8; 32] {", "doc": "Compute HMAC-SHA256 message authentication code.\n\n# Arguments\n- `key`: The secret key\n- `message`: T..."},
        {"kind": "fn", "name": "hmac_sha256_hex", "signature": "fn hmac_sha256_hex(key: &[u8], message: &[u8]) -> String {", "doc": "Compute HMAC-SHA256 and return as hex string."},
        {"kind": "fn", "name": "base64_encode", "signature": "fn base64_encode(data: &[u8]) -> String {", "doc": "Encode bytes as Base64.\n\n# Example\n```simplex\nlet encoded = base64_encode(b\"hello\");\nassert_eq!(enco..."},
        {"kind": "fn", "name": "base64_decode", "signature": "fn base64_decode(encoded: &str) -> Option<Vec<u8>> {", "doc": "Decode Base64 string to bytes.\n\nReturns None if the input is invalid Base64."},
        {"kind": "fn", "name": "base64_char_value", "signature": "fn base64_char_value(c: u8) -> Option<u8> {"},
        {"kind": "fn", "name": "random_bytes", "signature": "fn random_bytes(count: usize) -> Vec<u8> {", "doc": "Generate cryptographically secure random bytes.\n\n# Example\n```simplex\nlet key = random_bytes(32);  /..."},
        {"kind": "fn", "name": "random_hex", "signature": "fn random_hex(count: usize) -> String {", "doc": "Generate random bytes and return as hex string."},
        {"kind": "fn", "name": "random_base64", "signature": "fn random_base64(count: usize) -> String {", "doc": "Generate random bytes and return as base64 string."},
        {"kind": "fn", "name": "constant_time_eq", "signature": "fn constant_time_eq(a: &[u8], b: &[u8]) -> bool {", "doc": "Compare two byte slices in constant time.\n\nThis prevents timing attacks when comparing secrets like ..."},
        {"kind": "fn", "name": "constant_time_eq_str", "signature": "fn constant_time_eq_str(a: &str, b: &str) -> bool {", "doc": "Compare two strings in constant time."},
        {"kind": "fn", "name": "hash_password", "signature": "fn hash_password(password: &str, salt: &str) -> String {", "doc": "Hash a password with salt using SHA-256.\n\nNote: For production, use a proper KDF like bcrypt or argo..."},
        {"kind": "fn", "name": "verify_password", "signature": "fn verify_password(password: &str, salt: &str, expected_hash: &str) -> bool {", "doc": "Verify a password against a hash."},
        {"kind": "fn", "name": "bcrypt_hash", "signature": "fn bcrypt_hash(password: &str, cost: u32) -> Result<String, CryptoError> {", "doc": "Hash a password using bcrypt.\n\n# Arguments\n- `password`: The password to hash\n- `cost`: The work fac..."},
        {"kind": "fn", "name": "bcrypt_verify", "signature": "fn bcrypt_verify(password: &str, hash: &str) -> Result<bool, CryptoError> {", "doc": "Verify a password against a bcrypt hash.\n\n# Arguments\n- `password`: The password to verify\n- `hash`:..."},
        {"kind": "fn", "name": "generate_token", "signature": "fn generate_token(byte_len: usize) -> String {", "doc": "Generate a cryptographically secure random token.\n\nReturns a hex-encoded string of the specified byt..."},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "crypto_sha256", "signature": "fn crypto_sha256(data: *const u8, len: i64, out: *mut u8);"},
        {"kind": "fn", "name": "crypto_sha512", "signature": "fn crypto_sha512(data: *const u8, len: i64, out: *mut u8);"},
        {"kind": "fn", "name": "crypto_hmac_sha256", "signature": "fn crypto_hmac_sha256(key: *const u8, key_len: i64, msg: *const u8, msg_len: i64, out: *mut u8);"},
        {"kind": "fn", "name": "crypto_random_bytes", "signature": "fn crypto_random_bytes(out: *mut u8, count: i64);"},
        {"kind": "fn", "name": "crypto_bcrypt_hash", "signature": "fn crypto_bcrypt_hash(password: *const u8, password_len: i64, cost: u32, out: *mut u8) -> i64;"},
        {"kind": "fn", "name": "crypto_bcrypt_verify", "signature": "fn crypto_bcrypt_verify(password: *const u8, password_len: i64, hash: *const u8, hash_len: i64) -> i64;"}
      ]
    },
    {
      "name": "anneal",
      "file": "anneal.html",
      "items": [
        {"kind": "fn", "name": "default", "signature": "fn default() -> ScheduleGradient {"},
        {"kind": "fn", "name": "norm", "signature": "fn norm(&self) -> f64 {", "doc": "L2 norm of gradient (for regularization)"},
        {"kind": "fn", "name": "scale", "signature": "fn scale(&mut self, factor: f64) {", "doc": "Scale gradient by factor"},
        {"kind": "fn", "name": "add", "signature": "fn add(&mut self, other: &ScheduleGradient) {", "doc": "Add another gradient"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> LearnableSchedule {", "doc": "Create a new learnable schedule with default initial values.\n\nParameters are initialized to reasonab..."},
        {"kind": "fn", "name": "from_params", "signature": "fn from_params(", "doc": "Create schedule from explicit parameter values"},
        {"kind": "fn", "name": "temperature", "signature": "fn temperature(&self, step: dual, stagnation: dual) -> dual {", "doc": "Compute temperature at given step with stagnation info.\n\nTemperature follows exponential cooling wit..."},
        {"kind": "fn", "name": "accept_probability", "signature": "fn accept_probability(&self, delta_e: dual, temp: dual) -> dual {", "doc": "Compute soft acceptance probability (differentiable).\n\nUnlike hard acceptance (binary), this returns..."},
        {"kind": "fn", "name": "gradient", "signature": "fn gradient(&self) -> ScheduleGradient {", "doc": "Extract gradient vector from all parameters."},
        {"kind": "fn", "name": "update", "signature": "fn update(&mut self, grad: &ScheduleGradient, learning_rate: f64) {", "doc": "Apply meta-gradient update to all parameters."},
        {"kind": "fn", "name": "clamp_parameters", "signature": "fn clamp_parameters(&mut self) {", "doc": "Ensure parameters stay in valid ranges"},
        {"kind": "fn", "name": "l2_norm", "signature": "fn l2_norm(&self) -> dual {", "doc": "L2 norm of parameters (for regularization)"},
        {"kind": "fn", "name": "temperature_variance", "signature": "fn temperature_variance(&self, steps: i64) -> dual {", "doc": "Compute temperature variance over a window (for exploration bonus)"},
        {"kind": "fn", "name": "snapshot", "signature": "fn snapshot(&self) -> ScheduleSnapshot {", "doc": "Get a snapshot of current parameter values (for logging)"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> LearnableSchedule {"},
        {"kind": "fn", "name": "new", "signature": "fn new(initial: S, initial_energy: dual) -> AnnealState<S> {", "doc": "Create initial annealing state"},
        {"kind": "fn", "name": "accept", "signature": "fn accept(&mut self, new_solution: S, new_energy: dual) {", "doc": "Update state when accepting a new solution"},
        {"kind": "fn", "name": "reject", "signature": "fn reject(&mut self) {", "doc": "Update state when rejecting a solution"},
        {"kind": "fn", "name": "is_converged", "signature": "fn is_converged(&self, threshold: i64) -> bool {", "doc": "Check if converged (stagnation exceeds threshold)"},
        {"kind": "fn", "name": "new", "signature": "fn new(quality: dual, efficiency: dual, simplicity: dual) -> MetaLoss {", "doc": "Create meta-loss from components"},
        {"kind": "fn", "name": "from_quality", "signature": "fn from_quality(quality: dual) -> MetaLoss {", "doc": "Create from just quality (simple version)"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> MetaHistory {", "doc": "Create empty history"},
        {"kind": "fn", "name": "push", "signature": "fn push(&mut self, epoch: MetaEpoch) {", "doc": "Add an epoch record"},
        {"kind": "fn", "name": "best_energy", "signature": "fn best_energy(&self) -> f64 {", "doc": "Get best energy achieved"},
        {"kind": "fn", "name": "is_improving", "signature": "fn is_improving(&self, window: usize) -> bool {", "doc": "Check if improving (last N epochs)"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> MetaHistory {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> AnnealConfig {", "doc": "Default configuration suitable for many problems"},
        {"kind": "fn", "name": "quick", "signature": "fn quick() -> AnnealConfig {", "doc": "Quick configuration for fast exploration"},
        {"kind": "fn", "name": "thorough", "signature": "fn thorough() -> AnnealConfig {", "doc": "Thorough configuration for difficult problems"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> AnnealConfig {"},
        {"kind": "fn", "name": "exponential", "signature": "fn exponential(t0: f64, alpha: f64, step: i64) -> f64 {", "doc": "Exponential cooling: T(t) = T  exp(-t)"},
        {"kind": "fn", "name": "linear", "signature": "fn linear(t0: f64, t_final: f64, step: i64, total_steps: i64) -> f64 {", "doc": "Linear cooling: T(t) = T - (T - T_final)  t / steps"},
        {"kind": "fn", "name": "logarithmic", "signature": "fn logarithmic(c: f64, step: i64) -> f64 {", "doc": "Logarithmic cooling: T(t) = c / ln(t + 2)"},
        {"kind": "fn", "name": "cosine", "signature": "fn cosine(t0: f64, t_min: f64, step: i64, total_steps: i64) -> f64 {", "doc": "Cosine annealing: T(t) = T_min + (T - T_min)  (1 + cos(t/steps)) / 2"},
        {"kind": "fn", "name": "random_f64", "signature": "fn random_f64() -> f64 {"},
        {"kind": "fn", "name": "random_normal", "signature": "fn random_normal() -> f64 {", "doc": "Generate random normal (standard normal distribution)"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> MetaOptimizer {", "doc": "Create a new meta-optimizer with default schedule"},
        {"kind": "fn", "name": "with_schedule", "signature": "fn with_schedule(schedule: LearnableSchedule) -> MetaOptimizer {", "doc": "Create with custom schedule"},
        {"kind": "fn", "name": "learning_rate", "signature": "fn learning_rate(mut self, lr: f64) -> MetaOptimizer {", "doc": "Set meta-learning rate"},
        {"kind": "fn", "name": "regularization", "signature": "fn regularization(mut self, reg: f64) -> MetaOptimizer {", "doc": "Set regularization strength"},
        {"kind": "fn", "name": "anneal_episode", "signature": "fn anneal_episode<S: Clone, F, N>(", "doc": "Run a single annealing episode with gradient tracking.\n\nReturns the best solution found and the fina..."},
        {"kind": "fn", "name": "compute_meta_loss", "signature": "fn compute_meta_loss(", "doc": "Compute meta-loss that measures schedule quality.\n\nComponents:\n- Quality: final objective value (low..."},
        {"kind": "fn", "name": "update_schedule", "signature": "fn update_schedule(&mut self, meta_loss: &MetaLoss) {", "doc": "Update schedule parameters based on meta-loss."},
        {"kind": "fn", "name": "optimize", "signature": "fn optimize<S: Clone, F, N>(", "doc": "Run complete meta-optimization loop.\n\nTrains the schedule over multiple epochs, improving it based\no..."},
        {"kind": "fn", "name": "get_schedule", "signature": "fn get_schedule(&self) -> &LearnableSchedule {", "doc": "Get current schedule (for inspection)"},
        {"kind": "fn", "name": "get_history", "signature": "fn get_history(&self) -> &MetaHistory {", "doc": "Get training history"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> MetaOptimizer {"},
        {"kind": "fn", "name": "self_learn_anneal", "signature": "fn self_learn_anneal<S: Clone, F, N>(", "doc": "Run self-learning annealing with default configuration.\n\nThis is the main entry point for using self..."},
        {"kind": "fn", "name": "simple_anneal", "signature": "fn simple_anneal<S: Clone, F, N>(", "doc": "Run simple (non-learning) simulated annealing with fixed schedule.\n\nUseful for comparison with self-..."},
        {"kind": "fn", "name": "test_dual_temperature", "signature": "fn test_dual_temperature() {"},
        {"kind": "fn", "name": "test_acceptance_probability", "signature": "fn test_acceptance_probability() {"},
        {"kind": "fn", "name": "test_gradient_flow", "signature": "fn test_gradient_flow() {"},
        {"kind": "fn", "name": "test_meta_update", "signature": "fn test_meta_update() {"}
      ]
    },
    {
      "name": "collections",
      "file": "collections.html",
      "items": [
        {"kind": "fn", "name": "new", "signature": "fn new() -> Vec<T> {", "doc": "Create a new empty vector."},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize) -> Vec<T> {", "doc": "Create a vector with the given capacity."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the number of elements."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if empty."},
        {"kind": "fn", "name": "capacity", "signature": "fn capacity(&self) -> usize {", "doc": "Get the capacity."},
        {"kind": "fn", "name": "reserve", "signature": "fn reserve(&mut self, additional: usize) {", "doc": "Reserve capacity for at least `additional` more elements."},
        {"kind": "fn", "name": "shrink_to_fit", "signature": "fn shrink_to_fit(&mut self) {", "doc": "Shrink capacity to fit current length."},
        {"kind": "fn", "name": "push", "signature": "fn push(&mut self, value: T) {", "doc": "Push an element to the end."},
        {"kind": "fn", "name": "pop", "signature": "fn pop(&mut self) -> Option<T> {", "doc": "Pop an element from the end."},
        {"kind": "fn", "name": "insert", "signature": "fn insert(&mut self, index: usize, value: T) {", "doc": "Insert an element at the given index."},
        {"kind": "fn", "name": "remove", "signature": "fn remove(&mut self, index: usize) -> T {", "doc": "Remove and return the element at the given index."},
        {"kind": "fn", "name": "swap_remove", "signature": "fn swap_remove(&mut self, index: usize) -> T {", "doc": "Swap-remove the element at the given index (O(1) but doesn't preserve order)."},
        {"kind": "fn", "name": "get", "signature": "fn get(&self, index: usize) -> Option<&T> {", "doc": "Get an element by index."},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self, index: usize) -> Option<&mut T> {", "doc": "Get a mutable element by index."},
        {"kind": "fn", "name": "first", "signature": "fn first(&self) -> Option<&T> {", "doc": "Get the first element."},
        {"kind": "fn", "name": "last", "signature": "fn last(&self) -> Option<&T> {", "doc": "Get the last element."},
        {"kind": "fn", "name": "clear", "signature": "fn clear(&mut self) {", "doc": "Clear all elements."},
        {"kind": "fn", "name": "truncate", "signature": "fn truncate(&mut self, len: usize) {", "doc": "Truncate to the given length."},
        {"kind": "fn", "name": "iter", "signature": "fn iter(&self) -> VecIter<T> {", "doc": "Iterate over elements."},
        {"kind": "fn", "name": "iter_mut", "signature": "fn iter_mut(&mut self) -> VecIterMut<T> {", "doc": "Iterate mutably over elements."},
        {"kind": "fn", "name": "map", "signature": "fn map<U, F: Fn(&T) -> U>(&self, f: F) -> Vec<U> {", "doc": "Map a function over elements."},
        {"kind": "fn", "name": "filter", "signature": "fn filter<F: Fn(&T) -> bool>(&self, pred: F) -> Vec<T>", "doc": "Filter elements by predicate."},
        {"kind": "fn", "name": "fold", "signature": "fn fold<U, F: Fn(U, &T) -> U>(&self, init: U, f: F) -> U {", "doc": "Fold elements with accumulator."},
        {"kind": "fn", "name": "find", "signature": "fn find<F: Fn(&T) -> bool>(&self, pred: F) -> Option<&T> {", "doc": "Find the first element matching a predicate."},
        {"kind": "fn", "name": "position", "signature": "fn position<F: Fn(&T) -> bool>(&self, pred: F) -> Option<usize> {", "doc": "Find the index of the first element matching a predicate."},
        {"kind": "fn", "name": "any", "signature": "fn any<F: Fn(&T) -> bool>(&self, pred: F) -> bool {", "doc": "Check if any element matches a predicate."},
        {"kind": "fn", "name": "all", "signature": "fn all<F: Fn(&T) -> bool>(&self, pred: F) -> bool {", "doc": "Check if all elements match a predicate."},
        {"kind": "fn", "name": "count", "signature": "fn count<F: Fn(&T) -> bool>(&self, pred: F) -> usize {", "doc": "Count elements matching a predicate."},
        {"kind": "fn", "name": "reverse", "signature": "fn reverse(&mut self) {", "doc": "Reverse the vector in place."},
        {"kind": "fn", "name": "sort", "signature": "fn sort(&mut self) where T: Ord {", "doc": "Sort the vector (requires Ord)."},
        {"kind": "fn", "name": "sort_by", "signature": "fn sort_by<F: FnMut(&T, &T) -> Ordering>(&mut self, mut compare: F) {", "doc": "Sort by a comparison function."},
        {"kind": "fn", "name": "contains", "signature": "fn contains(&self, value: &T) -> bool where T: Eq {", "doc": "Check if the vector contains an element."},
        {"kind": "fn", "name": "append", "signature": "fn append(&mut self, other: &mut Vec<T>) {", "doc": "Append another vector to this one."},
        {"kind": "fn", "name": "extend", "signature": "fn extend<I: Iterator<Item = T>>(&mut self, iter: I) {", "doc": "Extend from an iterator."},
        {"kind": "fn", "name": "from_slice", "signature": "fn from_slice(slice: &[T]) -> Vec<T> where T: Clone {", "doc": "Create a vector from a slice."},
        {"kind": "fn", "name": "as_slice", "signature": "fn as_slice(&self) -> &[T] {", "doc": "Convert to a slice."},
        {"kind": "fn", "name": "as_mut_slice", "signature": "fn as_mut_slice(&mut self) -> &mut [T] {", "doc": "Convert to a mutable slice."},
        {"kind": "fn", "name": "split_off", "signature": "fn split_off(&mut self, at: usize) -> Vec<T> {", "doc": "Split the vector at the given index."},
        {"kind": "fn", "name": "retain", "signature": "fn retain<F: FnMut(&T) -> bool>(&mut self, mut pred: F) {", "doc": "Retain only elements matching a predicate."},
        {"kind": "fn", "name": "dedup", "signature": "fn dedup(&mut self) where T: Eq {", "doc": "Deduplicate consecutive elements (requires Eq)."},
        {"kind": "fn", "name": "dedup_by", "signature": "fn dedup_by<F: FnMut(&T, &T) -> bool>(&mut self, mut same: F) {", "doc": "Deduplicate consecutive elements by a comparison function."},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Vec<T> {"},
        {"kind": "fn", "name": "resize_default", "signature": "fn resize_default(&mut self, new_len: usize) {", "doc": "Resize the vector to the given length, using default values."},
        {"kind": "fn", "name": "resize", "signature": "fn resize(&mut self, new_len: usize, value: T) {", "doc": "Resize the vector to the given length, using the given value."},
        {"kind": "fn", "name": "resize_with", "signature": "fn resize_with<F: FnMut() -> T>(&mut self, new_len: usize, mut f: F) {", "doc": "Resize the vector to the given length, using a function to generate values."},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "size_hint", "signature": "fn size_hint(&self) -> (usize, Option<usize>) {"},
        {"kind": "fn", "name": "enumerate", "signature": "fn enumerate(self) -> Enumerate<Self> {", "doc": "Enumerate the iterator."},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "quicksort_slice", "signature": "fn quicksort_slice<T, F: FnMut(&T, &T) -> Ordering>(v: &mut Vec<T>, low: usize, high: usize, compare: &mut F) {"},
        {"kind": "fn", "name": "partition", "signature": "fn partition<T, F: FnMut(&T, &T) -> Ordering>(v: &mut Vec<T>, low: usize, high: usize, compare: &mut F) -> usize {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> HashMap<K, V> {", "doc": "Create a new empty hash map."},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize) -> HashMap<K, V> {", "doc": "Create a hash map with the given capacity."},
        {"kind": "fn", "name": "insert", "signature": "fn insert(&mut self, key: K, value: V) -> Option<V> {", "doc": "Insert a key-value pair."},
        {"kind": "fn", "name": "get", "signature": "fn get(&self, key: &K) -> Option<&V> {", "doc": "Get a value by key."},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self, key: &K) -> Option<&mut V> {", "doc": "Get a mutable value by key."},
        {"kind": "fn", "name": "remove", "signature": "fn remove(&mut self, key: &K) -> Option<V> {", "doc": "Remove a key-value pair."},
        {"kind": "fn", "name": "contains_key", "signature": "fn contains_key(&self, key: &K) -> bool {", "doc": "Check if key exists."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the number of entries."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if empty."},
        {"kind": "fn", "name": "capacity", "signature": "fn capacity(&self) -> usize {", "doc": "Get the capacity."},
        {"kind": "fn", "name": "clear", "signature": "fn clear(&mut self) {", "doc": "Clear all entries."},
        {"kind": "fn", "name": "entry", "signature": "fn entry(&mut self, key: K) -> Entry<K, V> {", "doc": "Get or insert a value with a default."},
        {"kind": "fn", "name": "iter", "signature": "fn iter(&self) -> HashMapIter<K, V> {", "doc": "Iterate over key-value pairs."},
        {"kind": "fn", "name": "keys", "signature": "fn keys(&self) -> HashMapKeys<K, V> {", "doc": "Iterate over keys."},
        {"kind": "fn", "name": "values", "signature": "fn values(&self) -> HashMapValues<K, V> {", "doc": "Iterate over values."},
        {"kind": "fn", "name": "values_mut", "signature": "fn values_mut(&mut self) -> HashMapValuesMut<K, V> {", "doc": "Iterate mutably over values."},
        {"kind": "fn", "name": "retain", "signature": "fn retain<F: FnMut(&K, &mut V) -> bool>(&mut self, mut pred: F) {", "doc": "Retain only entries matching a predicate."},
        {"kind": "fn", "name": "get_or_insert_with", "signature": "fn get_or_insert_with<F: FnOnce() -> V>(&mut self, key: K, f: F) -> &mut V {", "doc": "Get or insert with a function."},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "or_insert", "signature": "fn or_insert(self, default: V) -> &'a mut V {", "doc": "Get or insert a default value."},
        {"kind": "fn", "name": "or_insert_with", "signature": "fn or_insert_with<F: FnOnce() -> V>(self, f: F) -> &'a mut V {", "doc": "Get or insert with a function."},
        {"kind": "fn", "name": "or_default", "signature": "fn or_default(self) -> &'a mut V where V: Default {", "doc": "Get or insert a default value (requires Default)."},
        {"kind": "fn", "name": "get", "signature": "fn get(&self) -> &V {", "doc": "Get a reference to the value."},
        {"kind": "fn", "name": "get_mut", "signature": "fn get_mut(&mut self) -> &mut V {", "doc": "Get a mutable reference to the value."},
        {"kind": "fn", "name": "into_mut", "signature": "fn into_mut(self) -> &'a mut V {", "doc": "Convert to a mutable reference."},
        {"kind": "fn", "name": "insert", "signature": "fn insert(&mut self, value: V) -> V {", "doc": "Insert a new value, returning the old."},
        {"kind": "fn", "name": "remove", "signature": "fn remove(self) -> V {", "doc": "Remove the entry."},
        {"kind": "fn", "name": "insert", "signature": "fn insert(self, value: V) -> &'a mut V {", "doc": "Insert a value into the vacant entry."},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> HashSet<T> {", "doc": "Create a new empty hash set."},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize) -> HashSet<T> {", "doc": "Create a hash set with the given capacity."},
        {"kind": "fn", "name": "insert", "signature": "fn insert(&mut self, value: T) -> bool {", "doc": "Insert a value. Returns true if the value was not already present."},
        {"kind": "fn", "name": "contains", "signature": "fn contains(&self, value: &T) -> bool {", "doc": "Check if value exists."},
        {"kind": "fn", "name": "remove", "signature": "fn remove(&mut self, value: &T) -> bool {", "doc": "Remove a value. Returns true if the value was present."},
        {"kind": "fn", "name": "take", "signature": "fn take(&mut self, value: &T) -> Option<T> {", "doc": "Take a value from the set."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the number of elements."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if empty."},
        {"kind": "fn", "name": "clear", "signature": "fn clear(&mut self) {", "doc": "Clear all elements."},
        {"kind": "fn", "name": "iter", "signature": "fn iter(&self) -> HashSetIter<T> {", "doc": "Iterate over elements."},
        {"kind": "fn", "name": "retain", "signature": "fn retain<F: FnMut(&T) -> bool>(&mut self, mut pred: F) {", "doc": "Retain only elements matching a predicate."},
        {"kind": "fn", "name": "union", "signature": "fn union<'a>(&'a self, other: &'a HashSet<T>) -> HashSet<T> where T: Clone {", "doc": "Compute the union with another set."},
        {"kind": "fn", "name": "intersection", "signature": "fn intersection<'a>(&'a self, other: &'a HashSet<T>) -> HashSet<T> where T: Clone {", "doc": "Compute the intersection with another set."},
        {"kind": "fn", "name": "difference", "signature": "fn difference<'a>(&'a self, other: &'a HashSet<T>) -> HashSet<T> where T: Clone {", "doc": "Compute the difference with another set."},
        {"kind": "fn", "name": "symmetric_difference", "signature": "fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T>) -> HashSet<T> where T: Clone {", "doc": "Compute the symmetric difference with another set."},
        {"kind": "fn", "name": "is_subset", "signature": "fn is_subset(&self, other: &HashSet<T>) -> bool {", "doc": "Check if this set is a subset of another."},
        {"kind": "fn", "name": "is_superset", "signature": "fn is_superset(&self, other: &HashSet<T>) -> bool {", "doc": "Check if this set is a superset of another."},
        {"kind": "fn", "name": "is_disjoint", "signature": "fn is_disjoint(&self, other: &HashSet<T>) -> bool {", "doc": "Check if this set is disjoint from another."},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> HashSet<T> {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> VecDeque<T> {", "doc": "Create a new empty deque."},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize) -> VecDeque<T> {", "doc": "Create a deque with the given capacity."},
        {"kind": "fn", "name": "push_back", "signature": "fn push_back(&mut self, value: T) {", "doc": "Push to the back."},
        {"kind": "fn", "name": "push_front", "signature": "fn push_front(&mut self, value: T) {", "doc": "Push to the front."},
        {"kind": "fn", "name": "pop_back", "signature": "fn pop_back(&mut self) -> Option<T> {", "doc": "Pop from the back."},
        {"kind": "fn", "name": "pop_front", "signature": "fn pop_front(&mut self) -> Option<T> {", "doc": "Pop from the front."},
        {"kind": "fn", "name": "front", "signature": "fn front(&self) -> Option<&T> {", "doc": "Get front element."},
        {"kind": "fn", "name": "back", "signature": "fn back(&self) -> Option<&T> {", "doc": "Get back element."},
        {"kind": "fn", "name": "front_mut", "signature": "fn front_mut(&mut self) -> Option<&mut T> {", "doc": "Get front element mutably."},
        {"kind": "fn", "name": "back_mut", "signature": "fn back_mut(&mut self) -> Option<&mut T> {", "doc": "Get back element mutably."},
        {"kind": "fn", "name": "get", "signature": "fn get(&self, index: usize) -> Option<&T> {", "doc": "Get element by index."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get length."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if empty."},
        {"kind": "fn", "name": "capacity", "signature": "fn capacity(&self) -> usize {", "doc": "Get capacity."},
        {"kind": "fn", "name": "clear", "signature": "fn clear(&mut self) {", "doc": "Clear all elements."},
        {"kind": "fn", "name": "rotate_left", "signature": "fn rotate_left(&mut self, n: usize) {", "doc": "Rotate the deque left by n positions."},
        {"kind": "fn", "name": "rotate_right", "signature": "fn rotate_right(&mut self, n: usize) {", "doc": "Rotate the deque right by n positions."},
        {"kind": "fn", "name": "iter", "signature": "fn iter(&self) -> VecDequeIter<T> {", "doc": "Iterate over elements."},
        {"kind": "fn", "name": "make_contiguous", "signature": "fn make_contiguous(&mut self) -> &mut [T] {", "doc": "Make contiguous (useful for converting to slices)."},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> VecDeque<T> {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Self::Item> {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> BinaryHeap<T> {", "doc": "Create a new empty heap."},
        {"kind": "fn", "name": "with_capacity", "signature": "fn with_capacity(capacity: usize) -> BinaryHeap<T> {", "doc": "Create a heap with the given capacity."},
        {"kind": "fn", "name": "push", "signature": "fn push(&mut self, value: T) {", "doc": "Push an element onto the heap."},
        {"kind": "fn", "name": "pop", "signature": "fn pop(&mut self) -> Option<T> {", "doc": "Pop the largest element from the heap."},
        {"kind": "fn", "name": "peek", "signature": "fn peek(&self) -> Option<&T> {", "doc": "Peek at the largest element."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the length."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if empty."},
        {"kind": "fn", "name": "clear", "signature": "fn clear(&mut self) {", "doc": "Clear the heap."},
        {"kind": "fn", "name": "sift_up", "signature": "fn sift_up(&mut self, mut pos: usize) {"},
        {"kind": "fn", "name": "sift_down", "signature": "fn sift_down(&mut self, mut pos: usize) {"},
        {"kind": "fn", "name": "into_sorted_vec", "signature": "fn into_sorted_vec(mut self) -> Vec<T> {", "doc": "Convert to a sorted vector."},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self {"},
        {"kind": "fn", "name": "vec_new", "signature": "fn vec_new() -> i64;"},
        {"kind": "fn", "name": "vec_with_capacity", "signature": "fn vec_with_capacity(cap: i64) -> i64;"},
        {"kind": "fn", "name": "vec_len", "signature": "fn vec_len(v: i64) -> i64;"},
        {"kind": "fn", "name": "vec_capacity", "signature": "fn vec_capacity(v: i64) -> i64;"},
        {"kind": "fn", "name": "vec_reserve", "signature": "fn vec_reserve(v: i64, additional: i64);"},
        {"kind": "fn", "name": "vec_shrink_to_fit", "signature": "fn vec_shrink_to_fit(v: i64);"},
        {"kind": "fn", "name": "vec_push", "signature": "fn vec_push(v: i64, item: i64);"},
        {"kind": "fn", "name": "vec_pop", "signature": "fn vec_pop(v: i64) -> i64;"},
        {"kind": "fn", "name": "vec_insert", "signature": "fn vec_insert(v: i64, index: i64, item: i64);"},
        {"kind": "fn", "name": "vec_remove", "signature": "fn vec_remove(v: i64, index: i64) -> i64;"},
        {"kind": "fn", "name": "vec_swap_remove", "signature": "fn vec_swap_remove(v: i64, index: i64) -> i64;"},
        {"kind": "fn", "name": "vec_get", "signature": "fn vec_get(v: i64, index: i64) -> i64;"},
        {"kind": "fn", "name": "vec_clear", "signature": "fn vec_clear(v: i64);"},
        {"kind": "fn", "name": "vec_truncate", "signature": "fn vec_truncate(v: i64, len: i64);"},
        {"kind": "fn", "name": "vec_reverse", "signature": "fn vec_reverse(v: i64);"},
        {"kind": "fn", "name": "vec_as_ptr", "signature": "fn vec_as_ptr(v: i64) -> i64;"},
        {"kind": "fn", "name": "vec_drop", "signature": "fn vec_drop(v: i64);"},
        {"kind": "fn", "name": "hashmap_new", "signature": "fn hashmap_new() -> i64;"},
        {"kind": "fn", "name": "hashmap_with_capacity", "signature": "fn hashmap_with_capacity(cap: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_insert", "signature": "fn hashmap_insert(m: i64, key: i64, value: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_get", "signature": "fn hashmap_get(m: i64, key: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_remove", "signature": "fn hashmap_remove(m: i64, key: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_len", "signature": "fn hashmap_len(m: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_capacity", "signature": "fn hashmap_capacity(m: i64) -> i64;"},
        {"kind": "fn", "name": "hashmap_clear", "signature": "fn hashmap_clear(m: i64);"},
        {"kind": "fn", "name": "hashmap_iter_next", "signature": "fn hashmap_iter_next(m: i64, index: *mut i64) -> (i64, i64);"},
        {"kind": "fn", "name": "hashmap_retain", "signature": "fn hashmap_retain(m: i64, pred: fn(i64, i64) -> bool);"},
        {"kind": "fn", "name": "hashmap_drop", "signature": "fn hashmap_drop(m: i64);"},
        {"kind": "fn", "name": "hashset_new", "signature": "fn hashset_new() -> i64;"},
        {"kind": "fn", "name": "hashset_with_capacity", "signature": "fn hashset_with_capacity(cap: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_insert", "signature": "fn hashset_insert(s: i64, value: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_contains", "signature": "fn hashset_contains(s: i64, value: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_remove", "signature": "fn hashset_remove(s: i64, value: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_take", "signature": "fn hashset_take(s: i64, value: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_len", "signature": "fn hashset_len(s: i64) -> i64;"},
        {"kind": "fn", "name": "hashset_clear", "signature": "fn hashset_clear(s: i64);"},
        {"kind": "fn", "name": "hashset_iter_next", "signature": "fn hashset_iter_next(s: i64, index: *mut i64) -> i64;"},
        {"kind": "fn", "name": "hashset_retain", "signature": "fn hashset_retain(s: i64, pred: fn(i64) -> bool);"},
        {"kind": "fn", "name": "hashset_drop", "signature": "fn hashset_drop(s: i64);"},
        {"kind": "fn", "name": "vecdeque_new", "signature": "fn vecdeque_new() -> i64;"},
        {"kind": "fn", "name": "vecdeque_with_capacity", "signature": "fn vecdeque_with_capacity(cap: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_push_back", "signature": "fn vecdeque_push_back(d: i64, value: i64);"},
        {"kind": "fn", "name": "vecdeque_push_front", "signature": "fn vecdeque_push_front(d: i64, value: i64);"},
        {"kind": "fn", "name": "vecdeque_pop_back", "signature": "fn vecdeque_pop_back(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_pop_front", "signature": "fn vecdeque_pop_front(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_front", "signature": "fn vecdeque_front(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_back", "signature": "fn vecdeque_back(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_get", "signature": "fn vecdeque_get(d: i64, index: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_len", "signature": "fn vecdeque_len(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_capacity", "signature": "fn vecdeque_capacity(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_clear", "signature": "fn vecdeque_clear(d: i64);"},
        {"kind": "fn", "name": "vecdeque_make_contiguous", "signature": "fn vecdeque_make_contiguous(d: i64);"},
        {"kind": "fn", "name": "vecdeque_as_ptr", "signature": "fn vecdeque_as_ptr(d: i64) -> i64;"},
        {"kind": "fn", "name": "vecdeque_drop", "signature": "fn vecdeque_drop(d: i64);"},
        {"kind": "fn", "name": "panic", "signature": "fn panic(msg: &str) -> ! {"}
      ]
    },
    {
      "name": "cli",
      "file": "cli.html",
      "items": [
        {"kind": "fn", "name": "arg_count", "signature": "fn arg_count() -> i64 {", "doc": "Get the number of command-line arguments (including program name)."},
        {"kind": "fn", "name": "get_arg", "signature": "fn get_arg(index: i64) -> String {", "doc": "Get a command-line argument by index.\n\nIndex 0 is the program name."},
        {"kind": "fn", "name": "program_name", "signature": "fn program_name() -> String {", "doc": "Get the program name (first argument)."},
        {"kind": "fn", "name": "args", "signature": "fn args() -> Vec<String> {", "doc": "Get all command-line arguments as a vector."},
        {"kind": "fn", "name": "positional_args", "signature": "fn positional_args() -> Vec<String> {", "doc": "Get positional arguments (excludes flags and their values).\n\nFlags start with `-` or `--`."},
        {"kind": "fn", "name": "has_flag", "signature": "fn has_flag(flag: &str) -> bool {", "doc": "Check if a flag exists in the arguments.\n\nSupports both `--flag` and `-f` formats.\n\n# Example\n```sim..."},
        {"kind": "fn", "name": "get_option", "signature": "fn get_option(name: &str) -> Option<String> {", "doc": "Get an option value from the arguments.\n\nSupports both `--name=value` and `--name value` formats.\nRe..."},
        {"kind": "fn", "name": "get_option_or", "signature": "fn get_option_or(name: &str, default: &str) -> String {", "doc": "Get an option value with a default fallback.\n\n# Example\n```simplex\nlet port = get_option_or(\"--port\"..."},
        {"kind": "fn", "name": "get_option_i64", "signature": "fn get_option_i64(name: &str) -> Option<i64> {", "doc": "Get an option value as an integer."},
        {"kind": "fn", "name": "get_option_i64_or", "signature": "fn get_option_i64_or(name: &str, default: i64) -> i64 {", "doc": "Get an option value as an integer with default."},
        {"kind": "fn", "name": "getenv", "signature": "fn getenv(name: &str) -> Option<String> {", "doc": "Get an environment variable value.\n\nReturns None if the variable is not set.\n\n# Example\n```simplex\ni..."},
        {"kind": "fn", "name": "getenv_or", "signature": "fn getenv_or(name: &str, default: &str) -> String {", "doc": "Get an environment variable with a default value.\n\n# Example\n```simplex\nlet editor = getenv_or(\"EDIT..."},
        {"kind": "fn", "name": "has_env", "signature": "fn has_env(name: &str) -> bool {", "doc": "Check if an environment variable is set."},
        {"kind": "fn", "name": "setenv", "signature": "fn setenv(name: &str, value: &str) -> bool {", "doc": "Set an environment variable.\n\nReturns true on success, false on failure.\n\n# Example\n```simplex\nseten..."},
        {"kind": "fn", "name": "unsetenv", "signature": "fn unsetenv(name: &str) -> bool {", "doc": "Unset an environment variable."},
        {"kind": "fn", "name": "cwd", "signature": "fn cwd() -> String {", "doc": "Get the current working directory."},
        {"kind": "fn", "name": "chdir", "signature": "fn chdir(path: &str) -> bool {", "doc": "Change the current working directory.\n\nReturns true on success."},
        {"kind": "fn", "name": "exit", "signature": "fn exit(code: i64) -> ! {", "doc": "Exit the program with the specified exit code.\n\nThis function does not return.\n\n# Example\n```simplex..."},
        {"kind": "fn", "name": "pid", "signature": "fn pid() -> i64 {", "doc": "Get the process ID."},
        {"kind": "struct", "name": "FlagDef"}
      ]
    },
    {
      "name": "compress",
      "file": "compress.html",
      "items": [
        {"kind": "fn", "name": "gzip", "signature": "fn gzip(data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Compress data using gzip\n\n# Arguments\n* `data` - Raw data to compress\n\n# Returns\nGzip-compressed dat..."},
        {"kind": "fn", "name": "gunzip", "signature": "fn gunzip(data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Decompress gzip data\n\n# Arguments\n* `data` - Gzip-compressed data\n\n# Returns\nDecompressed data"},
        {"kind": "fn", "name": "gzip_level", "signature": "fn gzip_level(data: &[u8], level: u32) -> Result<Vec<u8>, CompressError> {", "doc": "Compress data using gzip with specified compression level\n\n# Arguments\n* `data` - Raw data to compre..."},
        {"kind": "fn", "name": "deflate", "signature": "fn deflate(data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Compress data using raw DEFLATE\n\n# Arguments\n* `data` - Raw data to compress\n\n# Returns\nDEFLATE-comp..."},
        {"kind": "fn", "name": "inflate", "signature": "fn inflate(data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Decompress raw DEFLATE data\n\n# Arguments\n* `data` - DEFLATE-compressed data\n\n# Returns\nDecompressed ..."},
        {"kind": "fn", "name": "new", "signature": "fn new() -> Self {", "doc": "Create new gzip encoder"},
        {"kind": "fn", "name": "with_level", "signature": "fn with_level(level: u32) -> Self {", "doc": "Create encoder with specified compression level"},
        {"kind": "fn", "name": "compress", "signature": "fn compress(&mut self, data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Compress a chunk of data"},
        {"kind": "fn", "name": "finish", "signature": "fn finish(self) -> Result<Vec<u8>, CompressError> {", "doc": "Finish compression and return final bytes"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "new", "signature": "fn new() -> Self {", "doc": "Create new gzip decoder"},
        {"kind": "fn", "name": "decompress", "signature": "fn decompress(&mut self, data: &[u8]) -> Result<Vec<u8>, CompressError> {", "doc": "Decompress a chunk of data"},
        {"kind": "fn", "name": "finish", "signature": "fn finish(self) -> Result<Vec<u8>, CompressError> {", "doc": "Finish decompression"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "compress_gzip", "signature": "fn compress_gzip(data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Gzip compress"},
        {"kind": "fn", "name": "compress_gzip_level", "signature": "fn compress_gzip_level(data: &[u8], level: u32) -> Result<Vec<u8>, CompressError>;", "doc": "Gzip compress with level"},
        {"kind": "fn", "name": "decompress_gzip", "signature": "fn decompress_gzip(data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Gzip decompress"},
        {"kind": "fn", "name": "compress_deflate", "signature": "fn compress_deflate(data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Deflate compress"},
        {"kind": "fn", "name": "decompress_deflate", "signature": "fn decompress_deflate(data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Deflate decompress"},
        {"kind": "fn", "name": "gzip_encoder_new", "signature": "fn gzip_encoder_new(level: u32) -> i64;", "doc": "Create gzip encoder"},
        {"kind": "fn", "name": "gzip_encoder_write", "signature": "fn gzip_encoder_write(handle: i64, data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Write to gzip encoder"},
        {"kind": "fn", "name": "gzip_encoder_finish", "signature": "fn gzip_encoder_finish(handle: i64) -> Result<Vec<u8>, CompressError>;", "doc": "Finish gzip encoder"},
        {"kind": "fn", "name": "gzip_encoder_free", "signature": "fn gzip_encoder_free(handle: i64);", "doc": "Free gzip encoder"},
        {"kind": "fn", "name": "gzip_decoder_new", "signature": "fn gzip_decoder_new() -> i64;", "doc": "Create gzip decoder"},
        {"kind": "fn", "name": "gzip_decoder_write", "signature": "fn gzip_decoder_write(handle: i64, data: &[u8]) -> Result<Vec<u8>, CompressError>;", "doc": "Write to gzip decoder"},
        {"kind": "fn", "name": "gzip_decoder_finish", "signature": "fn gzip_decoder_finish(handle: i64) -> Result<Vec<u8>, CompressError>;", "doc": "Finish gzip decoder"},
        {"kind": "fn", "name": "gzip_decoder_free", "signature": "fn gzip_decoder_free(handle: i64);", "doc": "Free gzip decoder"}
      ]
    },
    {
      "name": "prelude",
      "file": "prelude.html",
      "items": [
      ]
    },
    {
      "name": "http",
      "file": "http.html",
      "items": [
        {"kind": "enum", "name": "Method", "doc": "HTTP request method"}
      ]
    },
    {
      "name": "math",
      "file": "math.html",
      "items": [
        {"kind": "fn", "name": "min", "signature": "fn min<T: Ord>(a: T, b: T) -> T {", "doc": "Minimum of two values."},
        {"kind": "fn", "name": "max", "signature": "fn max<T: Ord>(a: T, b: T) -> T {", "doc": "Maximum of two values."},
        {"kind": "fn", "name": "abs", "signature": "fn abs(x: i64) -> i64 {", "doc": "Absolute value (integer)."},
        {"kind": "fn", "name": "fabs", "signature": "fn fabs(x: f64) -> f64 {", "doc": "Absolute value (float)."},
        {"kind": "fn", "name": "clamp", "signature": "fn clamp<T: Ord>(x: T, lo: T, hi: T) -> T {", "doc": "Clamp value to range."},
        {"kind": "fn", "name": "sign", "signature": "fn sign(x: i64) -> i64 {", "doc": "Sign of a number (-1, 0, or 1)."},
        {"kind": "fn", "name": "signum", "signature": "fn signum(x: f64) -> f64 {", "doc": "Sign of a float (-1.0, 0.0, or 1.0)."},
        {"kind": "fn", "name": "div_floor", "signature": "fn div_floor(a: i64, b: i64) -> i64 {", "doc": "Integer division (floor)."},
        {"kind": "fn", "name": "div_ceil", "signature": "fn div_ceil(a: i64, b: i64) -> i64 {", "doc": "Integer division (ceiling)."},
        {"kind": "fn", "name": "gcd", "signature": "fn gcd(a: i64, b: i64) -> i64 {", "doc": "Greatest common divisor."},
        {"kind": "fn", "name": "lcm", "signature": "fn lcm(a: i64, b: i64) -> i64 {", "doc": "Least common multiple."},
        {"kind": "fn", "name": "pow", "signature": "fn pow(base: i64, exp: i64) -> i64 {", "doc": "Power (integer exponent)."},
        {"kind": "fn", "name": "sqrt", "signature": "fn sqrt(x: f64) -> f64 {", "doc": "Square root."},
        {"kind": "fn", "name": "cbrt", "signature": "fn cbrt(x: f64) -> f64 {", "doc": "Cube root."},
        {"kind": "fn", "name": "powf", "signature": "fn powf(base: f64, exp: f64) -> f64 {", "doc": "Power (float)."},
        {"kind": "fn", "name": "exp", "signature": "fn exp(x: f64) -> f64 {", "doc": "Exponential (e^x)."},
        {"kind": "fn", "name": "ln", "signature": "fn ln(x: f64) -> f64 {", "doc": "Natural logarithm."},
        {"kind": "fn", "name": "log10", "signature": "fn log10(x: f64) -> f64 {", "doc": "Base-10 logarithm."},
        {"kind": "fn", "name": "log2", "signature": "fn log2(x: f64) -> f64 {", "doc": "Base-2 logarithm."},
        {"kind": "fn", "name": "sin", "signature": "fn sin(x: f64) -> f64 {", "doc": "Sine."},
        {"kind": "fn", "name": "cos", "signature": "fn cos(x: f64) -> f64 {", "doc": "Cosine."},
        {"kind": "fn", "name": "tan", "signature": "fn tan(x: f64) -> f64 {", "doc": "Tangent."},
        {"kind": "fn", "name": "asin", "signature": "fn asin(x: f64) -> f64 {", "doc": "Arcsine."},
        {"kind": "fn", "name": "acos", "signature": "fn acos(x: f64) -> f64 {", "doc": "Arccosine."},
        {"kind": "fn", "name": "atan", "signature": "fn atan(x: f64) -> f64 {", "doc": "Arctangent."},
        {"kind": "fn", "name": "atan2", "signature": "fn atan2(y: f64, x: f64) -> f64 {", "doc": "Two-argument arctangent."},
        {"kind": "fn", "name": "sinh", "signature": "fn sinh(x: f64) -> f64 {", "doc": "Hyperbolic sine."},
        {"kind": "fn", "name": "cosh", "signature": "fn cosh(x: f64) -> f64 {", "doc": "Hyperbolic cosine."},
        {"kind": "fn", "name": "tanh", "signature": "fn tanh(x: f64) -> f64 {", "doc": "Hyperbolic tangent."},
        {"kind": "fn", "name": "floor", "signature": "fn floor(x: f64) -> f64 {", "doc": "Floor."},
        {"kind": "fn", "name": "ceil", "signature": "fn ceil(x: f64) -> f64 {", "doc": "Ceiling."},
        {"kind": "fn", "name": "round", "signature": "fn round(x: f64) -> f64 {", "doc": "Round to nearest integer."},
        {"kind": "fn", "name": "trunc", "signature": "fn trunc(x: f64) -> f64 {", "doc": "Truncate toward zero."},
        {"kind": "fn", "name": "math_sqrt", "signature": "fn math_sqrt(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_cbrt", "signature": "fn math_cbrt(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_pow", "signature": "fn math_pow(base: f64, exp: f64) -> f64;"},
        {"kind": "fn", "name": "math_exp", "signature": "fn math_exp(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_log", "signature": "fn math_log(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_log10", "signature": "fn math_log10(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_log2", "signature": "fn math_log2(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_sin", "signature": "fn math_sin(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_cos", "signature": "fn math_cos(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_tan", "signature": "fn math_tan(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_asin", "signature": "fn math_asin(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_acos", "signature": "fn math_acos(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_atan", "signature": "fn math_atan(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_atan2", "signature": "fn math_atan2(y: f64, x: f64) -> f64;"},
        {"kind": "fn", "name": "math_sinh", "signature": "fn math_sinh(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_cosh", "signature": "fn math_cosh(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_tanh", "signature": "fn math_tanh(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_floor", "signature": "fn math_floor(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_ceil", "signature": "fn math_ceil(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_round", "signature": "fn math_round(x: f64) -> f64;"},
        {"kind": "fn", "name": "math_trunc", "signature": "fn math_trunc(x: f64) -> f64;"}
      ]
    },
    {
      "name": "string",
      "file": "string.html",
      "items": [
        {"kind": "fn", "name": "repeat", "signature": "fn repeat(s: &str, count: usize) -> String {", "doc": "Repeat a string N times."},
        {"kind": "fn", "name": "pad_left", "signature": "fn pad_left(s: &str, width: usize, pad_char: char) -> String {", "doc": "Pad string on the left to reach target width."},
        {"kind": "fn", "name": "pad_right", "signature": "fn pad_right(s: &str, width: usize, pad_char: char) -> String {", "doc": "Pad string on the right to reach target width."},
        {"kind": "fn", "name": "center", "signature": "fn center(s: &str, width: usize, pad_char: char) -> String {", "doc": "Center a string in the given width."},
        {"kind": "fn", "name": "trim", "signature": "fn trim(s: &str) -> &str {", "doc": "Trim whitespace from both ends."},
        {"kind": "fn", "name": "trim_left", "signature": "fn trim_left(s: &str) -> &str {", "doc": "Trim whitespace from the left."},
        {"kind": "fn", "name": "trim_right", "signature": "fn trim_right(s: &str) -> &str {", "doc": "Trim whitespace from the right."},
        {"kind": "fn", "name": "is_digit", "signature": "fn is_digit(c: char) -> bool {", "doc": "Check if character is a digit (0-9)."},
        {"kind": "fn", "name": "is_alpha", "signature": "fn is_alpha(c: char) -> bool {", "doc": "Check if character is alphabetic (A-Z, a-z)."},
        {"kind": "fn", "name": "is_alphanumeric", "signature": "fn is_alphanumeric(c: char) -> bool {", "doc": "Check if character is alphanumeric."},
        {"kind": "fn", "name": "is_whitespace", "signature": "fn is_whitespace(c: char) -> bool {", "doc": "Check if character is whitespace."},
        {"kind": "fn", "name": "is_uppercase", "signature": "fn is_uppercase(c: char) -> bool {", "doc": "Check if character is uppercase."},
        {"kind": "fn", "name": "is_lowercase", "signature": "fn is_lowercase(c: char) -> bool {", "doc": "Check if character is lowercase."},
        {"kind": "fn", "name": "to_uppercase", "signature": "fn to_uppercase(c: char) -> char {", "doc": "Convert character to uppercase."},
        {"kind": "fn", "name": "to_lowercase", "signature": "fn to_lowercase(c: char) -> char {", "doc": "Convert character to lowercase."},
        {"kind": "fn", "name": "to_upper", "signature": "fn to_upper(s: &str) -> String {", "doc": "Convert string to uppercase."},
        {"kind": "fn", "name": "to_lower", "signature": "fn to_lower(s: &str) -> String {", "doc": "Convert string to lowercase."},
        {"kind": "fn", "name": "capitalize", "signature": "fn capitalize(s: &str) -> String {", "doc": "Capitalize first character."},
        {"kind": "fn", "name": "starts_with", "signature": "fn starts_with(s: &str, prefix: &str) -> bool {", "doc": "Check if string starts with prefix."},
        {"kind": "fn", "name": "ends_with", "signature": "fn ends_with(s: &str, suffix: &str) -> bool {", "doc": "Check if string ends with suffix."},
        {"kind": "fn", "name": "contains", "signature": "fn contains(s: &str, substr: &str) -> bool {", "doc": "Check if string contains substring."},
        {"kind": "fn", "name": "replace", "signature": "fn replace(s: &str, pattern: &str, replacement: &str) -> String {", "doc": "Replace all occurrences of pattern with replacement."},
        {"kind": "fn", "name": "replace_first", "signature": "fn replace_first(s: &str, pattern: &str, replacement: &str) -> String {", "doc": "Replace first occurrence of pattern."},
        {"kind": "fn", "name": "split", "signature": "fn split(s: &str, delimiter: &str) -> Vec<String> {", "doc": "Split string by delimiter."},
        {"kind": "fn", "name": "lines", "signature": "fn lines(s: &str) -> Vec<String> {", "doc": "Split string into lines."},
        {"kind": "fn", "name": "join", "signature": "fn join(parts: &[String], separator: &str) -> String {", "doc": "Join strings with separator."},
        {"kind": "fn", "name": "eq_ignore_case", "signature": "fn eq_ignore_case(a: &str, b: &str) -> bool {", "doc": "Compare strings, ignoring case."},
        {"kind": "fn", "name": "edit_distance", "signature": "fn edit_distance(a: &str, b: &str) -> usize {", "doc": "Levenshtein edit distance between strings."},
        {"kind": "fn", "name": "min", "signature": "fn min(a: usize, b: usize) -> usize {"}
      ]
    },
    {
      "name": "mod",
      "file": "mod.html",
      "items": [
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Self;"},
        {"kind": "fn", "name": "eq", "signature": "fn eq(&self, other: &Self) -> bool;"},
        {"kind": "fn", "name": "ne", "signature": "fn ne(&self, other: &Self) -> bool {"},
        {"kind": "fn", "name": "cmp", "signature": "fn cmp(&self, other: &Self) -> Ordering;"},
        {"kind": "fn", "name": "lt", "signature": "fn lt(&self, other: &Self) -> bool { self.cmp(other) == Ordering::Less }"},
        {"kind": "fn", "name": "le", "signature": "fn le(&self, other: &Self) -> bool { self.cmp(other) != Ordering::Greater }"},
        {"kind": "fn", "name": "gt", "signature": "fn gt(&self, other: &Self) -> bool { self.cmp(other) == Ordering::Greater }"},
        {"kind": "fn", "name": "ge", "signature": "fn ge(&self, other: &Self) -> bool { self.cmp(other) != Ordering::Less }"},
        {"kind": "fn", "name": "hash", "signature": "fn hash(&self) -> u64;"},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self) -> String;"},
        {"kind": "fn", "name": "debug_fmt", "signature": "fn debug_fmt(&self) -> String;"},
        {"kind": "fn", "name": "default", "signature": "fn default() -> Self;"}
      ]
    },
    {
      "name": "regex",
      "file": "regex.html",
      "items": [
        {"kind": "fn", "name": "new", "signature": "fn new(pattern: &str) -> Result<Regex, RegexError> {", "doc": "Compile a regular expression pattern.\n\nReturns an error if the pattern is invalid.\n\n# Example\n```sim..."},
        {"kind": "fn", "name": "with_flags", "signature": "fn with_flags(pattern: &str, flags: u32) -> Result<Regex, RegexError> {", "doc": "Compile a regex with specific flags.\n\n# Example\n```simplex\nlet re = Regex::with_flags(\"hello\", flags..."},
        {"kind": "fn", "name": "pattern", "signature": "fn pattern(&self) -> &str {", "doc": "Get the pattern string."},
        {"kind": "fn", "name": "is_match", "signature": "fn is_match(&self, text: &str) -> bool {", "doc": "Check if the pattern matches anywhere in the text.\n\n# Example\n```simplex\nlet re = Regex::new(r\"\\d+\")..."},
        {"kind": "fn", "name": "find", "signature": "fn find<'t>(&self, text: &'t str) -> Option<Match<'t>> {", "doc": "Find the first match in the text.\n\nReturns None if no match is found.\n\n# Example\n```simplex\nlet re =..."},
        {"kind": "fn", "name": "find_iter", "signature": "fn find_iter<'r, 't>(&'r self, text: &'t str) -> Matches<'r, 't> {", "doc": "Find all non-overlapping matches.\n\n# Example\n```simplex\nlet re = Regex::new(r\"\\d+\").unwrap();\nlet ma..."},
        {"kind": "fn", "name": "find_all", "signature": "fn find_all<'t>(&self, text: &'t str) -> Vec<Match<'t>> {", "doc": "Find all matches and return as a vector."},
        {"kind": "fn", "name": "count", "signature": "fn count(&self, text: &str) -> usize {", "doc": "Count the number of matches."},
        {"kind": "fn", "name": "replace", "signature": "fn replace(&self, text: &str, replacement: &str) -> String {", "doc": "Replace the first match with the replacement string.\n\n# Example\n```simplex\nlet re = Regex::new(r\"\\d+..."},
        {"kind": "fn", "name": "replace_all", "signature": "fn replace_all(&self, text: &str, replacement: &str) -> String {", "doc": "Replace all matches with the replacement string.\n\n# Example\n```simplex\nlet re = Regex::new(r\"\\d+\").u..."},
        {"kind": "fn", "name": "split", "signature": "fn split<'t>(&self, text: &'t str) -> Split<'t> {", "doc": "Split the text by the pattern.\n\n# Example\n```simplex\nlet re = Regex::new(r\"[,\\s]+\").unwrap();\nlet pa..."},
        {"kind": "fn", "name": "captures", "signature": "fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {", "doc": "Get capture groups from the first match.\n\nReturns None if no match is found.\nThe first element is th..."},
        {"kind": "fn", "name": "captures_len", "signature": "fn captures_len(&self) -> usize {", "doc": "Get the number of capture groups in the pattern."},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "clone", "signature": "fn clone(&self) -> Regex {"},
        {"kind": "fn", "name": "start", "signature": "fn start(&self) -> usize {", "doc": "Get the starting byte offset of the match."},
        {"kind": "fn", "name": "end", "signature": "fn end(&self) -> usize {", "doc": "Get the ending byte offset of the match."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the length of the match in bytes."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if the match is empty."},
        {"kind": "fn", "name": "as_str", "signature": "fn as_str(&self) -> &'t str {", "doc": "Get the matched text."},
        {"kind": "fn", "name": "range", "signature": "fn range(&self) -> std::ops::Range<usize> {", "doc": "Get the byte range of the match."},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<Match<'t>> {"},
        {"kind": "fn", "name": "next", "signature": "fn next(&mut self) -> Option<String> {"},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "get", "signature": "fn get(&self, index: usize) -> Option<&'t str> {", "doc": "Get a capture group by index.\n\nIndex 0 is the full match, 1 is the first group, etc."},
        {"kind": "fn", "name": "len", "signature": "fn len(&self) -> usize {", "doc": "Get the number of capture groups (including the full match)."},
        {"kind": "fn", "name": "is_empty", "signature": "fn is_empty(&self) -> bool {", "doc": "Check if there are no captures."},
        {"kind": "fn", "name": "drop", "signature": "fn drop(&mut self) {"},
        {"kind": "fn", "name": "message", "signature": "fn message(&self) -> &str {", "doc": "Get the error message."},
        {"kind": "fn", "name": "fmt", "signature": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"},
        {"kind": "fn", "name": "is_match", "signature": "fn is_match(pattern: &str, text: &str) -> bool {", "doc": "Check if a pattern matches the text.\n\nThis is a convenience function that compiles the pattern, matc..."},
        {"kind": "fn", "name": "replace_all", "signature": "fn replace_all(pattern: &str, text: &str, replacement: &str) -> String {", "doc": "Replace all matches with a replacement string.\n\nConvenience function that compiles, replaces, and fr..."},
        {"kind": "fn", "name": "is_valid", "signature": "fn is_valid(pattern: &str) -> bool {", "doc": "Check if a pattern is valid.\n\n# Example\n```simplex\nassert!(is_valid(r\"\\d+\"));\nassert!(!is_valid(r\"[i..."},
        {"kind": "fn", "name": "escape", "signature": "fn escape(text: &str) -> String {", "doc": "Escape special regex characters in a string.\n\nReturns a string that will match the literal input.\n\n#..."},
        {"kind": "fn", "name": "ffi_regex_new", "signature": "fn ffi_regex_new(pattern: &str, flags: i64) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_free", "signature": "fn ffi_regex_free(handle: i64);"},
        {"kind": "fn", "name": "ffi_regex_is_match", "signature": "fn ffi_regex_is_match(handle: i64, text: &str) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_find", "signature": "fn ffi_regex_find(handle: i64, text: &str) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_count", "signature": "fn ffi_regex_count(handle: i64, text: &str) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_replace", "signature": "fn ffi_regex_replace(handle: i64, text: &str, replacement: &str) -> String;"},
        {"kind": "fn", "name": "ffi_regex_replace_first", "signature": "fn ffi_regex_replace_first(handle: i64, text: &str, replacement: &str) -> String;"},
        {"kind": "fn", "name": "ffi_regex_split", "signature": "fn ffi_regex_split(handle: i64, text: &str) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_captures", "signature": "fn ffi_regex_captures(handle: i64, text: &str) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_group_count", "signature": "fn ffi_regex_group_count(handle: i64) -> i64;"},
        {"kind": "fn", "name": "ffi_regex_error", "signature": "fn ffi_regex_error(pattern: &str) -> String;"},
        {"kind": "fn", "name": "ffi_split_get", "signature": "fn ffi_split_get(handle: i64, index: i64) -> String;"},
        {"kind": "fn", "name": "ffi_split_free", "signature": "fn ffi_split_free(handle: i64);"},
        {"kind": "fn", "name": "ffi_captures_get", "signature": "fn ffi_captures_get(handle: i64, index: i64) -> String;"},
        {"kind": "fn", "name": "ffi_captures_len", "signature": "fn ffi_captures_len(handle: i64) -> i64;"},
        {"kind": "fn", "name": "ffi_captures_free", "signature": "fn ffi_captures_free(handle: i64);"}
      ]
    }
  ]
}
