<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>regex - Simplex API Reference</title>
  <meta name="description" content="Compile a regular expression pattern.

Returns an error if the pattern is invalid.

# Example
```simplex
let re = Regex::new(r"\d{3}-\d{4}").unwrap();
```">
  <link rel="stylesheet" href="../assets/docs.css">
  <script src="../assets/nav.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "regex - Simplex API Reference",
  "description": "Compile a regular expression pattern.\n\nReturns an error if the pattern is invalid.\n\n# Example\n```simplex\nlet re = Regex::new(r\"\\d{3}-\\d{4}\").unwrap();\n```",
  "programmingLanguage": {
    "@type": "ComputerLanguage",
    "name": "Simplex",
    "url": "https://github.com/senuamedia/simplex"
  },
  "isPartOf": {
    "@type": "WebSite",
    "name": "Simplex Documentation",
    "url": "https://simplex.senuamedia.com/api/"
  },
  "articleSection": "std"
}
</script>
</head>
<body>
<div class="doc-wrapper">
  <nav class="sidebar" id="sidebar">
    <div class="sidebar-header"><a href="../index.html">Simplex API</a></div>
    <div class="search-box">
      <input type="text" id="search" placeholder="Search...">
    </div>
    <div id="nav-content">Loading...</div>
  </nav>
  <main class="content">
    <nav class="breadcrumb">
      <a href="../index.html">API Reference</a> &raquo;       <span class="current-category">std</span> &raquo; regex
    </nav>
    <h1>Module: regex</h1>
<div class="toc">
<strong>Contents</strong>
<ul>
<li><a href="#new">fn new</a></li>
<li><a href="#with_flags">fn with_flags</a></li>
<li><a href="#pattern">fn pattern</a></li>
<li><a href="#is_match">fn is_match</a></li>
<li><a href="#find">fn find</a></li>
<li><a href="#find_iter">fn find_iter</a></li>
<li><a href="#find_all">fn find_all</a></li>
<li><a href="#count">fn count</a></li>
<li><a href="#replace">fn replace</a></li>
<li><a href="#replace_all">fn replace_all</a></li>
<li><a href="#split">fn split</a></li>
<li><a href="#captures">fn captures</a></li>
<li><a href="#captures_len">fn captures_len</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#clone">fn clone</a></li>
<li><a href="#start">fn start</a></li>
<li><a href="#end">fn end</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#as_str">fn as_str</a></li>
<li><a href="#range">fn range</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#next">fn next</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#get">fn get</a></li>
<li><a href="#len">fn len</a></li>
<li><a href="#is_empty">fn is_empty</a></li>
<li><a href="#drop">fn drop</a></li>
<li><a href="#message">fn message</a></li>
<li><a href="#fmt">fn fmt</a></li>
<li><a href="#is_match">fn is_match</a></li>
<li><a href="#replace_all">fn replace_all</a></li>
<li><a href="#is_valid">fn is_valid</a></li>
<li><a href="#escape">fn escape</a></li>
<li><a href="#ffi_regex_new">fn ffi_regex_new</a></li>
<li><a href="#ffi_regex_free">fn ffi_regex_free</a></li>
<li><a href="#ffi_regex_is_match">fn ffi_regex_is_match</a></li>
<li><a href="#ffi_regex_find">fn ffi_regex_find</a></li>
<li><a href="#ffi_regex_count">fn ffi_regex_count</a></li>
<li><a href="#ffi_regex_replace">fn ffi_regex_replace</a></li>
<li><a href="#ffi_regex_replace_first">fn ffi_regex_replace_first</a></li>
<li><a href="#ffi_regex_split">fn ffi_regex_split</a></li>
<li><a href="#ffi_regex_captures">fn ffi_regex_captures</a></li>
<li><a href="#ffi_regex_group_count">fn ffi_regex_group_count</a></li>
<li><a href="#ffi_regex_error">fn ffi_regex_error</a></li>
<li><a href="#ffi_split_get">fn ffi_split_get</a></li>
<li><a href="#ffi_split_free">fn ffi_split_free</a></li>
<li><a href="#ffi_captures_get">fn ffi_captures_get</a></li>
<li><a href="#ffi_captures_len">fn ffi_captures_len</a></li>
<li><a href="#ffi_captures_free">fn ffi_captures_free</a></li>
</ul>
</div>
<h2 id="new">fn new</h2>
<pre class="signature">fn new(pattern: &amp;str) -&gt; Result&lt;Regex, RegexError&gt; {</pre>
<p class="doc">Compile a regular expression pattern.

Returns an error if the pattern is invalid.

# Example
```simplex
let re = Regex::new(r"\d{3}-\d{4}").unwrap();
```</p>
<h2 id="with_flags">fn with_flags</h2>
<pre class="signature">fn with_flags(pattern: &amp;str, flags: u32) -&gt; Result&lt;Regex, RegexError&gt; {</pre>
<p class="doc">Compile a regex with specific flags.

# Example
```simplex
let re = Regex::with_flags("hello", flags::ICASE).unwrap();
assert!(re.is_match("HELLO"));
```</p>
<h2 id="pattern">fn pattern</h2>
<pre class="signature">fn pattern(&amp;self) -&gt; &amp;str {</pre>
<p class="doc">Get the pattern string.</p>
<h2 id="is_match">fn is_match</h2>
<pre class="signature">fn is_match(&amp;self, text: &amp;str) -&gt; bool {</pre>
<p class="doc">Check if the pattern matches anywhere in the text.

# Example
```simplex
let re = Regex::new(r"\d+").unwrap();
assert!(re.is_match("hello123"));
assert!(!re.is_match("hello"));
```</p>
<h2 id="find">fn find</h2>
<pre class="signature">fn find&lt;'t&gt;(&amp;self, text: &amp;'t str) -&gt; Option&lt;Match&lt;'t&gt;&gt; {</pre>
<p class="doc">Find the first match in the text.

Returns None if no match is found.

# Example
```simplex
let re = Regex::new(r"\d+").unwrap();
if let Some(m) = re.find("abc123def") {
    assert_eq!(m.start(), 3);
    assert_eq!(m.end(), 6);
    assert_eq!(m.as_str(), "123");
}
```</p>
<h2 id="find_iter">fn find_iter</h2>
<pre class="signature">fn find_iter&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t str) -&gt; Matches&lt;'r, 't&gt; {</pre>
<p class="doc">Find all non-overlapping matches.

# Example
```simplex
let re = Regex::new(r"\d+").unwrap();
let matches: Vec&lt;_&gt; = re.find_all("a1b22c333").collect();
assert_eq!(matches.len(), 3);
```</p>
<h2 id="find_all">fn find_all</h2>
<pre class="signature">fn find_all&lt;'t&gt;(&amp;self, text: &amp;'t str) -&gt; Vec&lt;Match&lt;'t&gt;&gt; {</pre>
<p class="doc">Find all matches and return as a vector.</p>
<h2 id="count">fn count</h2>
<pre class="signature">fn count(&amp;self, text: &amp;str) -&gt; usize {</pre>
<p class="doc">Count the number of matches.</p>
<h2 id="replace">fn replace</h2>
<pre class="signature">fn replace(&amp;self, text: &amp;str, replacement: &amp;str) -&gt; String {</pre>
<p class="doc">Replace the first match with the replacement string.

# Example
```simplex
let re = Regex::new(r"\d+").unwrap();
assert_eq!(re.replace("a1b2", "X"), "aXb2");
```</p>
<h2 id="replace_all">fn replace_all</h2>
<pre class="signature">fn replace_all(&amp;self, text: &amp;str, replacement: &amp;str) -&gt; String {</pre>
<p class="doc">Replace all matches with the replacement string.

# Example
```simplex
let re = Regex::new(r"\d+").unwrap();
assert_eq!(re.replace_all("a1b2c3", "X"), "aXbXcX");
```</p>
<h2 id="split">fn split</h2>
<pre class="signature">fn split&lt;'t&gt;(&amp;self, text: &amp;'t str) -&gt; Split&lt;'t&gt; {</pre>
<p class="doc">Split the text by the pattern.

# Example
```simplex
let re = Regex::new(r"[,\s]+").unwrap();
let parts: Vec&lt;_&gt; = re.split("a, b,  c").collect();
assert_eq!(parts, vec!["a", "b", "c"]);
```</p>
<h2 id="captures">fn captures</h2>
<pre class="signature">fn captures&lt;'t&gt;(&amp;self, text: &amp;'t str) -&gt; Option&lt;Captures&lt;'t&gt;&gt; {</pre>
<p class="doc">Get capture groups from the first match.

Returns None if no match is found.
The first element is the full match, followed by each capture group.

# Example
```simplex
let re = Regex::new(r"(\d+)-(\d+)").unwrap();
if let Some(caps) = re.captures("phone: 123-4567") {
    assert_eq!(caps.get(0), Some("123-4567"));
    assert_eq!(caps.get(1), Some("123"));
    assert_eq!(caps.get(2), Some("4567"));
}
```</p>
<h2 id="captures_len">fn captures_len</h2>
<pre class="signature">fn captures_len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the number of capture groups in the pattern.</p>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="clone">fn clone</h2>
<pre class="signature">fn clone(&amp;self) -&gt; Regex {</pre>
<h2 id="start">fn start</h2>
<pre class="signature">fn start(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the starting byte offset of the match.</p>
<h2 id="end">fn end</h2>
<pre class="signature">fn end(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the ending byte offset of the match.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the length of the match in bytes.</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if the match is empty.</p>
<h2 id="as_str">fn as_str</h2>
<pre class="signature">fn as_str(&amp;self) -&gt; &amp;'t str {</pre>
<p class="doc">Get the matched text.</p>
<h2 id="range">fn range</h2>
<pre class="signature">fn range(&amp;self) -&gt; std::ops::Range&lt;usize&gt; {</pre>
<p class="doc">Get the byte range of the match.</p>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;Match&lt;'t&gt;&gt; {</pre>
<h2 id="next">fn next</h2>
<pre class="signature">fn next(&amp;mut self) -&gt; Option&lt;String&gt; {</pre>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="get">fn get</h2>
<pre class="signature">fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;'t str&gt; {</pre>
<p class="doc">Get a capture group by index.

Index 0 is the full match, 1 is the first group, etc.</p>
<h2 id="len">fn len</h2>
<pre class="signature">fn len(&amp;self) -&gt; usize {</pre>
<p class="doc">Get the number of capture groups (including the full match).</p>
<h2 id="is_empty">fn is_empty</h2>
<pre class="signature">fn is_empty(&amp;self) -&gt; bool {</pre>
<p class="doc">Check if there are no captures.</p>
<h2 id="drop">fn drop</h2>
<pre class="signature">fn drop(&amp;mut self) {</pre>
<h2 id="message">fn message</h2>
<pre class="signature">fn message(&amp;self) -&gt; &amp;str {</pre>
<p class="doc">Get the error message.</p>
<h2 id="fmt">fn fmt</h2>
<pre class="signature">fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {</pre>
<h2 id="is_match">fn is_match</h2>
<pre class="signature">fn is_match(pattern: &amp;str, text: &amp;str) -&gt; bool {</pre>
<p class="doc">Check if a pattern matches the text.

This is a convenience function that compiles the pattern, matches, and frees.
For repeated matching, use `Regex::new()` instead.

# Example
```simplex
if is_match(r"\d+", "hello123") {
    println("Found digits!");
}
```</p>
<h2 id="replace_all">fn replace_all</h2>
<pre class="signature">fn replace_all(pattern: &amp;str, text: &amp;str, replacement: &amp;str) -&gt; String {</pre>
<p class="doc">Replace all matches with a replacement string.

Convenience function that compiles, replaces, and frees.

# Example
```simplex
let result = replace_all(r"\s+", "hello   world", " ");
assert_eq!(result, "hello world");
```</p>
<h2 id="is_valid">fn is_valid</h2>
<pre class="signature">fn is_valid(pattern: &amp;str) -&gt; bool {</pre>
<p class="doc">Check if a pattern is valid.

# Example
```simplex
assert!(is_valid(r"\d+"));
assert!(!is_valid(r"[invalid"));
```</p>
<h2 id="escape">fn escape</h2>
<pre class="signature">fn escape(text: &amp;str) -&gt; String {</pre>
<p class="doc">Escape special regex characters in a string.

Returns a string that will match the literal input.

# Example
```simplex
let escaped = escape("hello.world");
assert_eq!(escaped, r"hello\.world");
```</p>
<h2 id="ffi_regex_new">fn ffi_regex_new</h2>
<pre class="signature">fn ffi_regex_new(pattern: &amp;str, flags: i64) -&gt; i64;</pre>
<h2 id="ffi_regex_free">fn ffi_regex_free</h2>
<pre class="signature">fn ffi_regex_free(handle: i64);</pre>
<h2 id="ffi_regex_is_match">fn ffi_regex_is_match</h2>
<pre class="signature">fn ffi_regex_is_match(handle: i64, text: &amp;str) -&gt; i64;</pre>
<h2 id="ffi_regex_find">fn ffi_regex_find</h2>
<pre class="signature">fn ffi_regex_find(handle: i64, text: &amp;str) -&gt; i64;</pre>
<h2 id="ffi_regex_count">fn ffi_regex_count</h2>
<pre class="signature">fn ffi_regex_count(handle: i64, text: &amp;str) -&gt; i64;</pre>
<h2 id="ffi_regex_replace">fn ffi_regex_replace</h2>
<pre class="signature">fn ffi_regex_replace(handle: i64, text: &amp;str, replacement: &amp;str) -&gt; String;</pre>
<h2 id="ffi_regex_replace_first">fn ffi_regex_replace_first</h2>
<pre class="signature">fn ffi_regex_replace_first(handle: i64, text: &amp;str, replacement: &amp;str) -&gt; String;</pre>
<h2 id="ffi_regex_split">fn ffi_regex_split</h2>
<pre class="signature">fn ffi_regex_split(handle: i64, text: &amp;str) -&gt; i64;</pre>
<h2 id="ffi_regex_captures">fn ffi_regex_captures</h2>
<pre class="signature">fn ffi_regex_captures(handle: i64, text: &amp;str) -&gt; i64;</pre>
<h2 id="ffi_regex_group_count">fn ffi_regex_group_count</h2>
<pre class="signature">fn ffi_regex_group_count(handle: i64) -&gt; i64;</pre>
<h2 id="ffi_regex_error">fn ffi_regex_error</h2>
<pre class="signature">fn ffi_regex_error(pattern: &amp;str) -&gt; String;</pre>
<h2 id="ffi_split_get">fn ffi_split_get</h2>
<pre class="signature">fn ffi_split_get(handle: i64, index: i64) -&gt; String;</pre>
<h2 id="ffi_split_free">fn ffi_split_free</h2>
<pre class="signature">fn ffi_split_free(handle: i64);</pre>
<h2 id="ffi_captures_get">fn ffi_captures_get</h2>
<pre class="signature">fn ffi_captures_get(handle: i64, index: i64) -&gt; String;</pre>
<h2 id="ffi_captures_len">fn ffi_captures_len</h2>
<pre class="signature">fn ffi_captures_len(handle: i64) -&gt; i64;</pre>
<h2 id="ffi_captures_free">fn ffi_captures_free</h2>
<pre class="signature">fn ffi_captures_free(handle: i64);</pre>

    <hr>
    <p><em>Generated by sxdoc</em></p>
  </main>
</div>
</body>
</html>
