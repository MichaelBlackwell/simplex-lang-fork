// Package Manifest Module for Simplex
// Implements simplex.json parsing and validation
// Part of Phase 2: Package Ecosystem
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex

// ============================================================================
// Package Manifest Structure
// ============================================================================
// A simplex.json file contains:
// {
//   "name": "package-name",
//   "version": "0.1.0",
//   "authors": ["Name <email>"],
//   "description": "Short description",
//   "license": "MIT",
//   "repository": "https://github.com/user/repo",
//   "keywords": ["keyword1", "keyword2"],
//   "dependencies": {
//     "dep-name": "1.0.0",
//     "dep-name2": { "version": "0.2.0", "features": ["tls"] },
//     "local-dep": { "path": "../local" },
//     "git-dep": { "git": "https://github.com/user/lib" }
//   },
//   "dev_dependencies": {
//     "simplex-test": "0.1.0"
//   },
//   "build": {
//     "entry": "src/lib.sx"
//   },
//   "features": {
//     "default": ["std"],
//     "std": [],
//     "async": ["simplex-async"]
//   }
// }

// ============================================================================
// Manifest Data Structure
// ============================================================================
// Layout: name(0), version(1), authors(2), description(3), license(4),
//         repository(5), keywords(6), dependencies(7), dev_deps(8),
//         entry(9), features(10)

fn manifest_new() -> i64 {
    let m: i64 = malloc(88);  // 11 fields * 8 bytes
    store_ptr(m, 0, "");       // name
    store_ptr(m, 1, "0.0.0");  // version
    store_ptr(m, 2, vec_new()); // authors
    store_ptr(m, 3, "");       // description
    store_ptr(m, 4, "");       // license
    store_ptr(m, 5, "");       // repository
    store_ptr(m, 6, vec_new()); // keywords
    store_ptr(m, 7, vec_new()); // dependencies (list of Dependency)
    store_ptr(m, 8, vec_new()); // dev_dependencies
    store_ptr(m, 9, "src/main.sx"); // entry
    store_ptr(m, 10, hashmap_new()); // features
    m
}

fn manifest_name(m: i64) -> i64 { load_ptr(m, 0) }
fn manifest_set_name(m: i64, name: i64) { store_ptr(m, 0, name); }

fn manifest_version(m: i64) -> i64 { load_ptr(m, 1) }
fn manifest_set_version(m: i64, ver: i64) { store_ptr(m, 1, ver); }

fn manifest_authors(m: i64) -> i64 { load_ptr(m, 2) }
fn manifest_description(m: i64) -> i64 { load_ptr(m, 3) }
fn manifest_set_description(m: i64, desc: i64) { store_ptr(m, 3, desc); }

fn manifest_license(m: i64) -> i64 { load_ptr(m, 4) }
fn manifest_set_license(m: i64, lic: i64) { store_ptr(m, 4, lic); }

fn manifest_repository(m: i64) -> i64 { load_ptr(m, 5) }
fn manifest_set_repository(m: i64, repo: i64) { store_ptr(m, 5, repo); }

fn manifest_keywords(m: i64) -> i64 { load_ptr(m, 6) }
fn manifest_dependencies(m: i64) -> i64 { load_ptr(m, 7) }
fn manifest_dev_dependencies(m: i64) -> i64 { load_ptr(m, 8) }

fn manifest_entry(m: i64) -> i64 { load_ptr(m, 9) }
fn manifest_set_entry(m: i64, entry: i64) { store_ptr(m, 9, entry); }

fn manifest_features(m: i64) -> i64 { load_ptr(m, 10) }

// ============================================================================
// Dependency Structure
// ============================================================================
// Layout: name(0), version(1), path(2), git(3), features(4)

fn dependency_new(name: i64) -> i64 {
    let d: i64 = malloc(40);
    store_ptr(d, 0, name);
    store_ptr(d, 1, "");     // version
    store_ptr(d, 2, "");     // path
    store_ptr(d, 3, "");     // git
    store_ptr(d, 4, vec_new()); // features
    d
}

fn dep_name(d: i64) -> i64 { load_ptr(d, 0) }
fn dep_version(d: i64) -> i64 { load_ptr(d, 1) }
fn dep_set_version(d: i64, ver: i64) { store_ptr(d, 1, ver); }
fn dep_path(d: i64) -> i64 { load_ptr(d, 2) }
fn dep_set_path(d: i64, path: i64) { store_ptr(d, 2, path); }
fn dep_git(d: i64) -> i64 { load_ptr(d, 3) }
fn dep_set_git(d: i64, git: i64) { store_ptr(d, 3, git); }
fn dep_features(d: i64) -> i64 { load_ptr(d, 4) }

fn dep_is_registry(d: i64) -> bool {
    string_len(dep_version(d)) > 0
}

fn dep_is_path(d: i64) -> bool {
    string_len(dep_path(d)) > 0
}

fn dep_is_git(d: i64) -> bool {
    string_len(dep_git(d)) > 0
}

// ============================================================================
// Semver Parsing
// ============================================================================
// Version format: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
// Layout: major(0), minor(1), patch(2), prerelease(3), build(4)

fn semver_new(major: i64, minor: i64, patch: i64) -> i64 {
    let v: i64 = malloc(40);
    store_i64(v, 0, major);
    store_i64(v, 1, minor);
    store_i64(v, 2, patch);
    store_ptr(v, 3, "");  // prerelease
    store_ptr(v, 4, "");  // build
    v
}

fn semver_major(v: i64) -> i64 { load_i64(v, 0) }
fn semver_minor(v: i64) -> i64 { load_i64(v, 1) }
fn semver_patch(v: i64) -> i64 { load_i64(v, 2) }
fn semver_prerelease(v: i64) -> i64 { load_ptr(v, 3) }
fn semver_build(v: i64) -> i64 { load_ptr(v, 4) }

fn semver_parse(s: i64) -> i64 {
    // Parse "1.2.3" format
    let parts: i64 = string_split(s, ".");
    if vec_len(parts) < 3 {
        return 0;  // Invalid
    }

    let major_str: i64 = vec_get(parts, 0);
    let minor_str: i64 = vec_get(parts, 1);
    let patch_part: i64 = vec_get(parts, 2);

    // Handle prerelease/build in patch part
    var patch_str: i64 = patch_part;
    var prerelease: i64 = "";
    var build: i64 = "";

    // Check for prerelease (-alpha, -beta, etc)
    let dash_pos: i64 = string_find(patch_part, "-");
    if dash_pos >= 0 {
        patch_str = string_slice(patch_part, 0, dash_pos);
        let rest: i64 = string_slice(patch_part, dash_pos + 1, string_len(patch_part));

        // Check for build metadata in rest
        let plus_pos: i64 = string_find(rest, "+");
        if plus_pos >= 0 {
            prerelease = string_slice(rest, 0, plus_pos);
            build = string_slice(rest, plus_pos + 1, string_len(rest));
        } else {
            prerelease = rest;
        }
    } else {
        // Check for build metadata directly
        let plus_pos: i64 = string_find(patch_part, "+");
        if plus_pos >= 0 {
            patch_str = string_slice(patch_part, 0, plus_pos);
            build = string_slice(patch_part, plus_pos + 1, string_len(patch_part));
        }
    }

    let major: i64 = string_to_int(major_str);
    let minor: i64 = string_to_int(minor_str);
    let patch: i64 = string_to_int(patch_str);

    let v: i64 = semver_new(major, minor, patch);
    store_ptr(v, 3, prerelease);
    store_ptr(v, 4, build);
    v
}

fn semver_to_string(v: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, int_to_string(semver_major(v)));
    sb_append_char(sb, 46);  // '.'
    sb_append(sb, int_to_string(semver_minor(v)));
    sb_append_char(sb, 46);  // '.'
    sb_append(sb, int_to_string(semver_patch(v)));

    if string_len(semver_prerelease(v)) > 0 {
        sb_append_char(sb, 45);  // '-'
        sb_append(sb, semver_prerelease(v));
    }
    if string_len(semver_build(v)) > 0 {
        sb_append_char(sb, 43);  // '+'
        sb_append(sb, semver_build(v));
    }

    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

// Compare two semvers: -1 (a < b), 0 (a == b), 1 (a > b)
fn semver_compare(a: i64, b: i64) -> i64 {
    if semver_major(a) < semver_major(b) { return 0 - 1; }
    if semver_major(a) > semver_major(b) { return 1; }

    if semver_minor(a) < semver_minor(b) { return 0 - 1; }
    if semver_minor(a) > semver_minor(b) { return 1; }

    if semver_patch(a) < semver_patch(b) { return 0 - 1; }
    if semver_patch(a) > semver_patch(b) { return 1; }

    // Prerelease versions have lower precedence than release
    let pre_a: i64 = semver_prerelease(a);
    let pre_b: i64 = semver_prerelease(b);

    if string_len(pre_a) == 0 && string_len(pre_b) > 0 { return 1; }
    if string_len(pre_a) > 0 && string_len(pre_b) == 0 { return 0 - 1; }

    // Both have prerelease - compare lexically
    string_compare(pre_a, pre_b)
}

fn semver_eq(a: i64, b: i64) -> bool { semver_compare(a, b) == 0 }
fn semver_lt(a: i64, b: i64) -> bool { semver_compare(a, b) < 0 }
fn semver_le(a: i64, b: i64) -> bool { semver_compare(a, b) <= 0 }
fn semver_gt(a: i64, b: i64) -> bool { semver_compare(a, b) > 0 }
fn semver_ge(a: i64, b: i64) -> bool { semver_compare(a, b) >= 0 }

// ============================================================================
// Version Range Parsing
// ============================================================================
// Supports: "1.0.0", "^1.0", "~1.0", ">=1.0,<2.0", "*"
// Layout: min_ver(0), max_ver(1), min_inclusive(2), max_inclusive(3)

fn version_range_new() -> i64 {
    let r: i64 = malloc(32);
    store_ptr(r, 0, 0);   // min_ver (null = no min)
    store_ptr(r, 1, 0);   // max_ver (null = no max)
    store_i64(r, 2, 1);   // min_inclusive (default true)
    store_i64(r, 3, 0);   // max_inclusive (default false)
    r
}

fn range_min(r: i64) -> i64 { load_ptr(r, 0) }
fn range_max(r: i64) -> i64 { load_ptr(r, 1) }
fn range_min_inclusive(r: i64) -> bool { load_i64(r, 2) != 0 }
fn range_max_inclusive(r: i64) -> bool { load_i64(r, 3) != 0 }

fn version_range_parse(spec: i64) -> i64 {
    let trimmed: i64 = string_trim(spec);

    // Handle "*" - any version
    if string_eq(trimmed, "*") {
        return version_range_new();
    }

    // Handle caret (^) - compatible with version
    if string_char_at(trimmed, 0) == 94 {  // '^'
        let ver_str: i64 = string_slice(trimmed, 1, string_len(trimmed));
        let ver: i64 = semver_parse(ver_str);
        if ver == 0 { return 0; }

        let r: i64 = version_range_new();
        store_ptr(r, 0, ver);

        // ^1.2.3 means >=1.2.3, <2.0.0 (for major > 0)
        // ^0.2.3 means >=0.2.3, <0.3.0 (for major == 0, minor > 0)
        // ^0.0.3 means >=0.0.3, <0.0.4 (for major == 0, minor == 0)
        var max_major: i64 = semver_major(ver);
        var max_minor: i64 = semver_minor(ver);
        var max_patch: i64 = 0;

        if max_major > 0 {
            max_major = max_major + 1;
            max_minor = 0;
        } else if max_minor > 0 {
            max_minor = max_minor + 1;
        } else {
            max_patch = semver_patch(ver) + 1;
        }

        store_ptr(r, 1, semver_new(max_major, max_minor, max_patch));
        return r;
    }

    // Handle tilde (~) - approximately equivalent
    if string_char_at(trimmed, 0) == 126 {  // '~'
        let ver_str: i64 = string_slice(trimmed, 1, string_len(trimmed));
        let ver: i64 = semver_parse(ver_str);
        if ver == 0 { return 0; }

        let r: i64 = version_range_new();
        store_ptr(r, 0, ver);

        // ~1.2.3 means >=1.2.3, <1.3.0
        store_ptr(r, 1, semver_new(semver_major(ver), semver_minor(ver) + 1, 0));
        return r;
    }

    // Handle comparison operators
    if string_starts_with(trimmed, ">=") {
        let ver_str: i64 = string_trim(string_slice(trimmed, 2, string_len(trimmed)));
        // Check for comma (range)
        let comma_pos: i64 = string_find(ver_str, ",");
        if comma_pos >= 0 {
            let min_str: i64 = string_trim(string_slice(ver_str, 0, comma_pos));
            let max_part: i64 = string_trim(string_slice(ver_str, comma_pos + 1, string_len(ver_str)));

            let r: i64 = version_range_new();
            store_ptr(r, 0, semver_parse(min_str));

            if string_starts_with(max_part, "<") {
                let max_str: i64 = string_trim(string_slice(max_part, 1, string_len(max_part)));
                store_ptr(r, 1, semver_parse(max_str));
            }
            return r;
        } else {
            let r: i64 = version_range_new();
            store_ptr(r, 0, semver_parse(ver_str));
            return r;
        }
    }

    // Plain version - exact match
    let ver: i64 = semver_parse(trimmed);
    if ver != 0 {
        let r: i64 = version_range_new();
        store_ptr(r, 0, ver);
        store_ptr(r, 1, ver);
        store_i64(r, 3, 1);  // max_inclusive = true for exact match
        return r;
    }

    0  // Invalid
}

fn version_matches(ver: i64, range: i64) -> bool {
    if range == 0 || ver == 0 { return false; }

    let min: i64 = range_min(range);
    let max: i64 = range_max(range);

    // Check minimum
    if min != 0 {
        if range_min_inclusive(range) {
            if semver_lt(ver, min) { return false; }
        } else {
            if semver_le(ver, min) { return false; }
        }
    }

    // Check maximum
    if max != 0 {
        if range_max_inclusive(range) {
            if semver_gt(ver, max) { return false; }
        } else {
            if semver_ge(ver, max) { return false; }
        }
    }

    true
}

// ============================================================================
// Manifest JSON Parsing
// ============================================================================

fn manifest_parse(json_str: i64) -> i64 {
    let json: i64 = json_parse(json_str);
    if json == 0 {
        return 0;
    }

    let m: i64 = manifest_new();

    // Required: name
    let name_opt: i64 = json_get(json, "name");
    if option_is_some(name_opt) {
        let name_val: i64 = option_unwrap(name_opt);
        if json_is_string(name_val) {
            manifest_set_name(m, json_as_string(name_val));
        }
    }

    // Required: version
    let ver_opt: i64 = json_get(json, "version");
    if option_is_some(ver_opt) {
        let ver_val: i64 = option_unwrap(ver_opt);
        if json_is_string(ver_val) {
            manifest_set_version(m, json_as_string(ver_val));
        }
    }

    // Optional: authors
    let authors_opt: i64 = json_get(json, "authors");
    if option_is_some(authors_opt) {
        let authors_val: i64 = option_unwrap(authors_opt);
        if json_is_array(authors_val) {
            let arr: i64 = json_as_array(authors_val);
            let n: i64 = vec_len(arr);
            var i: i64 = 0;
            while i < n {
                let item: i64 = vec_get(arr, i);
                if json_is_string(item) {
                    vec_push(manifest_authors(m), json_as_string(item));
                }
                i = i + 1;
            }
        }
    }

    // Optional: description
    let desc_opt: i64 = json_get(json, "description");
    if option_is_some(desc_opt) {
        let desc_val: i64 = option_unwrap(desc_opt);
        if json_is_string(desc_val) {
            manifest_set_description(m, json_as_string(desc_val));
        }
    }

    // Optional: license
    let lic_opt: i64 = json_get(json, "license");
    if option_is_some(lic_opt) {
        let lic_val: i64 = option_unwrap(lic_opt);
        if json_is_string(lic_val) {
            manifest_set_license(m, json_as_string(lic_val));
        }
    }

    // Optional: repository
    let repo_opt: i64 = json_get(json, "repository");
    if option_is_some(repo_opt) {
        let repo_val: i64 = option_unwrap(repo_opt);
        if json_is_string(repo_val) {
            manifest_set_repository(m, json_as_string(repo_val));
        }
    }

    // Optional: keywords
    let kw_opt: i64 = json_get(json, "keywords");
    if option_is_some(kw_opt) {
        let kw_val: i64 = option_unwrap(kw_opt);
        if json_is_array(kw_val) {
            let arr: i64 = json_as_array(kw_val);
            let n: i64 = vec_len(arr);
            var i: i64 = 0;
            while i < n {
                let item: i64 = vec_get(arr, i);
                if json_is_string(item) {
                    vec_push(manifest_keywords(m), json_as_string(item));
                }
                i = i + 1;
            }
        }
    }

    // Optional: dependencies
    let deps_opt: i64 = json_get(json, "dependencies");
    if option_is_some(deps_opt) {
        let deps_val: i64 = option_unwrap(deps_opt);
        if json_is_object(deps_val) {
            parse_dependencies(m, deps_val, false);
        }
    }

    // Optional: dev_dependencies
    let dev_deps_opt: i64 = json_get(json, "dev_dependencies");
    if option_is_some(dev_deps_opt) {
        let dev_deps_val: i64 = option_unwrap(dev_deps_opt);
        if json_is_object(dev_deps_val) {
            parse_dependencies(m, dev_deps_val, true);
        }
    }

    // Optional: build.entry
    let build_opt: i64 = json_get(json, "build");
    if option_is_some(build_opt) {
        let build_val: i64 = option_unwrap(build_opt);
        if json_is_object(build_val) {
            let entry_opt: i64 = json_get(build_val, "entry");
            if option_is_some(entry_opt) {
                let entry_val: i64 = option_unwrap(entry_opt);
                if json_is_string(entry_val) {
                    manifest_set_entry(m, json_as_string(entry_val));
                }
            }
        }
    }

    m
}

fn parse_dependencies(m: i64, deps_json: i64, is_dev: bool) -> i64 {
    let keys: i64 = json_keys(deps_json);
    let n: i64 = vec_len(keys);
    let deps_list: i64 = if is_dev { manifest_dev_dependencies(m) } else { manifest_dependencies(m) };

    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(keys, i);
        let val_opt: i64 = json_get(deps_json, name);

        if option_is_some(val_opt) {
            let val: i64 = option_unwrap(val_opt);
            let dep: i64 = dependency_new(name);

            if json_is_string(val) {
                // Simple version: "1.0.0"
                dep_set_version(dep, json_as_string(val));
            } else if json_is_object(val) {
                // Complex: { version, path, git, features }
                let ver_opt: i64 = json_get(val, "version");
                if option_is_some(ver_opt) {
                    let ver_val: i64 = option_unwrap(ver_opt);
                    if json_is_string(ver_val) {
                        dep_set_version(dep, json_as_string(ver_val));
                    }
                }

                let path_opt: i64 = json_get(val, "path");
                if option_is_some(path_opt) {
                    let path_val: i64 = option_unwrap(path_opt);
                    if json_is_string(path_val) {
                        dep_set_path(dep, json_as_string(path_val));
                    }
                }

                let git_opt: i64 = json_get(val, "git");
                if option_is_some(git_opt) {
                    let git_val: i64 = option_unwrap(git_opt);
                    if json_is_string(git_val) {
                        dep_set_git(dep, json_as_string(git_val));
                    }
                }

                let feat_opt: i64 = json_get(val, "features");
                if option_is_some(feat_opt) {
                    let feat_val: i64 = option_unwrap(feat_opt);
                    if json_is_array(feat_val) {
                        let arr: i64 = json_as_array(feat_val);
                        let fn_: i64 = vec_len(arr);
                        var fi: i64 = 0;
                        while fi < fn_ {
                            let fitem: i64 = vec_get(arr, fi);
                            if json_is_string(fitem) {
                                vec_push(dep_features(dep), json_as_string(fitem));
                            }
                            fi = fi + 1;
                        }
                    }
                }
            }

            vec_push(deps_list, dep);
        }
        i = i + 1;
    }
    0
}

// ============================================================================
// Manifest File I/O
// ============================================================================

fn manifest_load(path: i64) -> i64 {
    let content: i64 = read_file(path);
    if content == 0 {
        return 0;
    }
    manifest_parse(content)
}

fn manifest_find() -> i64 {
    // Look for simplex.json in current directory
    if file_exists("simplex.json") {
        return manifest_load("simplex.json");
    }
    0
}

// ============================================================================
// Manifest Validation
// ============================================================================

fn manifest_validate(m: i64) -> i64 {
    let errors: i64 = vec_new();

    // Name is required
    if string_len(manifest_name(m)) == 0 {
        vec_push(errors, "missing required field: name");
    } else {
        // Validate name format (alphanumeric + hyphens)
        let name: i64 = manifest_name(m);
        if string_char_at(name, 0) == 45 {  // '-'
            vec_push(errors, "name cannot start with hyphen");
        }
    }

    // Version is required and must be valid semver
    let ver_str: i64 = manifest_version(m);
    if string_len(ver_str) == 0 {
        vec_push(errors, "missing required field: version");
    } else {
        let ver: i64 = semver_parse(ver_str);
        if ver == 0 {
            vec_push(errors, "invalid version format (must be semver)");
        }
    }

    // Validate dependencies
    let deps: i64 = manifest_dependencies(m);
    let n: i64 = vec_len(deps);
    var i: i64 = 0;
    while i < n {
        let dep: i64 = vec_get(deps, i);
        let dep_name: i64 = dep_name(dep);

        // Must have at least one source
        if dep_is_registry(dep) == false && dep_is_path(dep) == false && dep_is_git(dep) == false {
            let msg: i64 = string_concat("dependency '", string_concat(dep_name, "' has no version, path, or git source"));
            vec_push(errors, msg);
        }

        // Validate version range if present
        if dep_is_registry(dep) {
            let range: i64 = version_range_parse(dep_version(dep));
            if range == 0 {
                let msg: i64 = string_concat("invalid version spec for dependency '", string_concat(dep_name, "'"));
                vec_push(errors, msg);
            }
        }
        i = i + 1;
    }

    errors
}

// ============================================================================
// Manifest Serialization
// ============================================================================

fn manifest_to_json(m: i64) -> i64 {
    let obj: i64 = json_object_new();

    json_object_set(obj, "name", json_string(manifest_name(m)));
    json_object_set(obj, "version", json_string(manifest_version(m)));

    // Authors
    let authors: i64 = manifest_authors(m);
    if vec_len(authors) > 0 {
        let arr: i64 = json_array_new();
        let n: i64 = vec_len(authors);
        var i: i64 = 0;
        while i < n {
            json_array_push(arr, json_string(vec_get(authors, i)));
            i = i + 1;
        }
        json_object_set(obj, "authors", arr);
    }

    if string_len(manifest_description(m)) > 0 {
        json_object_set(obj, "description", json_string(manifest_description(m)));
    }

    if string_len(manifest_license(m)) > 0 {
        json_object_set(obj, "license", json_string(manifest_license(m)));
    }

    if string_len(manifest_repository(m)) > 0 {
        json_object_set(obj, "repository", json_string(manifest_repository(m)));
    }

    // Keywords
    let keywords: i64 = manifest_keywords(m);
    if vec_len(keywords) > 0 {
        let arr: i64 = json_array_new();
        let n: i64 = vec_len(keywords);
        var i: i64 = 0;
        while i < n {
            json_array_push(arr, json_string(vec_get(keywords, i)));
            i = i + 1;
        }
        json_object_set(obj, "keywords", arr);
    }

    // Dependencies
    let deps: i64 = manifest_dependencies(m);
    if vec_len(deps) > 0 {
        let deps_obj: i64 = json_object_new();
        let n: i64 = vec_len(deps);
        var i: i64 = 0;
        while i < n {
            let dep: i64 = vec_get(deps, i);
            let name: i64 = dep_name(dep);

            if dep_is_registry(dep) && vec_len(dep_features(dep)) == 0 {
                // Simple version
                json_object_set(deps_obj, name, json_string(dep_version(dep)));
            } else {
                // Complex dependency
                let dep_obj: i64 = json_object_new();
                if dep_is_registry(dep) {
                    json_object_set(dep_obj, "version", json_string(dep_version(dep)));
                }
                if dep_is_path(dep) {
                    json_object_set(dep_obj, "path", json_string(dep_path(dep)));
                }
                if dep_is_git(dep) {
                    json_object_set(dep_obj, "git", json_string(dep_git(dep)));
                }
                if vec_len(dep_features(dep)) > 0 {
                    let feat_arr: i64 = json_array_new();
                    let fn_: i64 = vec_len(dep_features(dep));
                    var fi: i64 = 0;
                    while fi < fn_ {
                        json_array_push(feat_arr, json_string(vec_get(dep_features(dep), fi)));
                        fi = fi + 1;
                    }
                    json_object_set(dep_obj, "features", feat_arr);
                }
                json_object_set(deps_obj, name, dep_obj);
            }
            i = i + 1;
        }
        json_object_set(obj, "dependencies", deps_obj);
    }

    // Build
    let build_obj: i64 = json_object_new();
    json_object_set(build_obj, "entry", json_string(manifest_entry(m)));
    json_object_set(obj, "build", build_obj);

    json_stringify(obj)
}
