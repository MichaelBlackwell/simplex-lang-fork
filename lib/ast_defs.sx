// Simplex AST Definitions
// Centralized AST tag constants shared between parser.sx and codegen.sx
// Eliminates duplication in multiple files
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex

// Item Tags (shared between parser and codegen)
// ========================================

// Top-level item types in AST
pub fn TAG_FN() -> i64 { 0 }           // Function definition
pub fn TAG_ENUM() -> i64 { 1 }         // Enum definition
pub fn TAG_STRUCT() -> i64 { 2 }       // Struct definition
pub fn TAG_IMPL() -> i64 { 3 }         // Impl block
pub fn TAG_TRAIT() -> i64 { 4 }        // Trait definition
pub fn TAG_IMPL_TRAIT() -> i64 { 5 }   // impl Trait for Type
pub fn TAG_MOD() -> i64 { 6 }          // Module declaration
pub fn TAG_USE() -> i64 { 7 }          // Use statement
pub fn TAG_ACTOR() -> i64 { 8 }        // Actor definition
pub fn TAG_SPECIALIST() -> i64 { 9 }   // AI specialist
pub fn TAG_HIVE() -> i64 { 10 }        // Cognitive hive
pub fn TAG_ANIMA() -> i64 { 11 }      // Cognitive soul
pub fn TAG_TYPE_ALIAS() -> i64 { 12 }  // Type alias
pub fn TAG_NEURAL_GATE() -> i64 { 13 } // Neural gate with differentiable control flow
pub fn TAG_CONST() -> i64 { 14 }       // Constant definition
pub fn TAG_EXTERN() -> i64 { 15 }      // External function declaration

// Statement Tags
// ========================================

// Statement types in function bodies
pub fn STMT_LET() -> i64 { 0 }       // Let binding
pub fn STMT_EXPR() -> i64 { 1 }      // Expression statement
pub fn STMT_RETURN() -> i64 { 2 }    // Return statement
pub fn STMT_ASSIGN() -> i64 { 3 }    // Assignment
pub fn STMT_BREAK() -> i64 { 4 }      // Break statement
pub fn STMT_CONTINUE() -> i64 { 5 }   // Continue statement
pub fn STMT_CONST() -> i64 { 6 }     // Const statement
pub fn STMT_ITEM() -> i64 { 7 }      // Inner item (function, struct, etc.)

// Expression Tags
// ========================================

// Expression node types
pub fn EXPR_INT() -> i64 { 0 }        // Integer literal
pub fn EXPR_BOOL() -> i64 { 1 }      // Boolean literal
pub fn EXPR_STRING() -> i64 { 2 }    // String literal
pub fn EXPR_IDENT() -> i64 { 3 }     // Identifier
pub fn EXPR_PATH() -> i64 { 4 }      // Qualified path
pub fn EXPR_CALL() -> i64 { 5 }      // Function call
pub fn EXPR_BINARY() -> i64 { 6 }    // Binary operation
pub fn EXPR_UNARY() -> i64 { 7 }     // Unary operation
pub fn EXPR_IF() -> i64 { 8 }       // If expression
pub fn EXPR_WHILE() -> i64 { 9 }     // While loop
pub fn EXPR_BLOCK() -> i64 { 10 }    // Block expression
pub fn EXPR_STRUCT_LIT() -> i64 { 11 } // Struct literal
pub fn EXPR_FIELD() -> i64 { 12 }     // Field access
pub fn EXPR_FOR() -> i64 { 13 }      // For loop
pub fn EXPR_MATCH() -> i64 { 14 }    // Match expression
pub fn EXPR_METHOD_CALL() -> i64 { 15 } // Method call
pub fn EXPR_TRY() -> i64 { 16 }      // Try operator
pub fn EXPR_AWAIT() -> i64 { 17 }    // Await expression
pub fn EXPR_FSTRING() -> i64 { 18 }  // Formatted string
pub fn EXPR_YIELD() -> i64 { 19 }    // Yield expression
pub fn EXPR_SPAWN() -> i64 { 20 }    // Spawn expression
pub fn EXPR_ARRAY() -> i64 { 21 }    // Array literal
pub fn EXPR_FLOAT() -> i64 { 22 }    // Float literal
pub fn EXPR_CAST() -> i64 { 23 }     // Type cast
pub fn EXPR_REF() -> i64 { 24 }      // Reference operator
pub fn EXPR_DEREF() -> i64 { 25 }    // Dereference operator
pub fn EXPR_RANGE() -> i64 { 26 }   // Range expression
pub fn EXPR_CLOSURE() -> i64 { 27 }  // Closure literal
pub fn EXPR_MACRO() -> i64 { 28 }    // Macro invocation
pub fn EXPR_INDEX() -> i64 { 29 }    // Index operation
// Struct/pattern expressions (30-34 used by parser.sx)
pub fn EXPR_STRUCT_PAT() -> i64 { 30 }   // Struct pattern
pub fn EXPR_OR_PAT() -> i64 { 31 }       // Or pattern
pub fn EXPR_CAST_P() -> i64 { 32 }       // Type cast (parser version)
pub fn EXPR_METHOD() -> i64 { 33 }       // Method reference
pub fn EXPR_STRUCT() -> i64 { 34 }       // Struct expression

// Belief guard expressions (TASK-013-A)
pub fn EXPR_CONFIDENCE() -> i64 { 35 }    // confidence(belief_id)
pub fn EXPR_DERIVATIVE() -> i64 { 36 }    // expr.derivative
pub fn EXPR_BELIEF_GUARD() -> i64 { 37 }  // belief_expr cmp value
pub fn EXPR_BELIEF_AND() -> i64 { 38 }    // guard && guard
pub fn EXPR_BELIEF_OR() -> i64 { 39 }     // guard || guard

// Binary Operators
// ========================================

// Binary operation types
pub fn OP_ADD() -> i64 { 0 }        // +
pub fn OP_SUB() -> i64 { 1 }        // -
pub fn OP_MUL() -> i64 { 2 }        // *
pub fn OP_DIV() -> i64 { 3 }        // /
pub fn OP_EQ() -> i64 { 4 }         // ==
pub fn OP_NE() -> i64 { 5 }         // !=
pub fn OP_LT() -> i64 { 6 }         // <
pub fn OP_GT() -> i64 { 7 }         // >
pub fn OP_LE() -> i64 { 8 }         // <=
pub fn OP_GE() -> i64 { 9 }         // >=
pub fn OP_AND() -> i64 { 10 }       // &&
pub fn OP_OR() -> i64 { 11 }        // ||
pub fn OP_MOD() -> i64 { 12 }       // %
pub fn OP_BITAND() -> i64 { 13 }     // &
pub fn OP_BITOR() -> i64 { 14 }      // |
pub fn OP_BITXOR() -> i64 { 15 }    // ^
pub fn OP_SHL() -> i64 { 16 }       // <<
pub fn OP_SHR() -> i64 { 17 }       // >>
pub fn OP_ASSIGN() -> i64 { 18 }     // =
pub fn OP_ADD_ASSIGN() -> i64 { 19 } // +=
pub fn OP_SUB_ASSIGN() -> i64 { 20 } // -=
pub fn OP_MUL_ASSIGN() -> i64 { 21 } // *=
pub fn OP_DIV_ASSIGN() -> i64 { 22 } // /=
pub fn OP_MOD_ASSIGN() -> i64 { 23 } // %=

// Unary Operators
// ========================================

// Unary operation types
pub fn OP_NEG() -> i64 { 100 }       // Unary minus
pub fn OP_NOT() -> i64 { 101 }       // Logical NOT
pub fn OP_BITNOT() -> i64 { 102 }    // Bitwise NOT
pub fn OP_REF() -> i64 { 103 }       // Reference
pub fn OP_DEREF() -> i64 { 104 }     // Dereference

// Type Tags
// ========================================

// Primitive and complex types
pub fn TYPE_BOOL() -> i64 { 0 }      // bool
pub fn TYPE_I8() -> i64 { 1 }        // i8
pub fn TYPE_I16() -> i64 { 2 }       // i16
pub fn TYPE_I32() -> i64 { 3 }       // i32
pub fn TYPE_I64() -> i64 { 4 }       // i64
pub fn TYPE_U8() -> i64 { 5 }        // u8
pub fn TYPE_U16() -> i64 { 6 }       // u16
pub fn TYPE_U32() -> i64 { 7 }       // u32
pub fn TYPE_U64() -> i64 { 8 }       // u64
pub fn TYPE_F32() -> i64 { 9 }       // f32
pub fn TYPE_F64() -> i64 { 10 }      // f64
pub fn TYPE_STRING() -> i64 { 11 }   // String
pub fn TYPE_ARRAY() -> i64 { 12 }    // Array
pub fn TYPE_VEC() -> i64 { 13 }      // Vec
pub fn TYPE_PTR() -> i64 { 14 }      // Pointer
pub fn TYPE_REF() -> i64 { 15 }      // Reference
pub fn TYPE_OPTION() -> i64 { 16 }   // Option
pub fn TYPE_RESULT() -> i64 { 17 }   // Result
pub fn TYPE_DUAL() -> i64 { 18 }    // Dual number
pub fn TYPE_MULTIDUAL() -> i64 { 19 } // Multi-dual
pub fn TYPE_UNIT() -> i64 { 20 }     // ()
pub fn TYPE_NEURAL() -> i64 { 21 }   // Neural type
pub fn TYPE_COGNITIVE() -> i64 { 22 } // Cognitive type

// Pattern Tags
// ========================================

// Pattern matching types
pub fn PAT_LITERAL() -> i64 { 0 }    // Literal pattern
pub fn PAT_WILDCARD() -> i64 { 1 }  // _ pattern
pub fn PAT_BIND() -> i64 { 2 }       // Variable binding
pub fn PAT_STRUCT() -> i64 { 3 }     // Struct pattern
pub fn PAT_ENUM() -> i64 { 4 }       // Enum pattern
pub fn PAT_TUPLE() -> i64 { 5 }      // Tuple pattern
pub fn PAT_REF() -> i64 { 6 }        // Reference pattern
pub fn PAT_OR() -> i64 { 7 }         // Or pattern
pub fn PAT_RANGE() -> i64 { 8 }      // Range pattern
pub fn PAT_GUARD() -> i64 { 9 }      // Guard pattern

// Visibility Tags
// ========================================

pub fn VIS_PRIV() -> i64 { 0 }       // Private
pub fn VIS_PUB() -> i64 { 1 }        // Public
pub fn VIS_CRATE() -> i64 { 2 }      // Crate-visible
pub fn VIS_SUPER() -> i64 { 3 }      // Super-visible
pub fn VIS_SELF() -> i64 { 4 }       // Self-visible

// Mutability Tags
// ========================================

pub fn MUT_IMMUTABLE() -> i64 { 0 }   // Immutable
pub fn MUT_MUTABLE() -> i64 { 1 }     // Mutable

// Function Attribute Tags
// ========================================

pub fn ATTR_NONE() -> i64 { 0 }      // No attributes
pub fn ATTR_INLINE() -> i64 { 1 }    // Inline
pub fn ATTR_ALWAYS_INLINE() -> i64 { 2 } // Always inline
pub fn ATTR_NOINLINE() -> i64 { 3 }  // Never inline
pub fn ATTR_EXPORT() -> i64 { 4 }    // Export
pub fn ATTR_EXTERN() -> i64 { 5 }    // External
pub fn ATTR_ASYNC() -> i64 { 6 }     // Async
pub fn ATTR_UNSAFE() -> i64 { 7 }    // Unsafe
pub fn ATTR_NEURAL() -> i64 { 8 }    // Neural (differentiable)

// TASK-014: Epistemic safety attributes
pub fn ATTR_NO_LEARN() -> i64 { 9 }     // #[no_learn] - Cannot contain learnable params
pub fn ATTR_NO_GRADIENT() -> i64 { 10 } // #[no_gradient] - Gradients don't flow through
pub fn ATTR_INVARIANT() -> i64 { 11 }   // #[invariant] - Must hold before/after learning

// Hardware targeting attributes
pub fn ATTR_CPU() -> i64 { 12 }       // @cpu - Execute on CPU
pub fn ATTR_GPU() -> i64 { 13 }       // @gpu - Execute on GPU
pub fn ATTR_NPU() -> i64 { 14 }       // @npu - Execute on NPU

// Attribute bitmask helpers (for combining attributes)
pub fn ATTR_FLAG_NO_LEARN() -> i64 { 1 << 9 }
pub fn ATTR_FLAG_NO_GRADIENT() -> i64 { 1 << 10 }
pub fn ATTR_FLAG_INVARIANT() -> i64 { 1 << 11 }

// Generic Constraint Tags
// ========================================

pub fn CONSTRAIN_NONE() -> i64 { 0 }  // No constraints
pub fn CONSTRAIN_TRAIT() -> i64 { 1 } // Trait bound
pub fn CONSTRAIN_LIFETIME() -> i64 { 2 } // Lifetime bound
pub fn CONSTRAIN_TYPE() -> i64 { 3 }  // Type constraint
pub fn CONSTRAIN_CONST() -> i64 { 4 }  // Const generic

// AST Node Field Indices
// ========================================

// Function node field indices
pub fn FN_NAME() -> i64 { 1 }
pub fn FN_TYPE_PARAMS() -> i64 { 2 }
pub fn FN_PARAMS() -> i64 { 3 }
pub fn FN_RET_TYPE() -> i64 { 4 }
pub fn FN_BODY() -> i64 { 5 }
pub fn FN_ATTRS() -> i64 { 6 }

// Struct node field indices
pub fn STRUCT_NAME() -> i64 { 1 }
pub fn STRUCT_TYPE_PARAMS() -> i64 { 2 }
pub fn STRUCT_FIELDS() -> i64 { 3 }
pub fn STRUCT_ATTRS() -> i64 { 4 }

// Enum node field indices
pub fn ENUM_NAME() -> i64 { 1 }
pub fn ENUM_VARIANTS() -> i64 { 2 }
pub fn ENUM_ATTRS() -> i64 { 3 }

// Block expression field indices
pub fn BLOCK_STMTS() -> i64 { 1 }
pub fn BLOCK_RESULT() -> i64 { 2 }

// Binary expression field indices
pub fn BINARY_LEFT() -> i64 { 2 }
pub fn BINARY_RIGHT() -> i64 { 3 }

// Call expression field indices
pub fn CALL_CALLEE() -> i64 { 1 }
pub fn CALL_ARGS() -> i64 { 2 }

// AST Validation Helpers
// ========================================

// Check if tag is valid item tag
pub fn is_item_tag(tag: i64) -> bool {
    tag >= TAG_FN() && tag <= TAG_EXTERN()
}

// Check if tag is valid statement tag
pub fn is_stmt_tag(tag: i64) -> bool {
    tag >= STMT_LET() && tag <= STMT_ITEM()
}

// Check if tag is valid expression tag
pub fn is_expr_tag(tag: i64) -> bool {
    tag >= EXPR_INT() && tag <= EXPR_BELIEF_OR()
}

// Check if tag is valid binary operator
pub fn is_binary_op(op: i64) -> bool {
    op >= OP_ADD() && op <= OP_MOD_ASSIGN()
}

// Check if tag is valid unary operator
pub fn is_unary_op(op: i64) -> bool {
    op >= OP_NEG() && op <= OP_DEREF()
}

// Get tag name as string for debugging
pub fn get_tag_name(tag: i64) -> i64 {
    if is_item_tag(tag) {
        match tag {
            TAG_FN() => return string_from("TAG_FN"),
            TAG_ENUM() => return string_from("TAG_ENUM"),
            TAG_STRUCT() => return string_from("TAG_STRUCT"),
            TAG_IMPL() => return string_from("TAG_IMPL"),
            TAG_TRAIT() => return string_from("TAG_TRAIT"),
            TAG_IMPL_TRAIT() => return string_from("TAG_IMPL_TRAIT"),
            TAG_MOD() => return string_from("TAG_MOD"),
            TAG_USE() => return string_from("TAG_USE"),
            TAG_ACTOR() => return string_from("TAG_ACTOR"),
            TAG_SPECIALIST() => return string_from("TAG_SPECIALIST"),
            TAG_HIVE() => return string_from("TAG_HIVE"),
            TAG_ANIMA() => return string_from("TAG_ANIMA"),
            TAG_TYPE_ALIAS() => return string_from("TAG_TYPE_ALIAS"),
            TAG_NEURAL_GATE() => return string_from("TAG_NEURAL_GATE"),
            TAG_CONST() => return string_from("TAG_CONST"),
            TAG_EXTERN() => return string_from("TAG_EXTERN"),
            _ => return string_from("UNKNOWN_ITEM")
        }
    } else if is_stmt_tag(tag) {
        match tag {
            STMT_LET() => return string_from("STMT_LET"),
            STMT_EXPR() => return string_from("STMT_EXPR"),
            STMT_RETURN() => return string_from("STMT_RETURN"),
            STMT_ASSIGN() => return string_from("STMT_ASSIGN"),
            STMT_BREAK() => return string_from("STMT_BREAK"),
            STMT_CONTINUE() => return string_from("STMT_CONTINUE"),
            STMT_CONST() => return string_from("STMT_CONST"),
            STMT_ITEM() => return string_from("STMT_ITEM"),
            _ => return string_from("UNKNOWN_STMT")
        }
    } else if is_expr_tag(tag) {
        match tag {
            EXPR_INT() => return string_from("EXPR_INT"),
            EXPR_BOOL() => return string_from("EXPR_BOOL"),
            EXPR_STRING() => return string_from("EXPR_STRING"),
            EXPR_IDENT() => return string_from("EXPR_IDENT"),
            EXPR_PATH() => return string_from("EXPR_PATH"),
            EXPR_CALL() => return string_from("EXPR_CALL"),
            EXPR_BINARY() => return string_from("EXPR_BINARY"),
            EXPR_UNARY() => return string_from("EXPR_UNARY"),
            EXPR_IF() => return string_from("EXPR_IF"),
            EXPR_WHILE() => return string_from("EXPR_WHILE"),
            EXPR_BLOCK() => return string_from("EXPR_BLOCK"),
            EXPR_STRUCT_LIT() => return string_from("EXPR_STRUCT_LIT"),
            EXPR_FIELD() => return string_from("EXPR_FIELD"),
            EXPR_FOR() => return string_from("EXPR_FOR"),
            EXPR_MATCH() => return string_from("EXPR_MATCH"),
            EXPR_METHOD_CALL() => return string_from("EXPR_METHOD_CALL"),
            EXPR_TRY() => return string_from("EXPR_TRY"),
            EXPR_AWAIT() => return string_from("EXPR_AWAIT"),
            EXPR_FSTRING() => return string_from("EXPR_FSTRING"),
            EXPR_YIELD() => return string_from("EXPR_YIELD"),
            EXPR_SPAWN() => return string_from("EXPR_SPAWN"),
            EXPR_ARRAY() => return string_from("EXPR_ARRAY"),
            EXPR_FLOAT() => return string_from("EXPR_FLOAT"),
            EXPR_CAST() => return string_from("EXPR_CAST"),
            EXPR_REF() => return string_from("EXPR_REF"),
            EXPR_DEREF() => return string_from("EXPR_DEREF"),
            EXPR_RANGE() => return string_from("EXPR_RANGE"),
            EXPR_CLOSURE() => return string_from("EXPR_CLOSURE"),
            EXPR_MACRO() => return string_from("EXPR_MACRO"),
            EXPR_INDEX() => return string_from("EXPR_INDEX"),
            EXPR_STRUCT_PAT() => return string_from("EXPR_STRUCT_PAT"),
            EXPR_OR_PAT() => return string_from("EXPR_OR_PAT"),
            EXPR_CAST_P() => return string_from("EXPR_CAST_P"),
            EXPR_METHOD() => return string_from("EXPR_METHOD"),
            EXPR_STRUCT() => return string_from("EXPR_STRUCT"),
            EXPR_CONFIDENCE() => return string_from("EXPR_CONFIDENCE"),
            EXPR_DERIVATIVE() => return string_from("EXPR_DERIVATIVE"),
            EXPR_BELIEF_GUARD() => return string_from("EXPR_BELIEF_GUARD"),
            EXPR_BELIEF_AND() => return string_from("EXPR_BELIEF_AND"),
            EXPR_BELIEF_OR() => return string_from("EXPR_BELIEF_OR"),
            _ => return string_from("UNKNOWN_EXPR")
        }
    } else {
        return string_from("UNKNOWN_TAG")
    }
}