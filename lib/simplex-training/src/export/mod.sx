// simplex-training::export - Model Export Formats
//
// Implements export to various formats:
// - GGUF (llama.cpp compatible)
// - ONNX (cross-platform inference)
// - SafeTensors (HuggingFace format)
//
// Supports quantized model export.

pub mod gguf;

pub use gguf::{GgufExporter, GgufConfig, GgufTensor, GgufMetadata};

use simplex_std::dual::dual;
use simplex_std::{Clone, Default, Vec, String};

// =============================================================================
// Export Formats
// =============================================================================

/// Supported export formats
#[derive(Clone, Copy)]
pub enum ExportFormat {
    /// GGUF format for llama.cpp
    GGUF,
    /// ONNX format
    ONNX,
    /// SafeTensors format
    SafeTensors,
    /// Raw binary format
    RawBinary,
}

impl ExportFormat {
    pub fn extension(&self) -> &str {
        match self {
            ExportFormat::GGUF => "gguf",
            ExportFormat::ONNX => "onnx",
            ExportFormat::SafeTensors => "safetensors",
            ExportFormat::RawBinary => "bin",
        }
    }
}

// =============================================================================
// Export Configuration
// =============================================================================

/// General export configuration
#[derive(Clone)]
pub struct ExportConfig {
    /// Output format
    pub format: ExportFormat,
    /// Model name
    pub model_name: String,
    /// Model description
    pub description: String,
    /// Model version
    pub version: String,
    /// Author
    pub author: String,
    /// Include metadata
    pub include_metadata: bool,
    /// Compress output
    pub compress: bool,
}

impl ExportConfig {
    pub fn new(name: &str, format: ExportFormat) -> ExportConfig {
        ExportConfig {
            format,
            model_name: String::from(name),
            description: String::new(),
            version: String::from("1.0.0"),
            author: String::new(),
            include_metadata: true,
            compress: false,
        }
    }

    pub fn gguf(name: &str) -> ExportConfig {
        ExportConfig::new(name, ExportFormat::GGUF)
    }

    pub fn safetensors(name: &str) -> ExportConfig {
        ExportConfig::new(name, ExportFormat::SafeTensors)
    }
}

impl Default for ExportConfig {
    fn default() -> ExportConfig {
        ExportConfig::new("model", ExportFormat::GGUF)
    }
}

// =============================================================================
// Tensor Representation
// =============================================================================

/// Data type for exported tensors
#[derive(Clone, Copy)]
pub enum TensorDtype {
    /// 32-bit float
    F32,
    /// 16-bit float
    F16,
    /// Brain float 16
    BF16,
    /// 8-bit signed integer
    I8,
    /// 4-bit quantized
    Q4_0,
    /// 4-bit quantized with groups
    Q4_1,
    /// 8-bit quantized
    Q8_0,
}

impl TensorDtype {
    pub fn bits_per_element(&self) -> u8 {
        match self {
            TensorDtype::F32 => 32,
            TensorDtype::F16 | TensorDtype::BF16 => 16,
            TensorDtype::I8 | TensorDtype::Q8_0 => 8,
            TensorDtype::Q4_0 | TensorDtype::Q4_1 => 4,
        }
    }

    pub fn gguf_type_id(&self) -> u32 {
        match self {
            TensorDtype::F32 => 0,
            TensorDtype::F16 => 1,
            TensorDtype::Q4_0 => 2,
            TensorDtype::Q4_1 => 3,
            TensorDtype::Q8_0 => 8,
            TensorDtype::I8 => 16,
            TensorDtype::BF16 => 30,
        }
    }
}

/// Tensor for export
#[derive(Clone)]
pub struct ExportTensor {
    /// Tensor name
    pub name: String,
    /// Shape
    pub shape: Vec<u64>,
    /// Data type
    pub dtype: TensorDtype,
    /// Raw data (bytes)
    pub data: Vec<u8>,
}

impl ExportTensor {
    pub fn new(name: &str, shape: Vec<u64>, dtype: TensorDtype) -> ExportTensor {
        ExportTensor {
            name: String::from(name),
            shape,
            dtype,
            data: Vec::new(),
        }
    }

    /// Create from f32 values
    pub fn from_f32(name: &str, shape: Vec<u64>, values: &[f64]) -> ExportTensor {
        var tensor = ExportTensor::new(name, shape, TensorDtype::F32);
        tensor.data = f32_to_bytes(values);
        tensor
    }

    /// Create from f64 values (alias for from_f32 which casts internally)
    pub fn from_f64(name: &str, shape: Vec<u64>, values: &[f64]) -> ExportTensor {
        ExportTensor::from_f32(name, shape, values)
    }

    /// Create from dual values (extracts .val)
    pub fn from_dual(name: &str, shape: Vec<u64>, values: &[dual]) -> ExportTensor {
        var f64_vals = Vec::new();
        for v in values {
            f64_vals.push(v.val);
        }
        ExportTensor::from_f32(name, &shape, &f64_vals)
    }

    /// Number of elements
    pub fn numel(&self) -> u64 {
        var n = 1u64;
        for d in self.shape.iter() {
            n = n * d;
        }
        n
    }

    /// Size in bytes
    pub fn size_bytes(&self) -> u64 {
        self.numel() * (self.dtype.bits_per_element() as u64) / 8
    }
}

// =============================================================================
// Export Result
// =============================================================================

/// Result of export operation
#[derive(Clone)]
pub struct ExportResult {
    /// Output file path
    pub output_path: String,
    /// File size in bytes
    pub file_size: u64,
    /// Number of tensors exported
    pub tensor_count: u64,
    /// Total parameters
    pub total_params: u64,
    /// Compression ratio achieved
    pub compression_ratio: f64,
    /// Export duration (ms)
    pub duration_ms: u64,
}

impl ExportResult {
    pub fn new() -> ExportResult {
        ExportResult {
            output_path: String::new(),
            file_size: 0,
            tensor_count: 0,
            total_params: 0,
            compression_ratio: 1.0,
            duration_ms: 0,
        }
    }
}

impl Default for ExportResult {
    fn default() -> ExportResult {
        ExportResult::new()
    }
}

// =============================================================================
// Utilities
// =============================================================================

/// Convert f64 values to f32 bytes (little endian)
fn f32_to_bytes(values: &[f64]) -> Vec<u8> {
    var bytes = Vec::new();
    for v in values {
        let f = *v as f32;
        // Note: in real implementation, use proper byte conversion
        // This is a simplified placeholder
        let bits = f32_to_bits(f);
        bytes.push((bits & 0xFF) as u8);
        bytes.push(((bits >> 8) & 0xFF) as u8);
        bytes.push(((bits >> 16) & 0xFF) as u8);
        bytes.push(((bits >> 24) & 0xFF) as u8);
    }
    bytes
}

/// Convert f32 to bits (simplified)
fn f32_to_bits(f: f32) -> u32 {
    // Simplified bit conversion
    // In real code, use transmute or union
    if f == 0.0 {
        return 0;
    }

    var bits: u32 = 0;
    let sign = if f < 0.0 { 1u32 } else { 0u32 };
    let abs_f = if f < 0.0 { -f } else { f };

    // Simplified IEEE 754 encoding
    var exponent: i32 = 127;
    var mantissa = abs_f;

    while mantissa >= 2.0 {
        mantissa = mantissa / 2.0;
        exponent = exponent + 1;
    }
    while mantissa < 1.0 && exponent > 0 {
        mantissa = mantissa * 2.0;
        exponent = exponent - 1;
    }

    mantissa = mantissa - 1.0;  // Remove implicit 1
    let mantissa_bits = (mantissa * 8388608.0) as u32;  // 2^23

    bits = (sign << 31) | ((exponent as u32) << 23) | mantissa_bits;
    bits
}

/// Convert bytes to u32 little endian
fn bytes_to_u32(bytes: &[u8], offset: usize) -> u32 {
    if offset + 4 > bytes.len() {
        return 0;
    }
    (bytes[offset] as u32) |
    ((bytes[offset + 1] as u32) << 8) |
    ((bytes[offset + 2] as u32) << 16) |
    ((bytes[offset + 3] as u32) << 24)
}

/// Convert u32 to bytes little endian
fn u32_to_bytes(val: u32) -> Vec<u8> {
    vec![
        (val & 0xFF) as u8,
        ((val >> 8) & 0xFF) as u8,
        ((val >> 16) & 0xFF) as u8,
        ((val >> 24) & 0xFF) as u8,
    ]
}

/// Convert u64 to bytes little endian
fn u64_to_bytes(val: u64) -> Vec<u8> {
    vec![
        (val & 0xFF) as u8,
        ((val >> 8) & 0xFF) as u8,
        ((val >> 16) & 0xFF) as u8,
        ((val >> 24) & 0xFF) as u8,
        ((val >> 32) & 0xFF) as u8,
        ((val >> 40) & 0xFF) as u8,
        ((val >> 48) & 0xFF) as u8,
        ((val >> 56) & 0xFF) as u8,
    ]
}
