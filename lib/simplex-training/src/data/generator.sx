// Data generator trait and utilities
//
// Defines the interface for generating training data and provides
// common utilities for synthetic data generation.

use simplex_std::vec::Vec;
use simplex_std::string::String;
use simplex_std::option::Option;
use super::super::SpecialistDomain;

/// A single training example
#[derive(Clone)]
pub struct TrainingExample {
    /// Input prompt/question
    pub prompt: String,

    /// Expected response
    pub response: String,

    /// Metadata about the example
    pub metadata: ExampleMetadata,
}

impl TrainingExample {
    /// Create new example
    pub fn new(prompt: &str, response: &str) -> Self {
        TrainingExample {
            prompt: prompt.to_string(),
            response: response.to_string(),
            metadata: ExampleMetadata::default(),
        }
    }

    /// Create with domain
    pub fn with_domain(prompt: &str, response: &str, domain: &str) -> Self {
        TrainingExample {
            prompt: prompt.to_string(),
            response: response.to_string(),
            metadata: ExampleMetadata {
                domain: domain.to_string(),
                ..Default::default()
            },
        }
    }

    /// Set confidence target
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.metadata.confidence_target = confidence;
        self
    }

    /// Set source
    pub fn with_source(mut self, source: &str) -> Self {
        self.metadata.source = source.to_string();
        self
    }

    /// Get total length (for sorting/filtering)
    pub fn total_length(&self) -> usize {
        self.prompt.len() + self.response.len()
    }
}

/// Metadata for training examples
#[derive(Clone)]
pub struct ExampleMetadata {
    /// Domain/category of the example
    pub domain: String,

    /// Target confidence score
    pub confidence_target: f64,

    /// Source (synthetic, dataset name, etc.)
    pub source: String,

    /// Difficulty level (0.0 = easy, 1.0 = hard)
    pub difficulty: f64,

    /// Quality score (for filtering)
    pub quality: f64,

    /// Tags for categorization
    pub tags: Vec<String>,
}

impl Default for ExampleMetadata {
    fn default() -> Self {
        ExampleMetadata {
            domain: "general".to_string(),
            confidence_target: 0.9,
            source: "synthetic".to_string(),
            difficulty: 0.5,
            quality: 1.0,
            tags: Vec::new(),
        }
    }
}

/// Trait for generating training data
pub trait DataGenerator {
    /// Generate a single training example
    fn generate(&mut self) -> TrainingExample;

    /// Generate multiple examples
    fn generate_batch(&mut self, size: usize) -> Vec<TrainingExample> {
        (0..size).map(|_| self.generate()).collect()
    }

    /// Get the domain this generator produces
    fn domain(&self) -> SpecialistDomain;

    /// Get generator name
    fn name(&self) -> &str;

    /// Seed the random number generator for reproducibility
    fn seed(&mut self, seed: u64);

    /// Reset generator state
    fn reset(&mut self);
}

/// Batch generator for streaming data
pub struct BatchGenerator<G: DataGenerator> {
    /// Underlying generator
    generator: G,

    /// Batch size
    batch_size: usize,

    /// Examples generated so far
    generated: usize,

    /// Maximum examples (None = infinite)
    max_examples: Option<usize>,
}

impl<G: DataGenerator> BatchGenerator<G> {
    /// Create new batch generator
    pub fn new(generator: G, batch_size: usize) -> Self {
        BatchGenerator {
            generator,
            batch_size,
            generated: 0,
            max_examples: None,
        }
    }

    /// Set maximum examples
    pub fn with_max(mut self, max: usize) -> Self {
        self.max_examples = Some(max);
        self
    }

    /// Generate next batch
    pub fn next_batch(&mut self) -> Option<Vec<TrainingExample>> {
        if let Some(max) = self.max_examples {
            if self.generated >= max {
                return None;
            }
        }

        let batch = self.generator.generate_batch(self.batch_size);
        self.generated += batch.len();
        Some(batch)
    }

    /// Check if there are more examples
    pub fn has_more(&self) -> bool {
        match self.max_examples {
            Some(max) => self.generated < max,
            None => true,
        }
    }

    /// Reset generator
    pub fn reset(&mut self) {
        self.generated = 0;
        self.generator.reset();
    }

    /// Number of examples generated
    pub fn count(&self) -> usize {
        self.generated
    }
}

/// Simple random number generator (Xorshift64)
pub struct Rng {
    state: u64,
}

impl Rng {
    /// Create new RNG with seed
    pub fn new(seed: u64) -> Self {
        Rng {
            state: if seed == 0 { 1 } else { seed },
        }
    }

    /// Generate next u64
    pub fn next_u64(&mut self) -> u64 {
        let mut x = self.state;
        x ^= x << 13;
        x ^= x >> 7;
        x ^= x << 17;
        self.state = x;
        x
    }

    /// Generate float in [0, 1)
    pub fn next_f64(&mut self) -> f64 {
        (self.next_u64() as f64) / (u64::MAX as f64)
    }

    /// Generate integer in [min, max]
    pub fn int_range(&mut self, min: i64, max: i64) -> i64 {
        let range = (max - min + 1) as u64;
        (min as i64) + (self.next_u64() % range) as i64
    }

    /// Generate float in [min, max)
    pub fn float_range(&mut self, min: f64, max: f64) -> f64 {
        min + self.next_f64() * (max - min)
    }

    /// Choose random element from slice
    pub fn choice<'a, T>(&mut self, items: &'a [T]) -> &'a T {
        let idx = self.next_u64() as usize % items.len();
        &items[idx]
    }

    /// Choose random element and return owned copy
    pub fn choice_clone<T: Clone>(&mut self, items: &[T]) -> T {
        let idx = self.next_u64() as usize % items.len();
        items[idx].clone()
    }

    /// Shuffle slice in place
    pub fn shuffle<T>(&mut self, items: &mut [T]) {
        let n = items.len();
        for i in (1..n).rev() {
            let j = (self.next_u64() as usize) % (i + 1);
            items.swap(i, j);
        }
    }

    /// Generate random date string (YYYY-MM-DD)
    pub fn date(&mut self) -> String {
        let year = self.int_range(2020, 2025);
        let month = self.int_range(1, 12);
        let day = self.int_range(1, 28);
        format!("{:04}-{:02}-{:02}", year, month, day)
    }

    /// Generate random boolean with probability p
    pub fn bernoulli(&mut self, p: f64) -> bool {
        self.next_f64() < p
    }

    /// Seed the RNG
    pub fn seed(&mut self, seed: u64) {
        self.state = if seed == 0 { 1 } else { seed };
    }
}

/// Common word lists for synthetic data
pub struct WordLists;

impl WordLists {
    pub fn companies() -> Vec<&'static str> {
        vec![
            "Acme Corporation", "TechStart Inc", "Global Industries",
            "Innovate Labs", "DataDrive Solutions", "CloudFirst",
            "MetaSoft", "Quantum Systems", "NeuralNet AI",
            "CyberSecure", "GreenTech", "BioGenesis",
        ]
    }

    pub fn names() -> Vec<&'static str> {
        vec![
            "Alice Johnson", "Bob Smith", "Carol Williams", "David Brown",
            "Eva Martinez", "Frank Lee", "Grace Kim", "Henry Chen",
            "Iris Patel", "Jack Wilson", "Kate Anderson", "Leo Garcia",
        ]
    }

    pub fn cities() -> Vec<&'static str> {
        vec![
            "New York", "San Francisco", "London", "Tokyo", "Paris",
            "Berlin", "Sydney", "Toronto", "Singapore", "Mumbai",
        ]
    }

    pub fn programming_languages() -> Vec<&'static str> {
        vec![
            "Python", "JavaScript", "TypeScript", "Rust", "Go",
            "Java", "C++", "C#", "Ruby", "Swift", "Kotlin",
        ]
    }

    pub fn sentiments() -> Vec<&'static str> {
        vec!["positive", "negative", "neutral", "mixed"]
    }

    pub fn document_types() -> Vec<&'static str> {
        vec![
            "invoice", "receipt", "contract", "report", "memo",
            "email", "letter", "form", "certificate", "statement",
        ]
    }

    pub fn code_tasks() -> Vec<&'static str> {
        vec![
            "implement a function", "fix the bug", "optimize the algorithm",
            "add error handling", "write unit tests", "refactor the code",
            "add documentation", "implement the class", "create an API endpoint",
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rng() {
        let mut rng = Rng::new(42);

        let a = rng.next_u64();
        let b = rng.next_u64();
        assert_ne!(a, b);

        rng.seed(42);
        let c = rng.next_u64();
        assert_eq!(a, c); // Same seed = same sequence
    }

    #[test]
    fn test_rng_range() {
        let mut rng = Rng::new(42);

        for _ in 0..100 {
            let val = rng.int_range(1, 10);
            assert!(val >= 1 && val <= 10);
        }
    }

    #[test]
    fn test_training_example() {
        let example = TrainingExample::new("What is 2+2?", "4")
            .with_confidence(0.99)
            .with_source("math");

        assert_eq!(example.prompt, "What is 2+2?");
        assert_eq!(example.response, "4");
        assert!((example.metadata.confidence_target - 0.99).abs() < 0.001);
    }

    #[test]
    fn test_word_lists() {
        assert!(!WordLists::companies().is_empty());
        assert!(!WordLists::names().is_empty());
        assert!(!WordLists::cities().is_empty());
    }
}
