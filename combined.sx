// Simplex Combined Compiler
// Merged lexer, parser, and code generator for single-file compilation
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex
//
// Simplex Lexer
// Self-hosted lexer with full token support for all language features

// Token types as enum
enum TokenKind {
    Eof,
    Ident,
    Int,
    Float,
    String,
    FString,   // f"..." interpolated string
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    DotDot,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub,
    KwStruct,
    KwImpl,
    KwSelf,
    KwMatch,
    FatArrow,
    Underscore,
    AmpAmp,
    PipePipe,
    Percent,
    Amp,
    Pipe,
    Caret,
    LtLt,
    GtGt,
    KwBreak,
    KwContinue,
    Question,
    KwTrait,
    KwType,
    KwUse,
    KwMod,
    KwConst,
    KwAsync,
    KwAwait,
    KwYield,
    KwDyn,
    // Actor model keywords
    KwActor,
    KwReceive,
    KwInit,
    // AI/Cognitive keywords
    KwSpecialist,
    KwInfer,
    KwHive,
    // Mutable binding
    KwVar,
    // Spawn expression
    KwSpawn
}

// Lexer state - we pass this to all functions instead of using self
fn lexer_new(source: i64) -> i64 {
    // Allocate lexer state: source(0), pos(1), len(2)
    let lexer: i64 = malloc(24);
    store_ptr(lexer, 0, source);
    store_i64(lexer, 1, 0);
    let len: i64 = string_len(source);
    store_i64(lexer, 2, len);
    return lexer;
}

fn lexer_pos(lexer: i64) -> i64 {
    return load_i64(lexer, 1);
}

fn lexer_len(lexer: i64) -> i64 {
    return load_i64(lexer, 2);
}

fn lexer_source(lexer: i64) -> i64 {
    return load_ptr(lexer, 0);
}

fn lexer_at_end(lexer: i64) -> bool {
    let pos: i64 = lexer_pos(lexer);
    let len: i64 = lexer_len(lexer);
    return pos >= len;
}

fn lexer_peek(lexer: i64) -> i64 {
    if lexer_at_end(lexer) {
        return 0;
    }
    let src: i64 = lexer_source(lexer);
    let pos: i64 = lexer_pos(lexer);
    return string_char_at(src, pos);
}

fn lexer_advance(lexer: i64) -> i64 {
    let c: i64 = lexer_peek(lexer);
    if c != 0 {
        let pos: i64 = lexer_pos(lexer);
        store_i64(lexer, 1, pos + 1);
    }
    return c;
}

fn is_whitespace(c: i64) -> bool {
    if c == 32 { return true; }
    if c == 9 { return true; }
    if c == 10 { return true; }
    if c == 13 { return true; }
    return false;
}

fn is_digit(c: i64) -> bool {
    if c >= 48 {
        if c <= 57 { return true; }
    }
    return false;
}

fn is_alpha(c: i64) -> bool {
    // a-z: 97-122
    if c >= 97 {
        if c <= 122 { return true; }
    }
    // A-Z: 65-90
    if c >= 65 {
        if c <= 90 { return true; }
    }
    return false;
}

fn is_ident_start(c: i64) -> bool {
    if is_alpha(c) { return true; }
    if c == 95 { return true; }
    return false;
}

fn is_ident_continue(c: i64) -> bool {
    if is_ident_start(c) { return true; }
    if is_digit(c) { return true; }
    return false;
}

fn lexer_skip_whitespace(lexer: i64) -> i64 {
    while is_whitespace(lexer_peek(lexer)) {
        lexer_advance(lexer);
    }
    return 0;
}

fn lexer_skip_line_comment(lexer: i64) -> i64 {
    while lexer_peek(lexer) != 10 {
        if lexer_at_end(lexer) {
            return 0;
        }
        lexer_advance(lexer);
    }
    return 0;
}

// Create a token - returns ptr to token struct
// Token: kind(0), text(1), pos(2)
fn token_new(kind: i64, text: i64, pos: i64) -> i64 {
    let tok: i64 = malloc(24);
    store_i64(tok, 0, kind);
    store_ptr(tok, 1, text);
    store_i64(tok, 2, pos);
    return tok;
}

fn token_kind(tok: i64) -> i64 {
    return load_i64(tok, 0);
}

fn token_text(tok: i64) -> i64 {
    return load_ptr(tok, 1);
}

// Check if identifier matches keyword
fn check_keyword(text: i64) -> i64 {
    if string_eq(text, "fn") { return TokenKind::KwFn; }
    if string_eq(text, "let") { return TokenKind::KwLet; }
    if string_eq(text, "if") { return TokenKind::KwIf; }
    if string_eq(text, "else") { return TokenKind::KwElse; }
    if string_eq(text, "while") { return TokenKind::KwWhile; }
    if string_eq(text, "return") { return TokenKind::KwReturn; }
    if string_eq(text, "enum") { return TokenKind::KwEnum; }
    if string_eq(text, "true") { return TokenKind::KwTrue; }
    if string_eq(text, "false") { return TokenKind::KwFalse; }
    if string_eq(text, "pub") { return TokenKind::KwPub; }
    if string_eq(text, "struct") { return TokenKind::KwStruct; }
    if string_eq(text, "for") { return TokenKind::KwFor; }
    if string_eq(text, "in") { return TokenKind::KwIn; }
    if string_eq(text, "impl") { return TokenKind::KwImpl; }
    if string_eq(text, "self") { return TokenKind::KwSelf; }
    if string_eq(text, "match") { return TokenKind::KwMatch; }
    if string_eq(text, "break") { return TokenKind::KwBreak; }
    if string_eq(text, "continue") { return TokenKind::KwContinue; }
    if string_eq(text, "trait") { return TokenKind::KwTrait; }
    if string_eq(text, "type") { return TokenKind::KwType; }
    if string_eq(text, "use") { return TokenKind::KwUse; }
    if string_eq(text, "mod") { return TokenKind::KwMod; }
    if string_eq(text, "const") { return TokenKind::KwConst; }
    if string_eq(text, "async") { return TokenKind::KwAsync; }
    if string_eq(text, "await") { return TokenKind::KwAwait; }
    if string_eq(text, "yield") { return TokenKind::KwYield; }
    if string_eq(text, "dyn") { return TokenKind::KwDyn; }
    // Actor model keywords
    if string_eq(text, "actor") { return TokenKind::KwActor; }
    if string_eq(text, "receive") { return TokenKind::KwReceive; }
    if string_eq(text, "init") { return TokenKind::KwInit; }
    // AI/Cognitive keywords
    if string_eq(text, "specialist") { return TokenKind::KwSpecialist; }
    if string_eq(text, "infer") { return TokenKind::KwInfer; }
    if string_eq(text, "hive") { return TokenKind::KwHive; }
    // Mutable binding
    if string_eq(text, "var") { return TokenKind::KwVar; }
    // Spawn expression
    if string_eq(text, "spawn") { return TokenKind::KwSpawn; }
    if string_eq(text, "_") { return TokenKind::Underscore; }
    return TokenKind::Ident;
}

// Main tokenizer function
fn lexer_next_token(lexer: i64) -> i64 {
    lexer_skip_whitespace(lexer);

    if lexer_at_end(lexer) {
        return token_new(TokenKind::Eof, string_from(""), lexer_pos(lexer));
    }

    let start: i64 = lexer_pos(lexer);
    let c: i64 = lexer_advance(lexer);

    // Single character tokens
    if c == 40 { return token_new(TokenKind::LParen, string_from("("), start); }
    if c == 41 { return token_new(TokenKind::RParen, string_from(")"), start); }
    if c == 123 { return token_new(TokenKind::LBrace, string_from("{"), start); }
    if c == 125 { return token_new(TokenKind::RBrace, string_from("}"), start); }
    if c == 91 { return token_new(TokenKind::LBracket, string_from("["), start); }
    if c == 93 { return token_new(TokenKind::RBracket, string_from("]"), start); }
    if c == 44 { return token_new(TokenKind::Comma, string_from(","), start); }
    if c == 59 { return token_new(TokenKind::Semi, string_from(";"), start); }
    if c == 43 { return token_new(TokenKind::Plus, string_from("+"), start); }
    if c == 42 { return token_new(TokenKind::Star, string_from("*"), start); }
    if c == 37 { return token_new(TokenKind::Percent, string_from("%"), start); }
    if c == 38 {
        if lexer_peek(lexer) == 38 {
            lexer_advance(lexer);
            return token_new(TokenKind::AmpAmp, string_from("&&"), start);
        }
        return token_new(TokenKind::Amp, string_from("&"), start);
    }
    if c == 124 {
        if lexer_peek(lexer) == 124 {
            lexer_advance(lexer);
            return token_new(TokenKind::PipePipe, string_from("||"), start);
        }
        return token_new(TokenKind::Pipe, string_from("|"), start);
    }
    if c == 94 {
        return token_new(TokenKind::Caret, string_from("^"), start);
    }
    if c == 46 {
        if lexer_peek(lexer) == 46 {
            lexer_advance(lexer);
            return token_new(TokenKind::DotDot, string_from(".."), start);
        }
        return token_new(TokenKind::Dot, string_from("."), start);
    }

    // Two character tokens
    if c == 58 {
        if lexer_peek(lexer) == 58 {
            lexer_advance(lexer);
            return token_new(TokenKind::DoubleColon, string_from("::"), start);
        }
        return token_new(TokenKind::Colon, string_from(":"), start);
    }

    if c == 45 {
        if lexer_peek(lexer) == 62 {
            lexer_advance(lexer);
            return token_new(TokenKind::Arrow, string_from("->"), start);
        }
        return token_new(TokenKind::Minus, string_from("-"), start);
    }

    if c == 61 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::EqEq, string_from("=="), start);
        }
        if lexer_peek(lexer) == 62 {
            lexer_advance(lexer);
            return token_new(TokenKind::FatArrow, string_from("=>"), start);
        }
        return token_new(TokenKind::Eq, string_from("="), start);
    }

    if c == 33 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Ne, string_from("!="), start);
        }
        return token_new(TokenKind::Bang, string_from("!"), start);
    }

    // ? for try/error propagation
    if c == 63 {
        return token_new(TokenKind::Question, string_from("?"), start);
    }

    if c == 60 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Le, string_from("<="), start);
        }
        if lexer_peek(lexer) == 60 {
            lexer_advance(lexer);
            return token_new(TokenKind::LtLt, string_from("<<"), start);
        }
        return token_new(TokenKind::Lt, string_from("<"), start);
    }

    if c == 62 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Ge, string_from(">="), start);
        }
        if lexer_peek(lexer) == 62 {
            lexer_advance(lexer);
            return token_new(TokenKind::GtGt, string_from(">>"), start);
        }
        return token_new(TokenKind::Gt, string_from(">"), start);
    }

    if c == 47 {
        if lexer_peek(lexer) == 47 {
            lexer_skip_line_comment(lexer);
            return lexer_next_token(lexer);
        }
        return token_new(TokenKind::Slash, string_from("/"), start);
    }

    // f-string literals: f"..." with {expr} interpolation
    // Check for 'f' followed by '"'
    if c == 102 {
        if lexer_peek(lexer) == 34 {
            lexer_advance(lexer);  // consume the opening "
            let text: i64 = string_from("");
            while lexer_peek(lexer) != 34 {
                if lexer_at_end(lexer) {
                    return token_new(TokenKind::Eof, string_from(""), start);
                }
                let sc: i64 = lexer_advance(lexer);
                // Handle escape sequences
                if sc == 92 {
                    if lexer_at_end(lexer) == false {
                        let esc: i64 = lexer_advance(lexer);
                        if esc == 110 {
                            text = string_concat(text, string_from_char(10));
                        } else {
                            if esc == 116 {
                                text = string_concat(text, string_from_char(9));
                            } else {
                                if esc == 34 {
                                    text = string_concat(text, string_from_char(34));
                                } else {
                                    if esc == 92 {
                                        text = string_concat(text, string_from_char(92));
                                    } else {
                                        if esc == 123 {
                                            // \{ -> literal brace
                                            text = string_concat(text, string_from_char(123));
                                        } else {
                                            if esc == 125 {
                                                // \} -> literal brace
                                                text = string_concat(text, string_from_char(125));
                                            } else {
                                                text = string_concat(text, string_from_char(esc));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    text = string_concat(text, string_from_char(sc));
                }
            }
            lexer_advance(lexer);  // consume closing "
            return token_new(TokenKind::FString, text, start);
        }
    }

    // Identifiers and keywords
    if is_ident_start(c) {
        while is_ident_continue(lexer_peek(lexer)) {
            lexer_advance(lexer);
        }
        let end: i64 = lexer_pos(lexer);
        let text: i64 = string_slice(lexer_source(lexer), start, end);
        let kind: i64 = check_keyword(text);
        return token_new(kind, text, start);
    }

    // Numbers (int or float)
    if is_digit(c) {
        while is_digit(lexer_peek(lexer)) {
            lexer_advance(lexer);
        }
        // Check for decimal point followed by digits (float)
        if lexer_peek(lexer) == 46 {
            // Look ahead to see if there's a digit after the dot
            let saved_pos: i64 = lexer_pos(lexer);
            lexer_advance(lexer);  // consume .
            if is_digit(lexer_peek(lexer)) {
                // It's a float
                while is_digit(lexer_peek(lexer)) {
                    lexer_advance(lexer);
                }
                let end: i64 = lexer_pos(lexer);
                let text: i64 = string_slice(lexer_source(lexer), start, end);
                return token_new(TokenKind::Float, text, start);
            } else {
                // Not a float, backtrack (it's an int followed by a dot)
                // We need to restore position - but our simple lexer doesn't support this well
                // So just return the int up to the dot
                let end: i64 = saved_pos;
                let text: i64 = string_slice(lexer_source(lexer), start, end);
                // Reset position to before the dot (lexer_pos is now at saved_pos+1, we need saved_pos)
                store_i64(lexer, 1, saved_pos);
                return token_new(TokenKind::Int, text, start);
            }
        }
        let end: i64 = lexer_pos(lexer);
        let text: i64 = string_slice(lexer_source(lexer), start, end);
        return token_new(TokenKind::Int, text, start);
    }

    // String literals - build string with escape sequence conversion
    if c == 34 {
        let text: i64 = string_from("");
        while lexer_peek(lexer) != 34 {
            if lexer_at_end(lexer) {
                return token_new(TokenKind::Eof, string_from(""), start);
            }
            let sc: i64 = lexer_advance(lexer);
            // Handle escape sequences
            if sc == 92 {
                if lexer_at_end(lexer) == false {
                    let esc: i64 = lexer_advance(lexer);
                    if esc == 110 {
                        // \n -> newline (ASCII 10)
                        text = string_concat(text, string_from_char(10));
                    } else {
                        if esc == 116 {
                            // \t -> tab (ASCII 9)
                            text = string_concat(text, string_from_char(9));
                        } else {
                            if esc == 34 {
                                // \" -> quote
                                text = string_concat(text, string_from_char(34));
                            } else {
                                if esc == 92 {
                                    // \\ -> backslash
                                    text = string_concat(text, string_from_char(92));
                                } else {
                                    // Unknown escape - just add the char
                                    text = string_concat(text, string_from_char(esc));
                                }
                            }
                        }
                    }
                }
            } else {
                text = string_concat(text, string_from_char(sc));
            }
        }
        lexer_advance(lexer);
        return token_new(TokenKind::String, text, start);
    }

    // Unknown character - return EOF for now
    return token_new(TokenKind::Eof, string_from(""), start);
}

// Tokenize entire source into a list
fn tokenize(source: i64) -> i64 {
    let lexer: i64 = lexer_new(source);
    let tokens: i64 = vec_new();

    while true {
        let tok: i64 = lexer_next_token(lexer);
        vec_push(tokens, tok);
        if token_kind(tok) == TokenKind::Eof {
            return tokens;
        }
    }

    return tokens;
}
// Simplex Parser
// Self-hosted parser supporting full language features:
// - impl blocks, self keyword, for loops, match expressions
// - traits and impl Trait for Type
// - generic functions with type parameters
// - struct literals with lookahead disambiguation

// Token types enum - duplicated from lexer.sx for standalone compilation
enum TokenKind {
    Eof,
    Ident,
    Int,
    Float,
    String,
    FString,   // f"..." interpolated string
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    DotDot,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub,
    KwStruct,
    KwImpl,
    KwSelf,
    KwMatch,
    FatArrow,
    Underscore,
    AmpAmp,
    PipePipe,
    Percent,
    Amp,
    Pipe,
    Caret,
    LtLt,
    GtGt,
    KwBreak,
    KwContinue,
    Question,
    KwTrait,
    KwType,
    KwUse,
    KwMod,
    KwConst,
    KwAsync,
    KwAwait,
    KwYield,
    KwDyn,
    // Actor model keywords
    KwActor,
    KwReceive,
    KwInit,
    // AI/Cognitive keywords
    KwSpecialist,
    KwInfer,
    KwHive,
    // Mutable binding
    KwVar,
    // Spawn expression
    KwSpawn
}

// AST node tags - using i64 since stage1 doesn't have proper enums for everything
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }
fn TAG_TRAIT() -> i64 { 4 }
fn TAG_IMPL_TRAIT() -> i64 { 5 }  // impl Trait for Type
fn TAG_MOD() -> i64 { 6 }         // mod name;
fn TAG_USE() -> i64 { 7 }         // use name::item;
fn TAG_ACTOR() -> i64 { 8 }       // actor definition
fn TAG_SPECIALIST() -> i64 { 9 }  // AI specialist
fn TAG_HIVE() -> i64 { 10 }       // cognitive hive

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }
fn EXPR_TRY() -> i64 { 16 }  // expr? - early return on error
fn EXPR_AWAIT() -> i64 { 17 }  // expr.await - await future
fn EXPR_FSTRING() -> i64 { 18 }  // f"..." - interpolated string
fn EXPR_YIELD() -> i64 { 19 }    // yield expr - generator yield
fn EXPR_SPAWN() -> i64 { 20 }    // spawn Type - spawn actor/specialist
fn EXPR_ARRAY() -> i64 { 21 }    // [a, b, c] - array literal
fn EXPR_FLOAT() -> i64 { 22 }    // floating point literal
fn EXPR_CLOSURE() -> i64 { 23 }  // (params) => expr - closure/lambda

// Parser state - we pass this to all functions
fn parser_new(tokens: i64) -> i64 {
    // Allocate parser: tokens(0), pos(1), len(2), errors(3)
    let parser: i64 = malloc(32);
    store_ptr(parser, 0, tokens);
    store_i64(parser, 1, 0);
    let len: i64 = vec_len(tokens);
    store_i64(parser, 2, len);
    store_i64(parser, 3, 0);
    parser
}

fn parser_error_count(parser: i64) -> i64 {
    load_i64(parser, 3)
}

fn parser_add_error(parser: i64, msg: i64) -> i64 {
    let count: i64 = load_i64(parser, 3);
    store_i64(parser, 3, count + 1);
    println(string_concat(string_from("Parse error: "), msg));
    0
}

fn parser_tokens(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn parser_pos(parser: i64) -> i64 {
    load_i64(parser, 1)
}

fn parser_len(parser: i64) -> i64 {
    load_i64(parser, 2)
}

fn parser_at_end(parser: i64) -> bool {
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    pos >= len
}

fn parser_current(parser: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    vec_get(tokens, pos)
}

// Peek ahead n tokens (0 = current, 1 = next, etc.)
fn parser_peek(parser: i64, n: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    if pos + n >= len {
        return 0;  // Return null for out of bounds
    }
    vec_get(tokens, pos + n)
}

// Check if token at offset n has the given kind
fn parser_peek_check(parser: i64, n: i64, kind: i64) -> bool {
    let tok: i64 = parser_peek(parser, n);
    if tok == 0 { return false; }
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_advance(parser: i64) -> i64 {
    let tok: i64 = parser_current(parser);
    let pos: i64 = parser_pos(parser);
    store_i64(parser, 1, pos + 1);
    tok
}

fn parser_check(parser: i64, kind: i64) -> bool {
    if parser_at_end(parser) { return false; }
    let tok: i64 = parser_current(parser);
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_match(parser: i64, kind: i64) -> bool {
    if parser_check(parser, kind) {
        parser_advance(parser);
        return true;
    }
    false
}

fn parser_expect(parser: i64, kind: i64) -> i64 {
    if parser_check(parser, kind) {
        return parser_advance(parser);
    }
    // Error - report and continue
    parser_add_error(parser, string_from("unexpected token"));
    0
}

// AST node constructors

// Item: FnDef
// Layout: tag(0), name(1), type_params(2), params(3), ret_ty(4), body(5)
fn ast_fn_def(name: i64, type_params: i64, params: i64, ret_ty: i64, body: i64, is_async: i64) -> i64 {
    let node: i64 = malloc(56);
    store_i64(node, 0, TAG_FN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);  // vec of type param names, or 0 for non-generic
    store_ptr(node, 3, params);
    store_ptr(node, 4, ret_ty);
    store_ptr(node, 5, body);
    store_i64(node, 6, is_async);     // 1 if async fn, 0 otherwise
    node
}

fn ast_fn_is_async(node: i64) -> i64 {
    load_i64(node, 6)
}

// Item: EnumDef
// Layout: tag(0), name(1), variants(2)
fn ast_enum_def(name: i64, variants: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_ENUM());
    store_ptr(node, 1, name);
    store_ptr(node, 2, variants);
    node
}

// Stmt: Let
// Layout: tag(0), name(1), ty(2), init_expr(3)
fn ast_let(name: i64, ty: i64, init_expr: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, STMT_LET());
    store_ptr(node, 1, name);
    store_ptr(node, 2, ty);
    store_ptr(node, 3, init_expr);
    node
}

// Stmt: Expr
// Layout: tag(0), expr(1)
fn ast_expr_stmt(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_EXPR());
    store_ptr(node, 1, expr);
    node
}

// Stmt: Return
// Layout: tag(0), expr(1)
fn ast_return(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_RETURN());
    store_ptr(node, 1, expr);
    node
}

fn ast_break() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_BREAK());
    node
}

fn ast_continue() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_CONTINUE());
    node
}

// Stmt: Assign
// Layout: tag(0), name(1), value(2)
fn ast_assign(name: i64, value: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, STMT_ASSIGN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, value);
    node
}

// Expr: Int literal
// Layout: tag(0), value(1)
fn ast_int(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INT());
    store_i64(node, 1, value);
    node
}

// Expr: Bool literal
// Layout: tag(0), value(1)
fn ast_bool(value: bool) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BOOL());
    store_i64(node, 1, value);
    node
}

// Expr: String literal
// Layout: tag(0), value(1)
fn ast_string(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_STRING());
    store_ptr(node, 1, value);
    node
}

// Expr: FString (interpolated string)
// Layout: tag(0), parts(1), exprs(2)
// parts is a vec of string segments, exprs is a vec of expressions
fn ast_fstring(parts: i64, exprs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FSTRING());
    store_ptr(node, 1, parts);
    store_ptr(node, 2, exprs);
    node
}

// Expr: Identifier
// Layout: tag(0), name(1)
fn ast_ident(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_IDENT());
    store_ptr(node, 1, name);
    node
}

// Expr: Path (Type::Variant)
// Layout: tag(0), segments(1)
fn ast_path(segments: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_PATH());
    store_ptr(node, 1, segments);
    node
}

// Expr: Call
// Layout: tag(0), callee(1), args(2), type_args(3)
fn ast_call(callee: i64, args: i64) -> i64 {
    ast_call_generic(callee, args, 0)
}

fn ast_call_generic(callee: i64, args: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_CALL());
    store_ptr(node, 1, callee);
    store_ptr(node, 2, args);
    store_ptr(node, 3, type_args);  // vec of type names, or 0 for non-generic
    node
}

// Expr: Binary
// Layout: tag(0), op(1), left(2), right(3)
fn ast_binary(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_BINARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, left);
    store_ptr(node, 3, right);
    node
}

// Expr: Unary
// Layout: tag(0), op(1), operand(2)
fn ast_unary(op: i64, operand: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_UNARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, operand);
    node
}

// Expr: If
// Layout: tag(0), cond(1), then_block(2), else_block(3)
fn ast_if(cond: i64, then_block: i64, else_block: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_IF());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, then_block);
    store_ptr(node, 3, else_block);
    node
}

// Expr: While
// Layout: tag(0), cond(1), body(2)
fn ast_while(cond: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_WHILE());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, body);
    node
}

// Expr: For (range-based)
// Layout: tag(0), var_name(1), start(2), end(3), body(4)
fn ast_for(var_name: i64, start: i64, end: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, EXPR_FOR());
    store_ptr(node, 1, var_name);
    store_ptr(node, 2, start);
    store_ptr(node, 3, end);
    store_ptr(node, 4, body);
    node
}

// Expr: Match
// Layout: tag(0), scrutinee(1), arms(2)
// Each arm is (pattern, result) where pattern is an expr (Ident for wildcards, Path for enum variants)
fn ast_match(scrutinee: i64, arms: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_MATCH());
    store_ptr(node, 1, scrutinee);
    store_ptr(node, 2, arms);
    node
}

// Match arm: pattern(0), result(1)
fn ast_match_arm(pattern: i64, result: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, pattern);
    store_ptr(node, 1, result);
    node
}

// Expr: Block
// Layout: tag(0), stmts(1), result(2)
fn ast_block(stmts: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_BLOCK());
    store_ptr(node, 1, stmts);
    store_ptr(node, 2, result);
    node
}

// Item: StructDef
// Layout: tag(0), name(1), type_params(2), fields(3)
// type_params is vec of type param names, or 0 for non-generic
// fields is vec of (name, type) pairs
fn ast_struct_def(name: i64, type_params: i64, fields: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_STRUCT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);
    store_ptr(node, 3, fields);
    node
}

// Item: Impl block
// Layout: tag(0), type_name(1), methods(2)
fn ast_impl(type_name: i64, methods: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_IMPL());
    store_ptr(node, 1, type_name);
    store_ptr(node, 2, methods);
    node
}

// Item: Trait definition
// Layout: tag(0), name(1), method_sigs(2)
fn ast_trait(name: i64, method_sigs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_TRAIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, method_sigs);  // vec of fn signatures (name, params, ret_ty)
    node
}

// Item: Impl Trait for Type
// Layout: tag(0), trait_name(1), type_name(2), methods(3), assoc_types(4)
fn ast_impl_trait(trait_name: i64, type_name: i64, methods: i64, assoc_types: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_IMPL_TRAIT());
    store_ptr(node, 1, trait_name);
    store_ptr(node, 2, type_name);
    store_ptr(node, 3, methods);
    store_ptr(node, 4, assoc_types);  // vec of (name, type) pairs
    node
}

// Associated type mapping
// Layout: name(0), type(1)
fn ast_assoc_type(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Method signature (for traits)
// Layout: name(0), params(1), ret_ty(2)
fn ast_method_sig(name: i64, params: i64, ret_ty: i64) -> i64 {
    let node: i64 = malloc(24);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    node
}

// Default method (trait method with body)
// Layout: name(0), params(1), ret_ty(2), fn_def(3)
fn ast_default_method(name: i64, params: i64, ret_ty: i64, fn_def: i64) -> i64 {
    let node: i64 = malloc(32);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    store_ptr(node, 3, fn_def);
    node
}

// Item: Module declaration (mod name;)
// Layout: tag(0), name(1)
fn ast_mod(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_MOD());
    store_ptr(node, 1, name);
    node
}

// Item: Use statement (use path::item;)
// Layout: tag(0), path(1)  -- path is vec of strings
fn ast_use(path: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_USE());
    store_ptr(node, 1, path);
    node
}

// Item: Actor definition
// Layout: tag(0), name(1), state_fields(2), receive_handlers(3), init_fn(4)
fn ast_actor(name: i64, state_fields: i64, handlers: i64, init_fn: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_ACTOR());
    store_ptr(node, 1, name);
    store_ptr(node, 2, state_fields);
    store_ptr(node, 3, handlers);
    store_ptr(node, 4, init_fn);
    node
}

// Item: AI Specialist definition
// Layout: tag(0), name(1), capabilities(2), knowledge(3), methods(4)
fn ast_specialist(name: i64, config: i64, state_fields: i64, handlers: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_SPECIALIST());
    store_ptr(node, 1, name);
    store_ptr(node, 2, config);
    store_ptr(node, 3, state_fields);
    store_ptr(node, 4, handlers);
    node
}

// Item: Cognitive Hive definition
// Layout: tag(0), name(1), specialists(2), routing(3)
fn ast_hive(name: i64, specialists: i64, routing: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_HIVE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, specialists);
    store_ptr(node, 3, routing);
    node
}

// Expr: StructLit
// Layout: tag(0), name(1), field_inits(2), type_args(3)
// field_inits is vec of (name, expr) pairs
fn ast_struct_lit(name: i64, field_inits: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_STRUCT_LIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, field_inits);
    store_ptr(node, 3, type_args);
    node
}

// Expr: FieldAccess
// Layout: tag(0), object(1), field_name(2)
fn ast_field_access(object: i64, field_name: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FIELD());
    store_ptr(node, 1, object);
    store_ptr(node, 2, field_name);
    node
}

// Expr: MethodCall
// Layout: tag(0), object(1), method_name(2), args(3)
fn ast_method_call(object: i64, method_name: i64, args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_METHOD_CALL());
    store_ptr(node, 1, object);
    store_ptr(node, 2, method_name);
    store_ptr(node, 3, args);
    node
}

// Expr: Try (? operator)
// Layout: tag(0), inner(1)
fn ast_try(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_TRY());
    store_ptr(node, 1, inner);
    node
}

// Expr: Await (.await)
// Layout: tag(0), inner(1)
fn ast_await(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_AWAIT());
    store_ptr(node, 1, inner);
    node
}

// Expr: Yield (yield expr)
// Layout: tag(0), inner(1)
fn ast_yield(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_YIELD());
    store_ptr(node, 1, inner);
    node
}

// Expr: Spawn (spawn TypeName)
// Layout: tag(0), type_name(1)
fn ast_spawn(type_name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_SPAWN());
    store_ptr(node, 1, type_name);
    node
}

// Expr: Array literal [a, b, c]
// Layout: tag(0), elements(1)
fn ast_array(elements: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_ARRAY());
    store_ptr(node, 1, elements);
    node
}

// Expr: Float literal
// Layout: tag(0), text(1) - store as string for precision
fn ast_float(text: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_FLOAT());
    store_ptr(node, 1, text);
    node
}

// Param: name, type
// Layout: name(0), ty(1)
fn ast_param(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Closure: (params) => body
// Layout: tag(0), params(1), body(2)
fn ast_closure(params: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_CLOSURE());
    store_ptr(node, 1, params);
    store_ptr(node, 2, body);
    node
}

// Binary operator codes
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }

// Unary operator codes
fn OP_NEG() -> i64 { 0 }
fn OP_NOT() -> i64 { 1 }

// Parse f-string content into parts and expressions
// Content like "Hello {name}, you are {age} years old" becomes:
// parts = ["Hello ", ", you are ", " years old"]
// exprs = [ident(name), ident(age)]
fn parse_fstring(parser: i64, content: i64) -> i64 {
    let parts: i64 = vec_new();
    let exprs: i64 = vec_new();
    let current: i64 = string_from("");
    let len: i64 = string_len(content);
    let i: i64 = 0;

    while i < len {
        let c: i64 = string_char_at(content, i);
        if c == 123 {  // '{'
            // Found expression start
            vec_push(parts, current);
            current = string_from("");
            i = i + 1;

            // Extract expression text until '}'
            let expr_text: i64 = string_from("");
            let depth: i64 = 1;
            while i < len {
                let ec: i64 = string_char_at(content, i);
                if ec == 123 {
                    depth = depth + 1;
                    expr_text = string_concat(expr_text, string_from_char(ec));
                } else {
                    if ec == 125 {  // '}'
                        depth = depth - 1;
                        if depth == 0 {
                            i = i + 1;
                            break;
                        }
                        expr_text = string_concat(expr_text, string_from_char(ec));
                    } else {
                        expr_text = string_concat(expr_text, string_from_char(ec));
                    }
                }
                i = i + 1;
            }

            // Parse the expression text
            // For now, just treat it as an identifier for simple cases
            // TODO: Full expression parsing inside f-strings
            vec_push(exprs, ast_ident(expr_text));
        } else {
            current = string_concat(current, string_from_char(c));
            i = i + 1;
        }
    }

    // Add remaining part
    vec_push(parts, current);

    return ast_fstring(parts, exprs);
}

// Parse primary expression
fn parse_primary(parser: i64) -> i64 {
    // Float literal (check before Int to handle properly)
    if parser_check(parser, TokenKind::Float) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_float(text);
    }

    // Integer literal
    if parser_check(parser, TokenKind::Int) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        let value: i64 = string_to_int(text);
        return ast_int(value);
    }

    // Boolean literals
    if parser_check(parser, TokenKind::KwTrue) {
        parser_advance(parser);
        return ast_bool(true);
    }
    if parser_check(parser, TokenKind::KwFalse) {
        parser_advance(parser);
        return ast_bool(false);
    }

    // String literal
    if parser_check(parser, TokenKind::String) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_string(text);
    }

    // FString literal (interpolated string)
    if parser_check(parser, TokenKind::FString) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return parse_fstring(parser, text);
    }

    // Yield expression (for generators)
    if parser_check(parser, TokenKind::KwYield) {
        parser_advance(parser);
        let inner: i64 = parse_expr(parser);
        return ast_yield(inner);
    }

    // Spawn expression (spawn TypeName)
    if parser_check(parser, TokenKind::KwSpawn) {
        parser_advance(parser);
        let type_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_tok);
        return ast_spawn(type_name);
    }

    // Array literal [a, b, c]
    if parser_check(parser, TokenKind::LBracket) {
        parser_advance(parser);
        let elements: i64 = vec_new();
        if parser_check(parser, TokenKind::RBracket) == false {
            let first: i64 = parse_expr(parser);
            vec_push(elements, first);
            while parser_match(parser, TokenKind::Comma) {
                let elem: i64 = parse_expr(parser);
                vec_push(elements, elem);
            }
        }
        parser_expect(parser, TokenKind::RBracket);
        return ast_array(elements);
    }

    // 'self' keyword as identifier
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        return ast_ident(string_from("self"));
    }

    // Identifier or path
    if parser_check(parser, TokenKind::Ident) {
        let tok: i64 = parser_advance(parser);
        let name: i64 = token_text(tok);

        // Check for turbofish syntax: foo::<T1, T2>(args)
        // Must check before path handling because :: followed by < is turbofish, not path
        let call_type_args: i64 = 0;
        if parser_check(parser, TokenKind::DoubleColon) {
            // Peek ahead: if next is < then it's turbofish, otherwise it's a path
            // We need to consume :: and check
            parser_advance(parser);
            if parser_check(parser, TokenKind::Lt) {
                // Turbofish!
                parser_advance(parser);
                call_type_args = vec_new();
                // Parse type arguments (can be Ident or Int for const generics)
                if parser_check(parser, TokenKind::Ident) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else if parser_check(parser, TokenKind::Int) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else {
                    parser_add_error(parser, "Expected type or const value");
                }
                while parser_match(parser, TokenKind::Comma) {
                    if parser_check(parser, TokenKind::Ident) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else if parser_check(parser, TokenKind::Int) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else {
                        parser_add_error(parser, "Expected type or const value");
                    }
                }
                parser_expect(parser, TokenKind::Gt);
            } else {
                // Path - could be Type::Variant or Type::function()
                if parser_check(parser, TokenKind::Ident) {
                    let seg_tok: i64 = parser_advance(parser);
                    let seg_name: i64 = token_text(seg_tok);

                    // Check if followed by ( for associated function call
                    if parser_check(parser, TokenKind::LParen) {
                        // Type::function(args) - mangle to Type_function
                        let mangled_name: i64 = string_concat(name, "_");
                        mangled_name = string_concat(mangled_name, seg_name);
                        parser_advance(parser);  // consume (
                        let args: i64 = vec_new();
                        if parser_check(parser, TokenKind::RParen) == false {
                            let first_arg: i64 = parse_expr(parser);
                            vec_push(args, first_arg);
                            while parser_match(parser, TokenKind::Comma) {
                                let arg: i64 = parse_expr(parser);
                                vec_push(args, arg);
                            }
                        }
                        parser_expect(parser, TokenKind::RParen);
                        return ast_call(ast_ident(mangled_name), args);
                    }

                    // Path: Name::Variant (possibly with more segments)
                    let segments: i64 = vec_new();
                    vec_push(segments, name);
                    vec_push(segments, seg_name);

                    while parser_match(parser, TokenKind::DoubleColon) {
                        if parser_check(parser, TokenKind::Ident) {
                            let next_seg: i64 = parser_advance(parser);
                            vec_push(segments, token_text(next_seg));
                        }
                    }
                    return ast_path(segments);
                }
            }
        }

        // Check for function call
        if parser_check(parser, TokenKind::LParen) {
            parser_advance(parser);
            let args: i64 = vec_new();

            if parser_check(parser, TokenKind::RParen) {
                // Empty args
            } else {
                let first_arg: i64 = parse_expr(parser);
                vec_push(args, first_arg);

                while parser_match(parser, TokenKind::Comma) {
                    let arg: i64 = parse_expr(parser);
                    vec_push(args, arg);
                }
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_call_generic(ast_ident(name), args, call_type_args);
        }

        // Struct literal syntax: Name { field: value, ... }
        // Disambiguate from `if cond { ... }` by checking if { is followed by:
        // - `}` (empty struct literal)
        // - `Ident :` (field initialization)
        if parser_check(parser, TokenKind::LBrace) {
            // Look ahead to see if this is a struct literal
            let is_struct_lit: bool = false;

            // Check for empty struct: Name { }
            if parser_peek_check(parser, 1, TokenKind::RBrace) {
                is_struct_lit = true;
            }
            // Check for field init: Name { field: value }
            if parser_peek_check(parser, 1, TokenKind::Ident) {
                if parser_peek_check(parser, 2, TokenKind::Colon) {
                    is_struct_lit = true;
                }
            }

            if is_struct_lit {
                parser_advance(parser);  // consume {
                let field_inits: i64 = vec_new();

                while parser_check(parser, TokenKind::RBrace) == false {
                    // Parse field: name: value
                    let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let field_name: i64 = token_text(field_name_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let field_value: i64 = parse_expr(parser);

                    // Create field init pair (name, value)
                    let field_init: i64 = malloc(16);
                    store_ptr(field_init, 0, field_name);
                    store_ptr(field_init, 1, field_value);
                    vec_push(field_inits, field_init);

                    // Optional comma
                    if parser_check(parser, TokenKind::RBrace) == false {
                        parser_match(parser, TokenKind::Comma);
                    }
                }

                parser_expect(parser, TokenKind::RBrace);
                return ast_struct_lit(name, field_inits, call_type_args);
            }
        }

        return ast_ident(name);
    }

    // Parenthesized expression or closure: (expr) or (params) => body
    if parser_check(parser, TokenKind::LParen) {
        // Check if this is a closure: () => body or (x: i64) => body
        // Lookahead: if we see ) => or ident : after (, it's likely a closure
        let is_closure: bool = false;

        // () => body  - empty params closure
        if parser_peek_check(parser, 1, TokenKind::RParen) {
            if parser_peek_check(parser, 2, TokenKind::FatArrow) {
                is_closure = true;
            }
        }
        // (ident : type) => body  - closure with params
        if parser_peek_check(parser, 1, TokenKind::Ident) {
            if parser_peek_check(parser, 2, TokenKind::Colon) {
                is_closure = true;
            }
        }

        if is_closure {
            parser_advance(parser);  // consume (
            let params: i64 = vec_new();

            // Parse params if not empty
            if parser_check(parser, TokenKind::RParen) == false {
                // Parse first param: name : type
                let p_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let p_name: i64 = token_text(p_name_tok);
                parser_expect(parser, TokenKind::Colon);
                let p_type: i64 = parse_type(parser);
                vec_push(params, ast_param(p_name, p_type));

                // Parse more params
                while parser_match(parser, TokenKind::Comma) {
                    let pn_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let pn: i64 = token_text(pn_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let pt: i64 = parse_type(parser);
                    vec_push(params, ast_param(pn, pt));
                }
            }

            parser_expect(parser, TokenKind::RParen);
            parser_expect(parser, TokenKind::FatArrow);
            let body: i64 = parse_expr(parser);
            return ast_closure(params, body);
        }

        // Not a closure - parenthesized expression
        parser_advance(parser);  // consume (
        let expr: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return expr;
    }

    // If expression
    if parser_check(parser, TokenKind::KwIf) {
        return parse_if(parser);
    }

    // While expression
    if parser_check(parser, TokenKind::KwWhile) {
        return parse_while(parser);
    }

    // For expression
    if parser_check(parser, TokenKind::KwFor) {
        return parse_for(parser);
    }

    // Match expression
    if parser_check(parser, TokenKind::KwMatch) {
        return parse_match(parser);
    }

    // Block expression
    if parser_check(parser, TokenKind::LBrace) {
        return parse_block(parser);
    }

    // Error - advance past unrecognized token to prevent infinite loop
    if parser_at_end(parser) == false {
        parser_advance(parser);
    }
    0
}

// Parse postfix expression (field access: expr.field, method call: expr.method(args), try: expr?, await: expr.await)
fn parse_postfix(parser: i64) -> i64 {
    let expr: i64 = parse_primary(parser);

    while true {
        if parser_match(parser, TokenKind::Dot) {
            // Check for .await keyword
            if parser_check(parser, TokenKind::KwAwait) {
                parser_advance(parser);
                expr = ast_await(expr);
            } else {
                let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let name: i64 = token_text(name_tok);

                // Check if this is a method call (followed by '(')
                if parser_check(parser, TokenKind::LParen) {
                    parser_advance(parser);
                    let args: i64 = vec_new();

                    if parser_check(parser, TokenKind::RParen) {
                        // Empty args
                    } else {
                        let first_arg: i64 = parse_expr(parser);
                        vec_push(args, first_arg);

                        while parser_match(parser, TokenKind::Comma) {
                            let arg: i64 = parse_expr(parser);
                            vec_push(args, arg);
                        }
                    }

                    parser_expect(parser, TokenKind::RParen);
                    expr = ast_method_call(expr, name, args);
                } else {
                    // Field access
                    expr = ast_field_access(expr, name);
                }
            }
        } else {
            // Try operator: expr?
            if parser_match(parser, TokenKind::Question) {
                expr = ast_try(expr);
            } else {
                return expr;
            }
        }
    }

    expr
}

// Parse unary expression
fn parse_unary(parser: i64) -> i64 {
    if parser_match(parser, TokenKind::Minus) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NEG(), operand);
    }
    if parser_match(parser, TokenKind::Bang) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NOT(), operand);
    }
    parse_postfix(parser)
}

// Parse multiplicative expression
fn parse_multiplicative(parser: i64) -> i64 {
    let left: i64 = parse_unary(parser);

    while true {
        if parser_match(parser, TokenKind::Star) {
            let right: i64 = parse_unary(parser);
            left = ast_binary(OP_MUL(), left, right);
        } else {
            if parser_match(parser, TokenKind::Slash) {
                let right: i64 = parse_unary(parser);
                left = ast_binary(OP_DIV(), left, right);
            } else {
                if parser_match(parser, TokenKind::Percent) {
                    let right: i64 = parse_unary(parser);
                    left = ast_binary(OP_MOD(), left, right);
                } else {
                    return left;
                }
            }
        }
    }
    left
}

// Parse additive expression
fn parse_additive(parser: i64) -> i64 {
    let left: i64 = parse_multiplicative(parser);

    while true {
        if parser_match(parser, TokenKind::Plus) {
            let right: i64 = parse_multiplicative(parser);
            left = ast_binary(OP_ADD(), left, right);
        } else {
            if parser_match(parser, TokenKind::Minus) {
                let right: i64 = parse_multiplicative(parser);
                left = ast_binary(OP_SUB(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse shift expression (<< >>)
fn parse_shift(parser: i64) -> i64 {
    let left: i64 = parse_additive(parser);

    while true {
        if parser_match(parser, TokenKind::LtLt) {
            let right: i64 = parse_additive(parser);
            left = ast_binary(OP_SHL(), left, right);
        } else {
            if parser_match(parser, TokenKind::GtGt) {
                let right: i64 = parse_additive(parser);
                left = ast_binary(OP_SHR(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse comparison expression
fn parse_comparison(parser: i64) -> i64 {
    let left: i64 = parse_shift(parser);

    if parser_match(parser, TokenKind::EqEq) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_EQ(), left, right);
    }
    if parser_match(parser, TokenKind::Ne) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_NE(), left, right);
    }
    if parser_match(parser, TokenKind::Lt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LT(), left, right);
    }
    if parser_match(parser, TokenKind::Gt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GT(), left, right);
    }
    if parser_match(parser, TokenKind::Le) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LE(), left, right);
    }
    if parser_match(parser, TokenKind::Ge) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GE(), left, right);
    }
    left
}

// Parse bitwise AND expression (&)
fn parse_bitand(parser: i64) -> i64 {
    let left: i64 = parse_comparison(parser);

    while parser_match(parser, TokenKind::Amp) {
        let right: i64 = parse_comparison(parser);
        left = ast_binary(OP_BITAND(), left, right);
    }
    left
}

// Parse bitwise XOR expression (^)
fn parse_bitxor(parser: i64) -> i64 {
    let left: i64 = parse_bitand(parser);

    while parser_match(parser, TokenKind::Caret) {
        let right: i64 = parse_bitand(parser);
        left = ast_binary(OP_BITXOR(), left, right);
    }
    left
}

// Parse bitwise OR expression (|)
fn parse_bitor(parser: i64) -> i64 {
    let left: i64 = parse_bitxor(parser);

    while parser_match(parser, TokenKind::Pipe) {
        let right: i64 = parse_bitxor(parser);
        left = ast_binary(OP_BITOR(), left, right);
    }
    left
}

// Parse logical AND expression (&&)
fn parse_and(parser: i64) -> i64 {
    let left: i64 = parse_bitor(parser);

    while parser_match(parser, TokenKind::AmpAmp) {
        let right: i64 = parse_bitor(parser);
        left = ast_binary(OP_AND(), left, right);
    }
    left
}

// Parse logical OR expression (||)
fn parse_or(parser: i64) -> i64 {
    let left: i64 = parse_and(parser);

    while parser_match(parser, TokenKind::PipePipe) {
        let right: i64 = parse_and(parser);
        left = ast_binary(OP_OR(), left, right);
    }
    left
}

// Parse expression
fn parse_expr(parser: i64) -> i64 {
    parse_or(parser)
}

// Parse block
fn parse_block(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::LBrace);
    let stmts: i64 = vec_new();
    let result: i64 = 0;

    while true {
        // Check for EOF to prevent infinite loop on incomplete input
        if parser_at_end(parser) {
            return ast_block(stmts, result);
        }

        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_block(stmts, result);
        }

        // Check for statement vs expression
        if parser_check(parser, TokenKind::KwLet) {
            let stmt: i64 = parse_let(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwVar) {
            // var is like let but for mutable bindings
            let stmt: i64 = parse_var(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwReturn) {
            let stmt: i64 = parse_return(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwBreak) {
            parser_advance(parser);
            parser_expect(parser, TokenKind::Semi);
            let stmt: i64 = ast_break();
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwContinue) {
            parser_advance(parser);
            parser_expect(parser, TokenKind::Semi);
            let stmt: i64 = ast_continue();
            vec_push(stmts, stmt);
        } else {
            // Expression - could be statement, assignment, or result
            let expr: i64 = parse_expr(parser);

            // Check for assignment: ident = expr;
            if parser_match(parser, TokenKind::Eq) {
                // This is an assignment statement
                // expr should be an identifier
                let expr_tag: i64 = load_i64(expr, 0);
                if expr_tag == EXPR_IDENT() {
                    let name: i64 = load_ptr(expr, 1);
                    let value: i64 = parse_expr(parser);
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_assign(name, value));
                } else {
                    // Invalid assignment target, treat as expression
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_expr_stmt(expr));
                }
            } else {
                if parser_match(parser, TokenKind::Semi) {
                    // Expression statement with explicit semicolon
                    vec_push(stmts, ast_expr_stmt(expr));
                } else {
                    // No semicolon - check if more statements follow
                    if parser_check(parser, TokenKind::RBrace) {
                        // Next is }, so this is the result expression
                        result = expr;
                    } else {
                        // More statements follow, so this is an implicit statement
                        // (if/while don't need semicolons when followed by more code)
                        vec_push(stmts, ast_expr_stmt(expr));
                    }
                }
            }
        }
        }
        }
        }
        }
    }

    ast_block(stmts, result)
}

// Parse var statement (mutable binding)
fn parse_var(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwVar);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse if expression
fn parse_if(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwIf);
    let cond: i64 = parse_expr(parser);
    let then_block: i64 = parse_block(parser);
    let else_block: i64 = 0;

    if parser_match(parser, TokenKind::KwElse) {
        // Check if it's else-if or else block
        if parser_check(parser, TokenKind::KwIf) {
            else_block = parse_if(parser);
        } else {
            else_block = parse_block(parser);
        }
    }

    ast_if(cond, then_block, else_block)
}

// Parse while expression
fn parse_while(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwWhile);
    let cond: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_while(cond, body)
}

// Parse for expression: for i in start..end { body }
fn parse_for(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFor);
    let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let var_name: i64 = token_text(var_tok);
    parser_expect(parser, TokenKind::KwIn);
    let start: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::DotDot);
    let end: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_for(var_name, start, end, body)
}

// Parse match expression: match expr { pattern => result, ... }
fn parse_match(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMatch);
    let scrutinee: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::LBrace);

    let arms: i64 = vec_new();

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_match(scrutinee, arms);
        }

        // Parse pattern - could be:
        // - Underscore: wildcard
        // - Path: EnumName::Variant
        // - Ident: variable or enum variant
        let pattern: i64 = 0;
        if parser_match(parser, TokenKind::Underscore) {
            // Wildcard pattern - use null to indicate wildcard
            pattern = 0;
        } else {
            // Parse as expression (will handle paths and identifiers)
            pattern = parse_expr(parser);
        }

        parser_expect(parser, TokenKind::FatArrow);

        // Parse arm result (could be block or expression)
        let result: i64 = 0;
        if parser_check(parser, TokenKind::LBrace) {
            result = parse_block(parser);
        } else {
            result = parse_expr(parser);
        }

        vec_push(arms, ast_match_arm(pattern, result));

        // Optional comma between arms
        parser_match(parser, TokenKind::Comma);
    }

    ast_match(scrutinee, arms)
}

// Parse let statement
fn parse_let(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwLet);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse return statement
fn parse_return(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwReturn);
    let expr: i64 = 0;

    if parser_check(parser, TokenKind::Semi) {
        // return;
    } else {
        expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_return(expr)
}

// Parse type: handles simple idents, Self, Self::AssocType, and dyn Trait
fn parse_type(parser: i64) -> i64 {
    // Check for dyn keyword (dynamic trait object)
    if parser_check(parser, TokenKind::KwDyn) {
        parser_advance(parser);  // consume 'dyn'
        let trait_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let trait_name: i64 = token_text(trait_tok);
        // Return "dyn:TraitName" as the type string - will be resolved in codegen
        return string_concat(string_from("dyn:"), trait_name);
    }
    // Check for Self keyword
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        // Check for Self::AssocType syntax
        if parser_check(parser, TokenKind::DoubleColon) {
            parser_advance(parser);  // consume ::
            let assoc_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let assoc_name: i64 = token_text(assoc_tok);
            // Return "Self::TypeName" as the type string - will be resolved in codegen
            return string_concat(string_from("Self::"), assoc_name);
        }
        // Just Self - refers to the implementing type
        return string_from("Self");
    }
    // Regular identifier type
    let tok: i64 = parser_expect(parser, TokenKind::Ident);
    let type_name: i64 = token_text(tok);

    // Phase 36: Handle generic type arguments like Option<i64>, Result<T, E>, Vec<T>
    if parser_check(parser, TokenKind::Lt) {
        parser_advance(parser);  // consume <
        let type_args: i64 = vec_new();

        // First type argument
        let first_arg: i64 = parse_type(parser);
        vec_push(type_args, first_arg);

        // Additional type arguments
        while parser_match(parser, TokenKind::Comma) {
            let arg: i64 = parse_type(parser);
            vec_push(type_args, arg);
        }

        parser_expect(parser, TokenKind::Gt);

        // Build type string: Name<Arg1, Arg2, ...>
        let result: i64 = string_concat(type_name, string_from("<"));
        let n: i64 = vec_len(type_args);
        let i: i64 = 0;
        while i < n {
            if i > 0 {
                result = string_concat(result, string_from(", "));
            }
            result = string_concat(result, vec_get(type_args, i));
            i = i + 1;
        }
        result = string_concat(result, string_from(">"));
        return result;
    }

    type_name
}

// Parse function parameters
fn parse_params(parser: i64) -> i64 {
    let params: i64 = vec_new();
    parser_expect(parser, TokenKind::LParen);

    if parser_check(parser, TokenKind::RParen) {
        parser_advance(parser);
        return params;
    }

    // First param - accept either Ident or 'self' keyword
    let name: i64 = 0;
    let ty: i64 = 0;
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        name = string_from("self");
        // Check if self has explicit type (self: Type) or implicit (bare self)
        if parser_check(parser, TokenKind::Colon) {
            parser_advance(parser);
            ty = parse_type(parser);
        } else {
            // Bare self - type is implicit (Self)
            ty = string_from("Self");
        }
    } else {
        let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        name = token_text(name_tok);
        parser_expect(parser, TokenKind::Colon);
        ty = parse_type(parser);
    }
    vec_push(params, ast_param(name, ty));

    // More params
    while parser_match(parser, TokenKind::Comma) {
        let pname: i64 = 0;
        let pty: i64 = 0;
        if parser_check(parser, TokenKind::KwSelf) {
            parser_advance(parser);
            pname = string_from("self");
            if parser_check(parser, TokenKind::Colon) {
                parser_advance(parser);
                pty = parse_type(parser);
            } else {
                pty = string_from("Self");
            }
        } else {
            let pname_tok: i64 = parser_expect(parser, TokenKind::Ident);
            pname = token_text(pname_tok);
            parser_expect(parser, TokenKind::Colon);
            pty = parse_type(parser);
        }
        vec_push(params, ast_param(pname, pty));
    }

    parser_expect(parser, TokenKind::RParen);
    params
}

// Parse type parameters: <T, U, V> or <T: Trait, U: Bound>
// Returns a vec of type param strings. For bounded params, stores as "name:bound"
// For const params, stores as "const:name"
fn parse_type_params(parser: i64) -> i64 {
    if parser_check(parser, TokenKind::Lt) == false {
        return 0;  // No type params
    }
    parser_advance(parser);  // consume <

    let type_params: i64 = vec_new();

    // First type param (may be const or type with optional bound)
    if parser_check(parser, TokenKind::KwConst) {
        // const N: Type
        parser_advance(parser);
        let tok: i64 = parser_expect(parser, TokenKind::Ident);
        parser_expect(parser, TokenKind::Colon);
        parse_type(parser);  // Skip the type for now
        // Store with "const:" prefix to distinguish
        vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
    } else {
        if parser_check(parser, TokenKind::Ident) {
            let tok: i64 = parser_advance(parser);
            let param_name: i64 = token_text(tok);
            // Check for trait bound: T: Trait
            if parser_match(parser, TokenKind::Colon) {
                if parser_check(parser, TokenKind::Ident) {
                    let bound_tok: i64 = parser_advance(parser);
                    // Store as "T:Trait" - type param with bound
                    param_name = string_concat(param_name, ":");
                    param_name = string_concat(param_name, token_text(bound_tok));
                    // Handle additional bounds with + (e.g., T: A + B)
                    while parser_match(parser, TokenKind::Plus) {
                        if parser_check(parser, TokenKind::Ident) {
                            let extra_bound: i64 = parser_advance(parser);
                            param_name = string_concat(param_name, "+");
                            param_name = string_concat(param_name, token_text(extra_bound));
                        }
                    }
                }
            }
            vec_push(type_params, param_name);
        }
    }

    // Additional type params
    while parser_match(parser, TokenKind::Comma) {
        if parser_check(parser, TokenKind::KwConst) {
            parser_advance(parser);
            let tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Colon);
            parse_type(parser);
            vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
        } else {
            if parser_check(parser, TokenKind::Ident) {
                let tok: i64 = parser_advance(parser);
                let param_name: i64 = token_text(tok);
                // Check for trait bound
                if parser_match(parser, TokenKind::Colon) {
                    if parser_check(parser, TokenKind::Ident) {
                        let bound_tok: i64 = parser_advance(parser);
                        param_name = string_concat(param_name, ":");
                        param_name = string_concat(param_name, token_text(bound_tok));
                        while parser_match(parser, TokenKind::Plus) {
                            if parser_check(parser, TokenKind::Ident) {
                                let extra_bound: i64 = parser_advance(parser);
                                param_name = string_concat(param_name, "+");
                                param_name = string_concat(param_name, token_text(extra_bound));
                            }
                        }
                    }
                }
                vec_push(type_params, param_name);
            }
        }
    }

    parser_expect(parser, TokenKind::Gt);
    type_params
}

// Parse function definition (is_async: 1 if preceded by async keyword)
fn parse_fn(parser: i64, is_async: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFn);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let params: i64 = parse_params(parser);

    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    let body: i64 = parse_block(parser);
    ast_fn_def(name, type_params, params, ret_ty, body, is_async)
}

// Parse enum definition
fn parse_enum(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwEnum);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let variants: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_enum_def(name, variants);
        }

        let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let var_name: i64 = token_text(var_tok);
        vec_push(variants, var_name);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_enum_def(name, variants)
}

// Parse struct definition with optional type parameters
// struct Name<T, U> { field: T, ... }
fn parse_struct(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwStruct);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let fields: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_struct_def(name, type_params, fields);
        }

        // Parse field: name: Type
        let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let field_name: i64 = token_text(field_name_tok);
        parser_expect(parser, TokenKind::Colon);
        let field_ty: i64 = parse_type(parser);

        // Create field pair (name, type)
        let field: i64 = malloc(16);
        store_ptr(field, 0, field_name);
        store_ptr(field, 1, field_ty);
        vec_push(fields, field);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_struct_def(name, type_params, fields)
}

// Parse trait definition: trait Name { type AssocType; fn method(...) -> Type; }
fn parse_trait(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwTrait);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let method_sigs: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_trait(name, method_sigs);
        }

        // Check for associated type: type Name;
        if parser_check(parser, TokenKind::KwType) {
            parser_advance(parser);
            let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Semi);
            // Store associated type as a method sig with null params (to distinguish)
            vec_push(method_sigs, ast_method_sig(token_text(type_name_tok), 0, 0));
        } else {
            // Parse method signature: fn name(params) -> Type;
            // OR default method: fn name(params) -> Type { body }
            let is_async: i64 = 0;
            if parser_check(parser, TokenKind::KwAsync) {
                parser_advance(parser);
                is_async = 1;
            }
            parser_expect(parser, TokenKind::KwFn);
            let method_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let method_name: i64 = token_text(method_name_tok);
            let params: i64 = parse_params(parser);

            let ret_ty: i64 = 0;
            if parser_match(parser, TokenKind::Arrow) {
                ret_ty = parse_type(parser);
            }

            // Check for semicolon (signature only) or brace (default impl)
            if parser_check(parser, TokenKind::Semi) {
                parser_advance(parser);
                vec_push(method_sigs, ast_method_sig(method_name, params, ret_ty));
            } else if parser_check(parser, TokenKind::LBrace) {
                // Default method implementation - parse full function
                let body: i64 = parse_block(parser);
                let default_fn: i64 = ast_fn_def(method_name, 0, params, ret_ty, body, is_async);
                // Store default method (with body field set)
                vec_push(method_sigs, ast_default_method(method_name, params, ret_ty, default_fn));
            }
        }
    }

    ast_trait(name, method_sigs)
}

// Parse impl block: impl TypeName { ... } or impl TraitName for TypeName { ... }
fn parse_impl(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwImpl);
    let first_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let first_name: i64 = token_text(first_name_tok);

    // Check if this is "impl Trait for Type" syntax
    if parser_check(parser, TokenKind::KwFor) {
        parser_advance(parser);  // consume 'for'
        let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_name_tok);

        let methods: i64 = vec_new();
        let assoc_types: i64 = vec_new();
        parser_expect(parser, TokenKind::LBrace);

        while parser_check(parser, TokenKind::RBrace) == false {
            parser_match(parser, TokenKind::KwPub);
            // Check for associated type definition: type Name = Type;
            if parser_check(parser, TokenKind::KwType) {
                parser_advance(parser);
                let assoc_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let assoc_name: i64 = token_text(assoc_name_tok);
                parser_expect(parser, TokenKind::Eq);     // =
                let assoc_ty: i64 = parse_type(parser);   // Type
                parser_expect(parser, TokenKind::Semi);   // ;
                // Store the associated type mapping
                vec_push(assoc_types, ast_assoc_type(assoc_name, assoc_ty));
            } else {
                // Check for async fn
                let is_async: i64 = 0;
                if parser_check(parser, TokenKind::KwAsync) {
                    parser_advance(parser);
                    is_async = 1;
                }
                let method: i64 = parse_fn(parser, is_async);
                vec_push(methods, method);
            }
        }
        parser_advance(parser);  // consume }

        return ast_impl_trait(first_name, type_name, methods, assoc_types);
    }

    // Regular impl block: impl TypeName { ... }
    let methods: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_impl(first_name, methods);
        }

        // Skip pub keyword if present
        parser_match(parser, TokenKind::KwPub);

        // Check for async fn
        let is_async: i64 = 0;
        if parser_check(parser, TokenKind::KwAsync) {
            parser_advance(parser);
            is_async = 1;
        }

        // Parse method (must be fn)
        if parser_check(parser, TokenKind::KwFn) {
            let method: i64 = parse_fn(parser, is_async);
            vec_push(methods, method);
        }
    }

    ast_impl(first_name, methods)
}

// Parse mod declaration: mod name;
fn parse_mod(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMod);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Semi);
    ast_mod(name)
}

// Parse use statement: use name::item;
fn parse_use(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwUse);
    let path: i64 = vec_new();

    // Parse first segment
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    vec_push(path, token_text(name_tok));

    // Parse remaining segments (::name)
    while parser_match(parser, TokenKind::DoubleColon) {
        let seg_tok: i64 = parser_expect(parser, TokenKind::Ident);
        vec_push(path, token_text(seg_tok));
    }

    parser_expect(parser, TokenKind::Semi);
    ast_use(path)
}

// Parse actor definition
// actor Name { var field: Type = init, init(params) { }, receive MsgName(params) -> RetType { } }
fn parse_actor(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwActor);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();
    let init_fn: i64 = 0;

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in actor"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for init block
        if parser_check(parser, TokenKind::KwInit) {
            parser_advance(parser);
            // parse_params handles LParen and RParen internally
            let init_params: i64 = parse_params(parser);
            let body: i64 = parse_block(parser);
            let init_node: i64 = malloc(16);
            store_ptr(init_node, 0, init_params);
            store_ptr(init_node, 1, body);
            init_fn = init_node;
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            let body: i64 = parse_block(parser);
            let handler: i64 = malloc(32);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            vec_push(handlers, handler);
        } else {
            parser_add_error(parser, string_from("Unexpected token in actor"));
            parser_advance(parser);
        }
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_actor(name, state_fields, handlers, init_fn)
}

// Parse specialist definition (like actor but with model config)
// specialist Name { model: "str", var field: Type = init, receive MsgName(params) -> RetType { } }
fn parse_specialist(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwSpecialist);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let config: i64 = vec_new();  // model config key-value pairs
    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in specialist"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            let body: i64 = parse_block(parser);
            let handler: i64 = malloc(32);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            vec_push(handlers, handler);
        } else {
            // Config property: name: value (string or number)
            let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let prop_name: i64 = token_text(prop_tok);
            parser_expect(parser, TokenKind::Colon);
            let prop_val: i64 = parse_expr(parser);
            let prop: i64 = malloc(16);
            store_ptr(prop, 0, prop_name);
            store_ptr(prop, 1, prop_val);
            vec_push(config, prop);
            parser_match(parser, TokenKind::Comma);
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_specialist(name, config, state_fields, handlers)
}

// Parse hive definition
// hive Name { specialists: [...], routing: { ... } }
fn parse_hive(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwHive);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let specialists: i64 = vec_new();
    let routing: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in hive"));
            return 0;
        }

        let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let prop_name: i64 = token_text(prop_tok);
        parser_expect(parser, TokenKind::Colon);

        // Parse array of specialist names or identifier value
        if parser_check(parser, TokenKind::LBracket) {
            parser_advance(parser);
            let items: i64 = vec_new();
            while parser_check(parser, TokenKind::RBracket) == false {
                let item_tok: i64 = parser_expect(parser, TokenKind::Ident);
                vec_push(items, token_text(item_tok));
                parser_match(parser, TokenKind::Comma);
            }
            parser_expect(parser, TokenKind::RBracket);

            if string_eq(prop_name, string_from("specialists")) {
                specialists = items;
            }
        } else {
            // Simple identifier value (router, strategy, etc.)
            if parser_check(parser, TokenKind::Ident) {
                let val_tok: i64 = parser_advance(parser);
                let val: i64 = token_text(val_tok);
                // Store in routing for now (we can extend later)
                vec_push(routing, prop_name);
                vec_push(routing, val);
            }
        }
        parser_match(parser, TokenKind::Comma);
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_hive(name, specialists, routing)
}

// Parse a single item (fn, enum, or struct)
fn parse_item(parser: i64) -> i64 {
    // Skip pub keyword if present
    parser_match(parser, TokenKind::KwPub);

    // Check for async fn
    if parser_check(parser, TokenKind::KwAsync) {
        parser_advance(parser);
        if parser_check(parser, TokenKind::KwFn) {
            return parse_fn(parser, 1);  // async fn
        }
        // async without fn - error
        parser_add_error(parser, string_from("expected 'fn' after 'async'"));
        return 0;
    }

    if parser_check(parser, TokenKind::KwFn) {
        return parse_fn(parser, 0);  // regular fn
    }
    if parser_check(parser, TokenKind::KwEnum) {
        return parse_enum(parser);
    }
    if parser_check(parser, TokenKind::KwStruct) {
        return parse_struct(parser);
    }
    if parser_check(parser, TokenKind::KwImpl) {
        return parse_impl(parser);
    }
    if parser_check(parser, TokenKind::KwTrait) {
        return parse_trait(parser);
    }
    if parser_check(parser, TokenKind::KwMod) {
        return parse_mod(parser);
    }
    if parser_check(parser, TokenKind::KwUse) {
        return parse_use(parser);
    }
    if parser_check(parser, TokenKind::KwActor) {
        return parse_actor(parser);
    }
    if parser_check(parser, TokenKind::KwSpecialist) {
        return parse_specialist(parser);
    }
    if parser_check(parser, TokenKind::KwHive) {
        return parse_hive(parser);
    }

    // Unknown item
    0
}

// Parse result: items(0), error_count(1)
fn parse_result_new(items: i64, error_count: i64) -> i64 {
    let result: i64 = malloc(16);
    store_ptr(result, 0, items);
    store_i64(result, 1, error_count);
    result
}

fn parse_result_items(result: i64) -> i64 {
    load_ptr(result, 0)
}

fn parse_result_errors(result: i64) -> i64 {
    load_i64(result, 1)
}

// Parse entire program
fn parse_program(tokens: i64) -> i64 {
    let parser: i64 = parser_new(tokens);
    let items: i64 = vec_new();

    while true {
        if parser_at_end(parser) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        // Skip EOF tokens
        if parser_check(parser, TokenKind::Eof) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        let item: i64 = parse_item(parser);
        if item != 0 {
            vec_push(items, item);
        } else {
            // Unknown item - skip token and report error
            parser_add_error(parser, string_from("unexpected token at top level"));
            parser_advance(parser);
        }
    }

    let errors: i64 = parser_error_count(parser);
    parse_result_new(items, errors)
}
// Simplex Code Generator
// Self-hosted LLVM IR generator supporting:
// - impl blocks, traits, for loops, match expressions
// - generic functions with monomorphization
// - struct literals and field access

// Codegen state
fn codegen_new() -> i64 {
    // Allocate codegen: output_sb(0), temp_counter(1), label_counter(2), enums(3), locals(4), strings(5), terminated(6), structs(7), var_types(8), loop_stack(9), loop_depth(10), pre_alloca_queue(11), module_name(12), generic_fns(13), instantiated(14), pending_instantiations(15), assoc_types(16), current_impl_type(17), const_params(18), type_params(19), generic_struct_templates(20), trait_impls(21), is_async_fn(22), async_state_counter(23), async_await_points(24), async_fn_name(25), default_methods(26), trait_defs(27), vtables(28)
    // Note: slot 0 is now a StringBuilder for O(n) instead of O(n) string building
    let cg: i64 = malloc(248);
    store_ptr(cg, 0, sb_new_cap(65536));
    store_i64(cg, 1, 0);
    store_i64(cg, 2, 0);
    store_ptr(cg, 3, vec_new());  // registered enums: vec of (name, variants)
    store_ptr(cg, 4, vec_new());  // local variables in current function
    store_ptr(cg, 5, vec_new());  // string constants: vec of string values
    store_i64(cg, 6, 0);          // terminated flag (set after ret)
    store_ptr(cg, 7, vec_new());  // registered structs: vec of (name, fields)
    store_ptr(cg, 8, vec_new());  // variable types: vec of (name, type_name) pairs
    store_ptr(cg, 9, vec_new());  // loop_stack: vec of (continue_label, break_label) pairs
    store_i64(cg, 10, 0);         // loop_depth: current depth in loop stack
    store_ptr(cg, 11, vec_new()); // pre_alloca_queue: pre-allocated local names in order
    store_ptr(cg, 12, string_from("mod")); // module_name: prefix for string constants
    store_ptr(cg, 13, vec_new()); // generic_fns: vec of (name, fn_def) pairs
    store_ptr(cg, 14, vec_new()); // instantiated: vec of mangled names already generated
    store_ptr(cg, 15, vec_new()); // pending_instantiations: vec of (mangled_name, fn_def, type_args)
    store_ptr(cg, 16, vec_new()); // assoc_types: vec of (impl_type::assoc_name, concrete_type) pairs
    store_ptr(cg, 17, 0);         // current_impl_type: type being implemented (for Self resolution)
    store_ptr(cg, 18, vec_new()); // const_params: vec of (name, value) pairs for current instantiation
    store_ptr(cg, 19, vec_new()); // type_params: vec of (name, concrete_type) pairs for current instantiation
    store_ptr(cg, 20, vec_new()); // generic_struct_templates: vec of (name, type_params, fields)
    store_ptr(cg, 21, vec_new()); // trait_impls: vec of (type_name, trait_name) pairs
    store_i64(cg, 22, 0);         // is_async_fn: flag for async function context
    store_i64(cg, 23, 0);         // async_state_counter: state number for async state machine
    store_ptr(cg, 24, vec_new()); // async_await_points: vec of await point info
    store_ptr(cg, 25, 0);         // async_fn_name: current async function name
    store_ptr(cg, 26, vec_new()); // default_methods: vec of (trait::method, fn_def) pairs
    store_ptr(cg, 27, vec_new()); // trait_defs: vec of (trait_name, method_sigs) for vtable layout
    store_ptr(cg, 28, vec_new()); // vtables: vec of (type_name, trait_name, vtable_global) pairs
    store_ptr(cg, 29, vec_new()); // pending_closures: vec of closure code strings
    store_i64(cg, 30, 0);         // closure_counter: unique ID for closures
    cg
}

// Async state accessors
fn cg_is_async_fn(cg: i64) -> i64 {
    load_i64(cg, 22)
}

fn cg_set_async_fn(cg: i64, is_async: i64) -> i64 {
    store_i64(cg, 22, is_async);
    0
}

fn cg_next_async_state(cg: i64) -> i64 {
    let state: i64 = load_i64(cg, 23);
    store_i64(cg, 23, state + 1);
    state
}

fn cg_reset_async_state(cg: i64) -> i64 {
    store_i64(cg, 23, 0);
    0
}

fn cg_async_await_points(cg: i64) -> i64 {
    load_ptr(cg, 24)
}

fn cg_add_await_point(cg: i64, state: i64, label: i64) -> i64 {
    let points: i64 = cg_async_await_points(cg);
    let point: i64 = malloc(16);
    store_i64(point, 0, state);
    store_ptr(point, 1, label);
    vec_push(points, point);
    0
}

fn cg_clear_await_points(cg: i64) -> i64 {
    store_ptr(cg, 24, vec_new());
    0
}

fn cg_async_fn_name(cg: i64) -> i64 {
    load_ptr(cg, 25)
}

fn cg_set_async_fn_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 25, name);
    0
}

fn cg_module_name(cg: i64) -> i64 {
    load_ptr(cg, 12)
}

fn cg_set_module_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 12, name);
    0
}

// Closure accessors
fn cg_pending_closures(cg: i64) -> i64 {
    load_ptr(cg, 29)
}

fn cg_add_closure(cg: i64, closure_code: i64) -> i64 {
    let closures: i64 = cg_pending_closures(cg);
    vec_push(closures, closure_code);
    0
}

fn cg_next_closure_id(cg: i64) -> i64 {
    let id: i64 = load_i64(cg, 30);
    store_i64(cg, 30, id + 1);
    id
}

// State management for closure generation
fn cg_get_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_set_output(cg: i64, sb: i64) -> i64 {
    store_ptr(cg, 0, sb);
    0
}

fn cg_get_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_set_locals(cg: i64, locals: i64) -> i64 {
    store_ptr(cg, 4, locals);
    0
}

fn cg_get_temp_counter(cg: i64) -> i64 {
    load_i64(cg, 1)
}

fn cg_set_temp_counter(cg: i64, val: i64) -> i64 {
    store_i64(cg, 1, val);
    0
}

fn cg_get_local_id(cg: i64) -> i64 {
    load_i64(cg, 2)
}

fn cg_set_local_id(cg: i64, val: i64) -> i64 {
    store_i64(cg, 2, val);
    0
}

fn cg_generic_fns(cg: i64) -> i64 {
    load_ptr(cg, 13)
}

fn cg_instantiated(cg: i64) -> i64 {
    load_ptr(cg, 14)
}

fn cg_pending_instantiations(cg: i64) -> i64 {
    load_ptr(cg, 15)
}

// Register a generic function definition
fn cg_register_generic(cg: i64, name: i64, fn_def: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, fn_def);
    vec_push(generics, pair);
    0
}

// Look up a generic function by name
fn cg_lookup_generic(cg: i64, name: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let n: i64 = vec_len(generics);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(generics, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Check if an instantiation has been generated
fn cg_is_instantiated(cg: i64, mangled_name: i64) -> bool {
    let instantiated: i64 = cg_instantiated(cg);
    let n: i64 = vec_len(instantiated);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(instantiated, i), mangled_name) {
            return true;
        }
        i = i + 1;
    }
    false
}

// Mark an instantiation as generated
fn cg_mark_instantiated(cg: i64, mangled_name: i64) -> i64 {
    vec_push(cg_instantiated(cg), mangled_name);
    0
}

// Queue a pending instantiation
fn cg_queue_instantiation(cg: i64, mangled_name: i64, fn_def: i64, type_args: i64) -> i64 {
    let pending: i64 = cg_pending_instantiations(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, mangled_name);
    store_ptr(entry, 1, fn_def);
    store_ptr(entry, 2, type_args);
    vec_push(pending, entry);
    0
}

// Associated types helpers
fn cg_assoc_types(cg: i64) -> i64 {
    load_ptr(cg, 16)
}

fn cg_current_impl_type(cg: i64) -> i64 {
    load_ptr(cg, 17)
}

fn cg_set_current_impl_type(cg: i64, type_name: i64) -> i64 {
    store_ptr(cg, 17, type_name);
    0
}

// Register an associated type: maps "TypeName::AssocName" to concrete type
fn cg_register_assoc_type(cg: i64, impl_type: i64, assoc_name: i64, concrete_type: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = string_concat(impl_type, string_concat(string_from("::"), assoc_name));
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, key);
    store_ptr(pair, 1, concrete_type);
    vec_push(assoc_types, pair);
    0
}

// Look up an associated type
fn cg_lookup_assoc_type(cg: i64, impl_type: i64, assoc_name: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = string_concat(impl_type, string_concat(string_from("::"), assoc_name));
    let n: i64 = vec_len(assoc_types);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(assoc_types, i);
        if string_eq(load_ptr(pair, 0), key) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Resolve a type: if it's "Self::Name", look it up; if it's "Self", return current impl type
fn cg_resolve_type(cg: i64, type_name: i64) -> i64 {
    // Check for Self::Name pattern
    if string_starts_with(type_name, string_from("Self::")) {
        let assoc_name: i64 = string_slice(type_name, 6, string_len(type_name));
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            let resolved: i64 = cg_lookup_assoc_type(cg, impl_type, assoc_name);
            if resolved != 0 {
                return resolved;
            }
        }
        // Not found - return as-is (will be an error at compile time)
        return type_name;
    }
    // Check for plain Self
    if string_eq(type_name, string_from("Self")) {
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            return impl_type;
        }
    }
    // Not Self::anything, return as-is
    type_name
}

// Const params helpers for const generics
fn cg_const_params(cg: i64) -> i64 {
    load_ptr(cg, 18)
}

fn cg_clear_const_params(cg: i64) -> i64 {
    store_ptr(cg, 18, vec_new());
    0
}

fn cg_add_const_param(cg: i64, name: i64, value: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, value);
    vec_push(const_params, pair);
    0
}

fn cg_lookup_const_param(cg: i64, name: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let n: i64 = vec_len(const_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(const_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Type Parameter Substitution (Phase 21 completion)
// ========================================

// Slot 19: type_params - maps type param names to concrete types
fn cg_type_params(cg: i64) -> i64 {
    load_ptr(cg, 19)
}

fn cg_clear_type_params(cg: i64) -> i64 {
    store_ptr(cg, 19, vec_new());
    0
}

fn cg_add_type_param(cg: i64, name: i64, concrete_type: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, concrete_type);
    vec_push(type_params, pair);
    0
}

fn cg_lookup_type_param(cg: i64, name: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(type_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Substitute type parameters in a type string
// e.g., "Vec<T>" with T=i64 becomes "Vec<i64>"
fn substitute_type_params(cg: i64, type_str: i64) -> i64 {
    if type_str == 0 {
        return type_str;
    }
    // Check if type_str is a type parameter itself
    let subst: i64 = cg_lookup_type_param(cg, type_str);
    if subst != 0 {
        return subst;
    }
    // Otherwise return unchanged (bootstrap compiler uses i64 for everything)
    type_str
}

// ========================================
// Generic Struct Templates (Phase 21 completion)
// ========================================

// Slot 20: generic_struct_templates - stores generic struct definitions
// Format: vec of (name, type_params, fields) tuples
fn cg_generic_struct_templates(cg: i64) -> i64 {
    load_ptr(cg, 20)
}

fn cg_add_generic_struct_template(cg: i64, name: i64, type_params: i64, fields: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, type_params);
    store_ptr(entry, 2, fields);
    vec_push(templates, entry);
    0
}

fn cg_lookup_generic_struct_template(cg: i64, name: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let n: i64 = vec_len(templates);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(templates, i);
        if string_eq(load_ptr(entry, 0), name) {
            return entry;
        }
        i = i + 1;
    }
    0
}

// Monomorphize a generic struct with concrete type arguments
// Returns the mangled name (e.g., "Pair_i64_i64")
fn monomorphize_struct(cg: i64, struct_name: i64, type_args: i64) -> i64 {
    // Build mangled name
    let mangled_name: i64 = struct_name;
    if type_args != 0 {
        let num_args: i64 = vec_len(type_args);
        if num_args > 0 {
            let i: i64 = 0;
            while i < num_args {
                mangled_name = string_concat(mangled_name, "_");
                mangled_name = string_concat(mangled_name, vec_get(type_args, i));
                i = i + 1;
            }
        }
    }

    // Check if already registered
    let existing: i64 = lookup_struct_fields(cg, mangled_name);
    if existing != 0 {
        return mangled_name;
    }

    // Look up the generic struct template
    let template: i64 = cg_lookup_generic_struct_template(cg, struct_name);
    if template == 0 {
        // Not a generic struct, check if it's already registered
        let plain: i64 = lookup_struct_fields(cg, struct_name);
        if plain != 0 {
            return struct_name;
        }
        return struct_name;  // Fall back to plain name
    }

    // Get template info
    let type_params: i64 = load_ptr(template, 1);
    let fields: i64 = load_ptr(template, 2);

    // Set up type parameter mappings
    cg_clear_type_params(cg);
    if type_params != 0 {
        let num_type_params: i64 = vec_len(type_params);
        let pi: i64 = 0;
        while pi < num_type_params {
            let param_name: i64 = vec_get(type_params, pi);
            if type_args != 0 {
                if pi < vec_len(type_args) {
                    cg_add_type_param(cg, param_name, vec_get(type_args, pi));
                }
            }
            pi = pi + 1;
        }
    }

    // Create monomorphized fields (in bootstrap compiler, all types are i64)
    // Just register with same fields
    register_struct(cg, mangled_name, fields);

    mangled_name
}

// ========================================
// Trait Implementation Tracking (Phase 21 completion)
// ========================================

// Slot 21: trait_impls - stores which types implement which traits
fn cg_trait_impls(cg: i64) -> i64 {
    load_ptr(cg, 21)
}

fn cg_register_trait_impl(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    vec_push(impls, entry);
    0
}

fn cg_type_implements_trait(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let n: i64 = vec_len(impls);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(impls, i);
        let impl_type: i64 = load_ptr(entry, 0);
        let impl_trait: i64 = load_ptr(entry, 1);
        if string_eq(impl_type, type_name) {
            if string_eq(impl_trait, trait_name) {
                return 1;
            }
        }
        i = i + 1;
    }
    0
}

// Default method accessors
fn cg_default_methods(cg: i64) -> i64 {
    load_ptr(cg, 26)
}

fn cg_register_default_method(cg: i64, trait_name: i64, method_name: i64, fn_def: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = string_concat(trait_name, string_concat(string_from("::"), method_name));
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, key);
    store_ptr(entry, 1, fn_def);
    vec_push(methods, entry);
    0
}

fn cg_get_default_method(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = string_concat(trait_name, string_concat(string_from("::"), method_name));
    let n: i64 = vec_len(methods);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(methods, i);
        let entry_key: i64 = load_ptr(entry, 0);
        if string_eq(entry_key, key) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Vtable Support for Dynamic Dispatch (Phase 32)
// ========================================

// Slot 27: trait_defs - stores trait definitions with their method signatures
fn cg_trait_defs(cg: i64) -> i64 {
    load_ptr(cg, 27)
}

// Register a trait definition with its method signatures for vtable layout
// method_sigs is a vec of method signatures from the trait definition
fn cg_register_trait_def(cg: i64, trait_name: i64, method_sigs: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, trait_name);
    store_ptr(entry, 1, method_sigs);
    vec_push(defs, entry);
    0
}

// Get method signatures for a trait (for vtable layout)
fn cg_get_trait_methods(cg: i64, trait_name: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let n: i64 = vec_len(defs);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(defs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, trait_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Slot 28: vtables - stores generated vtables
fn cg_vtables(cg: i64) -> i64 {
    load_ptr(cg, 28)
}

// Register a vtable global for (type, trait) pair
fn cg_register_vtable(cg: i64, type_name: i64, trait_name: i64, vtable_global: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    store_ptr(entry, 2, vtable_global);
    vec_push(vtables, entry);
    0
}

// Get vtable global name for a (type, trait) pair
fn cg_get_vtable(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let n: i64 = vec_len(vtables);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(vtables, i);
        let t: i64 = load_ptr(entry, 0);
        let tr: i64 = load_ptr(entry, 1);
        if string_eq(t, type_name) {
            if string_eq(tr, trait_name) {
                return load_ptr(entry, 2);
            }
        }
        i = i + 1;
    }
    0
}

// Get method index in vtable for a trait method
fn cg_get_vtable_method_index(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let method_sigs: i64 = cg_get_trait_methods(cg, trait_name);
    if method_sigs == 0 {
        return 0;  // Unknown trait
    }
    let n: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < n {
        let sig: i64 = vec_get(method_sigs, i);
        let sig_name: i64 = load_ptr(sig, 0);
        if string_eq(sig_name, method_name) {
            return i;
        }
        i = i + 1;
    }
    0  // Default to first slot if not found
}

// Check if a type is a dyn trait type (starts with "dyn:")
fn is_dyn_type(type_name: i64) -> i64 {
    string_starts_with(type_name, string_from("dyn:"))
}

// Extract trait name from dyn type (e.g., "dyn:Display" -> "Display")
fn extract_dyn_trait(type_name: i64) -> i64 {
    if is_dyn_type(type_name) != 0 {
        return string_slice(type_name, 4, string_len(type_name));
    }
    type_name
}

// Extract type param name from bounded type param (e.g., "T:Display" -> "T")
fn extract_type_param_name(type_param: i64) -> i64 {
    // Check for const: prefix
    if string_starts_with(type_param, string_from("const:")) {
        return string_slice(type_param, 6, string_len(type_param));
    }
    // Check for trait bound (contains : but not const:)
    let colon_pos: i64 = string_find(type_param, string_from(":"), 0);
    if colon_pos > 0 {
        return string_slice(type_param, 0, colon_pos);
    }
    type_param
}

// Extract trait bound from bounded type param (e.g., "T:Display" -> "Display")
fn extract_trait_bound(type_param: i64) -> i64 {
    // Check for const: prefix (no trait bound)
    if string_starts_with(type_param, string_from("const:")) {
        return 0;
    }
    // Check for trait bound
    let colon_pos: i64 = string_find(type_param, string_from(":"), 0);
    if colon_pos > 0 {
        return string_slice(type_param, colon_pos + 1, string_len(type_param));
    }
    0
}

// Check if all trait bounds are satisfied for a generic instantiation
// Returns 1 if all bounds satisfied, 0 otherwise
fn check_trait_bounds(cg: i64, type_params: i64, type_args: i64) -> i64 {
    if type_params == 0 {
        return 1;
    }
    if type_args == 0 {
        return 1;
    }
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let type_param: i64 = vec_get(type_params, i);
        let bound: i64 = extract_trait_bound(type_param);
        if bound != 0 {
            // This type param has a trait bound
            if i < vec_len(type_args) {
                let concrete_type: i64 = vec_get(type_args, i);
                // Check if concrete type implements the bound trait
                // Handle multiple bounds separated by +
                let plus_pos: i64 = string_find(bound, string_from("+"), 0);
                if plus_pos > 0 {
                    // Multiple bounds: check each one
                    let remaining: i64 = bound;
                    while string_len(remaining) > 0 {
                        plus_pos = string_find(remaining, string_from("+"), 0);
                        let trait_name: i64 = remaining;
                        if plus_pos > 0 {
                            trait_name = string_slice(remaining, 0, plus_pos);
                            remaining = string_slice(remaining, plus_pos + 1, string_len(remaining));
                        } else {
                            remaining = string_from("");
                        }
                        if cg_type_implements_trait(cg, concrete_type, trait_name) == 0 {
                            println(string_concat("Error: type '", string_concat(concrete_type,
                                string_concat("' does not implement trait '", string_concat(trait_name, "'")))));
                            return 0;
                        }
                    }
                } else {
                    // Single bound
                    if cg_type_implements_trait(cg, concrete_type, bound) == 0 {
                        println(string_concat("Error: type '", string_concat(concrete_type,
                            string_concat("' does not implement trait '", string_concat(bound, "'")))));
                        return 0;
                    }
                }
            }
        }
        i = i + 1;
    }
    1
}

// ========================================
// Improved Type Error Messages (Phase 21 completion)
// ========================================

// Format a type mismatch error with context
fn type_error_mismatch(expected: i64, found: i64, context: i64) -> i64 {
    let msg: i64 = string_from("Type error: expected '");
    msg = string_concat(msg, expected);
    msg = string_concat(msg, "', found '");
    msg = string_concat(msg, found);
    msg = string_concat(msg, "'");
    if context != 0 {
        msg = string_concat(msg, " in ");
        msg = string_concat(msg, context);
    }
    println(msg);
    0
}

// Format an argument count mismatch error
fn error_arg_count(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = string_from("Error: function '");
    msg = string_concat(msg, fn_name);
    msg = string_concat(msg, "' expects ");
    msg = string_concat(msg, int_to_string(expected));
    msg = string_concat(msg, " argument(s), found ");
    msg = string_concat(msg, int_to_string(found));
    println(msg);
    0
}

// Format an undefined variable error
fn error_undefined_var(name: i64) -> i64 {
    println(string_concat("Error: undefined variable '", string_concat(name, "'")));
    0
}

// Format an undefined function error
fn error_undefined_fn(name: i64) -> i64 {
    println(string_concat("Error: undefined function '", string_concat(name, "'")));
    0
}

// Format an undefined struct error
fn error_undefined_struct(name: i64) -> i64 {
    println(string_concat("Error: undefined struct '", string_concat(name, "'")));
    0
}

// Format an undefined field error
fn error_undefined_field(struct_name: i64, field_name: i64) -> i64 {
    let msg: i64 = string_from("Error: struct '");
    msg = string_concat(msg, struct_name);
    msg = string_concat(msg, "' has no field '");
    msg = string_concat(msg, field_name);
    msg = string_concat(msg, "'");
    println(msg);
    0
}

// Format a generic instantiation error
fn error_generic_instantiation(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = string_from("Error: generic function '");
    msg = string_concat(msg, fn_name);
    msg = string_concat(msg, "' expects ");
    msg = string_concat(msg, int_to_string(expected));
    msg = string_concat(msg, " type argument(s), found ");
    msg = string_concat(msg, int_to_string(found));
    println(msg);
    0
}

fn cg_alloca_queue(cg: i64) -> i64 {
    load_ptr(cg, 11)
}

fn cg_clear_alloca_queue(cg: i64) -> i64 {
    store_ptr(cg, 11, vec_new());
    0
}

fn cg_push_alloca(cg: i64, unique_name: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    vec_push(queue, unique_name);
    0
}

fn cg_pop_alloca(cg: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    let len: i64 = vec_len(queue);
    if len == 0 {
        return 0;
    }
    let name: i64 = vec_get(queue, 0);
    // Shift queue (remove first element by building new vec)
    let new_queue: i64 = vec_new();
    let i: i64 = 1;
    while i < len {
        vec_push(new_queue, vec_get(queue, i));
        i = i + 1;
    }
    store_ptr(cg, 11, new_queue);
    name
}

// Collect all local variable names from a block (recursive)
// Returns a vector of variable names in declaration order
fn collect_locals_from_expr(expr: i64, result: i64) -> i64 {
    if expr == 0 {
        return 0;
    }
    let tag: i64 = load_i64(expr, 0);

    // Block - process stmts and result expr
    if tag == EXPR_BLOCK() {
        let stmts: i64 = load_ptr(expr, 1);
        let result_expr: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(stmts);
        let i: i64 = 0;
        while i < n {
            let stmt: i64 = vec_get(stmts, i);
            collect_locals_from_stmt(stmt, result);
            i = i + 1;
        }
        if result_expr != 0 {
            collect_locals_from_expr(result_expr, result);
        }
        return 0;
    }

    // If expression - process then/else blocks
    if tag == EXPR_IF() {
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        collect_locals_from_expr(then_block, result);
        if else_block != 0 {
            collect_locals_from_expr(else_block, result);
        }
        return 0;
    }

    // While expression - process body
    if tag == EXPR_WHILE() {
        let body: i64 = load_ptr(expr, 2);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // For expression - collect loop var and process body
    if tag == EXPR_FOR() {
        let var_name: i64 = load_ptr(expr, 1);
        vec_push(result, var_name);
        let body: i64 = load_ptr(expr, 4);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // Match expression - process arms
    if tag == EXPR_MATCH() {
        let arms: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(arms);
        let i: i64 = 0;
        while i < n {
            let arm: i64 = vec_get(arms, i);
            let body: i64 = load_ptr(arm, 1);
            collect_locals_from_expr(body, result);
            i = i + 1;
        }
        return 0;
    }

    0
}

fn collect_locals_from_stmt(stmt: i64, result: i64) -> i64 {
    if stmt == 0 {
        return 0;
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement - collect the variable name
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        vec_push(result, name);
        // Also check init expression for nested blocks
        let init_expr: i64 = load_ptr(stmt, 3);
        if init_expr != 0 {
            collect_locals_from_expr(init_expr, result);
        }
        return 0;
    }

    // Expression statement - check for blocks
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        collect_locals_from_expr(expr, result);
        return 0;
    }

    // Return statement - check expression
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            collect_locals_from_expr(expr, result);
        }
        return 0;
    }

    0
}

fn collect_locals_from_block(block: i64) -> i64 {
    let result: i64 = vec_new();
    collect_locals_from_expr(block, result);
    result
}

fn cg_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_next_temp(cg: i64) -> i64 {
    let t: i64 = load_i64(cg, 1);
    store_i64(cg, 1, t + 1);
    t
}

fn cg_next_label(cg: i64) -> i64 {
    let l: i64 = load_i64(cg, 2);
    store_i64(cg, 2, l + 1);
    l
}

fn cg_enums(cg: i64) -> i64 {
    load_ptr(cg, 3)
}

fn cg_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_clear_locals(cg: i64) -> i64 {
    store_ptr(cg, 4, vec_new());
    store_ptr(cg, 8, vec_new());  // Also clear var_types
    store_ptr(cg, 9, vec_new());  // Also clear loop_stack
    store_i64(cg, 10, 0);         // Reset loop_depth
    0
}

fn cg_strings(cg: i64) -> i64 {
    load_ptr(cg, 5)
}

// Variable type tracking for method calls
fn cg_var_types(cg: i64) -> i64 {
    load_ptr(cg, 8)
}

// Add variable type: stores (var_name, type_name) pair
fn add_var_type(cg: i64, var_name: i64, type_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, var_name);
    store_ptr(pair, 1, type_name);
    vec_push(var_types, pair);
    0
}

// Lookup variable type by name (returns type_name or 0 if not found)
fn lookup_var_type(cg: i64, var_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let n: i64 = vec_len(var_types);
    // Search backwards to get most recent binding
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(var_types, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, var_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    0
}

fn cg_is_terminated(cg: i64) -> bool {
    load_i64(cg, 6) != 0
}

fn cg_set_terminated(cg: i64, val: bool) -> i64 {
    if val != false {
        store_i64(cg, 6, 1);
    } else {
        store_i64(cg, 6, 0);
    }
    0
}

// Add a string constant and return its index
fn cg_add_string(cg: i64, value: i64) -> i64 {
    let strings: i64 = cg_strings(cg);
    let idx: i64 = vec_len(strings);
    vec_push(strings, value);
    idx
}

// Emit to output buffer using StringBuilder for O(n) instead of O(n)
fn emit(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    0
}

fn emit_line(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    sb_append(sb, "\n");
    0
}

// Register an enum
fn register_enum(cg: i64, name: i64, variants: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, variants);
    vec_push(enums, entry);
    0
}

// Look up enum variant index
fn lookup_variant(cg: i64, enum_name: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, enum_name) {
            let variants: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(variants);
            let j: i64 = 0;
            while j < m {
                let v: i64 = vec_get(variants, j);
                if string_eq(v, var_name) {
                    return j;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    -1
}

// Register builtin enums (Option, Result) for enum construction without explicit enum definition
fn register_builtin_enums(cg: i64) -> i64 {
    // Option<T>: None=0, Some=1
    let option_variants: i64 = vec_new();
    vec_push(option_variants, string_from("None"));
    vec_push(option_variants, string_from("Some"));
    register_enum(cg, string_from("Option"), option_variants);

    // Result<T,E>: Err=0, Ok=1
    let result_variants: i64 = vec_new();
    vec_push(result_variants, string_from("Err"));
    vec_push(result_variants, string_from("Ok"));
    register_enum(cg, string_from("Result"), result_variants);
    0
}

// Phase 36: Extract base type name from generic type string
// e.g., "Option<i64>" -> "Option", "Result<T, E>" -> "Result"
fn extract_base_type(type_name: i64) -> i64 {
    if type_name == 0 {
        return 0;
    }
    let len: i64 = string_len(type_name);
    let i: i64 = 0;
    while i < len {
        let ch: i64 = string_char_at(type_name, i);
        if ch == 60 {  // '<' character
            return string_slice(type_name, 0, i);
        }
        i = i + 1;
    }
    type_name  // No '<' found, return as-is
}

// Get structs vector
fn cg_structs(cg: i64) -> i64 {
    load_ptr(cg, 7)
}

// Get loop stack (for break/continue)
fn cg_loop_stack(cg: i64) -> i64 {
    load_ptr(cg, 9)
}

// Get loop depth
fn cg_loop_depth(cg: i64) -> i64 {
    load_i64(cg, 10)
}

// Push loop context onto stack - pair is (continue_label, break_label)
fn push_loop(cg: i64, continue_label: i64, break_label: i64) -> i64 {
    let stack: i64 = cg_loop_stack(cg);
    let depth: i64 = cg_loop_depth(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, continue_label);
    store_ptr(pair, 1, break_label);
    vec_push(stack, pair);
    store_i64(cg, 10, depth + 1);
    0
}

// Pop loop context from stack
fn pop_loop(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth > 0 {
        let new_depth: i64 = depth - 1;
        store_i64(cg, 10, new_depth);
        // When exiting all loops, clear the stack to prevent stale entries
        // from affecting subsequent loops in the same function
        if new_depth == 0 {
            store_ptr(cg, 9, vec_new());
        }
    }
    0
}

// Get current loop continue label (top of stack)
fn current_loop_continue(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 0)
}

// Get current loop break label (top of stack)
fn current_loop_break(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 1)
}

// Register a struct
fn register_struct(cg: i64, name: i64, fields: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, fields);
    vec_push(structs, entry);
    0
}

// Look up struct field index (returns byte offset = index * 8)
fn lookup_struct_field(cg: i64, struct_name: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            let fields: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(fields);
            let j: i64 = 0;
            while j < m {
                let field: i64 = vec_get(fields, j);
                let fname: i64 = load_ptr(field, 0);
                if string_eq(fname, field_name) {
                    return j;  // Return field index
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Get struct fields by name
fn lookup_struct_fields(cg: i64, struct_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Look up field in all registered structs (for field access without type info)
fn lookup_field_in_all_structs(cg: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let fields: i64 = load_ptr(entry, 1);
        let m: i64 = vec_len(fields);
        let j: i64 = 0;
        while j < m {
            let field: i64 = vec_get(fields, j);
            let fname: i64 = load_ptr(field, 0);
            if string_eq(fname, field_name) {
                return j;  // Return field index
            }
            j = j + 1;
        }
        i = i + 1;
    }
    0
}

// Add local: stores (original_name, unique_name) pair
fn add_local(cg: i64, original_name: i64, unique_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, original_name);
    store_ptr(pair, 1, unique_name);
    vec_push(locals, pair);
    0
}

// Lookup local: find most recent unique_name for original_name
fn lookup_local(cg: i64, original_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let n: i64 = vec_len(locals);
    // Search backwards to get most recent
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(locals, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, original_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    // Not found - report error and return original
    error_undefined_var(original_name);
    original_name
}

// Generate expression - returns the LLVM value (temp name or literal)
fn gen_expr(cg: i64, expr: i64) -> i64 {
    // Guard against null expressions
    if expr == 0 {
        return string_from("0");
    }
    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == EXPR_INT() {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == EXPR_BOOL() {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("1");
        }
        return string_from("0");
    }

    // String literal - allocate and initialize
    if tag == EXPR_STRING() {
        let value: i64 = load_ptr(expr, 1);
        let str_idx: i64 = cg_add_string(cg, value);  // Track the string constant
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        // Emit call to intrinsic_string_new with the string constant
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
        emit(cg, cg_module_name(cg));
        emit(cg, ".");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");

        // Convert ptr to i64 for consistent type handling
        let t2: i64 = cg_next_temp(cg);
        let temp2: i64 = string_concat("%t", int_to_string(t2));
        emit(cg, "  ");
        emit(cg, temp2);
        emit(cg, " = ptrtoint ptr ");
        emit(cg, temp);
        emit_line(cg, " to i64");

        return temp2;
    }

    // FString - interpolated string
    // Layout: tag(0), parts(1), exprs(2)
    if tag == EXPR_FSTRING() {
        let parts: i64 = load_ptr(expr, 1);
        let exprs: i64 = load_ptr(expr, 2);
        let num_parts: i64 = vec_len(parts);
        let num_exprs: i64 = vec_len(exprs);

        // Start with empty string
        let result: i64 = string_from("0");

        // Interleave parts and expressions
        let i: i64 = 0;
        while i < num_parts {
            // Emit the string part
            let part: i64 = vec_get(parts, i);
            if string_len(part) > 0 {
                let part_idx: i64 = cg_add_string(cg, part);
                let t1: i64 = cg_next_temp(cg);
                let temp1: i64 = string_concat("%t", int_to_string(t1));
                emit(cg, "  ");
                emit(cg, temp1);
                emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
                emit(cg, cg_module_name(cg));
                emit(cg, ".");
                emit(cg, int_to_string(part_idx));
                emit_line(cg, ")");

                let t2: i64 = cg_next_temp(cg);
                let temp2: i64 = string_concat("%t", int_to_string(t2));
                emit(cg, "  ");
                emit(cg, temp2);
                emit(cg, " = ptrtoint ptr ");
                emit(cg, temp1);
                emit_line(cg, " to i64");

                // Concat with result
                if string_eq(result, "0") {
                    result = temp2;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, temp2);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            // If there's an expression, evaluate and concat it
            if i < num_exprs {
                let ex: i64 = vec_get(exprs, i);
                let ex_val: i64 = gen_expr(cg, ex);

                // Concat with result (assuming expr returns string handle)
                if string_eq(result, "0") {
                    result = ex_val;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, ex_val);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            i = i + 1;
        }

        return result;
    }

    // Yield expression - for generators
    // Layout: tag(0), inner(1)
    if tag == EXPR_YIELD() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Call generator_yield intrinsic
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @generator_yield(i64 ");
        emit(cg, inner_val);
        emit_line(cg, ")");

        return temp;
    }

    // Identifier - load from local
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);

        // Check if this is a const generic parameter
        let const_value: i64 = cg_lookup_const_param(cg, name);
        if const_value != 0 {
            // Return the literal value directly
            return const_value;
        }

        // Phase 36: Check if this is an enum variant without arguments (e.g., None)
        let opt_variant_idx: i64 = lookup_variant(cg, string_from("Option"), name);
        if opt_variant_idx >= 0 {
            // This is None - allocate Option with just the tag
            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " = call ptr @malloc(i64 8)");
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(opt_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        let unique_name: i64 = lookup_local(cg, name);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = load i64, ptr %local.");
        emit_line(cg, unique_name);

        return temp;
    }

    // Path - enum variant
    if tag == EXPR_PATH() {
        let segments: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(segments);
        if len == 2 {
            let enum_name: i64 = vec_get(segments, 0);
            let var_name: i64 = vec_get(segments, 1);
            let idx: i64 = lookup_variant(cg, enum_name, var_name);
            return int_to_string(idx);
        }
        return string_from("0");
    }

    // Function call
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);  // Generic type arguments (or 0)

        // Get function name
        let callee_name: i64 = load_ptr(callee, 1);

        // Generate args
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // ===== PHASE 36: ENUM VARIANT CONSTRUCTORS =====
        // Handle Some(x), None, Ok(x), Err(e) as enum constructors
        let variant_idx: i64 = lookup_variant(cg, string_from("Option"), callee_name);
        if variant_idx >= 0 {
            // Option variant: Some or None
            // Allocate: 8 bytes tag + 8 bytes payload (if Some)
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads at offset 8, 16, etc.
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for Result variants
        let result_variant_idx: i64 = lookup_variant(cg, string_from("Result"), callee_name);
        if result_variant_idx >= 0 {
            // Result variant: Ok or Err
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(result_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for intrinsics - emit with proper type conversions
        // Pattern: convert i64 args to ptr, call intrinsic, convert ptr result to i64

        // string_from: argument is already a string handle from EXPR_STRING
        if string_eq(callee_name, "string_from") {
            return vec_get(arg_values, 0);
        }

        // void intrinsics (return "0")
        if string_eq(callee_name, "println") {
            emit_intrinsic_void_ptr(cg, "intrinsic_println", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "print") {
            emit_intrinsic_void_ptr(cg, "intrinsic_print", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_push") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_vec_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "write_file") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_write_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "free") {
            emit_intrinsic_void_ptr(cg, "free", vec_get(arg_values, 0));
            return string_from("0");
        }

        // i64 result intrinsics
        if string_eq(callee_name, "string_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_char_at") {
            return emit_intrinsic_i64_ptr_i64(cg, "intrinsic_string_char_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_to_int") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_to_int", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_vec_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_i64") {
            return emit_intrinsic_i64_ptr_i64(cg, "load_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_eq") {
            return emit_intrinsic_i1_ptr_ptr(cg, "intrinsic_string_eq", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // ptr result intrinsics -> convert to i64
        if string_eq(callee_name, "string_concat") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_concat", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_slice") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "intrinsic_string_slice", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "int_to_string") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_int_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_from_char") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_string_from_char", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_vec_new");
        }
        if string_eq(callee_name, "vec_get") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_vec_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_args") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_args");
        }
        if string_eq(callee_name, "read_file") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_read_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "malloc") {
            return emit_intrinsic_ptr_i64(cg, "malloc", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_ptr") {
            return emit_intrinsic_ptr_ptr_i64(cg, "load_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "store_ptr") {
            return emit_intrinsic_ptr_ptr_i64_ptr(cg, "store_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "store_i64") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "store_i64", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }

        // Timing intrinsics
        if string_eq(callee_name, "get_time_ms") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_ms");
        }
        if string_eq(callee_name, "get_time_us") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_us");
        }

        // File I/O intrinsics
        if string_eq(callee_name, "file_exists") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_exists", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_dir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_directory", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_size") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_size", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_mtime") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_mtime", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "remove_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_remove_path", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "mkdir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_mkdir_p", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "get_cwd") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_cwd");
        }
        if string_eq(callee_name, "set_cwd") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_set_cwd", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "list_dir") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_list_dir", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_join") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_path_join", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "path_dirname") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_dirname", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_basename") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_basename", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_ext") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_extension", vec_get(arg_values, 0));
        }

        // Arena intrinsics
        if string_eq(callee_name, "arena_create") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_arena_create", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "arena_alloc") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_arena_alloc", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "arena_reset") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_reset", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_used") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_arena_used", vec_get(arg_values, 0));
        }

        // StringBuilder intrinsics
        if string_eq(callee_name, "sb_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_sb_new");
        }
        if string_eq(callee_name, "sb_new_cap") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_sb_new_cap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_append") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_sb_append", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_char") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_char", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_i64") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_to_string") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_sb_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_clear") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_sb_len", vec_get(arg_values, 0));
        }

        // Error handling intrinsics
        if string_eq(callee_name, "panic") {
            emit_intrinsic_void_ptr(cg, "intrinsic_panic", vec_get(arg_values, 0));
            emit_line(cg, "  unreachable");
            return string_from("0");
        }
        if string_eq(callee_name, "print_stack_trace") {
            emit_intrinsic_void_void(cg, "intrinsic_print_stack_trace");
            return string_from("0");
        }

        // Process intrinsics
        if string_eq(callee_name, "process_run") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_process_run", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "process_output") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_process_output", vec_get(arg_values, 0));
        }

        // Phase 20: REPL/I/O intrinsics
        if string_eq(callee_name, "read_line") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_read_line");
        }
        if string_eq(callee_name, "is_tty") {
            return emit_intrinsic_i64_void(cg, "intrinsic_is_tty");
        }
        if string_eq(callee_name, "stdin_has_data") {
            return emit_intrinsic_i64_void(cg, "intrinsic_stdin_has_data");
        }
        if string_eq(callee_name, "string_hash") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_hash", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_find") {
            return emit_intrinsic_i64_ptr_ptr_i64(cg, "intrinsic_string_find", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "string_trim") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_trim", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_split") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_split", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_starts_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_starts_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_ends_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_ends_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_contains") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_replace") {
            return emit_intrinsic_ptr_ptr_ptr_ptr(cg, "intrinsic_string_replace", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "copy_file") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_copy_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_home_dir") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_home_dir");
        }

        // Check if this is a generic function call
        let emit_callee: i64 = callee_name;
        if type_args != 0 {
            if vec_len(type_args) > 0 {
                // This is a generic call - mangle the name
                let mangled: i64 = mangle_generic_name(callee_name, type_args);
                emit_callee = mangled;

                // Queue instantiation if not already done
                if cg_is_instantiated(cg, mangled) == false {
                    let fn_def: i64 = cg_lookup_generic(cg, callee_name);
                    if fn_def != 0 {
                        cg_queue_instantiation(cg, mangled, fn_def, type_args);
                        cg_mark_instantiated(cg, mangled);
                    }
                }
            }
        }

        // Default: emit call as user function
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, emit_callee);
        emit(cg, "\"(");

        i = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Binary operation
    if tag == EXPR_BINARY() {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        // Short-circuit evaluation for && and ||
        // Use simple approach: evaluate both and use logical and/or
        // This is simpler than proper phi-based short-circuit
        if op == OP_AND() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // and i1
            let and_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(and_t));
            emit(cg, " = and i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(and_t));
            emit_line(cg, " to i64");

            return result;
        }

        if op == OP_OR() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // or i1
            let or_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(or_t));
            emit(cg, " = or i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(or_t));
            emit_line(cg, " to i64");

            return result;
        }

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = ");

        let is_cmp: bool = false;
        if op == OP_ADD() { emit(cg, "add i64 "); }
        if op == OP_SUB() { emit(cg, "sub i64 "); }
        if op == OP_MUL() { emit(cg, "mul i64 "); }
        if op == OP_DIV() { emit(cg, "sdiv i64 "); }
        if op == OP_MOD() { emit(cg, "srem i64 "); }
        if op == OP_BITAND() { emit(cg, "and i64 "); }
        if op == OP_BITOR() { emit(cg, "or i64 "); }
        if op == OP_BITXOR() { emit(cg, "xor i64 "); }
        if op == OP_SHL() { emit(cg, "shl i64 "); }
        if op == OP_SHR() { emit(cg, "ashr i64 "); }
        if op == OP_EQ() { emit(cg, "icmp eq i64 "); is_cmp = true; }
        if op == OP_NE() { emit(cg, "icmp ne i64 "); is_cmp = true; }
        if op == OP_LT() { emit(cg, "icmp slt i64 "); is_cmp = true; }
        if op == OP_GT() { emit(cg, "icmp sgt i64 "); is_cmp = true; }
        if op == OP_LE() { emit(cg, "icmp sle i64 "); is_cmp = true; }
        if op == OP_GE() { emit(cg, "icmp sge i64 "); is_cmp = true; }

        emit(cg, left_val);
        emit(cg, ", ");
        emit_line(cg, right_val);

        // If comparison, zext from i1 to i64
        if is_cmp {
            let t2: i64 = cg_next_temp(cg);
            let temp2: i64 = string_concat("%t", int_to_string(t2));
            emit(cg, "  ");
            emit(cg, temp2);
            emit(cg, " = zext i1 ");
            emit(cg, temp);
            emit_line(cg, " to i64");
            return temp2;
        }

        return temp;
    }

    // Unary operation
    if tag == EXPR_UNARY() {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        let val: i64 = gen_expr(cg, operand);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);

        if op == OP_NEG() {
            emit(cg, " = sub i64 0, ");
            emit_line(cg, val);
        }
        if op == OP_NOT() {
            emit(cg, " = xor i1 ");
            emit(cg, val);
            emit_line(cg, ", 1");
        }

        return temp;
    }

    // If expression
    if tag == EXPR_IF() {
        return gen_if(cg, expr);
    }

    // While expression
    if tag == EXPR_WHILE() {
        return gen_while(cg, expr);
    }

    // For expression
    if tag == EXPR_FOR() {
        return gen_for(cg, expr);
    }

    // Match expression
    if tag == EXPR_MATCH() {
        return gen_match(cg, expr);
    }

    // Block expression
    if tag == EXPR_BLOCK() {
        return gen_block(cg, expr);
    }

    // Struct literal: Foo { x: 1, y: 2 } or Foo::<T> { x: 1, y: 2 }
    if tag == EXPR_STRUCT_LIT() {
        let struct_name: i64 = load_ptr(expr, 1);
        let field_inits: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);
        let num_fields: i64 = vec_len(field_inits);

        // Monomorphize if type args provided (e.g., Pair::<i64, i64>)
        let effective_name: i64 = monomorphize_struct(cg, struct_name, type_args);

        // Allocate struct: malloc(num_fields * 8)
        let alloc_size: i64 = num_fields * 8;
        let t: i64 = cg_next_temp(cg);
        let ptr_temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, ptr_temp);
        emit(cg, " = call ptr @malloc(i64 ");
        emit(cg, int_to_string(alloc_size));
        emit_line(cg, ")");

        // Get the struct field order from definition
        let fields: i64 = lookup_struct_fields(cg, effective_name);
        if fields == 0 {
            error_undefined_struct(effective_name);
        }

        // Initialize each field
        let i: i64 = 0;
        while i < num_fields {
            let field_init: i64 = vec_get(field_inits, i);
            let field_name: i64 = load_ptr(field_init, 0);
            let field_expr: i64 = load_ptr(field_init, 1);

            // Generate field value
            let field_val: i64 = gen_expr(cg, field_expr);

            // Look up field offset
            let field_idx: i64 = lookup_struct_field(cg, effective_name, field_name);
            let offset: i64 = field_idx * 8;

            // Store field using getelementptr + store
            let gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(gep_t));
            emit(cg, " = getelementptr i8, ptr ");
            emit(cg, ptr_temp);
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(offset));

            emit(cg, "  store i64 ");
            emit(cg, field_val);
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(gep_t));

            i = i + 1;
        }

        // Convert ptr to i64
        return emit_ptr_to_i64(cg, ptr_temp);
    }

    // Field access: expr.field
    if tag == EXPR_FIELD() {
        let object: i64 = load_ptr(expr, 1);
        let field_name: i64 = load_ptr(expr, 2);

        // Generate object value (pointer as i64)
        let obj_val: i64 = gen_expr(cg, object);

        // Convert i64 to ptr
        let ptr_temp: i64 = emit_i64_to_ptr(cg, obj_val);

        // For now, we need to figure out the struct type from context
        // We'll do a simple approach: try all structs and find one with this field
        let field_idx: i64 = lookup_field_in_all_structs(cg, field_name);
        let offset: i64 = field_idx * 8;

        // GEP to field
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr ");
        emit(cg, ptr_temp);
        emit(cg, ", i64 ");
        emit_line(cg, int_to_string(offset));

        // Load field value
        let load_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(load_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(load_t));
    }

    // Method call: expr.method(args)
    if tag == EXPR_METHOD_CALL() {
        let object: i64 = load_ptr(expr, 1);
        let method_name: i64 = load_ptr(expr, 2);
        let args: i64 = load_ptr(expr, 3);

        // Try to get the type of the object
        let type_name: i64 = 0;

        // If object is an identifier, look up its type
        let obj_tag: i64 = load_i64(object, 0);
        if obj_tag == EXPR_IDENT() {
            let obj_name: i64 = load_ptr(object, 1);
            type_name = lookup_var_type(cg, obj_name);
        }

        // Generate object value (this will be the first argument)
        let obj_val: i64 = gen_expr(cg, object);

        // Generate remaining arguments
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Check if this is a dyn trait object (Phase 32 dynamic dispatch)
        if is_dyn_type(type_name) != 0 {
            // Dynamic dispatch through vtable
            // dyn object layout: data_ptr(0), vtable_ptr(8)
            let trait_name: i64 = extract_dyn_trait(type_name);
            let method_idx: i64 = cg_get_vtable_method_index(cg, trait_name, method_name);

            // obj_val is a fat pointer (16 bytes): data_ptr + vtable_ptr
            // Convert to ptr to access fields
            let fat_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            // Load data pointer (offset 0)
            let data_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(data_ptr_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(fat_ptr_t));

            // Load vtable pointer (offset 8)
            let vtable_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_gep_t));
            emit(cg, " = getelementptr i8, ptr %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit_line(cg, ", i64 8");

            let vtable_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(vtable_gep_t));

            // Index into vtable to get function pointer
            let fn_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_gep_t));
            emit(cg, " = getelementptr ptr, ptr %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(method_idx));

            let fn_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(fn_gep_t));

            // Call through function pointer
            let t: i64 = cg_next_temp(cg);
            let temp: i64 = string_concat("%t", int_to_string(t));

            emit(cg, "  ");
            emit(cg, temp);
            emit(cg, " = call i64 %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, "(i64 %t");
            emit(cg, int_to_string(data_ptr_t));

            // Additional arguments
            let total_args: i64 = vec_len(arg_values);
            i = 0;
            while i < total_args {
                emit(cg, ", i64 ");
                emit(cg, vec_get(arg_values, i));
                i = i + 1;
            }
            emit_line(cg, ")");

            return temp;
        }

        // ===== PHASE 36: INLINE OPTION METHODS =====
        // Handle Option<T> methods inline (is_some, is_none, unwrap, unwrap_or)
        let base_type: i64 = extract_base_type(type_name);
        if string_eq(base_type, string_from("Option")) {
            // Option layout: tag at offset 0 (0=None, 1=Some), value at offset 8
            let opt_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(opt_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(opt_ptr_t));

            if string_eq(method_name, string_from("is_some")) {
                // tag == 1 means Some
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_none")) {
                // tag == 0 means None
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Some, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_some_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let some_lbl: i64 = string_concat("unwrap_or_some", int_to_string(lbl));
                let none_lbl: i64 = string_concat("unwrap_or_none", int_to_string(lbl));
                let done_lbl: i64 = string_concat("unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, ", label %");
                emit(cg, some_lbl);
                emit(cg, ", label %");
                emit_line(cg, none_lbl);

                emit(cg, some_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let some_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, none_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, ", %");
                emit(cg, some_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, none_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // ===== PHASE 36: INLINE RESULT METHODS =====
        // Handle Result<T,E> methods inline (is_ok, is_err, unwrap, unwrap_err, unwrap_or)
        if string_eq(base_type, string_from("Result")) {
            // Result layout: tag at offset 0 (0=Err, 1=Ok), value at offset 8
            let res_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(res_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(res_ptr_t));

            if string_eq(method_name, string_from("is_ok")) {
                // tag == 1 means Ok
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_err")) {
                // tag == 0 means Err
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_err")) {
                // Return error at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Ok, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_ok_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let ok_lbl: i64 = string_concat("result_unwrap_or_ok", int_to_string(lbl));
                let err_lbl: i64 = string_concat("result_unwrap_or_err", int_to_string(lbl));
                let done_lbl: i64 = string_concat("result_unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, ", label %");
                emit(cg, ok_lbl);
                emit(cg, ", label %");
                emit_line(cg, err_lbl);

                emit(cg, ok_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let ok_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, err_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, ", %");
                emit(cg, ok_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, err_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // Static dispatch - build mangled function name: TypeName_methodName
        let callee_name: i64 = method_name;
        if type_name != 0 {
            callee_name = string_concat(type_name, string_concat(string_from("_"), method_name));
        }

        // Emit call - object is first argument
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(i64 ");
        emit(cg, obj_val);

        let total_args: i64 = vec_len(arg_values);
        i = 0;
        while i < total_args {
            emit(cg, ", i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Try operator: expr? - check Result tag and early return on Err
    // Result layout: tag(0=Err, 1=Ok) at offset 0, value at offset 8
    if tag == EXPR_TRY() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Convert i64 to ptr
        let ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ptr_t));
        emit(cg, " = inttoptr i64 ");
        emit(cg, inner_val);
        emit_line(cg, " to ptr");

        // Load the tag (field 0)
        let tag_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tag_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(ptr_t));

        // Check if tag == 0 (Err)
        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp eq i64 %t");
        emit(cg, int_to_string(tag_t));
        emit_line(cg, ", 0");

        // Labels for conditional
        let label: i64 = cg_next_label(cg);
        let err_label: i64 = string_concat("try_err", int_to_string(label));
        let ok_label: i64 = string_concat("try_ok", int_to_string(label));

        // Branch: if Err goto err_label, else goto ok_label
        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, err_label);
        emit(cg, ", label %");
        emit_line(cg, ok_label);

        // Error path: early return the Result
        emit(cg, err_label);
        emit_line(cg, ":");
        emit(cg, "  ret i64 ");
        emit_line(cg, inner_val);

        // Ok path: unwrap the value (field 1, offset 8)
        emit(cg, ok_label);
        emit_line(cg, ":");
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr %t");
        emit(cg, int_to_string(ptr_t));
        emit_line(cg, ", i64 8");
        let val_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(val_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(val_t));
    }

    // EXPR_AWAIT - await a future
    if tag == EXPR_AWAIT() {
        let inner: i64 = load_ptr(expr, 1);
        let future_val: i64 = gen_expr(cg, inner);

        // For async context, we generate a state transition
        // For sync context, we poll in a loop until ready

        if cg_is_async_fn(cg) != 0 {
            // Inside async function - generate state machine transition
            let state_num: i64 = cg_next_async_state(cg);
            let resume_label: i64 = string_concat("await_resume_", int_to_string(state_num));

            // Save current state number
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(state_num));
            emit_line(cg, ", ptr %async_state");

            // Store the future we're awaiting
            emit(cg, "  store i64 ");
            emit(cg, future_val);
            emit_line(cg, ", ptr %async_inner_future");

            // Record this await point for the dispatch switch
            cg_add_await_point(cg, state_num, resume_label);

            // Poll the inner future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check poll result: 0 = Pending, 1 = Ready(value)
            let is_ready: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, " = and i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, ", 0");

            let pending_label: i64 = string_concat("await_pending_", int_to_string(state_num));
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, pending_label);
            emit(cg, ", label %");
            emit_line(cg, resume_label);

            // Pending path - return Pending from poll
            emit(cg, pending_label);
            emit_line(cg, ":");
            emit_line(cg, "  ret i64 0");  // Return Pending

            // Ready path - continue execution
            emit(cg, resume_label);
            emit_line(cg, ":");

            // Extract the value (shift right to remove tag bit)
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        } else {
            // Synchronous context - poll in a loop until ready
            let loop_label: i64 = string_concat("await_loop_", int_to_string(cg_next_label(cg)));
            let done_label: i64 = string_concat("await_done_", int_to_string(cg_next_label(cg)));

            emit(cg, "  br label %");
            emit_line(cg, loop_label);

            emit(cg, loop_label);
            emit_line(cg, ":");

            // Poll the future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check if ready
            let is_pending: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 0");

            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, ", label %");
            emit(cg, loop_label);
            emit(cg, ", label %");
            emit_line(cg, done_label);

            emit(cg, done_label);
            emit_line(cg, ":");

            // Extract the value
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        }
    }

    // EXPR_SPAWN - spawn an actor/specialist
    if tag == EXPR_SPAWN() {
        let type_name: i64 = load_ptr(expr, 1);
        // Generate call to TypeName_new() constructor
        let ctor_name: i64 = string_concat(type_name, "_new");
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @\"");
        emit(cg, ctor_name);
        emit_line(cg, "\"()");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_FLOAT - floating point literal
    if tag == EXPR_FLOAT() {
        let text: i64 = load_ptr(expr, 1);
        // Convert float string to f64 bits, store in i64
        // Use f64_parse intrinsic to convert string to f64 bits
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @f64_parse(ptr ");
        // Add string constant
        let str_idx: i64 = cg_add_string(cg, text);
        emit(cg, "@.str.mod.");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_ARRAY - array literal [a, b, c]
    if tag == EXPR_ARRAY() {
        let elements: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(elements);
        // Create a new vector and push all elements
        let vec_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " = call ptr @intrinsic_vec_new()");
        // Push each element
        let i: i64 = 0;
        while i < len {
            let elem: i64 = vec_get(elements, i);
            let elem_val: i64 = gen_expr(cg, elem);
            // Convert i64 to ptr for vec_push
            let ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, elem_val);
            emit_line(cg, " to ptr");
            emit(cg, "  call void @intrinsic_vec_push(ptr %t");
            emit(cg, int_to_string(vec_t));
            emit(cg, ", ptr %t");
            emit(cg, int_to_string(ptr_t));
            emit_line(cg, ")");
            i = i + 1;
        }
        // Return the vector as i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = ptrtoint ptr %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " to i64");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_CLOSURE - lambda/closure expression
    if tag == EXPR_CLOSURE() {
        let params: i64 = load_ptr(expr, 1);
        let body: i64 = load_ptr(expr, 2);

        // Generate a unique closure function name
        let closure_id: i64 = cg_next_closure_id(cg);
        let closure_name: i64 = string_concat("__closure_", int_to_string(closure_id));

        // For now, generate a simple non-capturing closure
        // The closure is a function pointer that can be called via call1/call2

        // Generate the closure function as a pending function
        // We'll emit it after the current function
        let saved_output: i64 = cg_get_output(cg);
        let saved_locals: i64 = cg_get_locals(cg);
        let saved_temp: i64 = cg_get_temp_counter(cg);
        let saved_local_id: i64 = cg_get_local_id(cg);

        // Create new output buffer for closure (StringBuilder)
        cg_set_output(cg, sb_new());
        cg_set_locals(cg, vec_new());
        cg_set_temp_counter(cg, 0);
        cg_set_local_id(cg, 0);

        // Generate closure function header
        emit(cg, "define i64 @\"");
        emit(cg, closure_name);
        emit(cg, "\"(");

        // Generate parameter list
        let num_params: i64 = vec_len(params);
        let i: i64 = 0;
        while i < num_params {
            if i > 0 {
                emit(cg, ", ");
            }
            let param: i64 = vec_get(params, i);
            let p_name: i64 = load_ptr(param, 0);
            emit(cg, "i64 %param.");
            emit(cg, p_name);
            i = i + 1;
        }
        emit_line(cg, ") {");
        emit_line(cg, "entry:");

        // Allocate locals for params
        i = 0;
        while i < num_params {
            let param: i64 = vec_get(params, i);
            let p_name: i64 = load_ptr(param, 0);
            let local_name: i64 = string_concat(p_name, ".0");
            emit(cg, "  %local.");
            emit(cg, local_name);
            emit_line(cg, " = alloca i64");
            emit(cg, "  store i64 %param.");
            emit(cg, p_name);
            emit(cg, ", ptr %local.");
            emit_line(cg, local_name);
            // Add to locals
            add_local(cg, p_name, local_name);
            i = i + 1;
        }

        // Generate body expression
        let body_val: i64 = gen_expr(cg, body);
        emit(cg, "  ret i64 ");
        emit_line(cg, body_val);
        emit_line(cg, "}");
        emit_line(cg, "");

        // Get closure code and restore state
        let closure_sb: i64 = cg_get_output(cg);
        let closure_code: i64 = sb_to_string(closure_sb);
        cg_set_output(cg, saved_output);
        cg_set_locals(cg, saved_locals);
        cg_set_temp_counter(cg, saved_temp);
        cg_set_local_id(cg, saved_local_id);

        // Add closure code to pending closures
        cg_add_closure(cg, closure_code);

        // Return function pointer as i64
        let fn_ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(fn_ptr_t));
        emit(cg, " = ptrtoint ptr @\"");
        emit(cg, closure_name);
        emit_line(cg, "\" to i64");
        return string_concat("%t", int_to_string(fn_ptr_t));
    }

    string_from("0")
}

// Generate if expression
fn gen_if(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let then_block: i64 = load_ptr(expr, 2);
    let else_block: i64 = load_ptr(expr, 3);

    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    let l: i64 = cg_next_label(cg);
    let then_lbl: i64 = string_concat("then", int_to_string(l));
    let then_end_lbl: i64 = string_concat("then", int_to_string(l));
    then_end_lbl = string_concat(then_end_lbl, "_end");
    let else_lbl: i64 = string_concat("else", int_to_string(l));
    let else_end_lbl: i64 = string_concat("else", int_to_string(l));
    else_end_lbl = string_concat(else_end_lbl, "_end");
    let end_lbl: i64 = string_concat("endif", int_to_string(l));

    // Branch
    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, then_lbl);
    emit(cg, ", label %");
    emit_line(cg, else_lbl);

    // Then block
    emit(cg, then_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let then_val: i64 = gen_block(cg, then_block);
    let then_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, then_end_lbl);
    // Then end block
    emit(cg, then_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Else block
    emit(cg, else_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let else_val: i64 = string_from("0");
    if else_block != 0 {
        else_val = gen_expr(cg, else_block);
    }
    let else_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, else_end_lbl);
    // Else end block
    emit(cg, else_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);

    // Phi with proper predecessor blocks
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = phi i64 [ ");
    emit(cg, then_val);
    emit(cg, ", %");
    emit(cg, then_end_lbl);
    emit(cg, " ], [ ");
    emit(cg, else_val);
    emit(cg, ", %");
    emit(cg, else_end_lbl);
    emit_line(cg, " ]");

    temp
}

// Generate while expression
fn gen_while(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let body: i64 = load_ptr(expr, 2);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let body_lbl: i64 = string_concat("body", int_to_string(l));
    let end_lbl: i64 = string_concat("endloop", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, loop_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate for expression: for i in start..end { body }
// Desugars to: let i = start; while i < end { body; i = i + 1; }
fn gen_for(cg: i64, expr: i64) -> i64 {
    let var_name: i64 = load_ptr(expr, 1);
    let start_expr: i64 = load_ptr(expr, 2);
    let end_expr: i64 = load_ptr(expr, 3);
    let body: i64 = load_ptr(expr, 4);

    // Generate start value
    let start_val: i64 = gen_expr(cg, start_expr);

    // Use pre-allocated local for loop variable
    let unique_name: i64 = cg_pop_alloca(cg);
    if unique_name == 0 {
        // Fallback: allocate inline (shouldn't happen with proper pre-pass)
        let local_id: i64 = cg_next_temp(cg);
        unique_name = string_concat(var_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
    }
    // Initialize loop variable
    emit(cg, "  store i64 ");
    emit(cg, start_val);
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);
    add_local(cg, var_name, unique_name);

    // Generate end value (before the loop since it's evaluated once)
    let end_val: i64 = gen_expr(cg, end_expr);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("for", int_to_string(l));
    let body_lbl: i64 = string_concat("forbody", int_to_string(l));
    let inc_lbl: i64 = string_concat("forinc", int_to_string(l));
    let end_lbl: i64 = string_concat("endfor", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition: i < end
    emit(cg, loop_lbl);
    emit_line(cg, ":");

    // Load current loop variable
    let cur_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    // Compare i < end
    let cmp_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, " = icmp slt i64 %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, ", ");
    emit_line(cg, end_val);

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, inc_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, inc_lbl);

    // Increment loop variable: i = i + 1
    emit(cg, inc_lbl);
    emit_line(cg, ":");
    let load_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(load_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    let inc_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, " = add i64 %t");
    emit(cg, int_to_string(load_t));
    emit_line(cg, ", 1");

    emit(cg, "  store i64 %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate match expression
// Lowered to a series of if-else comparisons
fn gen_match(cg: i64, expr: i64) -> i64 {
    let scrutinee: i64 = load_ptr(expr, 1);
    let arms: i64 = load_ptr(expr, 2);
    let num_arms: i64 = vec_len(arms);

    // Evaluate scrutinee once
    let scru_val: i64 = gen_expr(cg, scrutinee);

    let l: i64 = cg_next_label(cg);
    let end_lbl: i64 = string_concat("matchend", int_to_string(l));

    // Collect arm labels and results for phi
    let arm_labels: i64 = vec_new();
    let arm_results: i64 = vec_new();

    // Process each arm
    let i: i64 = 0;
    while i < num_arms {
        let arm: i64 = vec_get(arms, i);
        let pattern: i64 = load_ptr(arm, 0);
        let result: i64 = load_ptr(arm, 1);

        let arm_lbl: i64 = string_concat("arm", int_to_string(l));
        arm_lbl = string_concat(arm_lbl, string_concat("_", int_to_string(i)));
        let arm_end_lbl: i64 = string_concat(arm_lbl, "_end");
        let next_lbl: i64 = string_concat("arm", int_to_string(l));
        next_lbl = string_concat(next_lbl, string_concat("_", int_to_string(i + 1)));

        // Check if this is the last arm or wildcard
        let is_last: i64 = i == num_arms - 1;
        let is_wildcard: i64 = pattern == 0;

        if is_wildcard != 0 {
            // Wildcard - unconditional jump to arm
            emit(cg, "  br label %");
            emit_line(cg, arm_lbl);
        } else {
            // Generate pattern value
            let pat_val: i64 = gen_expr(cg, pattern);

            // Compare scrutinee == pattern
            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 ");
            emit(cg, scru_val);
            emit(cg, ", ");
            emit_line(cg, pat_val);

            // Branch: if match goto arm, else goto next/end
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, arm_lbl);
            emit(cg, ", label %");
            if is_last != 0 {
                // Last arm without wildcard - shouldn't happen in well-formed match
                emit_line(cg, end_lbl);
            } else {
                emit_line(cg, next_lbl);
            }
        }

        // Arm body
        emit(cg, arm_lbl);
        emit_line(cg, ":");
        cg_set_terminated(cg, false);
        let arm_val: i64 = gen_expr(cg, result);
        emit(cg, "  br label %");
        emit_line(cg, arm_end_lbl);

        // Arm end block for phi
        emit(cg, arm_end_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, end_lbl);

        vec_push(arm_labels, arm_end_lbl);
        vec_push(arm_results, arm_val);

        i = i + 1;
    }

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");

    let result_t: i64 = cg_next_temp(cg);
    let result_temp: i64 = string_concat("%t", int_to_string(result_t));
    emit(cg, "  ");
    emit(cg, result_temp);
    emit(cg, " = phi i64 ");

    i = 0;
    while i < num_arms {
        if i > 0 {
            emit(cg, ", ");
        }
        emit(cg, "[ ");
        emit(cg, vec_get(arm_results, i));
        emit(cg, ", %");
        emit(cg, vec_get(arm_labels, i));
        emit(cg, " ]");
        i = i + 1;
    }
    emit_line(cg, "");

    result_temp
}

// Generate block
fn gen_block(cg: i64, block: i64) -> i64 {
    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);

    let n: i64 = vec_len(stmts);
    let i: i64 = 0;
    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        gen_stmt(cg, stmt);
        i = i + 1;
    }

    if result != 0 {
        return gen_expr(cg, result);
    }

    string_from("0")
}

// Generate statement
fn gen_stmt(cg: i64, stmt: i64) -> i64 {
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        let ty: i64 = load_ptr(stmt, 2);
        let init_expr: i64 = load_ptr(stmt, 3);

        // Use pre-allocated local from entry block
        let unique_name: i64 = cg_pop_alloca(cg);
        if unique_name == 0 {
            // Fallback: allocate inline (shouldn't happen with proper pre-pass)
            let local_id: i64 = cg_next_temp(cg);
            unique_name = string_concat(name, string_concat(".", int_to_string(local_id)));
            emit(cg, "  %local.");
            emit(cg, unique_name);
            emit_line(cg, " = alloca i64");
        }
        add_local(cg, name, unique_name);

        // Record type if present (for method call resolution)
        if ty != 0 {
            add_var_type(cg, name, ty);
        }

        // Initialize if there's an init expression
        if init_expr != 0 {
            let val: i64 = gen_expr(cg, init_expr);
            emit(cg, "  store i64 ");
            emit(cg, val);
            emit(cg, ", ptr %local.");
            emit_line(cg, unique_name);
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            gen_expr(cg, expr);
        }
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            let val: i64 = gen_expr(cg, expr);
            emit(cg, "  ret i64 ");
            emit_line(cg, val);
        } else {
            emit_line(cg, "  ret void");
        }
        cg_set_terminated(cg, true);
        return 0;
    }

    // Assignment statement
    if tag == STMT_ASSIGN() {
        let name: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        let val: i64 = gen_expr(cg, value);
        let unique_name: i64 = lookup_local(cg, name);
        emit(cg, "  store i64 ");
        emit(cg, val);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        return 0;
    }

    // Break statement
    if tag == STMT_BREAK() {
        let break_lbl: i64 = current_loop_break(cg);
        if break_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, break_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_break");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    // Continue statement
    if tag == STMT_CONTINUE() {
        let continue_lbl: i64 = current_loop_continue(cg);
        if continue_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, continue_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_continue");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    0
}

// Generate async function as a Future with poll method
fn gen_async_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Future struct: poll_fn(0), state(8), inner_future(16), result(24), params(32+), locals...
    let future_name: i64 = string_concat(name, "_Future");

    // Set async context
    cg_set_async_fn(cg, 1);
    cg_set_async_fn_name(cg, name);
    cg_reset_async_state(cg);
    cg_clear_await_points(cg);
    cg_clear_locals(cg);

    // Generate the constructor function that creates the future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit(cg, "\"(");

    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Allocate future struct: poll_fn + state + inner_future + result + params + locals
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let struct_size: i64 = 32 + n * 8 + num_locals * 8;  // 4 fields + params + locals

    emit(cg, "  %future = call ptr @malloc(i64 ");
    emit(cg, int_to_string(struct_size));
    emit_line(cg, ")");

    // Store poll function pointer at offset 0
    emit(cg, "  %poll_fn_ptr = ptrtoint ptr @\"");
    emit(cg, name);
    emit_line(cg, "_poll\" to i64");
    emit_line(cg, "  store i64 %poll_fn_ptr, ptr %future");

    // Initialize state to 0 at offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  store i64 0, ptr %state_ptr");

    // Store parameters in future struct (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %param_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %param_ptr_");
        emit_line(cg, int_to_string(i));
        i = i + 1;
    }

    // Return the future pointer as i64
    emit_line(cg, "  %result = ptrtoint ptr %future to i64");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate the poll function for this future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_poll\"(i64 %future_ptr) {");
    emit_line(cg, "entry:");

    // Convert future_ptr to actual pointer
    emit_line(cg, "  %future = inttoptr i64 %future_ptr to ptr");

    // Allocate async state tracking
    emit_line(cg, "  %async_state = alloca i64");
    emit_line(cg, "  %async_inner_future = alloca i64");

    // Load current state from offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  %state = load i64, ptr %state_ptr");
    emit_line(cg, "  store i64 %state, ptr %async_state");

    // Load parameters from future struct into locals (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  %param_load_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, " = load i64, ptr %param_load_ptr_");
        emit_line(cg, int_to_string(i));
        emit(cg, "  store i64 %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);
        i = i + 1;
    }

    // Pre-allocate locals
    cg_clear_alloca_queue(cg);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // State dispatch switch
    emit_line(cg, "  switch i64 %state, label %state_0 [");
    emit_line(cg, "    i64 0, label %state_0");
    emit_line(cg, "  ]");

    // State 0 - start of function
    emit_line(cg, "state_0:");

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Return Ready with value (tagged: value << 1 | 1)
    if cg_is_terminated(cg) == false {
        let ret_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ret_t));
        emit(cg, " = shl i64 ");
        emit(cg, result);
        emit_line(cg, ", 1");
        let tagged_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tagged_t));
        emit(cg, " = or i64 %t");
        emit(cg, int_to_string(ret_t));
        emit_line(cg, ", 1");
        emit(cg, "  ret i64 %t");
        emit_line(cg, int_to_string(tagged_t));
    }

    emit_line(cg, "}");
    emit_line(cg, "");

    // Reset async context
    cg_set_async_fn(cg, 0);

    0
}

// Generate function
fn gen_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let type_params: i64 = load_ptr(fn_def, 2);  // Generic type params (or 0)
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);
    let is_async: i64 = load_i64(fn_def, 6);

    // If this is a generic function, register it but don't generate code yet
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            cg_register_generic(cg, name, fn_def);
            return 0;
        }
    }

    // Handle async functions
    if is_async != 0 {
        return gen_async_fn(cg, fn_def);
    }

    // Rename main to simplex_main
    let emit_name: i64 = name;
    if string_eq(name, "main") {
        emit_name = string_from("simplex_main");
    }

    cg_clear_locals(cg);

    // Function signature
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, emit_name);
    emit(cg, "\"(");

    // Parameters
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate ALL local variables in the entry block to avoid
    // allocas in loops/conditionals which cause stack corruption
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // Copy params to locals
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);  // Params use same name
        i = i + 1;
    }

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Only emit final return if body didn't already terminate
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Generate a monomorphized instantiation of a generic function
fn gen_fn_instantiation(cg: i64, fn_def: i64, mangled_name: i64, type_args: i64) -> i64 {
    let type_params: i64 = load_ptr(fn_def, 2);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Check trait bounds before proceeding
    if check_trait_bounds(cg, type_params, type_args) == 0 {
        println(string_concat("  in instantiation of: ", mangled_name));
        // Continue anyway for now - error was already printed
    }

    cg_clear_locals(cg);
    cg_clear_const_params(cg);
    cg_clear_type_params(cg);

    // Set up type params and const params from type_params and type_args
    // type_params has names like "T", "T:Trait" (bounded), or "const:N"
    // type_args has corresponding values like "i64" or "10"
    if type_params != 0 {
        if type_args != 0 {
            let num_type_params: i64 = vec_len(type_params);
            let tp_idx: i64 = 0;
            while tp_idx < num_type_params {
                let type_param: i64 = vec_get(type_params, tp_idx);
                // Check if this is a const param (has "const:" prefix)
                if string_starts_with(type_param, string_from("const:")) {
                    // Extract the name after "const:"
                    let const_name: i64 = string_slice(type_param, 6, string_len(type_param));
                    // Get the corresponding value from type_args
                    if tp_idx < vec_len(type_args) {
                        let const_value: i64 = vec_get(type_args, tp_idx);
                        cg_add_const_param(cg, const_name, const_value);
                    }
                } else {
                    // Regular type parameter (e.g., "T" or "T:Trait")
                    // Extract just the param name (before any : for bound)
                    let param_name: i64 = extract_type_param_name(type_param);
                    // Get the corresponding concrete type from type_args
                    if tp_idx < vec_len(type_args) {
                        let concrete_type: i64 = vec_get(type_args, tp_idx);
                        cg_add_type_param(cg, param_name, concrete_type);
                    }
                }
                tp_idx = tp_idx + 1;
            }
        }
    }

    // Function signature with mangled name
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, mangled_name);
    emit(cg, "\"(");

    // Parameters (all i64 in bootstrap compiler)
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate local variables
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        add_local(cg, local_name, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        j = j + 1;
    }

    // Copy parameters to local variables
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(pname, string_concat(".", int_to_string(local_id)));
        add_local(cg, pname, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        i = i + 1;
    }

    cg_set_terminated(cg, false);

    // Generate body
    let result: i64 = gen_block(cg, body);

    // Return
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Mangle a generic function name with type arguments
fn mangle_generic_name(name: i64, type_args: i64) -> i64 {
    let result: i64 = name;
    let n: i64 = vec_len(type_args);
    let i: i64 = 0;
    while i < n {
        result = string_concat(result, string_from("_"));
        result = string_concat(result, vec_get(type_args, i));
        i = i + 1;
    }
    result
}

// Generate enum (just register it)
fn gen_enum(cg: i64, enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    register_enum(cg, name, variants);
    0
}

// Generate struct (register it or store as template if generic)
fn gen_struct(cg: i64, struct_def: i64) -> i64 {
    let name: i64 = load_ptr(struct_def, 1);
    let type_params: i64 = load_ptr(struct_def, 2);
    let fields: i64 = load_ptr(struct_def, 3);

    // Check if this is a generic struct
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            // Store as template for later monomorphization
            cg_add_generic_struct_template(cg, name, type_params, fields);
            return 0;
        }
    }

    // Non-generic struct: register immediately
    register_struct(cg, name, fields);
    0
}

// Generate impl block
// Methods are generated with mangled names: TypeName_methodName
fn gen_impl(cg: i64, impl_def: i64) -> i64 {
    let type_name: i64 = load_ptr(impl_def, 1);
    let methods: i64 = load_ptr(impl_def, 2);
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Get method name and mangle it: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = string_concat(type_name, string_concat(string_from("_"), method_name));
        // Store mangled name back into the method AST
        store_ptr(method, 1, mangled_name);
        // Generate the function
        gen_fn(cg, method);
        i = i + 1;
    }

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate trait (just a declaration, no code)
fn gen_trait(cg: i64, trait_def: i64) -> i64 {
    // Register trait and its default methods for later use
    let name: i64 = load_ptr(trait_def, 1);
    let method_sigs: i64 = load_ptr(trait_def, 2);

    // Register trait definition for vtable layout (Phase 32)
    cg_register_trait_def(cg, name, method_sigs);

    // Store default method implementations in codegen context
    let num_methods: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < num_methods {
        let method_sig: i64 = vec_get(method_sigs, i);
        // Default methods have fn_def at offset 3
        let fn_def: i64 = load_ptr(method_sig, 3);
        if fn_def != 0 {
            // This is a default method - register it
            let method_name: i64 = load_ptr(method_sig, 0);
            cg_register_default_method(cg, name, method_name, fn_def);
        }
        i = i + 1;
    }
    0
}

// Generate impl Trait for Type block
// Methods are named: TypeName_methodName (same as regular impl, for simplicity)
fn gen_impl_trait(cg: i64, impl_def: i64) -> i64 {
    let trait_name: i64 = load_ptr(impl_def, 1);
    let type_name: i64 = load_ptr(impl_def, 2);
    let methods: i64 = load_ptr(impl_def, 3);
    let assoc_types: i64 = load_ptr(impl_def, 4);

    // Register this trait implementation for bounds checking
    cg_register_trait_impl(cg, type_name, trait_name);

    // Register associated types for this impl
    if assoc_types != 0 {
        let num_assoc: i64 = vec_len(assoc_types);
        let j: i64 = 0;
        while j < num_assoc {
            let assoc: i64 = vec_get(assoc_types, j);
            let assoc_name: i64 = load_ptr(assoc, 0);
            let assoc_ty: i64 = load_ptr(assoc, 1);
            cg_register_assoc_type(cg, type_name, assoc_name, assoc_ty);
            j = j + 1;
        }
    }

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    // Build list of mangled method names for vtable generation
    let mangled_methods: i64 = vec_new();
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Mangle method name: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = string_concat(type_name, string_concat(string_from("_"), method_name));
        store_ptr(method, 1, mangled_name);
        vec_push(mangled_methods, mangled_name);
        gen_fn(cg, method);
        i = i + 1;
    }

    // Generate vtable for this (type, trait) pair (Phase 32)
    gen_vtable(cg, type_name, trait_name, mangled_methods);

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate a vtable global for dynamic dispatch (Phase 32)
// Layout: array of function pointers matching trait method order
fn gen_vtable(cg: i64, type_name: i64, trait_name: i64, impl_methods: i64) -> i64 {
    // Get trait method signatures for vtable ordering
    let trait_methods: i64 = cg_get_trait_methods(cg, trait_name);
    if trait_methods == 0 {
        // Trait not yet seen - will generate vtable later
        return 0;
    }

    let num_trait_methods: i64 = vec_len(trait_methods);
    if num_trait_methods == 0 {
        return 0;
    }

    // Vtable global name: @vtable_TypeName_TraitName
    let vtable_name: i64 = string_concat(string_from("@vtable_"), type_name);
    vtable_name = string_concat(vtable_name, string_from("_"));
    vtable_name = string_concat(vtable_name, trait_name);

    // Register vtable
    cg_register_vtable(cg, type_name, trait_name, vtable_name);

    // Generate vtable global: @vtable_Type_Trait = global [N x ptr] [ptr @Type_method1, ptr @Type_method2, ...]
    emit(cg, vtable_name);
    emit(cg, " = global [");
    emit(cg, int_to_string(num_trait_methods));
    emit(cg, " x ptr] [");

    // Match trait methods to impl methods and emit function pointers
    let i: i64 = 0;
    while i < num_trait_methods {
        if i > 0 {
            emit(cg, ", ");
        }
        let trait_sig: i64 = vec_get(trait_methods, i);
        let trait_method_name: i64 = load_ptr(trait_sig, 0);

        // Find corresponding impl method (TypeName_methodName)
        let mangled: i64 = string_concat(type_name, string_concat(string_from("_"), trait_method_name));
        emit(cg, "ptr @\"");
        emit(cg, mangled);
        emit(cg, "\"");
        i = i + 1;
    }

    emit_line(cg, "]");
    0
}

// Generate actor definition (Phase 33)
// Actors become struct + message handlers + mailbox functions
fn gen_actor(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let state_fields: i64 = load_ptr(item, 2);
    let handlers: i64 = load_ptr(item, 3);
    let init_fn: i64 = load_ptr(item, 4);

    emit(cg, "; Actor: ");
    emit_line(cg, name);

    // Register actor state as a struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate actor_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %actor = call ptr @malloc(i64 64)");
    emit_line(cg, "  %ret = ptrtoint ptr %actor to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate message handler functions
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);
            let params: i64 = load_ptr(handler, 1);
            let body: i64 = load_ptr(handler, 2);

            // Generate handler function: ActorName_handle_MsgName
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit_line(cg, "\"(i64 %self) {");
            emit_line(cg, "entry:");
            emit_line(cg, "  ret i64 0");
            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate specialist definition (Phase 33)
// Specialists are AI agents with capabilities and knowledge
fn gen_specialist(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let config: i64 = load_ptr(item, 2);
    let state_fields: i64 = load_ptr(item, 3);
    let handlers: i64 = load_ptr(item, 4);

    emit(cg, "; Specialist: ");
    emit_line(cg, name);

    // Register state fields as struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate specialist_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %spec = call ptr @malloc(i64 64)");
    emit_line(cg, "  %ret = ptrtoint ptr %spec to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate infer function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_infer\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  ret i64 0");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate message handlers (like actor receive)
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);

            // Generate handler function
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit_line(cg, "\"(i64 %self) {");
            emit_line(cg, "entry:");
            emit_line(cg, "  ret i64 0");
            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate hive definition (Phase 33)
// Hives orchestrate multiple specialists
fn gen_hive(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let specialists: i64 = load_ptr(item, 2);
    let routing: i64 = load_ptr(item, 3);

    emit(cg, "; Hive: ");
    emit_line(cg, name);

    // Generate hive_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %hive = call ptr @malloc(i64 128)");
    emit_line(cg, "  %ret = ptrtoint ptr %hive to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate dispatch function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_dispatch\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  ret i64 0");
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate item
fn gen_item(cg: i64, item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == TAG_FN() {
        return gen_fn(cg, item);
    }
    if tag == TAG_ENUM() {
        return gen_enum(cg, item);
    }
    if tag == TAG_STRUCT() {
        return gen_struct(cg, item);
    }
    if tag == TAG_IMPL() {
        return gen_impl(cg, item);
    }
    if tag == TAG_TRAIT() {
        return gen_trait(cg, item);
    }
    if tag == TAG_IMPL_TRAIT() {
        return gen_impl_trait(cg, item);
    }
    // TAG_MOD and TAG_USE don't generate code - they're for the build system
    if tag == TAG_MOD() {
        return 0;
    }
    if tag == TAG_USE() {
        return 0;
    }
    // Actor, Specialist, Hive - call dedicated generators
    if tag == TAG_ACTOR() {
        return gen_actor(cg, item);
    }
    if tag == TAG_SPECIALIST() {
        return gen_specialist(cg, item);
    }
    if tag == TAG_HIVE() {
        return gen_hive(cg, item);
    }
    0
}

// Generate program header
fn gen_header(cg: i64) -> i64 {
    emit_line(cg, "; ModuleID = 'simplex_program'");
    emit_line(cg, "target triple = \"x86_64-apple-macosx14.0.0\"");
    emit_line(cg, "");
    emit_line(cg, "declare ptr @malloc(i64)");
    emit_line(cg, "declare void @free(ptr)");
    emit_line(cg, "declare void @intrinsic_println(ptr)");
    emit_line(cg, "declare void @intrinsic_print(ptr)");
    emit_line(cg, "declare ptr @intrinsic_int_to_string(i64)");
    emit_line(cg, "declare ptr @intrinsic_string_new(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_from_char(i64)");
    emit_line(cg, "declare i64 @intrinsic_string_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_concat(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_slice(ptr, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_string_char_at(ptr, i64)");
    emit_line(cg, "declare i1 @intrinsic_string_eq(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_to_int(ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_new()");
    emit_line(cg, "declare void @intrinsic_vec_push(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_get(ptr, i64)");
    emit_line(cg, "declare i64 @intrinsic_vec_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_args()");
    emit_line(cg, "declare ptr @intrinsic_read_file(ptr)");
    emit_line(cg, "declare void @intrinsic_write_file(ptr, ptr)");
    emit_line(cg, "declare ptr @store_ptr(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @store_i64(ptr, i64, i64)");
    emit_line(cg, "declare ptr @load_ptr(ptr, i64)");
    emit_line(cg, "declare i64 @load_i64(ptr, i64)");
    emit_line(cg, "; Timing intrinsics");
    emit_line(cg, "declare i64 @intrinsic_get_time_ms()");
    emit_line(cg, "declare i64 @intrinsic_get_time_us()");
    emit_line(cg, "; Arena allocator intrinsics");
    emit_line(cg, "declare ptr @intrinsic_arena_create(i64)");
    emit_line(cg, "declare ptr @intrinsic_arena_alloc(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_arena_reset(ptr)");
    emit_line(cg, "declare void @intrinsic_arena_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_arena_used(ptr)");
    emit_line(cg, "; StringBuilder intrinsics");
    emit_line(cg, "declare ptr @intrinsic_sb_new()");
    emit_line(cg, "declare ptr @intrinsic_sb_new_cap(i64)");
    emit_line(cg, "declare void @intrinsic_sb_append(ptr, ptr)");
    emit_line(cg, "declare void @intrinsic_sb_append_char(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_sb_append_i64(ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_sb_to_string(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_clear(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_sb_len(ptr)");
    emit_line(cg, "; File I/O intrinsics");
    emit_line(cg, "declare i64 @intrinsic_file_exists(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_file(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_directory(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_size(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_mtime(ptr)");
    emit_line(cg, "declare i64 @intrinsic_remove_path(ptr)");
    emit_line(cg, "declare i64 @intrinsic_mkdir_p(ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_cwd()");
    emit_line(cg, "declare i64 @intrinsic_set_cwd(ptr)");
    emit_line(cg, "declare ptr @intrinsic_list_dir(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_join(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_dirname(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_basename(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_extension(ptr)");
    emit_line(cg, "; Error handling intrinsics");
    emit_line(cg, "declare void @intrinsic_panic(ptr)");
    emit_line(cg, "declare void @intrinsic_print_stack_trace()");
    emit_line(cg, "; Process intrinsics");
    emit_line(cg, "declare i64 @intrinsic_process_run(ptr)");
    emit_line(cg, "declare ptr @intrinsic_process_output(ptr)");
    emit_line(cg, "; Phase 20: REPL/I/O intrinsics");
    emit_line(cg, "declare ptr @intrinsic_read_line()");
    emit_line(cg, "declare i64 @intrinsic_is_tty()");
    emit_line(cg, "declare i64 @intrinsic_stdin_has_data()");
    emit_line(cg, "declare i64 @intrinsic_string_hash(ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_find(ptr, ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_string_trim(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_split(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_starts_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_ends_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_contains(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_replace(ptr, ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_copy_file(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_home_dir()");
    // Float parsing
    emit_line(cg, "declare i64 @f64_parse(ptr)");

    // Async runtime
    emit_line(cg, "declare i64 @future_poll(i64)");
    emit_line(cg, "declare i64 @future_ready(i64)");
    emit_line(cg, "declare i64 @future_pending()");
    emit_line(cg, "declare void @executor_run(i64)");
    emit_line(cg, "declare i64 @executor_spawn(i64)");

    // Async combinators
    emit_line(cg, "declare i64 @async_join(i64, i64)");
    emit_line(cg, "declare i64 @join_result1(i64)");
    emit_line(cg, "declare i64 @join_result2(i64)");
    emit_line(cg, "declare i64 @async_select(i64, i64)");
    emit_line(cg, "declare i64 @select_result(i64)");
    emit_line(cg, "declare i64 @select_which(i64)");
    emit_line(cg, "declare i64 @async_timeout(i64, i64)");
    emit_line(cg, "declare i64 @timeout_result(i64)");
    emit_line(cg, "declare i64 @timeout_expired(i64)");
    emit_line(cg, "declare i64 @time_now_ms()");

    // Pin<T>
    emit_line(cg, "declare i64 @pin_new(i64, i64)");
    emit_line(cg, "declare i64 @pin_new_uninit(i64)");
    emit_line(cg, "declare i64 @pin_get(i64)");
    emit_line(cg, "declare i64 @pin_get_mut(i64)");
    emit_line(cg, "declare i64 @pin_is_pinned(i64)");
    emit_line(cg, "declare void @pin_ref(i64)");
    emit_line(cg, "declare void @pin_unref(i64)");
    emit_line(cg, "declare void @pin_set_self_ref(i64, i64)");
    emit_line(cg, "declare i64 @pin_check_self_ref(i64, i64)");

    // Function pointer calls
    emit_line(cg, "declare i64 @intrinsic_call0(i64)");
    emit_line(cg, "declare i64 @intrinsic_call1(i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call2(i64, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call3(i64, i64, i64, i64)");

    // Structured concurrency
    emit_line(cg, "declare i64 @scope_new()");
    emit_line(cg, "declare i64 @scope_spawn(i64, i64)");
    emit_line(cg, "declare i64 @scope_poll(i64)");
    emit_line(cg, "declare i64 @scope_join(i64)");
    emit_line(cg, "declare i64 @scope_get_result(i64, i64)");
    emit_line(cg, "declare void @scope_cancel(i64)");
    emit_line(cg, "declare i64 @scope_count(i64)");
    emit_line(cg, "declare i64 @scope_completed(i64)");
    emit_line(cg, "declare void @scope_free(i64)");
    emit_line(cg, "declare i64 @nursery_run(i64, i64)");

    // Phase 23.4: Actor Error Handling
    emit_line(cg, "declare i64 @actor_get_status(i64)");
    emit_line(cg, "declare i64 @actor_get_exit_reason(i64)");
    emit_line(cg, "declare i64 @actor_get_error_code(i64)");
    emit_line(cg, "declare void @actor_set_error(i64, i64, i64)");
    emit_line(cg, "declare void @actor_stop(i64)");
    emit_line(cg, "declare void @actor_kill(i64)");
    emit_line(cg, "declare void @actor_crash(i64, i64, i64)");
    emit_line(cg, "declare void @actor_set_on_error(i64, i64)");
    emit_line(cg, "declare void @actor_set_on_exit(i64, i64)");
    emit_line(cg, "declare void @actor_set_supervisor(i64, i64)");
    emit_line(cg, "declare i64 @actor_get_supervisor(i64)");
    emit_line(cg, "declare i64 @actor_get_restart_count(i64)");
    emit_line(cg, "declare void @actor_increment_restart(i64)");
    emit_line(cg, "declare i64 @actor_is_alive(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @circuit_breaker_allow(i64)");
    emit_line(cg, "declare void @circuit_breaker_success(i64)");
    emit_line(cg, "declare void @circuit_breaker_failure(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_state(i64)");
    emit_line(cg, "declare void @circuit_breaker_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_new(i64, i64, i64, i64)");
    emit_line(cg, "declare void @retry_policy_set_jitter(i64, i64)");
    emit_line(cg, "declare i64 @retry_policy_should_retry(i64)");
    emit_line(cg, "declare i64 @retry_policy_next_delay(i64)");
    emit_line(cg, "declare void @retry_policy_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_count(i64)");

    // Phase 23.5: Actor Linking and Monitoring
    emit_line(cg, "declare i64 @actor_link(i64, i64)");
    emit_line(cg, "declare void @actor_unlink(i64, i64)");
    emit_line(cg, "declare i64 @actor_monitor(i64, i64)");
    emit_line(cg, "declare void @actor_demonitor(i64)");
    emit_line(cg, "declare void @actor_propagate_exit(i64, i64)");
    emit_line(cg, "declare i64 @actor_is_linked(i64, i64)");
    emit_line(cg, "declare i64 @actor_spawn_link(i64, i64, i64)");
    emit_line(cg, "declare i64 @actor_get_links_count(i64)");
    emit_line(cg, "declare i64 @actor_send_down(i64, i64, i64)");

    // Phase 23.1: Supervision Trees
    emit_line(cg, "; Phase 23.1: Supervision Trees");
    emit_line(cg, "declare i64 @supervisor_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_add_child(i64, i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_start(i64)");
    emit_line(cg, "declare void @supervisor_stop(i64)");
    emit_line(cg, "declare i64 @supervisor_handle_exit(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_count(i64)");
    emit_line(cg, "declare i64 @supervisor_child_status(i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_handle(i64, i64)");
    emit_line(cg, "declare void @supervisor_free(i64)");
    emit_line(cg, "declare i64 @strategy_one_for_one()");
    emit_line(cg, "declare i64 @strategy_one_for_all()");
    emit_line(cg, "declare i64 @strategy_rest_for_one()");
    emit_line(cg, "declare i64 @child_permanent()");
    emit_line(cg, "declare i64 @child_temporary()");
    emit_line(cg, "declare i64 @child_transient()");

    // Phase 23.2: Work-Stealing Scheduler
    emit_line(cg, "; Phase 23.2: Work-Stealing Scheduler");
    emit_line(cg, "declare i64 @scheduler_new(i64)");
    emit_line(cg, "declare i64 @scheduler_start(i64)");
    emit_line(cg, "declare i64 @scheduler_submit(i64, i64, i64)");
    emit_line(cg, "declare i64 @scheduler_submit_local(i64, i64, i64, i64)");
    emit_line(cg, "declare void @scheduler_stop(i64)");
    emit_line(cg, "declare void @scheduler_free(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_count(i64)");
    emit_line(cg, "declare i64 @scheduler_queue_size(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_idle(i64, i64)");

    // Phase 23.3: Lock-Free Mailbox
    emit_line(cg, "; Phase 23.3: Lock-Free Mailbox");
    emit_line(cg, "declare i64 @mailbox_new(i64)");
    emit_line(cg, "declare i64 @mailbox_send(i64, i64)");
    emit_line(cg, "declare i64 @mailbox_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_try_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_size(i64)");
    emit_line(cg, "declare i64 @mailbox_empty(i64)");
    emit_line(cg, "declare i64 @mailbox_full(i64)");
    emit_line(cg, "declare void @mailbox_close(i64)");
    emit_line(cg, "declare i64 @mailbox_is_closed(i64)");
    emit_line(cg, "declare void @mailbox_free(i64)");

    // Phase 23.6: Actor Discovery and Registry
    emit_line(cg, "; Phase 23.6: Actor Discovery and Registry");
    emit_line(cg, "declare i64 @registry_register(i64, i64)");
    emit_line(cg, "declare void @registry_unregister(i64)");
    emit_line(cg, "declare i64 @registry_lookup(i64)");
    emit_line(cg, "declare i64 @registry_count()");
    emit_line(cg, "declare i64 @registry_set_metadata(i64, i64)");
    emit_line(cg, "declare i64 @registry_get_metadata(i64)");

    // Phase 23.7: Backpressure and Flow Control
    emit_line(cg, "; Phase 23.7: Backpressure and Flow Control");
    emit_line(cg, "declare i64 @flow_controller_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @flow_check(i64)");
    emit_line(cg, "declare i64 @flow_acquire(i64)");
    emit_line(cg, "declare void @flow_release(i64)");
    emit_line(cg, "declare i64 @flow_is_signaling(i64)");
    emit_line(cg, "declare i64 @flow_current(i64)");
    emit_line(cg, "declare i64 @flow_high_watermark(i64)");
    emit_line(cg, "declare i64 @flow_low_watermark(i64)");
    emit_line(cg, "declare void @flow_reset(i64)");
    emit_line(cg, "declare void @flow_free(i64)");
    emit_line(cg, "declare i64 @flow_mode_drop()");
    emit_line(cg, "declare i64 @flow_mode_block()");
    emit_line(cg, "declare i64 @flow_mode_signal()");

    // Phase 1 Stdlib: Option<T>
    emit_line(cg, "; Phase 1 Stdlib: Option");
    emit_line(cg, "declare ptr @option_some(i64)");
    emit_line(cg, "declare ptr @option_none()");
    emit_line(cg, "declare i8 @option_is_some(i64)");
    emit_line(cg, "declare i8 @option_is_none(i64)");
    emit_line(cg, "declare i64 @option_unwrap(i64)");
    emit_line(cg, "declare i64 @option_expect(i64, i64)");
    emit_line(cg, "declare i64 @option_unwrap_or(i64, i64)");
    emit_line(cg, "declare i64 @option_unwrap_or_else(i64, i64)");
    emit_line(cg, "declare i64 @option_map(i64, i64)");
    emit_line(cg, "declare i64 @option_map_or(i64, i64, i64)");
    emit_line(cg, "declare i64 @option_map_or_else(i64, i64, i64)");
    emit_line(cg, "declare i64 @option_and(i64, i64)");
    emit_line(cg, "declare i64 @option_and_then(i64, i64)");
    emit_line(cg, "declare i64 @option_or(i64, i64)");
    emit_line(cg, "declare i64 @option_or_else(i64, i64)");
    emit_line(cg, "declare i64 @option_filter(i64, i64)");
    emit_line(cg, "declare i64 @option_clone(i64)");
    emit_line(cg, "declare i64 @option_get_value(i64)");
    emit_line(cg, "declare i8 @option_get_tag(i64)");

    // Phase 1 Stdlib: Result<T, E>
    emit_line(cg, "; Phase 1 Stdlib: Result");
    emit_line(cg, "declare ptr @result_ok(i64)");
    emit_line(cg, "declare ptr @result_err(i64)");
    emit_line(cg, "declare i8 @result_is_ok(i64)");
    emit_line(cg, "declare i8 @result_is_err(i64)");
    emit_line(cg, "declare i64 @result_ok_option(i64)");
    emit_line(cg, "declare i64 @result_err_option(i64)");
    emit_line(cg, "declare i64 @result_unwrap(i64)");
    emit_line(cg, "declare i64 @result_unwrap_err(i64)");
    emit_line(cg, "declare i64 @result_expect(i64, i64)");
    emit_line(cg, "declare i64 @result_expect_err(i64, i64)");
    emit_line(cg, "declare i64 @result_unwrap_or(i64, i64)");
    emit_line(cg, "declare i64 @result_unwrap_or_else(i64, i64)");
    emit_line(cg, "declare i64 @result_map(i64, i64)");
    emit_line(cg, "declare i64 @result_map_err(i64, i64)");
    emit_line(cg, "declare i64 @result_and(i64, i64)");
    emit_line(cg, "declare i64 @result_and_then(i64, i64)");
    emit_line(cg, "declare i64 @result_or(i64, i64)");
    emit_line(cg, "declare i64 @result_or_else(i64, i64)");
    emit_line(cg, "declare i64 @result_clone(i64)");
    emit_line(cg, "declare i64 @result_ok_or(i64, i64)");

    // Phase 1 Stdlib: Vec extensions
    emit_line(cg, "; Phase 1 Stdlib: Vec extensions");
    emit_line(cg, "declare i64 @vec_sum(i64)");
    emit_line(cg, "declare i64 @vec_find(i64, i64)");
    emit_line(cg, "declare i8 @vec_contains(i64, i64)");
    emit_line(cg, "declare i64 @vec_reverse(i64)");
    emit_line(cg, "declare i64 @vec_clone(i64)");
    emit_line(cg, "declare i64 @vec_first(i64)");
    emit_line(cg, "declare i64 @vec_last(i64)");
    emit_line(cg, "declare i64 @vec_pop(i64)");
    emit_line(cg, "declare void @vec_set(i64, i64, i64)");
    emit_line(cg, "declare void @vec_clear(i64)");

    // Phase 1 Stdlib: HashMap (string keys)
    emit_line(cg, "; Phase 1 Stdlib: HashMap");
    emit_line(cg, "declare i64 @hashmap_new()");
    emit_line(cg, "declare i64 @hashmap_with_capacity(i64)");
    emit_line(cg, "declare i64 @hashmap_insert(i64, i64, i64)");
    emit_line(cg, "declare i64 @hashmap_get(i64, i64)");
    emit_line(cg, "declare i64 @hashmap_remove(i64, i64)");
    emit_line(cg, "declare i8 @hashmap_contains(i64, i64)");
    emit_line(cg, "declare i64 @hashmap_len(i64)");
    emit_line(cg, "declare i8 @hashmap_is_empty(i64)");
    emit_line(cg, "declare void @hashmap_clear(i64)");
    emit_line(cg, "declare i64 @hashmap_keys(i64)");
    emit_line(cg, "declare i64 @hashmap_values(i64)");

    // Phase 1 Stdlib: Integer HashMap
    emit_line(cg, "; Phase 1 Stdlib: Integer HashMap");
    emit_line(cg, "declare i64 @int_hashmap_new()");
    emit_line(cg, "declare i64 @int_hashmap_insert(i64, i64, i64)");
    emit_line(cg, "declare i64 @int_hashmap_get(i64, i64)");
    emit_line(cg, "declare i64 @int_hashmap_remove(i64, i64)");
    emit_line(cg, "declare i8 @int_hashmap_contains(i64, i64)");
    emit_line(cg, "declare i64 @int_hashmap_len(i64)");

    // Phase 1 Stdlib: HashSet (string values)
    emit_line(cg, "; Phase 1 Stdlib: HashSet");
    emit_line(cg, "declare i64 @hashset_new()");
    emit_line(cg, "declare i8 @hashset_insert(i64, i64)");
    emit_line(cg, "declare i8 @hashset_remove(i64, i64)");
    emit_line(cg, "declare i8 @hashset_contains(i64, i64)");
    emit_line(cg, "declare i64 @hashset_len(i64)");
    emit_line(cg, "declare i8 @hashset_is_empty(i64)");
    emit_line(cg, "declare void @hashset_clear(i64)");
    emit_line(cg, "declare i64 @hashset_union(i64, i64)");
    emit_line(cg, "declare i64 @hashset_intersection(i64, i64)");
    emit_line(cg, "declare i64 @hashset_difference(i64, i64)");
    emit_line(cg, "declare i8 @hashset_is_subset(i64, i64)");
    emit_line(cg, "declare i8 @hashset_is_superset(i64, i64)");

    // Phase 1 Stdlib: Integer HashSet
    emit_line(cg, "; Phase 1 Stdlib: Integer HashSet");
    emit_line(cg, "declare i64 @int_hashset_new()");
    emit_line(cg, "declare i8 @int_hashset_insert(i64, i64)");
    emit_line(cg, "declare i8 @int_hashset_remove(i64, i64)");
    emit_line(cg, "declare i8 @int_hashset_contains(i64, i64)");
    emit_line(cg, "declare i64 @int_hashset_len(i64)");

    // Phase 1 Stdlib: String extensions
    emit_line(cg, "; Phase 1 Stdlib: String extensions");
    emit_line(cg, "declare i64 @string_substring(i64, i64, i64)");
    emit_line(cg, "declare i64 @string_to_uppercase(i64)");
    emit_line(cg, "declare i64 @string_to_lowercase(i64)");
    emit_line(cg, "declare i64 @string_join(i64, i64)");
    emit_line(cg, "declare i64 @string_reverse(i64)");
    emit_line(cg, "declare i64 @string_count(i64, i64)");
    emit_line(cg, "declare i64 @string_rfind(i64, i64)");
    emit_line(cg, "declare i64 @string_split_n(i64, i64, i64)");
    emit_line(cg, "declare i64 @string_split_whitespace(i64)");
    emit_line(cg, "declare i64 @string_lines(i64)");
    emit_line(cg, "declare i64 @string_replace_n(i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @string_trim_start(i64)");
    emit_line(cg, "declare i64 @string_trim_end(i64)");
    emit_line(cg, "declare i64 @string_pad_left(i64, i64, i64)");
    emit_line(cg, "declare i64 @string_pad_right(i64, i64, i64)");

    // Phase 1 Stdlib: Iterators
    emit_line(cg, "; Phase 1 Stdlib: Iterators");
    emit_line(cg, "declare i64 @sxiter_from_vec(i64)");
    emit_line(cg, "declare i64 @sxiter_range(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_range_step(i64, i64, i64)");
    emit_line(cg, "declare i64 @sxiter_map(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_filter(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_filter_map(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_take(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_skip(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_chain(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_zip(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_enumerate(i64)");
    emit_line(cg, "declare i64 @sxiter_collect_vec(i64)");
    emit_line(cg, "declare i64 @sxiter_collect_int_hashset(i64)");
    emit_line(cg, "declare i64 @sxiter_fold(i64, i64, i64)");
    emit_line(cg, "declare i64 @sxiter_reduce(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_sum(i64)");
    emit_line(cg, "declare i64 @sxiter_product(i64)");
    emit_line(cg, "declare i64 @sxiter_count(i64)");
    emit_line(cg, "declare void @sxiter_for_each(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_find(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_position(i64, i64)");
    emit_line(cg, "declare i8 @sxiter_any(i64, i64)");
    emit_line(cg, "declare i8 @sxiter_all(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_min(i64)");
    emit_line(cg, "declare i64 @sxiter_max(i64)");
    emit_line(cg, "declare i64 @sxiter_nth(i64, i64)");
    emit_line(cg, "declare i64 @sxiter_last(i64)");

    // Phase 1 Stdlib: JSON
    emit_line(cg, "; Phase 1 Stdlib: JSON");
    emit_line(cg, "declare i64 @json_null()");
    emit_line(cg, "declare i64 @json_bool(i64)");
    emit_line(cg, "declare i64 @json_number(double)");
    emit_line(cg, "declare i64 @json_number_i64(i64)");
    emit_line(cg, "declare i64 @json_string(i64)");
    emit_line(cg, "declare i64 @json_array()");
    emit_line(cg, "declare i64 @json_object()");
    emit_line(cg, "declare i8 @json_is_null(i64)");
    emit_line(cg, "declare i8 @json_is_bool(i64)");
    emit_line(cg, "declare i8 @json_is_number(i64)");
    emit_line(cg, "declare i8 @json_is_string(i64)");
    emit_line(cg, "declare i8 @json_is_array(i64)");
    emit_line(cg, "declare i8 @json_is_object(i64)");
    emit_line(cg, "declare i64 @json_type(i64)");
    emit_line(cg, "declare i8 @json_as_bool(i64)");
    emit_line(cg, "declare i64 @json_as_i64(i64)");
    emit_line(cg, "declare double @json_as_f64(i64)");
    emit_line(cg, "declare i64 @json_as_string(i64)");
    emit_line(cg, "declare i64 @json_get(i64, i64)");
    emit_line(cg, "declare i64 @json_get_index(i64, i64)");
    emit_line(cg, "declare i64 @json_array_len(i64)");
    emit_line(cg, "declare i64 @json_object_len(i64)");
    emit_line(cg, "declare i8 @json_object_has(i64, i64)");
    emit_line(cg, "declare void @json_array_push(i64, i64)");
    emit_line(cg, "declare void @json_object_set(i64, i64, i64)");
    emit_line(cg, "declare i64 @json_parse(i64)");
    emit_line(cg, "declare i64 @json_stringify(i64)");
    emit_line(cg, "declare i64 @json_stringify_pretty(i64, i64)");
    emit_line(cg, "declare i64 @json_clone(i64)");
    emit_line(cg, "declare i8 @json_equals(i64, i64)");
    emit_line(cg, "declare void @json_free(i64)");

    emit_line(cg, "");
    0
}

// Emit a string constant in LLVM format
fn emit_string_constant(cg: i64, idx: i64, value: i64) -> i64 {
    // For simplicity, just emit the string with basic escaping
    // Format: @.str.MODULE.N = private unnamed_addr constant [LEN x i8] c"STRING\00"
    let len: i64 = string_len(value);

    emit(cg, "@.str.");
    emit(cg, cg_module_name(cg));
    emit(cg, ".");
    emit(cg, int_to_string(idx));
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(len + 1));  // +1 for null terminator
    emit(cg, " x i8] c\"");

    // Emit string with escaping
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(value, i);
        if c == 10 {
            // newline -> \0A
            emit(cg, "\\0A");
        } else {
            if c == 9 {
                // tab -> \09
                emit(cg, "\\09");
            } else {
                if c == 34 {
                    // quote -> \22
                    emit(cg, "\\22");
                } else {
                    if c == 92 {
                        // backslash -> \5C
                        emit(cg, "\\5C");
                    } else {
                        // Regular character
                        emit(cg, string_slice(value, i, i + 1));
                    }
                }
            }
        }
        i = i + 1;
    }

    emit_line(cg, "\\00\"");
    0
}

// Generate entire program with module name for unique string prefixes
fn gen_program_with_module(items: i64, module_name: i64) -> i64 {
    let cg: i64 = codegen_new();
    cg_set_module_name(cg, module_name);
    register_builtin_enums(cg);  // Phase 36: Pre-register Option and Result
    gen_header(cg);

    // First pass: register enums and structs
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        if tag == TAG_STRUCT() {
            gen_struct(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions, impl blocks, and trait impls
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        if tag == TAG_IMPL() {
            gen_impl(cg, item);
        }
        if tag == TAG_IMPL_TRAIT() {
            gen_impl_trait(cg, item);
        }
        // Note: TAG_TRAIT() doesn't generate code (trait definitions are just declarations)
        i = i + 1;
    }

    // Third pass: generate pending generic instantiations
    // Loop until no more pending (instantiation might queue more)
    let pending: i64 = cg_pending_instantiations(cg);
    let processed: i64 = 0;
    while processed < vec_len(pending) {
        let entry: i64 = vec_get(pending, processed);
        let mangled_name: i64 = load_ptr(entry, 0);
        let fn_def: i64 = load_ptr(entry, 1);
        let type_args: i64 = load_ptr(entry, 2);
        gen_fn_instantiation(cg, fn_def, mangled_name, type_args);
        processed = processed + 1;
    }

    // Emit string constants
    let strings: i64 = cg_strings(cg);
    let str_count: i64 = vec_len(strings);
    if str_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; String constants");
        i = 0;
        while i < str_count {
            let value: i64 = vec_get(strings, i);
            emit_string_constant(cg, i, value);
            i = i + 1;
        }
    }

    // Emit pending closures
    let closures: i64 = cg_pending_closures(cg);
    let closure_count: i64 = vec_len(closures);
    if closure_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; Closure functions");
        i = 0;
        while i < closure_count {
            let closure_code: i64 = vec_get(closures, i);
            emit(cg, closure_code);
            i = i + 1;
        }
    }

    // Convert StringBuilder to String for final output
    sb_to_string(cg_output(cg))
}

// Backward-compatible wrapper using default module name
fn gen_program(items: i64) -> i64 {
    gen_program_with_module(items, string_from("mod"))
}

// Helper functions for intrinsic emission with type conversions
// These handle the i64 <-> ptr conversions needed at boundaries

// Helper: convert i64 to ptr using inttoptr
fn emit_i64_to_ptr(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = inttoptr i64 ");
    emit(cg, val);
    emit_line(cg, " to ptr");
    temp
}

// Helper: convert ptr to i64 using ptrtoint
fn emit_ptr_to_i64(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = ptrtoint ptr ");
    emit(cg, val);
    emit_line(cg, " to i64");
    temp
}

// void intrinsic(ptr)
fn emit_intrinsic_void_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, ptr)
fn emit_intrinsic_void_ptr2(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr)
fn emit_intrinsic_i64_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, i64)
fn emit_intrinsic_i64_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i1 intrinsic(ptr, ptr) -> zext to i64
fn emit_intrinsic_i1_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i1 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    // zext i1 to i64
    let t2: i64 = cg_next_temp(cg);
    let temp2: i64 = string_concat("%t", int_to_string(t2));
    emit(cg, "  ");
    emit(cg, temp2);
    emit(cg, " = zext i1 ");
    emit(cg, temp);
    emit_line(cg, " to i64");
    temp2
}

// ptr intrinsic(ptr, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic() -> ptrtoint to i64
fn emit_intrinsic_ptr_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit_line(cg, "()");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// i64 intrinsic() - no args, returns i64
fn emit_intrinsic_i64_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit_line(cg, "()");
    temp
}

// void intrinsic() - no args, no return
fn emit_intrinsic_void_void(cg: i64, name: i64) -> i64 {
    emit(cg, "  call void @");
    emit(cg, name);
    emit_line(cg, "()");
    0
}

// void intrinsic(ptr, i64) - ptr arg and i64 arg, no return
fn emit_intrinsic_void_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr, ptr) - two ptr args, returns i64
fn emit_intrinsic_i64_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, ptr, i64) - two ptr args and one i64, returns i64
fn emit_intrinsic_i64_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    temp
}

// ptr intrinsic(ptr, ptr, ptr) - three ptr args, returns ptr
fn emit_intrinsic_ptr_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}
// Simplex Compiler - Main Entry Point (sxc)
// Self-hosted compiler CLI with build, run, check, repl, and fmt commands

// Version
fn VERSION() -> i64 { string_from("0.9.5") }

// CLI argument parsing result
// Layout: command(0), input_files(1), output_file(2), emit_type(3), verbose(4), force(5), show_deps(6), auto_deps(7)
// Commands: 0=build, 1=run, 2=check, 3=help, 4=version, 5=repl, 6=fmt
fn cli_new() -> i64 {
    let cli: i64 = malloc(64);
    store_i64(cli, 0, 0);        // command: 0=build, 1=run, 2=check, 3=help, 4=version, 5=repl, 6=fmt
    store_ptr(cli, 1, vec_new()); // input files
    store_ptr(cli, 2, 0);        // output file (optional)
    store_i64(cli, 3, 0);        // emit: 0=llvm-ir, 1=obj, 2=exe, 3=asm, 4=dylib
    store_i64(cli, 4, 0);        // verbose
    store_i64(cli, 5, 0);        // force (skip timestamp checks)
    store_i64(cli, 6, 0);        // show_deps
    store_i64(cli, 7, 0);        // auto_deps (auto-compile dependencies)
    cli
}

fn cli_command(cli: i64) -> i64 { load_i64(cli, 0) }
fn cli_set_command(cli: i64, cmd: i64) -> i64 { store_i64(cli, 0, cmd); 0 }
fn cli_input_files(cli: i64) -> i64 { load_ptr(cli, 1) }
fn cli_output_file(cli: i64) -> i64 { load_ptr(cli, 2) }
fn cli_set_output(cli: i64, path: i64) -> i64 { store_ptr(cli, 2, path); 0 }
fn cli_emit_type(cli: i64) -> i64 { load_i64(cli, 3) }
fn cli_set_emit(cli: i64, emit: i64) -> i64 { store_i64(cli, 3, emit); 0 }
fn cli_verbose(cli: i64) -> i64 { load_i64(cli, 4) }
fn cli_set_verbose(cli: i64, v: i64) -> i64 { store_i64(cli, 4, v); 0 }
fn cli_force(cli: i64) -> i64 { load_i64(cli, 5) }
fn cli_set_force(cli: i64, f: i64) -> i64 { store_i64(cli, 5, f); 0 }
fn cli_show_deps(cli: i64) -> i64 { load_i64(cli, 6) }
fn cli_set_show_deps(cli: i64, d: i64) -> i64 { store_i64(cli, 6, d); 0 }
fn cli_auto_deps(cli: i64) -> i64 { load_i64(cli, 7) }
fn cli_set_auto_deps(cli: i64, a: i64) -> i64 { store_i64(cli, 7, a); 0 }

fn show_help() -> i64 {
    println("sxc - Simplex Compiler");
    println("");
    println("USAGE:");
    println("    sxc [OPTIONS] <FILES...>");
    println("    sxc build [OPTIONS] <FILES...>");
    println("    sxc run <FILE>");
    println("    sxc check <FILES...>");
    println("    sxc repl                        Interactive REPL");
    println("    sxc fmt <FILES...>              Format source files");
    println("");
    println("OPTIONS:");
    println("    -o <file>       Output file name");
    println("    --emit <type>   Output type: llvm-ir (default), asm, obj, exe, dylib");
    println("    -v, --verbose   Verbose output");
    println("    -f, --force     Force recompilation (ignore timestamps)");
    println("    --deps          Show file dependencies");
    println("    --auto-deps     Auto-compile module dependencies");
    println("    -h, --help      Show this help");
    println("    --version       Show version");
    0
}

fn show_version() -> i64 {
    println(string_concat(string_from("sxc "), VERSION()));
    0
}

// Parse CLI arguments
fn parse_args(args: i64) -> i64 {
    let cli: i64 = cli_new();
    let argc: i64 = vec_len(args);
    let i: i64 = 1;  // Skip program name

    while i < argc {
        let arg: i64 = vec_get(args, i);

        // Check for flags
        if string_eq(arg, string_from("-h")) {
            cli_set_command(cli, 3);
            return cli;
        }
        if string_eq(arg, string_from("--help")) {
            cli_set_command(cli, 3);
            return cli;
        }
        if string_eq(arg, string_from("--version")) {
            cli_set_command(cli, 4);
            return cli;
        }
        if string_eq(arg, string_from("-v")) {
            cli_set_verbose(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--verbose")) {
            cli_set_verbose(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("-f")) {
            cli_set_force(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--force")) {
            cli_set_force(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--deps")) {
            cli_set_show_deps(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--auto-deps")) {
            cli_set_auto_deps(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("-o")) {
            // Next arg is output file
            if i + 1 < argc {
                i = i + 1;
                cli_set_output(cli, vec_get(args, i));
            }
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--emit")) {
            // Next arg is emit type
            // 0=llvm-ir, 1=obj, 2=exe, 3=asm
            if i + 1 < argc {
                i = i + 1;
                let emit_arg: i64 = vec_get(args, i);
                if string_eq(emit_arg, string_from("llvm-ir")) {
                    cli_set_emit(cli, 0);
                } else {
                if string_eq(emit_arg, string_from("obj")) {
                    cli_set_emit(cli, 1);
                } else {
                if string_eq(emit_arg, string_from("exe")) {
                    cli_set_emit(cli, 2);
                } else {
                if string_eq(emit_arg, string_from("asm")) {
                    cli_set_emit(cli, 3);
                } else {
                if string_eq(emit_arg, string_from("dylib")) {
                    cli_set_emit(cli, 4);
                } else {
                    println(string_concat(string_from("Unknown emit type: "), emit_arg));
                }
                }
                }
                }
                }
            }
            i = i + 1;
        } else {
        // Check for commands
        if string_eq(arg, string_from("build")) {
            cli_set_command(cli, 0);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("run")) {
            cli_set_command(cli, 1);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("check")) {
            cli_set_command(cli, 2);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("repl")) {
            cli_set_command(cli, 5);
            i = i + 1;
        } else {
        if string_eq(arg, string_from("fmt")) {
            cli_set_command(cli, 6);
            i = i + 1;
        } else {
            // Must be an input file
            vec_push(cli_input_files(cli), arg);
            i = i + 1;
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
    }

    cli
}

// Check if recompilation is needed
// Returns 1 if output is up to date, 0 if recompilation needed
fn is_up_to_date(source_path: i64, output_path: i64) -> i64 {
    // If output doesn't exist, need to compile
    if file_exists(output_path) == 0 {
        return 0;
    }
    // Compare modification times
    let src_mtime: i64 = file_mtime(source_path);
    let out_mtime: i64 = file_mtime(output_path);
    // If source is newer than output, need to recompile
    if src_mtime > out_mtime {
        return 0;
    }
    1
}

// ========================================
// Dependency Tracking (20.1.2)
// ========================================

// Check if vec contains a string
fn vec_contains_string(v: i64, s: i64) -> i64 {
    let n: i64 = vec_len(v);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(v, i), s) {
            return 1;
        }
        i = i + 1;
    }
    0
}

// Extract module dependencies from source file
// Returns vec of dependency paths (e.g., ["utils.sx", "parser.sx"])
fn extract_dependencies(source_path: i64) -> i64 {
    let deps: i64 = vec_new();
    let source: i64 = read_file(source_path);
    if source == 0 {
        return deps;
    }

    // Get directory of source file for relative paths
    let dir: i64 = get_directory(source_path);

    // Tokenize and look for mod/use statements
    let tokens: i64 = tokenize(source);
    let n: i64 = vec_len(tokens);
    let i: i64 = 0;

    while i < n {
        let tok: i64 = vec_get(tokens, i);
        let kind: i64 = token_kind(tok);
        let text: i64 = token_text(tok);

        // Check for 'mod' keyword
        if string_eq(text, string_from("mod")) {
            // Next token should be module name
            if i + 1 < n {
                let name_tok: i64 = vec_get(tokens, i + 1);
                let mod_name: i64 = token_text(name_tok);
                // Convert to file path: mod foo; -> foo.sx
                let dep_path: i64 = string_concat(dir, string_concat(mod_name, string_from(".sx")));
                if file_exists(dep_path) == 1 {
                    // Deduplicate
                    if vec_contains_string(deps, dep_path) == 0 {
                        vec_push(deps, dep_path);
                    }
                }
                i = i + 2;
            } else {
                i = i + 1;
            }
        } else {
        // Check for 'use' keyword
        if string_eq(text, string_from("use")) {
            // Next token should be path start
            if i + 1 < n {
                let path_tok: i64 = vec_get(tokens, i + 1);
                let path_name: i64 = token_text(path_tok);
                // Convert to file path: use foo::bar; -> foo.sx
                let dep_path: i64 = string_concat(dir, string_concat(path_name, string_from(".sx")));
                if file_exists(dep_path) == 1 {
                    // Deduplicate
                    if vec_contains_string(deps, dep_path) == 0 {
                        vec_push(deps, dep_path);
                    }
                }
                i = i + 2;
            } else {
                i = i + 1;
            }
        } else {
            i = i + 1;
        }
        }
    }

    deps
}

// Get directory part of a path (e.g., "foo/bar/baz.sx" -> "foo/bar/")
fn get_directory(path: i64) -> i64 {
    let len: i64 = string_len(path);
    let i: i64 = len - 1;
    while i >= 0 {
        let c: i64 = string_char_at(path, i);
        if c == 47 {
            // ASCII for '/'
            return string_slice(path, 0, i + 1);
        }
        i = i - 1;
    }
    // No directory, return empty string
    string_from("")
}

// Collect all transitive dependencies for a source file
// Returns vec of paths in dependency order (dependencies before dependents)
fn collect_all_dependencies(source_path: i64) -> i64 {
    let result: i64 = vec_new();
    let visited: i64 = vec_new();
    collect_deps_recursive(source_path, result, visited);
    result
}

fn collect_deps_recursive(path: i64, result: i64, visited: i64) -> i64 {
    // Skip if already visited
    if vec_contains_string(visited, path) == 1 {
        return 0;
    }
    vec_push(visited, path);

    // Get direct dependencies
    let deps: i64 = extract_dependencies(path);
    let n: i64 = vec_len(deps);
    let i: i64 = 0;

    // Process dependencies first (they come before the current file)
    while i < n {
        let dep: i64 = vec_get(deps, i);
        collect_deps_recursive(dep, result, visited);
        i = i + 1;
    }

    // Add current file after its dependencies (unless it's already in result)
    if vec_contains_string(result, path) == 0 {
        vec_push(result, path);
    }
    0
}

// Compile a file and all its dependencies automatically
// Returns 0 on success, 1 on failure
fn compile_with_dependencies(path: i64, output_path: i64, verbose: i64, emit_type: i64) -> i64 {
    // Collect all dependencies in order
    let all_files: i64 = collect_all_dependencies(path);
    let n: i64 = vec_len(all_files);

    if verbose == 1 {
        if n > 1 {
            println(string_concat("Compiling ", string_concat(int_to_string(n), " files with dependencies")));
        }
    }

    // Compile each dependency (producing .ll files)
    let i: i64 = 0;
    while i < n - 1 {  // Skip last one (that's the main file)
        let dep_path: i64 = vec_get(all_files, i);
        if verbose == 1 {
            println(string_concat("  Compiling dependency: ", dep_path));
        }
        // Compile to LLVM IR (emit_type = 0)
        let result: i64 = compile_file(dep_path, 0, 0, 0);
        if result != 0 {
            println(string_concat("Error: Failed to compile dependency: ", dep_path));
            return 1;
        }
        i = i + 1;
    }

    // Compile the main file with requested output type
    compile_file(path, output_path, verbose, emit_type)
}

// Check if output is up to date considering all dependencies
// Returns 1 if output is up to date, 0 if recompilation needed
fn is_up_to_date_with_deps(source_path: i64, output_path: i64) -> i64 {
    // If output doesn't exist, need to compile
    if file_exists(output_path) == 0 {
        return 0;
    }

    let out_mtime: i64 = file_mtime(output_path);

    // Check source file
    let src_mtime: i64 = file_mtime(source_path);
    if src_mtime > out_mtime {
        return 0;
    }

    // Check all dependencies
    let deps: i64 = extract_dependencies(source_path);
    let n: i64 = vec_len(deps);
    let i: i64 = 0;
    while i < n {
        let dep_path: i64 = vec_get(deps, i);
        let dep_mtime: i64 = file_mtime(dep_path);
        if dep_mtime > out_mtime {
            return 0;
        }
        // Recursively check dependencies of dependencies
        if is_up_to_date_with_deps(dep_path, output_path) == 0 {
            return 0;
        }
        i = i + 1;
    }

    1
}

// Compile a single file
// emit_type: 0=llvm-ir, 1=obj, 2=exe, 3=asm
// force: 1 = always recompile, 0 = check timestamps
fn compile_file(path: i64, output_path: i64, verbose: i64, emit_type: i64) -> i64 {
    return compile_file_force(path, output_path, verbose, emit_type, 0);
}

fn compile_file_force(path: i64, output_path: i64, verbose: i64, emit_type: i64, force: i64) -> i64 {
    // Determine expected output path
    let expected_out: i64 = output_path;
    if expected_out == 0 {
        if emit_type == 0 {
            expected_out = string_replace_ext(path, ".ll");
        } else {
        if emit_type == 1 {
            expected_out = string_replace_ext(path, ".o");
        } else {
        if emit_type == 2 {
            expected_out = string_replace_ext(path, "");
        } else {
        if emit_type == 3 {
            expected_out = string_replace_ext(path, ".s");
        } else {
        if emit_type == 4 {
            expected_out = string_replace_ext(path, ".dylib");
        }
        }
        }
        }
        }
    }

    // Check if up to date (unless force flag is set)
    // Uses dependency tracking to check all mod/use imports
    if force == 0 {
        if is_up_to_date_with_deps(path, expected_out) == 1 {
            if verbose == 1 {
                println(string_concat(string_from("Skipping (up to date): "), path));
            }
            return 0;
        }
    }

    if verbose == 1 {
        println(string_concat(string_from("Compiling: "), path));
    }

    // Read source file
    let source: i64 = read_file(path);
    if source == 0 {
        println(string_concat(string_from("Error: Could not read file: "), path));
        return 1;
    }

    // Tokenize
    let tokens: i64 = tokenize(source);

    // Parse
    let parse_result: i64 = parse_program(tokens);
    let items: i64 = parse_result_items(parse_result);
    let parse_errors: i64 = parse_result_errors(parse_result);

    // Check for parse errors
    if parse_errors > 0 {
        println(string_concat(string_from("Compilation failed with "),
                string_concat(int_to_string(parse_errors), string_from(" parse error(s)."))));
        return 1;
    }

    // Extract module name from path for unique string prefixes
    let module_name: i64 = get_module_name(path);

    // Generate code with module name
    let output: i64 = gen_program_with_module(items, module_name);

    // Determine output path based on emit type
    let ll_path: i64 = string_replace_ext(path, ".ll");
    let out_path: i64 = output_path;

    // For asm/obj/exe, we need intermediate .ll file
    if emit_type == 0 {
        // llvm-ir: output directly to target
        if out_path == 0 {
            out_path = ll_path;
        }
        write_file(out_path, output);
        if verbose == 1 {
            println(string_concat(string_from("  -> "), out_path));
        }
        return 0;
    }

    // Write intermediate .ll file
    write_file(ll_path, output);

    // asm output (emit_type == 3)
    if emit_type == 3 {
        let asm_path: i64 = out_path;
        if asm_path == 0 {
            asm_path = string_replace_ext(path, ".s");
        }
        // Run: llc -o <asm_path> <ll_path>
        let cmd: i64 = string_concat(string_from("/usr/local/opt/llvm/bin/llc -o "), asm_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, ll_path);
        let result: i64 = process_run(cmd);
        if result != 0 {
            println(string_from("Error: llc failed"));
            return 1;
        }
        if verbose == 1 {
            println(string_concat(string_from("  -> "), asm_path));
        }
        return 0;
    }

    // obj output (emit_type == 1)
    if emit_type == 1 {
        let obj_path: i64 = out_path;
        if obj_path == 0 {
            obj_path = string_replace_ext(path, ".o");
        }
        // Run: llc -filetype=obj -o <obj_path> <ll_path>
        let cmd: i64 = string_concat(string_from("/usr/local/opt/llvm/bin/llc -filetype=obj -o "), obj_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, ll_path);
        let result: i64 = process_run(cmd);
        if result != 0 {
            println(string_from("Error: llc failed"));
            return 1;
        }
        if verbose == 1 {
            println(string_concat(string_from("  -> "), obj_path));
        }
        return 0;
    }

    // exe output (emit_type == 2)
    if emit_type == 2 {
        let exe_path: i64 = out_path;
        if exe_path == 0 {
            // Remove extension for executable
            exe_path = string_replace_ext(path, "");
        }
        // First compile to object
        let obj_path: i64 = string_replace_ext(path, ".o");
        let cmd: i64 = string_concat(string_from("/usr/local/opt/llvm/bin/llc -filetype=obj -o "), obj_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, ll_path);
        let result: i64 = process_run(cmd);
        if result != 0 {
            println(string_from("Error: llc failed"));
            return 1;
        }
        // Then link with clang
        cmd = string_concat(string_from("clang -o "), exe_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, obj_path);
        cmd = string_concat(cmd, string_from(" standalone_runtime.o"));
        result = process_run(cmd);
        if result != 0 {
            println(string_from("Error: linking failed"));
            return 1;
        }
        if verbose == 1 {
            println(string_concat(string_from("  -> "), exe_path));
        }
        return 0;
    }

    // dylib output (emit_type == 4)
    if emit_type == 4 {
        let dylib_path: i64 = out_path;
        if dylib_path == 0 {
            dylib_path = string_replace_ext(path, ".dylib");
        }
        // First compile to object with PIC (position-independent code)
        let obj_path: i64 = string_replace_ext(path, ".o");
        let cmd: i64 = string_concat(string_from("/usr/local/opt/llvm/bin/llc -filetype=obj -relocation-model=pic -o "), obj_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, ll_path);
        let result: i64 = process_run(cmd);
        if result != 0 {
            println(string_from("Error: llc failed"));
            return 1;
        }
        // Create shared library with clang (no runtime - this is a library)
        cmd = string_concat(string_from("clang -shared -o "), dylib_path);
        cmd = string_concat(cmd, string_from(" "));
        cmd = string_concat(cmd, obj_path);
        result = process_run(cmd);
        if result != 0 {
            println(string_from("Error: linking shared library failed"));
            return 1;
        }
        if verbose == 1 {
            println(string_concat(string_from("  -> "), dylib_path));
        }
        return 0;
    }

    0
}

fn main() -> i64 {
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        show_help();
        return 1;
    }

    let cli: i64 = parse_args(args);
    let cmd: i64 = cli_command(cli);

    // Handle help
    if cmd == 3 {
        show_help();
        return 0;
    }

    // Handle version
    if cmd == 4 {
        show_version();
        return 0;
    }

    // Handle repl command (no files required)
    if cmd == 5 {
        return run_repl();
    }

    let files: i64 = cli_input_files(cli);
    let file_count: i64 = vec_len(files);

    if file_count == 0 {
        println("Error: No input files specified");
        return 1;
    }

    // Handle --deps flag: show dependencies for files
    if cli_show_deps(cli) == 1 {
        let i: i64 = 0;
        while i < file_count {
            let path: i64 = vec_get(files, i);
            println(string_concat(path, string_from(":")));
            let deps: i64 = extract_dependencies(path);
            let n: i64 = vec_len(deps);
            if n == 0 {
                println(string_from("  (no dependencies)"));
            } else {
                let j: i64 = 0;
                while j < n {
                    let dep: i64 = vec_get(deps, j);
                    println(string_concat(string_from("  "), dep));
                    j = j + 1;
                }
            }
            i = i + 1;
        }
        return 0;
    }

    // Handle build command (default)
    if cmd == 0 {
        let verbose: i64 = cli_verbose(cli);
        let emit: i64 = cli_emit_type(cli);
        let force: i64 = cli_force(cli);
        let auto_deps: i64 = cli_auto_deps(cli);
        let i: i64 = 0;
        while i < file_count {
            let path: i64 = vec_get(files, i);
            // Only use custom output for single file
            let out: i64 = 0;
            if file_count == 1 {
                out = cli_output_file(cli);
            }
            let result: i64 = 0;
            if auto_deps == 1 {
                // Auto-compile all module dependencies
                result = compile_with_dependencies(path, out, verbose, emit);
            } else {
                result = compile_file_force(path, out, verbose, emit, force);
            }
            if result != 0 {
                return result;
            }
            i = i + 1;
        }
        println("Compilation successful.");
        return 0;
    }

    // Handle run command
    if cmd == 1 {
        if file_count != 1 {
            println("Error: 'run' command requires exactly one file");
            return 1;
        }
        let path: i64 = vec_get(files, 0);
        // Compile to exe and run
        let result: i64 = compile_file(path, 0, 0, 2);
        if result != 0 {
            return result;
        }
        // Run the compiled executable
        let exe_path: i64 = string_replace_ext(path, "");
        let run_result: i64 = process_run(exe_path);
        return run_result;
    }

    // Handle check command
    if cmd == 2 {
        let i: i64 = 0;
        while i < file_count {
            let path: i64 = vec_get(files, i);
            let source: i64 = read_file(path);
            if source == 0 {
                println(string_concat(string_from("Error: Could not read file: "), path));
                return 1;
            }
            let tokens: i64 = tokenize(source);
            let parse_result: i64 = parse_program(tokens);
            let parse_errors: i64 = parse_result_errors(parse_result);
            if parse_errors > 0 {
                println(string_concat(path, string_from(": parse errors found")));
                return 1;
            }
            println(string_concat(path, string_from(": OK")));
            i = i + 1;
        }
        return 0;
    }

    // Handle fmt command
    if cmd == 6 {
        if file_count == 0 {
            println("Error: No files specified for formatting");
            return 1;
        }
        let i: i64 = 0;
        while i < file_count {
            let path: i64 = vec_get(files, i);
            let result: i64 = format_file(path, 1);  // write back
            if result != 0 {
                return result;
            }
            i = i + 1;
        }
        return 0;
    }

    0
}

// Helper to replace file extension
fn string_replace_ext(path: i64, new_ext: i64) -> i64 {
    // Find last dot
    let len: i64 = string_len(path);
    let i: i64 = len - 1;
    while i >= 0 {
        let c: i64 = string_char_at(path, i);
        if c == 46 {
            // Found dot
            let base: i64 = string_slice(path, 0, i);
            return string_concat(base, new_ext);
        }
        i = i - 1;
    }
    // No dot found, just append
    string_concat(path, new_ext)
}

// Extract module name from path (basename without extension)
// e.g., "lexer.sx" -> "lexer", "foo/bar/parser.sx" -> "parser"
fn get_module_name(path: i64) -> i64 {
    let len: i64 = string_len(path);

    // Find last slash to get basename
    let start: i64 = 0;
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(path, i);
        if c == 47 {
            // ASCII for '/'
            start = i + 1;
        }
        i = i + 1;
    }

    // Find last dot to strip extension
    let end: i64 = len;
    i = len - 1;
    while i >= start {
        let c: i64 = string_char_at(path, i);
        if c == 46 {
            // ASCII for '.'
            end = i;
            i = 0;  // Break
        }
        i = i - 1;
    }

    string_slice(path, start, end)
}

// ========================================
// REPL Implementation (20.1.4)
// ========================================

// REPL state for maintaining variables between evaluations
// Layout: vars(0), var_count(1)
fn repl_state_new() -> i64 {
    let state: i64 = malloc(16);
    store_ptr(state, 0, vec_new());  // variable bindings: (name, value) pairs
    store_i64(state, 1, 0);          // var count
    state
}

fn repl_state_vars(state: i64) -> i64 {
    load_ptr(state, 0)
}

// Run the REPL
fn run_repl() -> i64 {
    println("Simplex REPL v0.3.0");
    println("Type expressions to evaluate. Type 'exit' or Ctrl-D to quit.");
    println("");

    let state: i64 = repl_state_new();
    let line_num: i64 = 1;

    while true {
        // Print prompt
        print(string_concat(string_from("sx["),
              string_concat(int_to_string(line_num), string_from("]> "))));

        // Read line
        let line: i64 = read_line();
        if line == 0 {
            // EOF
            println("");
            println("Goodbye!");
            return 0;
        }

        // Check for exit command
        let trimmed: i64 = string_trim(line);
        if string_eq(trimmed, string_from("exit")) {
            println("Goodbye!");
            return 0;
        }
        if string_eq(trimmed, string_from("quit")) {
            println("Goodbye!");
            return 0;
        }

        // Skip empty lines
        if string_len(trimmed) == 0 {
            line_num = line_num + 1;
        } else {

        // Check for special commands
        if string_eq(trimmed, string_from(":help")) {
            println("REPL Commands:");
            println("  :help     Show this help");
            println("  :vars     Show defined variables");
            println("  :clear    Clear all variables");
            println("  exit      Exit the REPL");
            line_num = line_num + 1;
        } else {
        if string_eq(trimmed, string_from(":vars")) {
            let vars: i64 = repl_state_vars(state);
            let n: i64 = vec_len(vars);
            if n == 0 {
                println("No variables defined.");
            } else {
                let i: i64 = 0;
                while i < n {
                    let pair: i64 = vec_get(vars, i);
                    let name: i64 = load_ptr(pair, 0);
                    let value: i64 = load_i64(pair, 1);
                    println(string_concat(name, string_concat(string_from(" = "), int_to_string(value))));
                    i = i + 1;
                }
            }
            line_num = line_num + 1;
        } else {
        if string_eq(trimmed, string_from(":clear")) {
            store_ptr(state, 0, vec_new());
            println("Variables cleared.");
            line_num = line_num + 1;
        } else {

        // Try to evaluate as expression
        let result: i64 = repl_eval_line(state, trimmed);
        if result != 0 {
            // result is a string containing either error or value
            println(result);
        }
        line_num = line_num + 1;

        }
        }
        }
        }
    }

    0
}

// Evaluate a line of input in the REPL
fn repl_eval_line(state: i64, line: i64) -> i64 {
    // Wrap input in a function for evaluation
    // Handle both expressions and let statements

    // Check if it's a let statement
    if string_starts_with(line, string_from("let ")) {
        // Parse and store the variable
        return repl_eval_let(state, line);
    }

    // Otherwise, evaluate as expression
    return repl_eval_expr(state, line);
}

// Evaluate a let statement in the REPL
fn repl_eval_let(state: i64, line: i64) -> i64 {
    // Parse: let name = expr;
    // For simplicity, just parse and show message
    // Full evaluation would require JIT or interpretation

    // Try to tokenize and parse
    let source: i64 = string_concat(string_from("fn __repl() -> i64 { "),
                      string_concat(line, string_from(" 0 }")));
    let tokens: i64 = tokenize(source);
    let parse_result: i64 = parse_program(tokens);
    let errors: i64 = parse_result_errors(parse_result);

    if errors > 0 {
        return string_from("Parse error in let statement");
    }

    // Extract variable name from the line for display
    // Format: "let name ..." or "let name: type ..."
    let rest: i64 = string_slice(line, 4, string_len(line));
    let name: i64 = string_from("");
    let i: i64 = 0;
    while i < string_len(rest) {
        let c: i64 = string_char_at(rest, i);
        if c == 32 {
            // space
            i = string_len(rest);  // break
        } else {
        if c == 58 {
            // colon
            i = string_len(rest);  // break
        } else {
        if c == 61 {
            // equals
            i = string_len(rest);  // break
        } else {
            name = string_concat(name, string_from_char(c));
            i = i + 1;
        }
        }
        }
    }

    // Store variable reference (actual value would need interpretation)
    let vars: i64 = repl_state_vars(state);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_i64(pair, 1, 0);  // placeholder value
    vec_push(vars, pair);

    return string_concat(string_from("Defined: "), name);
}

// Evaluate an expression in the REPL
fn repl_eval_expr(state: i64, line: i64) -> i64 {
    // Wrap in a function and try to parse
    let source: i64 = string_concat(string_from("fn __repl() -> i64 { "),
                      string_concat(line, string_from(" }")));
    let tokens: i64 = tokenize(source);
    let parse_result: i64 = parse_program(tokens);
    let errors: i64 = parse_result_errors(parse_result);

    if errors > 0 {
        return string_from("Parse error");
    }

    // For now, just confirm the expression is valid
    // Full evaluation would require interpretation or JIT
    // Try to evaluate simple integer literals
    if is_integer_literal(line) {
        let val: i64 = string_to_int(line);
        return string_concat(string_from("= "), int_to_string(val));
    }

    // Check for simple binary expressions
    let result: i64 = try_eval_simple_expr(line);
    if result != 0 {
        return result;
    }

    return string_from("Expression parsed OK (evaluation requires compilation)");
}

// Check if string is just an integer literal
fn is_integer_literal(s: i64) -> bool {
    let len: i64 = string_len(s);
    if len == 0 {
        return false;
    }
    let i: i64 = 0;
    // Allow leading minus
    if string_char_at(s, 0) == 45 {
        i = 1;
    }
    while i < len {
        let c: i64 = string_char_at(s, i);
        if c < 48 {
            return false;
        }
        if c > 57 {
            return false;
        }
        i = i + 1;
    }
    true
}

// Try to evaluate simple arithmetic expressions
fn try_eval_simple_expr(expr: i64) -> i64 {
    // Look for + - * / operators
    let len: i64 = string_len(expr);
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(expr, i);
        if c == 43 {
            // +
            let left: i64 = string_trim(string_slice(expr, 0, i));
            let right: i64 = string_trim(string_slice(expr, i + 1, len));
            if is_integer_literal(left) {
                if is_integer_literal(right) {
                    let result: i64 = string_to_int(left) + string_to_int(right);
                    return string_concat(string_from("= "), int_to_string(result));
                }
            }
        }
        if c == 45 {
            // - (skip if at start, that's negative number)
            if i > 0 {
                let left: i64 = string_trim(string_slice(expr, 0, i));
                let right: i64 = string_trim(string_slice(expr, i + 1, len));
                if is_integer_literal(left) {
                    if is_integer_literal(right) {
                        let result: i64 = string_to_int(left) - string_to_int(right);
                        return string_concat(string_from("= "), int_to_string(result));
                    }
                }
            }
        }
        if c == 42 {
            // *
            let left: i64 = string_trim(string_slice(expr, 0, i));
            let right: i64 = string_trim(string_slice(expr, i + 1, len));
            if is_integer_literal(left) {
                if is_integer_literal(right) {
                    let result: i64 = string_to_int(left) * string_to_int(right);
                    return string_concat(string_from("= "), int_to_string(result));
                }
            }
        }
        if c == 47 {
            // /
            let left: i64 = string_trim(string_slice(expr, 0, i));
            let right: i64 = string_trim(string_slice(expr, i + 1, len));
            if is_integer_literal(left) {
                if is_integer_literal(right) {
                    let rval: i64 = string_to_int(right);
                    if rval != 0 {
                        let result: i64 = string_to_int(left) / rval;
                        return string_concat(string_from("= "), int_to_string(result));
                    } else {
                        return string_from("Error: Division by zero");
                    }
                }
            }
        }
        i = i + 1;
    }
    0
}

// ========================================
// Code Formatter Implementation (20.1.5)
// ========================================

// Format a source file with consistent style
fn format_file(path: i64, write_back: i64) -> i64 {
    let source: i64 = read_file(path);
    if source == 0 {
        println(string_concat(string_from("Error: Could not read file: "), path));
        return 1;
    }

    // Tokenize
    let tokens: i64 = tokenize(source);

    // Parse
    let parse_result: i64 = parse_program(tokens);
    let items: i64 = parse_result_items(parse_result);
    let errors: i64 = parse_result_errors(parse_result);

    if errors > 0 {
        println(string_concat(string_from("Error: Parse errors in "), path));
        return 1;
    }

    // Format the AST back to source
    let formatted: i64 = format_items(items);

    if write_back == 1 {
        write_file(path, formatted);
        println(string_concat(string_from("Formatted: "), path));
    } else {
        // Print to stdout
        println(formatted);
    }

    0
}

// Format a list of items
fn format_items(items: i64) -> i64 {
    let sb: i64 = sb_new();
    let n: i64 = vec_len(items);
    let i: i64 = 0;

    while i < n {
        let item: i64 = vec_get(items, i);
        let formatted_item: i64 = format_item(item);
        sb_append(sb, formatted_item);
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }

    sb_to_string(sb)
}

// Format a single item (fn, struct, enum, impl, trait)
fn format_item(item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == 0 {
        // Function
        return format_fn(item);
    }
    if tag == 1 {
        // Enum
        return format_enum(item);
    }
    if tag == 2 {
        // Struct
        return format_struct(item);
    }
    if tag == 3 {
        // Impl
        return format_impl(item);
    }
    if tag == 4 {
        // Trait
        return format_trait(item);
    }
    if tag == 5 {
        // Impl Trait for Type
        return format_impl_trait(item);
    }

    string_from("")
}

// Format a function definition
fn format_fn(fn_def: i64) -> i64 {
    let sb: i64 = sb_new();
    let name: i64 = load_ptr(fn_def, 1);
    let type_params: i64 = load_ptr(fn_def, 2);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    sb_append(sb, string_from("fn "));
    sb_append(sb, name);

    // Type parameters
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            sb_append(sb, string_from("<"));
            let i: i64 = 0;
            while i < vec_len(type_params) {
                if i > 0 {
                    sb_append(sb, string_from(", "));
                }
                sb_append(sb, vec_get(type_params, i));
                i = i + 1;
            }
            sb_append(sb, string_from(">"));
        }
    }

    // Parameters
    sb_append(sb, string_from("("));
    let i: i64 = 0;
    while i < vec_len(params) {
        if i > 0 {
            sb_append(sb, string_from(", "));
        }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let pty: i64 = load_ptr(param, 1);
        sb_append(sb, pname);
        sb_append(sb, string_from(": "));
        sb_append(sb, pty);
        i = i + 1;
    }
    sb_append(sb, string_from(")"));

    // Return type
    if ret_ty != 0 {
        sb_append(sb, string_from(" -> "));
        sb_append(sb, ret_ty);
    }

    sb_append(sb, string_from(" "));
    sb_append(sb, format_block(body, 0));

    sb_to_string(sb)
}

// Format a block expression
fn format_block(block: i64, indent: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, string_from("{\n"));

    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);
    let n: i64 = vec_len(stmts);
    let i: i64 = 0;

    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        sb_append(sb, make_indent(indent + 1));
        sb_append(sb, format_stmt(stmt, indent + 1));
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }

    if result != 0 {
        sb_append(sb, make_indent(indent + 1));
        sb_append(sb, format_expr(result, indent + 1));
        sb_append(sb, string_from("\n"));
    }

    sb_append(sb, make_indent(indent));
    sb_append(sb, string_from("}"));

    sb_to_string(sb)
}

// Create indentation string (4 spaces per level)
fn make_indent(level: i64) -> i64 {
    let sb: i64 = sb_new();
    let i: i64 = 0;
    while i < level {
        sb_append(sb, string_from("    "));
        i = i + 1;
    }
    sb_to_string(sb)
}

// Format a statement
fn format_stmt(stmt: i64, indent: i64) -> i64 {
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == 0 {
        let name: i64 = load_ptr(stmt, 1);
        let ty: i64 = load_ptr(stmt, 2);
        let init_expr: i64 = load_ptr(stmt, 3);
        let sb: i64 = sb_new();
        sb_append(sb, string_from("let "));
        sb_append(sb, name);
        if ty != 0 {
            sb_append(sb, string_from(": "));
            sb_append(sb, ty);
        }
        if init_expr != 0 {
            sb_append(sb, string_from(" = "));
            sb_append(sb, format_expr(init_expr, indent));
        }
        sb_append(sb, string_from(";"));
        return sb_to_string(sb);
    }

    // Expression statement
    if tag == 1 {
        let expr: i64 = load_ptr(stmt, 1);
        let formatted: i64 = format_expr(expr, indent);
        return string_concat(formatted, string_from(";"));
    }

    // Return statement
    if tag == 2 {
        let expr: i64 = load_ptr(stmt, 1);
        if expr == 0 {
            return string_from("return;");
        }
        return string_concat(string_from("return "),
               string_concat(format_expr(expr, indent), string_from(";")));
    }

    // Assign statement
    if tag == 3 {
        let name: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        return string_concat(name,
               string_concat(string_from(" = "),
               string_concat(format_expr(value, indent), string_from(";"))));
    }

    // Break
    if tag == 4 {
        return string_from("break;");
    }

    // Continue
    if tag == 5 {
        return string_from("continue;");
    }

    string_from("")
}

// Format an expression
fn format_expr(expr: i64, indent: i64) -> i64 {
    if expr == 0 {
        return string_from("");
    }

    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == 0 {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == 1 {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("true");
        }
        return string_from("false");
    }

    // String literal
    if tag == 2 {
        let value: i64 = load_ptr(expr, 1);
        return string_concat(string_from("\""),
               string_concat(value, string_from("\"")));
    }

    // Identifier
    if tag == 3 {
        return load_ptr(expr, 1);
    }

    // Path
    if tag == 4 {
        let segments: i64 = load_ptr(expr, 1);
        let sb: i64 = sb_new();
        let i: i64 = 0;
        while i < vec_len(segments) {
            if i > 0 {
                sb_append(sb, string_from("::"));
            }
            sb_append(sb, vec_get(segments, i));
            i = i + 1;
        }
        return sb_to_string(sb);
    }

    // Call
    if tag == 5 {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);
        let sb: i64 = sb_new();
        sb_append(sb, format_expr(callee, indent));
        sb_append(sb, string_from("("));
        let i: i64 = 0;
        while i < vec_len(args) {
            if i > 0 {
                sb_append(sb, string_from(", "));
            }
            sb_append(sb, format_expr(vec_get(args, i), indent));
            i = i + 1;
        }
        sb_append(sb, string_from(")"));
        return sb_to_string(sb);
    }

    // Binary
    if tag == 6 {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);
        return string_concat(format_expr(left, indent),
               string_concat(string_from(" "),
               string_concat(format_binop(op),
               string_concat(string_from(" "), format_expr(right, indent)))));
    }

    // Unary
    if tag == 7 {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        if op == 100 {
            return string_concat(string_from("-"), format_expr(operand, indent));
        }
        return string_concat(string_from("!"), format_expr(operand, indent));
    }

    // If
    if tag == 8 {
        let cond: i64 = load_ptr(expr, 1);
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        let sb: i64 = sb_new();
        sb_append(sb, string_from("if "));
        sb_append(sb, format_expr(cond, indent));
        sb_append(sb, string_from(" "));
        sb_append(sb, format_block(then_block, indent));
        if else_block != 0 {
            sb_append(sb, string_from(" else "));
            let else_tag: i64 = load_i64(else_block, 0);
            if else_tag == 8 {
                // else if
                sb_append(sb, format_expr(else_block, indent));
            } else {
                sb_append(sb, format_block(else_block, indent));
            }
        }
        return sb_to_string(sb);
    }

    // While
    if tag == 9 {
        let cond: i64 = load_ptr(expr, 1);
        let body: i64 = load_ptr(expr, 2);
        return string_concat(string_from("while "),
               string_concat(format_expr(cond, indent),
               string_concat(string_from(" "), format_block(body, indent))));
    }

    // Block
    if tag == 10 {
        return format_block(expr, indent);
    }

    // Struct literal
    if tag == 11 {
        let name: i64 = load_ptr(expr, 1);
        let fields: i64 = load_ptr(expr, 2);
        let sb: i64 = sb_new();
        sb_append(sb, name);
        sb_append(sb, string_from(" { "));
        let i: i64 = 0;
        while i < vec_len(fields) {
            if i > 0 {
                sb_append(sb, string_from(", "));
            }
            let field: i64 = vec_get(fields, i);
            let fname: i64 = load_ptr(field, 0);
            let fval: i64 = load_ptr(field, 1);
            sb_append(sb, fname);
            sb_append(sb, string_from(": "));
            sb_append(sb, format_expr(fval, indent));
            i = i + 1;
        }
        sb_append(sb, string_from(" }"));
        return sb_to_string(sb);
    }

    // Field access
    if tag == 12 {
        let obj: i64 = load_ptr(expr, 1);
        let field: i64 = load_ptr(expr, 2);
        return string_concat(format_expr(obj, indent),
               string_concat(string_from("."), field));
    }

    // For loop
    if tag == 13 {
        let loop_var: i64 = load_ptr(expr, 1);
        let start: i64 = load_ptr(expr, 2);
        let end: i64 = load_ptr(expr, 3);
        let body: i64 = load_ptr(expr, 4);
        return string_concat(string_from("for "),
               string_concat(loop_var,
               string_concat(string_from(" in "),
               string_concat(format_expr(start, indent),
               string_concat(string_from(".."),
               string_concat(format_expr(end, indent),
               string_concat(string_from(" "), format_block(body, indent))))))));
    }

    // Match
    if tag == 14 {
        let scrutinee: i64 = load_ptr(expr, 1);
        let arms: i64 = load_ptr(expr, 2);
        let sb: i64 = sb_new();
        sb_append(sb, string_from("match "));
        sb_append(sb, format_expr(scrutinee, indent));
        sb_append(sb, string_from(" {\n"));
        let i: i64 = 0;
        while i < vec_len(arms) {
            let arm: i64 = vec_get(arms, i);
            let pattern: i64 = load_ptr(arm, 0);
            let result: i64 = load_ptr(arm, 1);
            sb_append(sb, make_indent(indent + 1));
            if pattern == 0 {
                sb_append(sb, string_from("_"));
            } else {
                sb_append(sb, format_expr(pattern, indent + 1));
            }
            sb_append(sb, string_from(" => "));
            sb_append(sb, format_expr(result, indent + 1));
            sb_append(sb, string_from(",\n"));
            i = i + 1;
        }
        sb_append(sb, make_indent(indent));
        sb_append(sb, string_from("}"));
        return sb_to_string(sb);
    }

    // Method call
    if tag == 15 {
        let obj: i64 = load_ptr(expr, 1);
        let method: i64 = load_ptr(expr, 2);
        let args: i64 = load_ptr(expr, 3);
        let sb: i64 = sb_new();
        sb_append(sb, format_expr(obj, indent));
        sb_append(sb, string_from("."));
        sb_append(sb, method);
        sb_append(sb, string_from("("));
        let i: i64 = 0;
        while i < vec_len(args) {
            if i > 0 {
                sb_append(sb, string_from(", "));
            }
            sb_append(sb, format_expr(vec_get(args, i), indent));
            i = i + 1;
        }
        sb_append(sb, string_from(")"));
        return sb_to_string(sb);
    }

    // Try operator
    if tag == 16 {
        let inner: i64 = load_ptr(expr, 1);
        return string_concat(format_expr(inner, indent), string_from("?"));
    }

    string_from("")
}

// Format binary operator
fn format_binop(op: i64) -> i64 {
    if op == 0 { return string_from("+"); }
    if op == 1 { return string_from("-"); }
    if op == 2 { return string_from("*"); }
    if op == 3 { return string_from("/"); }
    if op == 4 { return string_from("=="); }
    if op == 5 { return string_from("!="); }
    if op == 6 { return string_from("<"); }
    if op == 7 { return string_from(">"); }
    if op == 8 { return string_from("<="); }
    if op == 9 { return string_from(">="); }
    if op == 10 { return string_from("&&"); }
    if op == 11 { return string_from("||"); }
    if op == 12 { return string_from("%"); }
    if op == 13 { return string_from("&"); }
    if op == 14 { return string_from("|"); }
    if op == 15 { return string_from("^"); }
    if op == 16 { return string_from("<<"); }
    if op == 17 { return string_from(">>"); }
    string_from("??")
}

// Format enum definition
fn format_enum(enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    let sb: i64 = sb_new();
    sb_append(sb, string_from("enum "));
    sb_append(sb, name);
    sb_append(sb, string_from(" {\n"));
    let i: i64 = 0;
    while i < vec_len(variants) {
        sb_append(sb, string_from("    "));
        sb_append(sb, vec_get(variants, i));
        if i < vec_len(variants) - 1 {
            sb_append(sb, string_from(","));
        }
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }
    sb_append(sb, string_from("}"));
    sb_to_string(sb)
}

// Format struct definition
fn format_struct(struct_def: i64) -> i64 {
    let name: i64 = load_ptr(struct_def, 1);
    let type_params: i64 = load_ptr(struct_def, 2);
    let fields: i64 = load_ptr(struct_def, 3);
    let sb: i64 = sb_new();
    sb_append(sb, string_from("struct "));
    sb_append(sb, name);
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            sb_append(sb, string_from("<"));
            let i: i64 = 0;
            while i < vec_len(type_params) {
                if i > 0 {
                    sb_append(sb, string_from(", "));
                }
                sb_append(sb, vec_get(type_params, i));
                i = i + 1;
            }
            sb_append(sb, string_from(">"));
        }
    }
    sb_append(sb, string_from(" {\n"));
    let i: i64 = 0;
    while i < vec_len(fields) {
        let field: i64 = vec_get(fields, i);
        let fname: i64 = load_ptr(field, 0);
        let fty: i64 = load_ptr(field, 1);
        sb_append(sb, string_from("    "));
        sb_append(sb, fname);
        sb_append(sb, string_from(": "));
        sb_append(sb, fty);
        if i < vec_len(fields) - 1 {
            sb_append(sb, string_from(","));
        }
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }
    sb_append(sb, string_from("}"));
    sb_to_string(sb)
}

// Format impl block
fn format_impl(impl_def: i64) -> i64 {
    let type_name: i64 = load_ptr(impl_def, 1);
    let methods: i64 = load_ptr(impl_def, 2);
    let sb: i64 = sb_new();
    sb_append(sb, string_from("impl "));
    sb_append(sb, type_name);
    sb_append(sb, string_from(" {\n"));
    let i: i64 = 0;
    while i < vec_len(methods) {
        let method: i64 = vec_get(methods, i);
        sb_append(sb, string_from("    "));
        let formatted: i64 = format_fn(method);
        // Indent the method body
        formatted = string_replace(formatted, string_from("\n"), string_from("\n    "));
        sb_append(sb, formatted);
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }
    sb_append(sb, string_from("}"));
    sb_to_string(sb)
}

// Format trait definition
fn format_trait(trait_def: i64) -> i64 {
    let name: i64 = load_ptr(trait_def, 1);
    let method_sigs: i64 = load_ptr(trait_def, 2);
    let sb: i64 = sb_new();
    sb_append(sb, string_from("trait "));
    sb_append(sb, name);
    sb_append(sb, string_from(" {\n"));
    let i: i64 = 0;
    while i < vec_len(method_sigs) {
        let sig: i64 = vec_get(method_sigs, i);
        let mname: i64 = load_ptr(sig, 0);
        let params: i64 = load_ptr(sig, 1);
        let ret_ty: i64 = load_ptr(sig, 2);
        sb_append(sb, string_from("    fn "));
        sb_append(sb, mname);
        sb_append(sb, string_from("("));
        if params != 0 {
            let j: i64 = 0;
            while j < vec_len(params) {
                if j > 0 {
                    sb_append(sb, string_from(", "));
                }
                let param: i64 = vec_get(params, j);
                let pname: i64 = load_ptr(param, 0);
                let pty: i64 = load_ptr(param, 1);
                sb_append(sb, pname);
                sb_append(sb, string_from(": "));
                sb_append(sb, pty);
                j = j + 1;
            }
        }
        sb_append(sb, string_from(")"));
        if ret_ty != 0 {
            sb_append(sb, string_from(" -> "));
            sb_append(sb, ret_ty);
        }
        sb_append(sb, string_from(";\n"));
        i = i + 1;
    }
    sb_append(sb, string_from("}"));
    sb_to_string(sb)
}

// Format impl Trait for Type
fn format_impl_trait(impl_def: i64) -> i64 {
    let trait_name: i64 = load_ptr(impl_def, 1);
    let type_name: i64 = load_ptr(impl_def, 2);
    let methods: i64 = load_ptr(impl_def, 3);
    let sb: i64 = sb_new();
    sb_append(sb, string_from("impl "));
    sb_append(sb, trait_name);
    sb_append(sb, string_from(" for "));
    sb_append(sb, type_name);
    sb_append(sb, string_from(" {\n"));
    let i: i64 = 0;
    while i < vec_len(methods) {
        let method: i64 = vec_get(methods, i);
        sb_append(sb, string_from("    "));
        let formatted: i64 = format_fn(method);
        formatted = string_replace(formatted, string_from("\n"), string_from("\n    "));
        sb_append(sb, formatted);
        sb_append(sb, string_from("\n"));
        i = i + 1;
    }
    sb_append(sb, string_from("}"));
    sb_to_string(sb)
}
