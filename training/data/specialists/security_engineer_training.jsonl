{"prompt": "How do I prevent SQL injection attacks?", "response": "**SQL Injection Prevention:**\n\n## 1. Parameterized Queries (Best Practice)\n\n```python\n# WRONG - Vulnerable\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# CORRECT - Parameterized\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```\n\n```javascript\n// WRONG\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\n\n// CORRECT - Prepared statement\nconst result = await db.query(\n  'SELECT * FROM users WHERE email = $1',\n  [email]\n);\n```\n\n```java\n// WRONG\nString query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// CORRECT\nPreparedStatement stmt = conn.prepareStatement(\n    \"SELECT * FROM users WHERE id = ?\");\nstmt.setInt(1, userId);\n```\n\n## 2. ORM Usage\n```python\n# SQLAlchemy (safe)\nuser = session.query(User).filter(User.id == user_id).first()\n\n# Django ORM (safe)\nuser = User.objects.get(id=user_id)\n```\n\n## 3. Input Validation\n```python\ndef validate_id(user_id):\n    if not isinstance(user_id, int):\n        raise ValueError(\"ID must be integer\")\n    if user_id < 0:\n        raise ValueError(\"ID must be positive\")\n    return user_id\n```\n\n## 4. Least Privilege\n```sql\n-- Create read-only user for app queries\nCREATE USER app_readonly WITH PASSWORD 'secret';\nGRANT SELECT ON users, products TO app_readonly;\n-- Don't use root/admin for application\n```\n\n## 5. Web Application Firewall\nDeploy WAF rules to detect SQLi patterns:\n- `' OR 1=1--`\n- `'; DROP TABLE--`\n- `UNION SELECT`"}
{"prompt": "How do I implement secure authentication?", "response": "**Secure Authentication Implementation:**\n\n## 1. Password Hashing\n```python\nimport bcrypt\n\n# Hash password\ndef hash_password(password: str) -> str:\n    salt = bcrypt.gensalt(rounds=12)\n    return bcrypt.hashpw(password.encode(), salt).decode()\n\n# Verify password\ndef verify_password(password: str, hashed: str) -> bool:\n    return bcrypt.checkpw(password.encode(), hashed.encode())\n```\n\n## 2. Password Requirements\n```python\nimport re\n\ndef validate_password(password: str) -> tuple[bool, str]:\n    if len(password) < 12:\n        return False, \"Minimum 12 characters\"\n    if not re.search(r'[A-Z]', password):\n        return False, \"Needs uppercase letter\"\n    if not re.search(r'[a-z]', password):\n        return False, \"Needs lowercase letter\"\n    if not re.search(r'\\d', password):\n        return False, \"Needs digit\"\n    if not re.search(r'[!@#$%^&*]', password):\n        return False, \"Needs special character\"\n    # Check against breached passwords\n    if is_breached(password):\n        return False, \"Password found in data breach\"\n    return True, \"Valid\"\n```\n\n## 3. Multi-Factor Authentication\n```python\nimport pyotp\n\n# Generate TOTP secret\ndef setup_mfa(user):\n    secret = pyotp.random_base32()\n    user.mfa_secret = secret\n    totp = pyotp.TOTP(secret)\n    return totp.provisioning_uri(user.email, issuer_name=\"MyApp\")\n\n# Verify TOTP\ndef verify_mfa(user, code):\n    totp = pyotp.TOTP(user.mfa_secret)\n    return totp.verify(code, valid_window=1)\n```\n\n## 4. Session Management\n```python\nimport secrets\nfrom datetime import datetime, timedelta\n\ndef create_session(user_id):\n    session_id = secrets.token_urlsafe(32)\n    expires = datetime.utcnow() + timedelta(hours=24)\n    # Store in Redis with expiry\n    redis.setex(f\"session:{session_id}\", 86400, user_id)\n    return session_id\n\n# Secure cookie settings\nresponse.set_cookie(\n    'session_id', session_id,\n    httponly=True,\n    secure=True,\n    samesite='Strict',\n    max_age=86400\n)\n```\n\n## 5. Rate Limiting\n```python\nfrom flask_limiter import Limiter\n\nlimiter = Limiter(key_func=get_remote_address)\n\n@app.route('/login', methods=['POST'])\n@limiter.limit(\"5 per minute\")\ndef login():\n    # Login logic\n    pass\n```"}
{"prompt": "How do I prevent Cross-Site Scripting (XSS)?", "response": "**XSS Prevention Strategies:**\n\n## 1. Output Encoding\n```javascript\n// WRONG - Direct HTML insertion\nelement.innerHTML = userInput;\n\n// CORRECT - Use textContent\nelement.textContent = userInput;\n\n// Or encode HTML entities\nfunction escapeHtml(text) {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n```\n\n```python\n# Python - Use template engine auto-escaping\nfrom markupsafe import escape\n\n# Flask/Jinja2 auto-escapes by default\n# {{ user_input }}  <- automatically escaped\n\n# Manual escaping\nsafe_text = escape(user_input)\n```\n\n## 2. Content Security Policy\n```python\n# Flask CSP headers\n@app.after_request\ndef add_security_headers(response):\n    response.headers['Content-Security-Policy'] = \"; \".join([\n        \"default-src 'self'\",\n        \"script-src 'self' 'nonce-{nonce}'\",\n        \"style-src 'self' 'unsafe-inline'\",\n        \"img-src 'self' data: https:\",\n        \"font-src 'self'\",\n        \"frame-ancestors 'none'\",\n        \"base-uri 'self'\",\n        \"form-action 'self'\"\n    ])\n    return response\n```\n\n## 3. Input Sanitization\n```python\nimport bleach\n\n# Allow only safe HTML tags\ndef sanitize_html(content):\n    allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'li', 'a']\n    allowed_attrs = {'a': ['href', 'title']}\n    return bleach.clean(\n        content,\n        tags=allowed_tags,\n        attributes=allowed_attrs,\n        strip=True\n    )\n```\n\n## 4. React/Vue Protections\n```jsx\n// React auto-escapes by default\n<div>{userInput}</div>  // Safe\n\n// DANGER - Only use when necessary\n<div dangerouslySetInnerHTML={{__html: sanitizedHtml}} />\n\n// Use DOMPurify if you must render HTML\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(dirtyHtml);\n```\n\n## 5. HTTP-Only Cookies\n```python\n# Prevent XSS from stealing session cookies\nresponse.set_cookie(\n    'session',\n    value,\n    httponly=True,  # JS cannot access\n    secure=True,     # HTTPS only\n    samesite='Strict'\n)\n```"}
{"prompt": "How do I implement secure API authentication with JWT?", "response": "**Secure JWT Implementation:**\n\n## 1. Token Generation\n```python\nimport jwt\nfrom datetime import datetime, timedelta\nimport os\n\nSECRET_KEY = os.environ['JWT_SECRET']  # 256+ bit secret\nALGORITHM = 'HS256'\n\ndef create_access_token(user_id: str, roles: list) -> str:\n    payload = {\n        'sub': user_id,\n        'roles': roles,\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + timedelta(minutes=15),\n        'jti': str(uuid.uuid4())  # Unique token ID\n    }\n    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n\ndef create_refresh_token(user_id: str) -> str:\n    payload = {\n        'sub': user_id,\n        'type': 'refresh',\n        'exp': datetime.utcnow() + timedelta(days=7),\n        'jti': str(uuid.uuid4())\n    }\n    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n```\n\n## 2. Token Verification\n```python\ndef verify_token(token: str) -> dict:\n    try:\n        payload = jwt.decode(\n            token,\n            SECRET_KEY,\n            algorithms=[ALGORITHM],\n            options={\n                'require': ['exp', 'sub', 'iat'],\n                'verify_exp': True\n            }\n        )\n        # Check if token is revoked\n        if is_token_revoked(payload['jti']):\n            raise jwt.InvalidTokenError('Token revoked')\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise AuthError('Token expired')\n    except jwt.InvalidTokenError as e:\n        raise AuthError(f'Invalid token: {e}')\n```\n\n## 3. Token Revocation\n```python\n# Store revoked tokens in Redis\ndef revoke_token(jti: str, exp: datetime):\n    ttl = (exp - datetime.utcnow()).total_seconds()\n    redis.setex(f\"revoked:{jti}\", int(ttl), \"1\")\n\ndef is_token_revoked(jti: str) -> bool:\n    return redis.exists(f\"revoked:{jti}\")\n```\n\n## 4. Secure Headers\n```python\n# Send token in Authorization header\n# Authorization: Bearer <token>\n\n# NEVER in URL query params (logged, cached)\n# NEVER in localStorage (XSS vulnerable)\n\n# Use HttpOnly cookies for web apps\nresponse.set_cookie(\n    'access_token',\n    token,\n    httponly=True,\n    secure=True,\n    samesite='Strict',\n    max_age=900  # 15 minutes\n)\n```\n\n## 5. Best Practices\n- Use asymmetric keys (RS256) for distributed systems\n- Short-lived access tokens (15 min)\n- Longer refresh tokens with rotation\n- Include minimal claims in payload\n- Never store sensitive data in JWT"}
{"prompt": "How do I perform a security code review?", "response": "**Security Code Review Checklist:**\n\n## 1. Authentication & Authorization\n```\n[ ] Password hashing uses bcrypt/argon2 (not MD5/SHA1)\n[ ] Rate limiting on login endpoints\n[ ] Account lockout after failed attempts\n[ ] Secure session management\n[ ] Proper logout invalidates session\n[ ] Authorization checks on every endpoint\n[ ] Role-based access control implemented\n[ ] No hardcoded credentials\n```\n\n## 2. Input Validation\n```\n[ ] All user inputs validated server-side\n[ ] Input length limits enforced\n[ ] File uploads validated (type, size)\n[ ] SQL queries use parameterized statements\n[ ] No eval() or exec() with user input\n[ ] Path traversal prevented\n[ ] XML parsing configured securely\n```\n\n## 3. Output Encoding\n```\n[ ] HTML output encoded\n[ ] JSON responses properly escaped\n[ ] CSP headers implemented\n[ ] X-Content-Type-Options: nosniff\n[ ] No sensitive data in error messages\n```\n\n## 4. Cryptography\n```\n[ ] TLS 1.2+ required\n[ ] Strong cipher suites only\n[ ] Certificates validated properly\n[ ] Secrets stored in environment/vault\n[ ] Random number generation uses CSPRNG\n[ ] No deprecated algorithms (MD5, SHA1, DES)\n```\n\n## 5. Common Vulnerabilities\n\n### SQL Injection\n```python\n# BAD\nf\"SELECT * FROM users WHERE id = {id}\"\n\n# GOOD\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (id,))\n```\n\n### Command Injection\n```python\n# BAD\nos.system(f\"ping {hostname}\")\n\n# GOOD\nsubprocess.run(['ping', hostname], capture_output=True)\n```\n\n### Path Traversal\n```python\n# BAD\nopen(f\"uploads/{filename}\")\n\n# GOOD\nsafe_path = os.path.join('uploads', os.path.basename(filename))\nif not safe_path.startswith('uploads/'):\n    raise SecurityError(\"Path traversal detected\")\n```\n\n## 6. Tools to Use\n- SAST: Semgrep, SonarQube, Bandit\n- DAST: OWASP ZAP, Burp Suite\n- Dependency: Snyk, Dependabot\n- Secrets: GitLeaks, TruffleHog"}
{"prompt": "How do I implement HTTPS and TLS correctly?", "response": "**TLS/HTTPS Best Practices:**\n\n## 1. Nginx Configuration\n```nginx\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    \n    # Certificate\n    ssl_certificate /etc/ssl/certs/fullchain.pem;\n    ssl_certificate_key /etc/ssl/private/privkey.pem;\n    \n    # TLS Configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    \n    # HSTS\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\" always;\n    \n    # Session\n    ssl_session_timeout 1d;\n    ssl_session_cache shared:SSL:50m;\n    ssl_session_tickets off;\n    \n    # OCSP Stapling\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n}\n\n# Redirect HTTP to HTTPS\nserver {\n    listen 80;\n    server_name example.com;\n    return 301 https://$server_name$request_uri;\n}\n```\n\n## 2. Security Headers\n```nginx\nadd_header X-Frame-Options \"SAMEORIGIN\" always;\nadd_header X-Content-Type-Options \"nosniff\" always;\nadd_header X-XSS-Protection \"1; mode=block\" always;\nadd_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\nadd_header Content-Security-Policy \"default-src 'self'\" always;\n```\n\n## 3. Certificate Management\n```bash\n# Let's Encrypt with Certbot\ncertbot certonly --nginx -d example.com -d www.example.com\n\n# Auto-renewal\ncertbot renew --dry-run\n\n# Cron for renewal\n0 0 1 * * /usr/bin/certbot renew --quiet\n```\n\n## 4. Testing Configuration\n```bash\n# SSL Labs test\ncurl https://api.ssllabs.com/api/v3/analyze?host=example.com\n\n# testssl.sh\n./testssl.sh example.com\n\n# Check certificate\nopenssl s_client -connect example.com:443 -servername example.com\n```\n\n## 5. Common Issues\n| Issue | Solution |\n|-------|----------|\n| Mixed content | Use protocol-relative or HTTPS URLs |\n| Certificate mismatch | Include all domain variants in cert |\n| Expired certificate | Set up monitoring and auto-renewal |\n| Weak ciphers | Use modern cipher suites only |\n| Missing chain | Include intermediate certificates |"}
{"prompt": "How do I handle sensitive data and secrets?", "response": "**Secrets Management Best Practices:**\n\n## 1. Environment Variables\n```bash\n# .env file (never commit)\nDATABASE_URL=postgres://user:pass@host:5432/db\nAPI_KEY=sk_live_xxxxx\nJWT_SECRET=your-256-bit-secret\n\n# .gitignore\n.env\n.env.*\n!.env.example\n```\n\n```python\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\ndb_url = os.environ['DATABASE_URL']\n```\n\n## 2. Secrets Managers\n\n### AWS Secrets Manager\n```python\nimport boto3\nimport json\n\ndef get_secret(secret_name):\n    client = boto3.client('secretsmanager')\n    response = client.get_secret_value(SecretId=secret_name)\n    return json.loads(response['SecretString'])\n\n# Usage\ndb_creds = get_secret('prod/database')\n```\n\n### HashiCorp Vault\n```python\nimport hvac\n\nclient = hvac.Client(url='https://vault.example.com')\nclient.token = os.environ['VAULT_TOKEN']\n\nsecret = client.secrets.kv.v2.read_secret_version(\n    path='myapp/database'\n)\npassword = secret['data']['data']['password']\n```\n\n## 3. Kubernetes Secrets\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secrets\ntype: Opaque\nstringData:\n  DATABASE_URL: \"postgres://user:pass@host/db\"\n  API_KEY: \"sk_live_xxxxx\"\n---\n# Pod using secret\nenv:\n  - name: DATABASE_URL\n    valueFrom:\n      secretKeyRef:\n        name: app-secrets\n        key: DATABASE_URL\n```\n\n## 4. Secret Detection\n```bash\n# Pre-commit hook with gitleaks\ngitleaks detect --source . --verbose\n\n# TruffleHog\ntrufflehog git file://./\n```\n\n## 5. Secret Rotation\n```python\nimport schedule\nimport time\n\ndef rotate_secrets():\n    # 1. Generate new secret\n    new_secret = generate_new_secret()\n    \n    # 2. Update in secrets manager\n    update_secret('api-key', new_secret)\n    \n    # 3. Update application\n    reload_application_config()\n    \n    # 4. Revoke old secret\n    revoke_old_secret(old_secret)\n\n# Rotate every 90 days\nschedule.every(90).days.do(rotate_secrets)\n```\n\n## 6. Data Classification\n| Level | Examples | Handling |\n|-------|----------|----------|\n| Public | Marketing content | No restrictions |\n| Internal | Employee directory | Basic access control |\n| Confidential | Customer data | Encrypted, audited |\n| Restricted | Passwords, keys | Vault, rotation |"}
{"prompt": "How do I secure a REST API?", "response": "**REST API Security Checklist:**\n\n## 1. Authentication\n```python\nfrom functools import wraps\nfrom flask import request, jsonify\n\ndef require_auth(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get('Authorization', '').replace('Bearer ', '')\n        if not token:\n            return jsonify({'error': 'Missing token'}), 401\n        try:\n            payload = verify_jwt(token)\n            request.user = payload\n        except:\n            return jsonify({'error': 'Invalid token'}), 401\n        return f(*args, **kwargs)\n    return decorated\n\n@app.route('/api/users', methods=['GET'])\n@require_auth\ndef get_users():\n    return jsonify(users)\n```\n\n## 2. Authorization\n```python\ndef require_role(*roles):\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            if request.user['role'] not in roles:\n                return jsonify({'error': 'Forbidden'}), 403\n            return f(*args, **kwargs)\n        return decorated\n    return decorator\n\n@app.route('/api/admin/users', methods=['DELETE'])\n@require_auth\n@require_role('admin')\ndef delete_user():\n    # Only admins can access\n    pass\n```\n\n## 3. Rate Limiting\n```python\nfrom flask_limiter import Limiter\n\nlimiter = Limiter(\n    app,\n    key_func=lambda: request.headers.get('X-API-Key'),\n    default_limits=[\"100 per hour\"]\n)\n\n@app.route('/api/search')\n@limiter.limit(\"10 per minute\")\ndef search():\n    pass\n```\n\n## 4. Input Validation\n```python\nfrom pydantic import BaseModel, validator, constr\n\nclass CreateUserRequest(BaseModel):\n    email: constr(max_length=255)\n    name: constr(min_length=1, max_length=100)\n    age: int\n    \n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email')\n        return v.lower()\n    \n    @validator('age')\n    def validate_age(cls, v):\n        if not 0 < v < 150:\n            raise ValueError('Invalid age')\n        return v\n\n@app.route('/api/users', methods=['POST'])\ndef create_user():\n    try:\n        data = CreateUserRequest(**request.json)\n    except ValidationError as e:\n        return jsonify({'errors': e.errors()}), 400\n```\n\n## 5. Security Headers\n```python\n@app.after_request\ndef add_security_headers(response):\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    response.headers['X-Frame-Options'] = 'DENY'\n    response.headers['Cache-Control'] = 'no-store'\n    response.headers['Content-Security-Policy'] = \"default-src 'none'\"\n    return response\n```\n\n## 6. Logging & Monitoring\n```python\nimport logging\n\n@app.before_request\ndef log_request():\n    logging.info(f\"{request.method} {request.path}\", extra={\n        'ip': request.remote_addr,\n        'user_agent': request.user_agent.string,\n        'user_id': getattr(request, 'user', {}).get('sub')\n    })\n```"}
{"prompt": "How do I implement CSRF protection?", "response": "**CSRF Protection Implementation:**\n\n## 1. Token-Based Protection\n```python\nfrom flask import Flask, session, request\nimport secrets\n\napp = Flask(__name__)\n\ndef generate_csrf_token():\n    if 'csrf_token' not in session:\n        session['csrf_token'] = secrets.token_urlsafe(32)\n    return session['csrf_token']\n\n@app.before_request\ndef csrf_protect():\n    if request.method in ['POST', 'PUT', 'DELETE', 'PATCH']:\n        token = request.form.get('csrf_token') or \\\n                request.headers.get('X-CSRF-Token')\n        if not token or token != session.get('csrf_token'):\n            abort(403, 'CSRF token missing or invalid')\n\n# Template\n# <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n```\n\n## 2. Double Submit Cookie\n```python\nimport hashlib\nimport hmac\n\ndef set_csrf_cookie(response):\n    token = secrets.token_urlsafe(32)\n    response.set_cookie(\n        'csrf_token',\n        token,\n        secure=True,\n        samesite='Strict',\n        httponly=False  # JS needs to read it\n    )\n    return token\n\n@app.before_request\ndef verify_csrf():\n    if request.method in ['POST', 'PUT', 'DELETE']:\n        cookie_token = request.cookies.get('csrf_token')\n        header_token = request.headers.get('X-CSRF-Token')\n        if not cookie_token or cookie_token != header_token:\n            abort(403)\n```\n\n## 3. SameSite Cookies\n```python\n# Modern browsers support SameSite\nresponse.set_cookie(\n    'session',\n    session_id,\n    secure=True,\n    httponly=True,\n    samesite='Strict'  # or 'Lax'\n)\n```\n\n## 4. JavaScript Implementation\n```javascript\n// Read CSRF token from cookie\nfunction getCsrfToken() {\n  return document.cookie\n    .split('; ')\n    .find(row => row.startsWith('csrf_token='))\n    ?.split('=')[1];\n}\n\n// Include in fetch requests\nfetch('/api/action', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-CSRF-Token': getCsrfToken()\n  },\n  body: JSON.stringify(data)\n});\n\n// Axios interceptor\naxios.interceptors.request.use(config => {\n  if (['post', 'put', 'delete'].includes(config.method)) {\n    config.headers['X-CSRF-Token'] = getCsrfToken();\n  }\n  return config;\n});\n```\n\n## 5. Framework Built-ins\n```python\n# Flask-WTF\nfrom flask_wtf.csrf import CSRFProtect\ncsrf = CSRFProtect(app)\n\n# Django (enabled by default)\nMIDDLEWARE = [\n    'django.middleware.csrf.CsrfViewMiddleware',\n]\n# {% csrf_token %} in templates\n```"}
{"prompt": "How do I perform penetration testing?", "response": "**Penetration Testing Methodology:**\n\n## 1. Reconnaissance\n```bash\n# Subdomain enumeration\nsubfinder -d target.com -o subdomains.txt\namass enum -d target.com\n\n# Port scanning\nnmap -sV -sC -p- target.com -oN nmap_results.txt\n\n# Technology fingerprinting\nwhatweb target.com\nwappalyzer target.com\n\n# Directory brute-forcing\ngobuster dir -u https://target.com -w /usr/share/wordlists/dirb/common.txt\nffuf -w wordlist.txt -u https://target.com/FUZZ\n```\n\n## 2. Vulnerability Scanning\n```bash\n# Web application scanner\nnikto -h https://target.com\n\n# OWASP ZAP\nzap-cli quick-scan https://target.com\n\n# Nuclei templates\nnuclei -u https://target.com -t cves/\nnuclei -u https://target.com -t exposures/\n```\n\n## 3. Manual Testing\n\n### Authentication Testing\n- [ ] Brute force protection\n- [ ] Password policy enforcement\n- [ ] Session fixation\n- [ ] Session timeout\n- [ ] Logout functionality\n- [ ] Account lockout\n\n### Authorization Testing\n- [ ] Horizontal privilege escalation\n- [ ] Vertical privilege escalation\n- [ ] IDOR (Insecure Direct Object Reference)\n- [ ] Function-level access control\n\n### Input Validation\n- [ ] SQL injection\n- [ ] XSS (Reflected, Stored, DOM)\n- [ ] Command injection\n- [ ] Path traversal\n- [ ] XML/XXE injection\n- [ ] SSRF\n\n## 4. Common Tools\n```bash\n# Burp Suite (manual testing)\n# Intercept, modify, replay requests\n\n# SQLMap (SQL injection)\nsqlmap -u \"https://target.com/page?id=1\" --dbs\n\n# XSS testing\nxsser -u \"https://target.com/search?q=test\"\n\n# SSRF testing\n# Test with Burp Collaborator or webhook.site\n```\n\n## 5. Report Template\n```markdown\n## Executive Summary\nOverall risk rating and key findings\n\n## Findings\n### Finding 1: SQL Injection in Login\n- Severity: Critical\n- CVSS: 9.8\n- Location: /api/login\n- Description: ...\n- Evidence: [Screenshot/POC]\n- Remediation: Use parameterized queries\n\n## Recommendations\nPrioritized list of fixes\n```\n\n**Note:** Only perform testing with explicit authorization."}
{"prompt": "How do I implement security logging and monitoring?", "response": "**Security Logging & Monitoring:**\n\n## 1. What to Log\n```python\n# Security-relevant events\nSECURITY_EVENTS = {\n    'AUTH_SUCCESS': 'User login successful',\n    'AUTH_FAILURE': 'User login failed',\n    'AUTH_LOCKOUT': 'Account locked after failed attempts',\n    'PASSWORD_CHANGE': 'User changed password',\n    'PERMISSION_DENIED': 'Access denied to resource',\n    'SENSITIVE_DATA_ACCESS': 'Accessed sensitive data',\n    'ADMIN_ACTION': 'Administrative action performed',\n    'RATE_LIMIT': 'Rate limit exceeded',\n    'SUSPICIOUS_ACTIVITY': 'Potential attack detected'\n}\n```\n\n## 2. Structured Logging\n```python\nimport logging\nimport json\nfrom datetime import datetime\n\nclass SecurityLogger:\n    def __init__(self):\n        self.logger = logging.getLogger('security')\n        handler = logging.FileHandler('/var/log/app/security.log')\n        handler.setFormatter(logging.Formatter('%(message)s'))\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n    \n    def log(self, event_type, user_id=None, ip=None, details=None):\n        entry = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'event_type': event_type,\n            'user_id': user_id,\n            'ip_address': ip,\n            'user_agent': request.user_agent.string,\n            'details': details\n        }\n        self.logger.info(json.dumps(entry))\n\nsecurity_log = SecurityLogger()\n\n# Usage\nsecurity_log.log(\n    'AUTH_FAILURE',\n    user_id='user@example.com',\n    ip=request.remote_addr,\n    details={'reason': 'invalid_password', 'attempts': 3}\n)\n```\n\n## 3. Alert Rules\n```yaml\n# Prometheus/AlertManager rules\ngroups:\n  - name: security\n    rules:\n      - alert: BruteForceAttempt\n        expr: rate(auth_failures_total[5m]) > 10\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Possible brute force attack\"\n      \n      - alert: SuspiciousAdminActivity\n        expr: rate(admin_actions_total[1h]) > 50\n        for: 5m\n        labels:\n          severity: warning\n```\n\n## 4. SIEM Integration\n```python\n# Send to Splunk\nimport requests\n\ndef send_to_siem(event):\n    requests.post(\n        'https://splunk.example.com:8088/services/collector',\n        headers={'Authorization': f'Splunk {HEC_TOKEN}'},\n        json={'event': event, 'sourcetype': 'security_events'}\n    )\n\n# ELK Stack (Elasticsearch)\nfrom elasticsearch import Elasticsearch\n\nes = Elasticsearch(['https://elk.example.com:9200'])\nes.index(index='security-events', body=event)\n```\n\n## 5. Dashboard Metrics\n```\nKey Security Metrics:\n- Failed login attempts (by IP, user)\n- Successful logins from new locations\n- Permission denied events\n- Rate limit triggers\n- Admin actions\n- Sensitive data access patterns\n- API error rates (4xx, 5xx)\n- Geographic anomalies\n```"}
{"prompt": "How do I handle security incidents?", "response": "**Incident Response Procedure:**\n\n## 1. Incident Classification\n\n| Severity | Description | Response Time |\n|----------|-------------|---------------|\n| P1 - Critical | Active breach, data exposure | Immediate |\n| P2 - High | Vulnerability being exploited | < 1 hour |\n| P3 - Medium | Security issue, no active exploit | < 24 hours |\n| P4 - Low | Minor issue, best practice | < 1 week |\n\n## 2. Response Process (PICERL)\n\n### Preparation\n```markdown\n- [ ] Incident response team identified\n- [ ] Communication channels established\n- [ ] Runbooks documented\n- [ ] Tools and access ready\n- [ ] Legal/PR contacts available\n```\n\n### Identification\n```markdown\n- [ ] Confirm incident is real (not false positive)\n- [ ] Determine scope and impact\n- [ ] Identify affected systems/data\n- [ ] Document timeline of events\n- [ ] Assign incident commander\n```\n\n### Containment\n```bash\n# Short-term containment\n- Block malicious IPs\n- Disable compromised accounts\n- Isolate affected systems\n- Preserve evidence\n\n# Example: Block IP in firewall\niptables -A INPUT -s 1.2.3.4 -j DROP\n\n# Disable user account\nkubectl delete secret user-token-xyz\n```\n\n### Eradication\n```markdown\n- [ ] Remove malware/backdoors\n- [ ] Patch vulnerabilities\n- [ ] Reset credentials\n- [ ] Update security controls\n- [ ] Verify clean state\n```\n\n### Recovery\n```markdown\n- [ ] Restore from clean backups\n- [ ] Gradually restore services\n- [ ] Monitor for re-infection\n- [ ] Validate system integrity\n- [ ] Return to normal operations\n```\n\n### Lessons Learned\n```markdown\n## Post-Incident Report\n\n### Summary\n- Date/time: 2024-01-15 14:30 UTC\n- Duration: 4 hours\n- Severity: P2\n- Impact: 1,000 users affected\n\n### Timeline\n- 14:30 - Alert triggered\n- 14:45 - Incident confirmed\n- 15:00 - Containment started\n- 17:00 - Threat eradicated\n- 18:30 - Services restored\n\n### Root Cause\n- SQL injection in /api/search\n- Input validation missing\n\n### Actions Taken\n1. Blocked attacker IP\n2. Patched vulnerability\n3. Reset affected credentials\n\n### Improvements\n1. Add input validation framework\n2. Improve WAF rules\n3. Enhance monitoring\n```\n\n## 3. Communication Templates\n```\nInternal: \"Security incident detected. Impact: [X]. \nTeam assembling in #incident-response.\"\n\nExternal: \"We identified a security issue affecting [X].\nWe've taken immediate action to protect your data.\nNo action required from you at this time.\"\n```"}
{"prompt": "How do I implement Content Security Policy?", "response": "**Content Security Policy Implementation:**\n\n## 1. Basic CSP Header\n```python\n# Flask\n@app.after_request\ndef add_csp(response):\n    csp = {\n        'default-src': \"'self'\",\n        'script-src': \"'self'\",\n        'style-src': \"'self' 'unsafe-inline'\",\n        'img-src': \"'self' data: https:\",\n        'font-src': \"'self'\",\n        'connect-src': \"'self' https://api.example.com\",\n        'frame-ancestors': \"'none'\",\n        'base-uri': \"'self'\",\n        'form-action': \"'self'\"\n    }\n    policy = '; '.join(f\"{k} {v}\" for k, v in csp.items())\n    response.headers['Content-Security-Policy'] = policy\n    return response\n```\n\n## 2. Nonce-Based CSP\n```python\nimport secrets\nfrom flask import g\n\n@app.before_request\ndef generate_nonce():\n    g.csp_nonce = secrets.token_urlsafe(16)\n\n@app.after_request\ndef add_csp(response):\n    policy = f\"script-src 'self' 'nonce-{g.csp_nonce}'\"\n    response.headers['Content-Security-Policy'] = policy\n    return response\n\n# Template usage\n# <script nonce=\"{{ g.csp_nonce }}\">...</script>\n```\n\n## 3. Report-Only Mode (Testing)\n```python\n# Start with report-only to avoid breaking things\nresponse.headers['Content-Security-Policy-Report-Only'] = policy\nresponse.headers['Report-To'] = json.dumps({\n    'group': 'csp-reports',\n    'max_age': 86400,\n    'endpoints': [{'url': '/csp-report'}]\n})\n\n# Endpoint to collect reports\n@app.route('/csp-report', methods=['POST'])\ndef csp_report():\n    report = request.get_json()\n    logging.warning(f\"CSP Violation: {report}\")\n    return '', 204\n```\n\n## 4. Common CSP Directives\n```\ndefault-src    - Fallback for all resource types\nscript-src     - JavaScript sources\nstyle-src      - CSS sources\nimg-src        - Image sources\nfont-src       - Font sources\nconnect-src    - XHR, WebSocket, fetch sources\nmedia-src      - Audio/video sources\nobject-src     - Plugin sources (Flash, etc.)\nframe-src      - iframe sources\nframe-ancestors - Who can embed this page\nbase-uri       - Restrict <base> element\nform-action    - Form submission targets\nupgrade-insecure-requests - Upgrade HTTP to HTTPS\n```\n\n## 5. Progressive Implementation\n```python\n# Phase 1: Report only, permissive\ncsp = \"default-src * 'unsafe-inline' 'unsafe-eval'; report-uri /csp\"\n\n# Phase 2: Tighten, still report only\ncsp = \"default-src 'self'; script-src 'self' 'unsafe-inline'; report-uri /csp\"\n\n# Phase 3: Remove unsafe-inline, use nonces\ncsp = f\"default-src 'self'; script-src 'self' 'nonce-{nonce}'\"\n\n# Phase 4: Enforce\n# Change from Report-Only to Content-Security-Policy\n```\n\n## 6. Testing CSP\n```bash\n# Online tools\n# - https://csp-evaluator.withgoogle.com/\n# - https://securityheaders.com/\n\n# Browser console shows violations\n# DevTools > Console > Filter by CSP\n```"}
{"prompt": "How do I perform security compliance assessments?", "response": "**Security Compliance Frameworks:**\n\n## 1. Common Frameworks\n\n| Framework | Focus | Industries |\n|-----------|-------|------------|\n| SOC 2 | Trust services | SaaS, Tech |\n| ISO 27001 | ISMS | Global |\n| PCI DSS | Payment data | E-commerce |\n| HIPAA | Health data | Healthcare |\n| GDPR | Privacy | EU data |\n| FedRAMP | Government | US Gov vendors |\n\n## 2. SOC 2 Controls Checklist\n\n### Security\n```markdown\n[ ] Access control policies documented\n[ ] Multi-factor authentication enabled\n[ ] Encryption at rest and in transit\n[ ] Vulnerability management program\n[ ] Security awareness training\n[ ] Incident response procedures\n[ ] Penetration testing conducted\n```\n\n### Availability\n```markdown\n[ ] Uptime SLA defined\n[ ] Disaster recovery plan\n[ ] Backup procedures tested\n[ ] Capacity monitoring\n[ ] Redundancy implemented\n```\n\n### Confidentiality\n```markdown\n[ ] Data classification policy\n[ ] Access based on need-to-know\n[ ] Data retention policies\n[ ] Secure data disposal\n```\n\n## 3. Policy Templates\n\n### Access Control Policy\n```markdown\n## Purpose\nDefine access control requirements for systems and data.\n\n## Scope\nAll employees, contractors, and systems.\n\n## Policy\n1. Access granted on least-privilege basis\n2. Access reviews conducted quarterly\n3. Terminated access within 24 hours of departure\n4. MFA required for all production access\n5. Shared accounts prohibited\n\n## Exceptions\nRequire CISO approval and documentation.\n\n## Enforcement\nViolations subject to disciplinary action.\n```\n\n## 4. Evidence Collection\n```python\n# Automated evidence collection\nclass ComplianceEvidence:\n    def collect_access_reviews(self):\n        # Pull access logs from IAM\n        users = iam.list_users()\n        return {\n            'date': datetime.now(),\n            'total_users': len(users),\n            'privileged_users': self.count_privileged(users),\n            'last_review': self.get_last_review_date()\n        }\n    \n    def collect_vulnerability_scans(self):\n        # Get scan results\n        return {\n            'last_scan': self.get_last_scan(),\n            'critical_vulns': self.count_by_severity('critical'),\n            'remediation_sla': '7 days'\n        }\n```\n\n## 5. Audit Preparation\n```markdown\n## 30 Days Before\n- [ ] Confirm audit scope\n- [ ] Assign control owners\n- [ ] Begin evidence collection\n- [ ] Schedule interviews\n\n## 2 Weeks Before\n- [ ] Complete evidence gathering\n- [ ] Review for gaps\n- [ ] Prepare personnel\n- [ ] Test walkthroughs\n\n## During Audit\n- [ ] Daily standups with auditors\n- [ ] Respond to requests within 24h\n- [ ] Document clarifications\n- [ ] Track findings\n```"}
{"prompt": "How do I implement secure file uploads?", "response": "**Secure File Upload Implementation:**\n\n## 1. Validation Checks\n```python\nimport os\nimport magic\nimport hashlib\nfrom werkzeug.utils import secure_filename\n\nALLOWED_EXTENSIONS = {'pdf', 'png', 'jpg', 'jpeg', 'gif'}\nMAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\nALLOWED_MIME_TYPES = {\n    'application/pdf',\n    'image/png',\n    'image/jpeg',\n    'image/gif'\n}\n\ndef validate_file(file):\n    errors = []\n    \n    # Check filename\n    filename = secure_filename(file.filename)\n    if not filename:\n        errors.append('Invalid filename')\n        return errors, None\n    \n    # Check extension\n    ext = filename.rsplit('.', 1)[-1].lower()\n    if ext not in ALLOWED_EXTENSIONS:\n        errors.append(f'Extension not allowed: {ext}')\n    \n    # Check file size\n    file.seek(0, 2)  # Seek to end\n    size = file.tell()\n    file.seek(0)     # Reset\n    if size > MAX_FILE_SIZE:\n        errors.append(f'File too large: {size} bytes')\n    \n    # Check MIME type (magic bytes)\n    mime = magic.from_buffer(file.read(2048), mime=True)\n    file.seek(0)\n    if mime not in ALLOWED_MIME_TYPES:\n        errors.append(f'MIME type not allowed: {mime}')\n    \n    return errors, filename\n```\n\n## 2. Secure Storage\n```python\nimport uuid\nimport boto3\n\ndef store_file_securely(file, filename):\n    # Generate unique name (prevent enumeration)\n    unique_id = str(uuid.uuid4())\n    ext = filename.rsplit('.', 1)[-1].lower()\n    stored_name = f\"{unique_id}.{ext}\"\n    \n    # Calculate hash for integrity\n    file_hash = hashlib.sha256(file.read()).hexdigest()\n    file.seek(0)\n    \n    # Store outside web root (S3 preferred)\n    s3 = boto3.client('s3')\n    s3.upload_fileobj(\n        file,\n        'secure-uploads-bucket',\n        f\"uploads/{stored_name}\",\n        ExtraArgs={\n            'ContentType': file.content_type,\n            'ServerSideEncryption': 'AES256',\n            'ContentDisposition': 'attachment'  # Force download\n        }\n    )\n    \n    # Store metadata in database\n    upload = Upload(\n        id=unique_id,\n        original_name=filename,\n        stored_name=stored_name,\n        file_hash=file_hash,\n        user_id=current_user.id\n    )\n    db.session.add(upload)\n    db.session.commit()\n    \n    return unique_id\n```\n\n## 3. Secure Download\n```python\n@app.route('/download/<file_id>')\n@require_auth\ndef download_file(file_id):\n    upload = Upload.query.get_or_404(file_id)\n    \n    # Authorization check\n    if upload.user_id != current_user.id:\n        abort(403)\n    \n    # Generate signed URL (expires in 5 minutes)\n    s3 = boto3.client('s3')\n    url = s3.generate_presigned_url(\n        'get_object',\n        Params={\n            'Bucket': 'secure-uploads-bucket',\n            'Key': f\"uploads/{upload.stored_name}\",\n            'ResponseContentDisposition': f'attachment; filename=\"{upload.original_name}\"'\n        },\n        ExpiresIn=300\n    )\n    \n    return redirect(url)\n```\n\n## 4. Malware Scanning\n```python\nimport clamd\n\ndef scan_for_malware(file_path):\n    cd = clamd.ClamdUnixSocket()\n    result = cd.scan(file_path)\n    \n    if result[file_path][0] == 'FOUND':\n        virus_name = result[file_path][1]\n        raise SecurityError(f'Malware detected: {virus_name}')\n    \n    return True\n```\n\n## 5. Content-Type Handling\n```python\n# When serving files, set proper headers\n@app.route('/serve/<file_id>')\ndef serve_file(file_id):\n    response = make_response(file_content)\n    response.headers['Content-Type'] = 'application/octet-stream'\n    response.headers['Content-Disposition'] = f'attachment; filename=\"{safe_name}\"'\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    return response\n```"}
{"prompt": "How do I protect against SSRF attacks?", "response": "**SSRF Prevention Strategies:**\n\n## 1. Understanding SSRF\n```\nAttacker-controlled URL → Server makes request → Access internal resources\n\nExamples:\n- http://169.254.169.254/metadata (AWS metadata)\n- http://localhost:8080/admin\n- http://internal-service.local\n- file:///etc/passwd\n```\n\n## 2. Input Validation\n```python\nimport ipaddress\nimport urllib.parse\n\nALLOWED_SCHEMES = {'http', 'https'}\nBLOCKED_HOSTS = {'localhost', '127.0.0.1', '0.0.0.0'}\nBLOCKED_NETWORKS = [\n    ipaddress.ip_network('10.0.0.0/8'),\n    ipaddress.ip_network('172.16.0.0/12'),\n    ipaddress.ip_network('192.168.0.0/16'),\n    ipaddress.ip_network('169.254.0.0/16'),  # Link-local\n    ipaddress.ip_network('127.0.0.0/8'),     # Loopback\n]\n\ndef validate_url(url):\n    parsed = urllib.parse.urlparse(url)\n    \n    # Check scheme\n    if parsed.scheme not in ALLOWED_SCHEMES:\n        raise ValueError(f\"Scheme not allowed: {parsed.scheme}\")\n    \n    # Check for blocked hostnames\n    hostname = parsed.hostname.lower()\n    if hostname in BLOCKED_HOSTS:\n        raise ValueError(f\"Host not allowed: {hostname}\")\n    \n    # Resolve DNS and check IP\n    try:\n        ip = ipaddress.ip_address(socket.gethostbyname(hostname))\n    except socket.gaierror:\n        raise ValueError(\"Could not resolve hostname\")\n    \n    # Check against blocked networks\n    for network in BLOCKED_NETWORKS:\n        if ip in network:\n            raise ValueError(f\"IP in blocked range: {ip}\")\n    \n    return True\n```\n\n## 3. Allowlist Approach\n```python\nALLOWED_DOMAINS = {\n    'api.example.com',\n    'cdn.example.com',\n    'images.example.com'\n}\n\ndef validate_url_allowlist(url):\n    parsed = urllib.parse.urlparse(url)\n    hostname = parsed.hostname.lower()\n    \n    if hostname not in ALLOWED_DOMAINS:\n        raise ValueError(f\"Domain not in allowlist: {hostname}\")\n    \n    return True\n```\n\n## 4. Network Segmentation\n```yaml\n# Kubernetes NetworkPolicy\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-internal-egress\nspec:\n  podSelector:\n    matchLabels:\n      app: url-fetcher\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 0.0.0.0/0\n        except:\n        - 10.0.0.0/8\n        - 172.16.0.0/12\n        - 192.168.0.0/16\n        - 169.254.169.254/32\n```\n\n## 5. AWS IMDSv2\n```bash\n# Require IMDSv2 (token-based)\naws ec2 modify-instance-metadata-options \\\n    --instance-id i-1234567890abcdef0 \\\n    --http-tokens required \\\n    --http-endpoint enabled\n```\n\n## 6. Secure URL Fetching\n```python\nimport requests\n\ndef safe_fetch(url, timeout=5):\n    validate_url(url)\n    \n    # Follow redirects carefully\n    response = requests.get(\n        url,\n        timeout=timeout,\n        allow_redirects=False  # Handle manually\n    )\n    \n    # Validate redirect targets\n    if response.is_redirect:\n        redirect_url = response.headers.get('Location')\n        validate_url(redirect_url)\n        return safe_fetch(redirect_url, timeout)\n    \n    return response\n```"}
{"prompt": "How do I implement security in microservices?", "response": "**Microservices Security Architecture:**\n\n## 1. Service-to-Service Authentication\n```python\n# mTLS with certificates\nimport ssl\n\nssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\nssl_context.load_cert_chain(\n    certfile='/certs/service.crt',\n    keyfile='/certs/service.key'\n)\nssl_context.load_verify_locations('/certs/ca.crt')\nssl_context.verify_mode = ssl.CERT_REQUIRED\n\n# Service mesh (Istio) handles this automatically\n```\n\n## 2. JWT Token Propagation\n```python\n# API Gateway validates external JWT\n# Internal services use service tokens\n\nclass ServiceClient:\n    def __init__(self, service_name):\n        self.service_name = service_name\n        self.token = self._get_service_token()\n    \n    def _get_service_token(self):\n        # Get token from identity provider\n        response = requests.post(\n            'http://auth-service/internal/token',\n            json={\n                'service': self.service_name,\n                'secret': os.environ['SERVICE_SECRET']\n            }\n        )\n        return response.json()['token']\n    \n    def call(self, endpoint, data):\n        return requests.post(\n            f'http://{self.service_name}/{endpoint}',\n            headers={\n                'Authorization': f'Bearer {self.token}',\n                'X-Request-ID': get_request_id(),\n                'X-Caller-Service': 'my-service'\n            },\n            json=data\n        )\n```\n\n## 3. API Gateway Security\n```yaml\n# Kong/AWS API Gateway configuration\nservices:\n  - name: user-service\n    url: http://user-service:8080\n    plugins:\n      - name: jwt\n        config:\n          secret_is_base64: true\n          claims_to_verify:\n            - exp\n      - name: rate-limiting\n        config:\n          minute: 100\n      - name: ip-restriction\n        config:\n          allow:\n            - 10.0.0.0/8\n```\n\n## 4. Secrets Management\n```yaml\n# Kubernetes secrets injection\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: app\n    env:\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-secrets\n          key: password\n    volumeMounts:\n    - name: vault-secrets\n      mountPath: /secrets\n      readOnly: true\n  volumes:\n  - name: vault-secrets\n    csi:\n      driver: secrets-store.csi.k8s.io\n      readOnly: true\n      volumeAttributes:\n        secretProviderClass: vault-db-creds\n```\n\n## 5. Network Policies\n```yaml\n# Only allow specific service communication\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: payment-service-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: payment-service\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: order-service\n    ports:\n    - port: 8080\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database\n```\n\n## 6. Distributed Tracing for Security\n```python\nfrom opentelemetry import trace\n\ntracer = trace.get_tracer(__name__)\n\n@app.route('/api/payment')\ndef process_payment():\n    with tracer.start_as_current_span('payment') as span:\n        span.set_attribute('user.id', current_user.id)\n        span.set_attribute('payment.amount', amount)\n        # If breach detected, trace full request path\n```"}
{"prompt": "How do I secure container images?", "response": "**Container Security Best Practices:**\n\n## 1. Secure Base Images\n```dockerfile\n# Use minimal base images\nFROM alpine:3.18\n# or\nFROM gcr.io/distroless/static-debian11\n\n# Pin versions\nFROM node:20.10.0-alpine3.18\n\n# Avoid latest tag\n# BAD: FROM node:latest\n```\n\n## 2. Non-Root User\n```dockerfile\n# Create non-root user\nRUN addgroup -g 1001 -S appgroup && \\\n    adduser -u 1001 -S appuser -G appgroup\n\n# Set ownership\nCOPY --chown=appuser:appgroup . /app\n\n# Switch to non-root\nUSER appuser\n\n# Verify\nRUN whoami  # Should print 'appuser'\n```\n\n## 3. Minimize Attack Surface\n```dockerfile\n# Multi-stage build\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\n# Production image - minimal\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nUSER node\nCMD [\"node\", \"dist/index.js\"]\n```\n\n## 4. Vulnerability Scanning\n```bash\n# Trivy scan\ntrivy image --severity HIGH,CRITICAL myapp:latest\n\n# Grype scan\ngrype myapp:latest\n\n# Docker Scout\ndocker scout cves myapp:latest\n\n# CI/CD integration\n- name: Scan image\n  uses: aquasecurity/trivy-action@master\n  with:\n    image-ref: myapp:${{ github.sha }}\n    exit-code: 1\n    severity: CRITICAL,HIGH\n```\n\n## 5. Image Signing\n```bash\n# Cosign - sign images\ncosign sign --key cosign.key myregistry/myapp:v1.0.0\n\n# Verify signature\ncosign verify --key cosign.pub myregistry/myapp:v1.0.0\n\n# Kubernetes admission control\napiVersion: policy/v1beta1\nkind: ClusterPolicy\nmetadata:\n  name: verify-images\nspec:\n  validationFailureAction: Enforce\n  rules:\n  - name: verify-signature\n    match:\n      resources:\n        kinds: [Pod]\n    verifyImages:\n    - image: \"myregistry/*\"\n      key: |-\n        -----BEGIN PUBLIC KEY-----\n        ...\n        -----END PUBLIC KEY-----\n```\n\n## 6. Runtime Security\n```yaml\n# Kubernetes security context\napiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1001\n    fsGroup: 1001\n  containers:\n  - name: app\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop: [ALL]\n    resources:\n      limits:\n        memory: \"256Mi\"\n        cpu: \"500m\"\n```\n\n## 7. Registry Security\n```bash\n# Private registry with authentication\ndocker login myregistry.com\n\n# Enable content trust\nexport DOCKER_CONTENT_TRUST=1\n\n# Scan on push (Harbor, ECR)\naws ecr put-image-scanning-configuration \\\n    --repository-name myapp \\\n    --image-scanning-configuration scanOnPush=true\n```"}
{"prompt": "How do I implement zero trust security?", "response": "**Zero Trust Architecture:**\n\n## 1. Core Principles\n```\n1. Never trust, always verify\n2. Assume breach\n3. Verify explicitly\n4. Least privilege access\n5. Microsegmentation\n```\n\n## 2. Identity Verification\n```python\nclass ZeroTrustAuthenticator:\n    def verify_request(self, request):\n        # 1. Verify identity\n        user = self.verify_user_identity(request)\n        \n        # 2. Verify device\n        device = self.verify_device_health(request)\n        \n        # 3. Check context\n        context = self.evaluate_context(request, user, device)\n        \n        # 4. Apply policy\n        decision = self.policy_engine.evaluate(\n            user=user,\n            device=device,\n            resource=request.resource,\n            action=request.action,\n            context=context\n        )\n        \n        if not decision.allowed:\n            raise AccessDenied(decision.reason)\n        \n        # 5. Continuous monitoring\n        self.log_access(user, device, request, decision)\n        \n        return decision\n    \n    def verify_device_health(self, request):\n        device_id = request.headers.get('X-Device-ID')\n        return {\n            'compliant': self.mdm.is_compliant(device_id),\n            'encrypted': self.mdm.is_encrypted(device_id),\n            'patched': self.mdm.is_patched(device_id),\n            'trusted': self.device_registry.is_known(device_id)\n        }\n```\n\n## 3. Network Microsegmentation\n```yaml\n# Kubernetes NetworkPolicy\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: zero-trust-default\nspec:\n  podSelector: {}  # Apply to all pods\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []      # Deny all by default\n  egress: []       # Deny all by default\n---\n# Explicit allow for specific communication\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-to-api\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - port: 8080\n```\n\n## 4. Just-In-Time Access\n```python\nclass JITAccessManager:\n    def request_access(self, user, resource, duration, justification):\n        # Create access request\n        request = AccessRequest(\n            user=user,\n            resource=resource,\n            duration=min(duration, MAX_DURATION),\n            justification=justification,\n            expires_at=datetime.utcnow() + timedelta(hours=duration)\n        )\n        \n        # Require approval for sensitive resources\n        if resource.sensitivity == 'high':\n            request.requires_approval = True\n            self.notify_approvers(request)\n        else:\n            self.grant_access(request)\n        \n        return request\n    \n    def grant_access(self, request):\n        # Create temporary credentials\n        credentials = self.create_temp_credentials(\n            user=request.user,\n            resource=request.resource,\n            expires_at=request.expires_at\n        )\n        \n        # Schedule revocation\n        self.schedule_revocation(request)\n        \n        # Audit log\n        self.audit_log.log('ACCESS_GRANTED', request)\n        \n        return credentials\n```\n\n## 5. Continuous Verification\n```python\n# Re-verify during session\nclass SessionMonitor:\n    def check_session(self, session):\n        # Check if context changed\n        current_context = self.get_current_context(session)\n        \n        if self.context_changed_significantly(session.original_context, current_context):\n            # Step-up authentication\n            return RequireReauth()\n        \n        if self.anomaly_detected(session):\n            # Suspicious activity\n            return TerminateSession()\n        \n        return Continue()\n```"}
