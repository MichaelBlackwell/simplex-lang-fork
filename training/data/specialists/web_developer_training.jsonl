{"prompt": "How do I center a div both horizontally and vertically using CSS?", "response": "Use flexbox on the parent container:\n\n```css\n.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n```\n\nOr use CSS Grid:\n\n```css\n.parent {\n  display: grid;\n  place-items: center;\n  height: 100vh;\n}\n```\n\nFor older browser support, use absolute positioning:\n\n```css\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```"}
{"prompt": "What's the difference between localStorage and sessionStorage?", "response": "Both are Web Storage APIs but differ in persistence:\n\n**localStorage:**\n- Data persists until explicitly cleared\n- Available across browser sessions and tabs\n- 5-10MB storage limit per origin\n- Use for: user preferences, themes, cached data\n\n**sessionStorage:**\n- Data cleared when tab/window closes\n- Isolated per tab (not shared between tabs)\n- 5-10MB storage limit per origin\n- Use for: temporary form data, single-session state\n\n```javascript\n// localStorage\nlocalStorage.setItem('user', JSON.stringify({name: 'John'}));\nconst user = JSON.parse(localStorage.getItem('user'));\n\n// sessionStorage\nsessionStorage.setItem('tempData', 'value');\n```\n\nBoth are synchronous and block the main thread, so avoid storing large amounts of data."}
{"prompt": "How do I prevent XSS attacks in my web application?", "response": "Key XSS prevention strategies:\n\n1. **Escape output** - Always encode user data before rendering:\n```javascript\nfunction escapeHtml(str) {\n  return str.replace(/[&<>\"']/g, char => ({\n    '&': '&amp;', '<': '&lt;', '>': '&gt;',\n    '\"': '&quot;', \"'\": '&#39;'\n  }[char]));\n}\n```\n\n2. **Use Content Security Policy (CSP)**:\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n```\n\n3. **Use textContent instead of innerHTML**:\n```javascript\nelement.textContent = userInput; // Safe\nelement.innerHTML = userInput;   // Dangerous\n```\n\n4. **Sanitize HTML with libraries** like DOMPurify:\n```javascript\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);\n```\n\n5. **Use HttpOnly cookies** for sensitive tokens\n6. **Validate input** on both client and server"}
{"prompt": "Explain the React useEffect hook and when to use it", "response": "useEffect handles side effects in functional components:\n\n```javascript\nuseEffect(() => {\n  // Effect runs after render\n  return () => {\n    // Cleanup runs before next effect or unmount\n  };\n}, [dependencies]);\n```\n\n**Dependency array patterns:**\n\n```javascript\n// Runs on every render\nuseEffect(() => { /* ... */ });\n\n// Runs once on mount\nuseEffect(() => { /* ... */ }, []);\n\n// Runs when dependencies change\nuseEffect(() => { /* ... */ }, [userId, count]);\n```\n\n**Common use cases:**\n- Data fetching\n- Subscriptions/event listeners\n- DOM manipulation\n- Timers/intervals\n\n**Example:**\n```javascript\nuseEffect(() => {\n  const controller = new AbortController();\n  fetch(`/api/user/${userId}`, { signal: controller.signal })\n    .then(res => res.json())\n    .then(setUser);\n  return () => controller.abort();\n}, [userId]);\n```\n\nAlways clean up subscriptions to prevent memory leaks."}
{"prompt": "How do I implement lazy loading for images?", "response": "Modern approaches for lazy loading images:\n\n**1. Native lazy loading (recommended):**\n```html\n<img src=\"image.jpg\" loading=\"lazy\" alt=\"Description\">\n```\n\n**2. Intersection Observer API:**\n```javascript\nconst observer = new IntersectionObserver((entries) => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      const img = entry.target;\n      img.src = img.dataset.src;\n      observer.unobserve(img);\n    }\n  });\n}, { rootMargin: '100px' });\n\ndocument.querySelectorAll('img[data-src]').forEach(img => {\n  observer.observe(img);\n});\n```\n\n**3. React component:**\n```jsx\nfunction LazyImage({ src, alt }) {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const ref = useRef();\n  \n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) setIsLoaded(true);\n    });\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, []);\n  \n  return <img ref={ref} src={isLoaded ? src : ''} alt={alt} />;\n}\n```\n\nUse placeholder images or skeleton loaders for better UX."}
{"prompt": "What's the best way to handle API errors in a React application?", "response": "Comprehensive error handling strategy:\n\n**1. Create an error boundary:**\n```jsx\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false, error: null };\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <ErrorFallback error={this.state.error} />;\n    }\n    return this.props.children;\n  }\n}\n```\n\n**2. API wrapper with error handling:**\n```javascript\nasync function apiRequest(url, options = {}) {\n  try {\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      throw new ApiError(response.status, await response.text());\n    }\n    return response.json();\n  } catch (error) {\n    if (error.name === 'AbortError') throw error;\n    console.error('API Error:', error);\n    throw error;\n  }\n}\n```\n\n**3. Custom hook for data fetching:**\n```javascript\nfunction useApi(url) {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    apiRequest(url)\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false));\n  }, [url]);\n  \n  return { data, error, loading };\n}\n```\n\nConsider using React Query or SWR for production apps."}
{"prompt": "How do I optimize webpack bundle size?", "response": "Key webpack optimization strategies:\n\n**1. Code splitting:**\n```javascript\n// Dynamic imports\nconst Component = React.lazy(() => import('./Component'));\n\n// webpack.config.js\noptimization: {\n  splitChunks: {\n    chunks: 'all',\n    cacheGroups: {\n      vendor: {\n        test: /[\\\\/]node_modules[\\\\/]/,\n        name: 'vendors',\n        chunks: 'all'\n      }\n    }\n  }\n}\n```\n\n**2. Tree shaking:**\n```javascript\n// Use ES modules for tree shaking\nimport { debounce } from 'lodash-es'; // Good\nimport _ from 'lodash'; // Bad - imports everything\n```\n\n**3. Analyze bundle:**\n```bash\nnpx webpack-bundle-analyzer stats.json\n```\n\n**4. Externalize large dependencies:**\n```javascript\nexternals: {\n  react: 'React',\n  'react-dom': 'ReactDOM'\n}\n```\n\n**5. Compression:**\n```javascript\nconst CompressionPlugin = require('compression-webpack-plugin');\nplugins: [new CompressionPlugin({ algorithm: 'gzip' })]\n```\n\n**6. Production mode:**\n```javascript\nmode: 'production' // Enables minification, dead code elimination\n```\n\nTarget: < 200KB for initial bundle, lazy load the rest."}
{"prompt": "Explain CORS and how to handle it", "response": "**CORS (Cross-Origin Resource Sharing)** is a security mechanism that restricts cross-origin HTTP requests.\n\n**How it works:**\n1. Browser sends preflight OPTIONS request for non-simple requests\n2. Server responds with allowed origins, methods, headers\n3. Browser either allows or blocks the actual request\n\n**Server-side configuration (Express):**\n```javascript\nconst cors = require('cors');\n\n// Allow all origins (development only)\napp.use(cors());\n\n// Production configuration\napp.use(cors({\n  origin: ['https://myapp.com', 'https://admin.myapp.com'],\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  credentials: true,\n  maxAge: 86400 // Cache preflight for 24 hours\n}));\n```\n\n**Headers involved:**\n- `Access-Control-Allow-Origin`\n- `Access-Control-Allow-Methods`\n- `Access-Control-Allow-Headers`\n- `Access-Control-Allow-Credentials`\n\n**Development workarounds:**\n```javascript\n// Proxy in package.json (CRA)\n\"proxy\": \"http://localhost:3001\"\n\n// Vite proxy\nserver: {\n  proxy: { '/api': 'http://localhost:3001' }\n}\n```\n\nNever use `Access-Control-Allow-Origin: *` with credentials in production."}
{"prompt": "What are Web Vitals and how do I improve them?", "response": "**Core Web Vitals** are Google's metrics for user experience:\n\n**1. LCP (Largest Contentful Paint) - Target: < 2.5s**\n- Optimize images: use WebP, proper sizing, lazy loading\n- Preload critical resources: `<link rel=\"preload\">`\n- Use CDN for static assets\n- Reduce server response time\n\n**2. FID (First Input Delay) - Target: < 100ms**\n- Break up long JavaScript tasks\n- Use web workers for heavy computation\n- Defer non-critical JavaScript\n- Minimize main thread work\n\n**3. CLS (Cumulative Layout Shift) - Target: < 0.1**\n- Set explicit dimensions on images/videos\n- Reserve space for dynamic content\n- Avoid inserting content above existing content\n- Use transform animations instead of layout-triggering properties\n\n**Measurement:**\n```javascript\nimport { getCLS, getFID, getLCP } from 'web-vitals';\n\ngetCLS(console.log);\ngetFID(console.log);\ngetLCP(console.log);\n```\n\n**Tools:**\n- Chrome DevTools Performance tab\n- Lighthouse\n- PageSpeed Insights\n- Chrome UX Report\n\nMonitor real user metrics (RUM) in production."}
{"prompt": "How do I implement authentication with JWT in a SPA?", "response": "JWT authentication flow for Single Page Applications:\n\n**1. Login flow:**\n```javascript\nasync function login(email, password) {\n  const response = await fetch('/api/auth/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ email, password })\n  });\n  const { accessToken, refreshToken } = await response.json();\n  \n  // Store tokens (see security notes below)\n  localStorage.setItem('accessToken', accessToken);\n}\n```\n\n**2. Attach token to requests:**\n```javascript\nconst api = axios.create({ baseURL: '/api' });\n\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('accessToken');\n  if (token) config.headers.Authorization = `Bearer ${token}`;\n  return config;\n});\n```\n\n**3. Handle token refresh:**\n```javascript\napi.interceptors.response.use(\n  response => response,\n  async error => {\n    if (error.response?.status === 401) {\n      const newToken = await refreshAccessToken();\n      error.config.headers.Authorization = `Bearer ${newToken}`;\n      return api.request(error.config);\n    }\n    return Promise.reject(error);\n  }\n);\n```\n\n**Security best practices:**\n- Store refresh token in HttpOnly cookie\n- Keep access token short-lived (15 min)\n- Use HTTPS only\n- Implement token rotation\n- Clear tokens on logout\n\nConsider using established libraries like Auth0 or NextAuth."}
{"prompt": "What's the difference between CSS Grid and Flexbox? When should I use each?", "response": "**Flexbox** - One-dimensional layout (row OR column)\n**CSS Grid** - Two-dimensional layout (rows AND columns)\n\n**Use Flexbox for:**\n- Navigation bars\n- Card layouts with equal heights\n- Centering content\n- Distributing space between items\n- Components that flow in one direction\n\n```css\n.navbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n```\n\n**Use Grid for:**\n- Page layouts\n- Complex magazine-style layouts\n- Forms with aligned labels/inputs\n- Image galleries\n- Layouts requiring both row and column control\n\n```css\n.page-layout {\n  display: grid;\n  grid-template-columns: 200px 1fr 300px;\n  grid-template-rows: auto 1fr auto;\n  gap: 20px;\n}\n```\n\n**Combine them:**\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n.grid-item {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n```\n\n**Rule of thumb:** Use Flexbox for components, Grid for page-level layouts. When in doubt, start with Flexbox and switch to Grid if you need 2D control."}
{"prompt": "How do I set up a Node.js project with TypeScript?", "response": "Complete TypeScript + Node.js setup:\n\n**1. Initialize project:**\n```bash\nmkdir my-project && cd my-project\nnpm init -y\nnpm install typescript ts-node @types/node -D\nnpx tsc --init\n```\n\n**2. Configure tsconfig.json:**\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n**3. Add scripts to package.json:**\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"ts-node src/index.ts\",\n    \"watch\": \"tsc -w\"\n  }\n}\n```\n\n**4. Create src/index.ts:**\n```typescript\nconst greeting: string = 'Hello, TypeScript!';\nconsole.log(greeting);\n```\n\n**5. For faster dev experience, use tsx:**\n```bash\nnpm install tsx -D\n# Then use: npx tsx watch src/index.ts\n```\n\nAdd ESLint with `@typescript-eslint` for linting."}
{"prompt": "How do I implement infinite scroll in React?", "response": "Two approaches for infinite scroll:\n\n**1. Intersection Observer (Recommended):**\n```jsx\nfunction InfiniteList() {\n  const [items, setItems] = useState([]);\n  const [page, setPage] = useState(1);\n  const [loading, setLoading] = useState(false);\n  const loaderRef = useRef(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      entries => {\n        if (entries[0].isIntersecting && !loading) {\n          setPage(prev => prev + 1);\n        }\n      },\n      { threshold: 1.0 }\n    );\n\n    if (loaderRef.current) observer.observe(loaderRef.current);\n    return () => observer.disconnect();\n  }, [loading]);\n\n  useEffect(() => {\n    setLoading(true);\n    fetchItems(page)\n      .then(newItems => setItems(prev => [...prev, ...newItems]))\n      .finally(() => setLoading(false));\n  }, [page]);\n\n  return (\n    <div>\n      {items.map(item => <Item key={item.id} {...item} />)}\n      <div ref={loaderRef}>\n        {loading && <Spinner />}\n      </div>\n    </div>\n  );\n}\n```\n\n**2. Using react-window for virtualization:**\n```jsx\nimport { FixedSizeList } from 'react-window';\nimport InfiniteLoader from 'react-window-infinite-loader';\n\nfunction VirtualizedInfiniteList({ hasMore, loadMore, items }) {\n  return (\n    <InfiniteLoader\n      isItemLoaded={index => index < items.length}\n      itemCount={hasMore ? items.length + 1 : items.length}\n      loadMoreItems={loadMore}\n    >\n      {({ onItemsRendered, ref }) => (\n        <FixedSizeList\n          ref={ref}\n          height={600}\n          itemCount={items.length}\n          itemSize={50}\n          onItemsRendered={onItemsRendered}\n        >\n          {({ index, style }) => (\n            <div style={style}>{items[index].name}</div>\n          )}\n        </FixedSizeList>\n      )}\n    </InfiniteLoader>\n  );\n}\n```\n\nUse virtualization for lists > 1000 items to prevent performance issues."}
{"prompt": "What's the difference between async/await and Promises?", "response": "**Promises** are the underlying mechanism; **async/await** is syntactic sugar.\n\n**Promise syntax:**\n```javascript\nfunction fetchUser(id) {\n  return fetch(`/api/users/${id}`)\n    .then(response => response.json())\n    .then(user => {\n      console.log(user);\n      return user;\n    })\n    .catch(error => {\n      console.error('Failed:', error);\n      throw error;\n    });\n}\n```\n\n**async/await syntax:**\n```javascript\nasync function fetchUser(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    console.log(user);\n    return user;\n  } catch (error) {\n    console.error('Failed:', error);\n    throw error;\n  }\n}\n```\n\n**Key differences:**\n\n| Aspect | Promises | async/await |\n|--------|----------|-------------|\n| Readability | Chained callbacks | Sequential, sync-like |\n| Error handling | .catch() | try/catch |\n| Debugging | Harder to trace | Better stack traces |\n| Parallel execution | Promise.all() directly | Same with await |\n\n**Parallel execution:**\n```javascript\n// Sequential (slow)\nconst user = await fetchUser(1);\nconst posts = await fetchPosts(1);\n\n// Parallel (fast)\nconst [user, posts] = await Promise.all([\n  fetchUser(1),\n  fetchPosts(1)\n]);\n```\n\nasync/await is generally preferred for readability, but understand Promises for complex flows."}
{"prompt": "How do I implement dark mode in a web application?", "response": "Complete dark mode implementation:\n\n**1. CSS Custom Properties:**\n```css\n:root {\n  --bg-primary: #ffffff;\n  --text-primary: #1a1a1a;\n  --border-color: #e0e0e0;\n}\n\n[data-theme=\"dark\"] {\n  --bg-primary: #1a1a1a;\n  --text-primary: #ffffff;\n  --border-color: #333333;\n}\n\nbody {\n  background-color: var(--bg-primary);\n  color: var(--text-primary);\n  transition: background-color 0.3s, color 0.3s;\n}\n```\n\n**2. React context for theme:**\n```jsx\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState(() => {\n    const saved = localStorage.getItem('theme');\n    if (saved) return saved;\n    return window.matchMedia('(prefers-color-scheme: dark)').matches \n      ? 'dark' : 'light';\n  });\n\n  useEffect(() => {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n\n  const toggle = () => setTheme(t => t === 'dark' ? 'light' : 'dark');\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggle }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n**3. Respect system preference:**\n```javascript\nuseEffect(() => {\n  const media = window.matchMedia('(prefers-color-scheme: dark)');\n  const handler = e => setTheme(e.matches ? 'dark' : 'light');\n  media.addEventListener('change', handler);\n  return () => media.removeEventListener('change', handler);\n}, []);\n```\n\n**4. Prevent flash on load:**\n```html\n<script>\n  const theme = localStorage.getItem('theme') || \n    (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');\n  document.documentElement.setAttribute('data-theme', theme);\n</script>\n```"}
{"prompt": "How do I handle form validation in React?", "response": "Three approaches for React form validation:\n\n**1. Native HTML validation:**\n```jsx\nfunction Form() {\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const formData = new FormData(e.target);\n    // Process formData\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"email\" type=\"email\" required />\n      <input name=\"password\" minLength={8} required />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**2. React Hook Form (Recommended):**\n```jsx\nimport { useForm } from 'react-hook-form';\n\nfunction Form() {\n  const { register, handleSubmit, formState: { errors } } = useForm();\n\n  const onSubmit = data => console.log(data);\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('email', {\n        required: 'Email is required',\n        pattern: {\n          value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i,\n          message: 'Invalid email'\n        }\n      })} />\n      {errors.email && <span>{errors.email.message}</span>}\n\n      <input type=\"password\" {...register('password', {\n        required: 'Password is required',\n        minLength: { value: 8, message: 'Min 8 characters' }\n      })} />\n      {errors.password && <span>{errors.password.message}</span>}\n\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**3. With Zod schema validation:**\n```jsx\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8)\n});\n\nconst { register, handleSubmit } = useForm({\n  resolver: zodResolver(schema)\n});\n```\n\nReact Hook Form provides the best DX with minimal re-renders."}
{"prompt": "Explain the Next.js App Router and when to use Server vs Client Components", "response": "**Next.js App Router** (v13+) uses React Server Components by default.\n\n**Server Components (default):**\n- Render on server, zero JS sent to client\n- Can access backend resources directly\n- No hooks like useState, useEffect\n- Better SEO and initial load performance\n\n```jsx\n// app/page.tsx - Server Component\nasync function Page() {\n  const data = await fetch('https://api.example.com/data');\n  return <div>{data.title}</div>;\n}\n```\n\n**Client Components:**\n- Add `'use client'` directive at top\n- Can use hooks, event handlers, browser APIs\n- Hydrated on client\n\n```jsx\n'use client'\nimport { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n}\n```\n\n**When to use each:**\n\n| Use Server Components | Use Client Components |\n|----------------------|----------------------|\n| Fetching data | Interactive UI |\n| Accessing backend | useState, useEffect |\n| Sensitive logic | Event listeners |\n| Large dependencies | Browser APIs |\n| Static content | Forms with validation |\n\n**Pattern: Server parent, Client children:**\n```jsx\n// app/page.tsx (Server)\nimport { Counter } from './Counter'; // Client\n\nasync function Page() {\n  const data = await getData();\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <Counter initialCount={data.count} />\n    </div>\n  );\n}\n```\n\nKeep Client Components at the leaves of your component tree."}
{"prompt": "How do I implement a debounce function in JavaScript?", "response": "**Debounce** delays execution until after a pause in calls:\n\n**Basic implementation:**\n```javascript\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n```\n\n**With immediate execution option:**\n```javascript\nfunction debounce(fn, delay, immediate = false) {\n  let timeoutId;\n  return function(...args) {\n    const callNow = immediate && !timeoutId;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      if (!immediate) fn.apply(this, args);\n    }, delay);\n    if (callNow) fn.apply(this, args);\n  };\n}\n```\n\n**Usage examples:**\n```javascript\n// Search input\nconst debouncedSearch = debounce((query) => {\n  fetch(`/api/search?q=${query}`)\n    .then(res => res.json())\n    .then(setResults);\n}, 300);\n\ninput.addEventListener('input', (e) => debouncedSearch(e.target.value));\n\n// Window resize\nwindow.addEventListener('resize', debounce(handleResize, 250));\n```\n\n**React hook:**\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n\n// Usage\nconst debouncedSearchTerm = useDebounce(searchTerm, 300);\n```\n\nFor production, use lodash.debounce or similar battle-tested implementation."}
{"prompt": "What are the best practices for REST API design?", "response": "**REST API design best practices:**\n\n**1. Use nouns for resources, not verbs:**\n```\nGood: GET /users, POST /orders\nBad: GET /getUsers, POST /createOrder\n```\n\n**2. Use proper HTTP methods:**\n- GET - Read (idempotent)\n- POST - Create\n- PUT - Full update (idempotent)\n- PATCH - Partial update\n- DELETE - Remove (idempotent)\n\n**3. Use proper status codes:**\n```\n200 OK - Success\n201 Created - Resource created\n204 No Content - Success, no body\n400 Bad Request - Invalid input\n401 Unauthorized - Not authenticated\n403 Forbidden - Not authorized\n404 Not Found - Resource doesn't exist\n409 Conflict - State conflict\n422 Unprocessable Entity - Validation error\n500 Internal Server Error - Server error\n```\n\n**4. Versioning:**\n```\n/api/v1/users\nAccept: application/vnd.api+json; version=1\n```\n\n**5. Pagination:**\n```\nGET /users?page=2&limit=20\nResponse: { data: [...], meta: { total: 100, page: 2, limit: 20 } }\n```\n\n**6. Filtering, sorting, searching:**\n```\nGET /users?status=active&sort=-createdAt&search=john\n```\n\n**7. Consistent error format:**\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid email format\",\n    \"details\": [{ \"field\": \"email\", \"message\": \"Must be valid email\" }]\n  }\n}\n```\n\n**8. Use HATEOAS for discoverability:**\n```json\n{\n  \"id\": 1,\n  \"name\": \"John\",\n  \"_links\": {\n    \"self\": \"/users/1\",\n    \"orders\": \"/users/1/orders\"\n  }\n}\n```"}
{"prompt": "How do I optimize images for web performance?", "response": "**Comprehensive image optimization strategy:**\n\n**1. Choose the right format:**\n- **WebP** - Best compression, wide support\n- **AVIF** - Best quality/size ratio, growing support\n- **JPEG** - Photos, no transparency needed\n- **PNG** - Transparency, graphics, screenshots\n- **SVG** - Icons, logos, illustrations\n\n**2. Responsive images:**\n```html\n<picture>\n  <source srcset=\"image.avif\" type=\"image/avif\">\n  <source srcset=\"image.webp\" type=\"image/webp\">\n  <img src=\"image.jpg\" alt=\"Description\"\n       srcset=\"image-400.jpg 400w,\n               image-800.jpg 800w,\n               image-1200.jpg 1200w\"\n       sizes=\"(max-width: 600px) 100vw, 50vw\"\n       loading=\"lazy\"\n       decoding=\"async\">\n</picture>\n```\n\n**3. Compression tools:**\n```bash\n# Sharp (Node.js)\nsharp('input.jpg').webp({ quality: 80 }).toFile('output.webp');\n\n# ImageMagick\nconvert input.jpg -quality 85 -strip output.jpg\n\n# Squoosh CLI\nnpx @squoosh/cli --webp auto input.jpg\n```\n\n**4. CDN and caching:**\n```\nCache-Control: public, max-age=31536000, immutable\n```\n\n**5. Placeholder strategies:**\n- LQIP (Low Quality Image Placeholder)\n- Dominant color placeholder\n- BlurHash\n\n```jsx\n<img\n  src=\"data:image/svg+xml,...\" // Tiny SVG placeholder\n  data-src=\"actual-image.webp\"\n  className=\"blur-up\"\n/>\n```\n\n**6. Size images properly:**\n- Never serve images larger than displayed\n- Use srcset for different screen densities\n- Target 2x for retina displays\n\n**Target: 100KB or less per image for most use cases.**"}
{"prompt": "How do I set up ESLint and Prettier in a React project?", "response": "**Complete ESLint + Prettier setup for React:**\n\n**1. Install dependencies:**\n```bash\nnpm install -D eslint prettier \\\n  eslint-plugin-react eslint-plugin-react-hooks \\\n  eslint-plugin-jsx-a11y eslint-config-prettier \\\n  @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n**2. Create .eslintrc.json:**\n```json\n{\n  \"env\": {\n    \"browser\": true,\n    \"es2022\": true,\n    \"node\": true\n  },\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:react-hooks/recommended\",\n    \"plugin:jsx-a11y/recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n    \"prettier\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaFeatures\": { \"jsx\": true },\n    \"ecmaVersion\": \"latest\",\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\"react\", \"react-hooks\", \"jsx-a11y\", \"@typescript-eslint\"],\n  \"rules\": {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"react/prop-types\": \"off\"\n  },\n  \"settings\": {\n    \"react\": { \"version\": \"detect\" }\n  }\n}\n```\n\n**3. Create .prettierrc:**\n```json\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"printWidth\": 80\n}\n```\n\n**4. Add scripts to package.json:**\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint src --ext .ts,.tsx\",\n    \"lint:fix\": \"eslint src --ext .ts,.tsx --fix\",\n    \"format\": \"prettier --write 'src/**/*.{ts,tsx,css,json}'\"\n  }\n}\n```\n\n**5. VS Code settings.json:**\n```json\n{\n  \"editor.formatOnSave\": true,\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  }\n}\n```\n\n**6. Add .eslintignore:**\n```\nnode_modules\ndist\nbuild\n```"}
{"prompt": "How do I implement a modal/dialog component accessibly?", "response": "**Accessible modal implementation:**\n\n**Key accessibility requirements:**\n- Focus trap inside modal\n- Return focus on close\n- Close on Escape key\n- Proper ARIA attributes\n- Prevent scroll on body\n\n```jsx\nimport { useEffect, useRef, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ isOpen, onClose, title, children }) {\n  const modalRef = useRef(null);\n  const previousFocus = useRef(null);\n\n  // Save and restore focus\n  useEffect(() => {\n    if (isOpen) {\n      previousFocus.current = document.activeElement;\n      modalRef.current?.focus();\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n      previousFocus.current?.focus();\n    }\n  }, [isOpen]);\n\n  // Handle Escape key\n  useEffect(() => {\n    const handleEscape = (e) => {\n      if (e.key === 'Escape') onClose();\n    };\n    if (isOpen) document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [isOpen, onClose]);\n\n  // Focus trap\n  const handleKeyDown = useCallback((e) => {\n    if (e.key !== 'Tab') return;\n    const focusable = modalRef.current.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    const first = focusable[0];\n    const last = focusable[focusable.length - 1];\n\n    if (e.shiftKey && document.activeElement === first) {\n      e.preventDefault();\n      last.focus();\n    } else if (!e.shiftKey && document.activeElement === last) {\n      e.preventDefault();\n      first.focus();\n    }\n  }, []);\n\n  if (!isOpen) return null;\n\n  return createPortal(\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div\n        ref={modalRef}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"modal-title\"\n        tabIndex={-1}\n        onClick={(e) => e.stopPropagation()}\n        onKeyDown={handleKeyDown}\n      >\n        <h2 id=\"modal-title\">{title}</h2>\n        {children}\n        <button onClick={onClose} aria-label=\"Close modal\">\n          &times;\n        </button>\n      </div>\n    </div>,\n    document.body\n  );\n}\n```\n\nConsider using Radix UI or Headless UI for production-ready accessible components."}
{"prompt": "What are Web Workers and when should I use them?", "response": "**Web Workers** run JavaScript in background threads, preventing UI blocking.\n\n**When to use:**\n- Heavy computations (parsing, encryption, image processing)\n- Large data processing\n- Real-time data analysis\n- Complex algorithms\n\n**Basic usage:**\n\n```javascript\n// main.js\nconst worker = new Worker('worker.js');\n\nworker.postMessage({ data: largeArray, operation: 'process' });\n\nworker.onmessage = (event) => {\n  console.log('Result:', event.data);\n};\n\nworker.onerror = (error) => {\n  console.error('Worker error:', error);\n};\n```\n\n```javascript\n// worker.js\nself.onmessage = (event) => {\n  const { data, operation } = event.data;\n  \n  // Heavy computation here - won't block UI\n  const result = processData(data);\n  \n  self.postMessage(result);\n};\n```\n\n**Inline worker (no separate file):**\n```javascript\nconst workerCode = `\n  self.onmessage = (e) => {\n    const result = e.data.map(x => x * 2);\n    self.postMessage(result);\n  };\n`;\n\nconst blob = new Blob([workerCode], { type: 'application/javascript' });\nconst worker = new Worker(URL.createObjectURL(blob));\n```\n\n**React hook for Web Workers:**\n```javascript\nfunction useWorker(workerFunction) {\n  const [result, setResult] = useState(null);\n  const [error, setError] = useState(null);\n  const workerRef = useRef(null);\n\n  useEffect(() => {\n    const code = workerFunction.toString();\n    const blob = new Blob([`(${code})()`]);\n    workerRef.current = new Worker(URL.createObjectURL(blob));\n    workerRef.current.onmessage = (e) => setResult(e.data);\n    workerRef.current.onerror = (e) => setError(e);\n    return () => workerRef.current?.terminate();\n  }, []);\n\n  const postMessage = useCallback((data) => {\n    workerRef.current?.postMessage(data);\n  }, []);\n\n  return { result, error, postMessage };\n}\n```\n\n**Limitations:**\n- No DOM access\n- No window object\n- Communication via postMessage (serialization overhead)"}
{"prompt": "How do I implement CSS-in-JS with styled-components?", "response": "**styled-components setup and patterns:**\n\n**Installation:**\n```bash\nnpm install styled-components\nnpm install -D @types/styled-components  # For TypeScript\n```\n\n**Basic usage:**\n```jsx\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background: ${props => props.primary ? '#007bff' : 'white'};\n  color: ${props => props.primary ? 'white' : '#007bff'};\n  padding: 10px 20px;\n  border: 2px solid #007bff;\n  border-radius: 4px;\n  cursor: pointer;\n  \n  &:hover {\n    opacity: 0.9;\n  }\n  \n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n`;\n\n// Usage\n<Button primary>Primary</Button>\n<Button>Secondary</Button>\n```\n\n**Theme provider:**\n```jsx\nimport { ThemeProvider, createGlobalStyle } from 'styled-components';\n\nconst theme = {\n  colors: {\n    primary: '#007bff',\n    secondary: '#6c757d',\n    background: '#f8f9fa'\n  },\n  spacing: (n) => `${n * 8}px`\n};\n\nconst GlobalStyle = createGlobalStyle`\n  * { box-sizing: border-box; margin: 0; }\n  body { background: ${props => props.theme.colors.background}; }\n`;\n\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      <GlobalStyle />\n      <Main />\n    </ThemeProvider>\n  );\n}\n```\n\n**Extending components:**\n```jsx\nconst BaseButton = styled.button`...`;\nconst PrimaryButton = styled(BaseButton)`\n  background: ${props => props.theme.colors.primary};\n`;\n```\n\n**With TypeScript:**\n```typescript\nimport styled from 'styled-components';\n\ninterface ButtonProps {\n  primary?: boolean;\n  size?: 'small' | 'medium' | 'large';\n}\n\nconst Button = styled.button<ButtonProps>`\n  padding: ${props => props.size === 'large' ? '16px 32px' : '8px 16px'};\n`;\n```\n\n**SSR support:** Use `ServerStyleSheet` for Next.js integration."}
{"prompt": "How do I handle file uploads in a web application?", "response": "**Complete file upload implementation:**\n\n**1. Basic HTML + JavaScript:**\n```html\n<input type=\"file\" id=\"fileInput\" accept=\"image/*\" multiple>\n<progress id=\"progress\" value=\"0\" max=\"100\"></progress>\n```\n\n```javascript\nconst input = document.getElementById('fileInput');\nconst progress = document.getElementById('progress');\n\ninput.addEventListener('change', async (e) => {\n  const files = e.target.files;\n  const formData = new FormData();\n  \n  for (const file of files) {\n    // Validate\n    if (file.size > 10 * 1024 * 1024) {\n      alert('File too large (max 10MB)');\n      continue;\n    }\n    formData.append('files', file);\n  }\n  \n  // Upload with progress\n  const xhr = new XMLHttpRequest();\n  xhr.upload.onprogress = (e) => {\n    progress.value = (e.loaded / e.total) * 100;\n  };\n  xhr.open('POST', '/api/upload');\n  xhr.send(formData);\n});\n```\n\n**2. React component with drag & drop:**\n```jsx\nfunction FileUpload({ onUpload }) {\n  const [isDragging, setIsDragging] = useState(false);\n  const [progress, setProgress] = useState(0);\n\n  const handleDrop = useCallback((e) => {\n    e.preventDefault();\n    setIsDragging(false);\n    const files = Array.from(e.dataTransfer.files);\n    uploadFiles(files);\n  }, []);\n\n  const uploadFiles = async (files) => {\n    const formData = new FormData();\n    files.forEach(f => formData.append('files', f));\n\n    const response = await fetch('/api/upload', {\n      method: 'POST',\n      body: formData,\n    });\n    \n    onUpload(await response.json());\n  };\n\n  return (\n    <div\n      onDrop={handleDrop}\n      onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}\n      onDragLeave={() => setIsDragging(false)}\n      className={isDragging ? 'dropzone active' : 'dropzone'}\n    >\n      Drop files here or click to upload\n      <input type=\"file\" onChange={(e) => uploadFiles([...e.target.files])} />\n    </div>\n  );\n}\n```\n\n**3. Express backend:**\n```javascript\nimport multer from 'multer';\n\nconst upload = multer({\n  dest: 'uploads/',\n  limits: { fileSize: 10 * 1024 * 1024 },\n  fileFilter: (req, file, cb) => {\n    const allowed = ['image/jpeg', 'image/png', 'image/webp'];\n    cb(null, allowed.includes(file.mimetype));\n  }\n});\n\napp.post('/api/upload', upload.array('files', 10), (req, res) => {\n  res.json({ files: req.files.map(f => ({ id: f.filename, name: f.originalname })) });\n});\n```\n\n**For large files:** Use chunked uploads with resumability (tus protocol)."}
{"prompt": "Explain the event loop in JavaScript", "response": "**JavaScript Event Loop** manages async execution in a single-threaded environment.\n\n**Components:**\n\n1. **Call Stack** - Executes synchronous code (LIFO)\n2. **Web APIs** - Handle async operations (setTimeout, fetch, DOM events)\n3. **Callback Queue (Task Queue)** - setTimeout, setInterval callbacks\n4. **Microtask Queue** - Promises, queueMicrotask, MutationObserver\n\n**Execution order:**\n1. Execute all synchronous code in call stack\n2. Process ALL microtasks (Promises)\n3. Process ONE task from callback queue\n4. Repeat\n\n**Example:**\n```javascript\nconsole.log('1'); // Sync\n\nsetTimeout(() => console.log('2'), 0); // Task queue\n\nPromise.resolve().then(() => console.log('3')); // Microtask\n\nconsole.log('4'); // Sync\n\n// Output: 1, 4, 3, 2\n```\n\n**More complex example:**\n```javascript\nconsole.log('start');\n\nsetTimeout(() => {\n  console.log('timeout 1');\n  Promise.resolve().then(() => console.log('promise inside timeout'));\n}, 0);\n\nPromise.resolve()\n  .then(() => console.log('promise 1'))\n  .then(() => console.log('promise 2'));\n\nsetTimeout(() => console.log('timeout 2'), 0);\n\nconsole.log('end');\n\n// Output:\n// start\n// end\n// promise 1\n// promise 2\n// timeout 1\n// promise inside timeout\n// timeout 2\n```\n\n**Key takeaways:**\n- Microtasks (Promises) always run before the next task\n- Long-running sync code blocks the event loop\n- Use `queueMicrotask()` for immediate async execution\n- Use `setTimeout(fn, 0)` to defer to next event loop iteration\n\n**Performance tip:** Break long tasks to keep UI responsive:\n```javascript\nfunction processChunk(items, index = 0) {\n  const chunk = items.slice(index, index + 100);\n  chunk.forEach(process);\n  if (index + 100 < items.length) {\n    setTimeout(() => processChunk(items, index + 100), 0);\n  }\n}\n```"}
{"prompt": "How do I implement server-sent events (SSE)?", "response": "**Server-Sent Events** provide real-time server-to-client updates.\n\n**Server (Node.js/Express):**\n```javascript\napp.get('/events', (req, res) => {\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  \n  // Send initial connection message\n  res.write('data: Connected\\n\\n');\n  \n  // Send updates\n  const interval = setInterval(() => {\n    const data = JSON.stringify({ time: new Date().toISOString() });\n    res.write(`data: ${data}\\n\\n`);\n  }, 1000);\n  \n  // Handle named events\n  const sendEvent = (event, data) => {\n    res.write(`event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`);\n  };\n  \n  // Cleanup on disconnect\n  req.on('close', () => {\n    clearInterval(interval);\n    res.end();\n  });\n});\n```\n\n**Client (JavaScript):**\n```javascript\nconst eventSource = new EventSource('/events');\n\n// Default message event\neventSource.onmessage = (event) => {\n  console.log('Message:', event.data);\n};\n\n// Named events\neventSource.addEventListener('notification', (event) => {\n  const data = JSON.parse(event.data);\n  showNotification(data);\n});\n\n// Handle errors and reconnection\neventSource.onerror = (error) => {\n  console.error('SSE Error:', error);\n  if (eventSource.readyState === EventSource.CLOSED) {\n    // Reconnect logic\n    setTimeout(() => initSSE(), 5000);\n  }\n};\n\n// Close connection\neventSource.close();\n```\n\n**React hook:**\n```javascript\nfunction useSSE(url) {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const source = new EventSource(url);\n    \n    source.onmessage = (e) => setData(JSON.parse(e.data));\n    source.onerror = () => setError(new Error('SSE failed'));\n    \n    return () => source.close();\n  }, [url]);\n\n  return { data, error };\n}\n```\n\n**SSE vs WebSockets:**\n| SSE | WebSockets |\n|-----|------------|\n| One-way (serverâ†’client) | Bidirectional |\n| HTTP-based, auto-reconnect | Separate protocol |\n| Simpler implementation | More complex |\n| Good for notifications | Good for chat, gaming |\n\nUse SSE for feeds, notifications, live updates. Use WebSockets when you need bidirectional communication."}
{"prompt": "How do I implement pagination in a REST API?", "response": "**Three pagination strategies:**\n\n**1. Offset-based (most common):**\n```javascript\n// GET /api/users?page=2&limit=20\napp.get('/api/users', async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const limit = Math.min(parseInt(req.query.limit) || 20, 100);\n  const offset = (page - 1) * limit;\n  \n  const [users, total] = await Promise.all([\n    User.find().skip(offset).limit(limit),\n    User.countDocuments()\n  ]);\n  \n  res.json({\n    data: users,\n    meta: {\n      page,\n      limit,\n      total,\n      totalPages: Math.ceil(total / limit),\n      hasNext: page * limit < total,\n      hasPrev: page > 1\n    },\n    links: {\n      self: `/api/users?page=${page}&limit=${limit}`,\n      first: `/api/users?page=1&limit=${limit}`,\n      last: `/api/users?page=${Math.ceil(total / limit)}&limit=${limit}`,\n      next: page * limit < total ? `/api/users?page=${page + 1}&limit=${limit}` : null,\n      prev: page > 1 ? `/api/users?page=${page - 1}&limit=${limit}` : null\n    }\n  });\n});\n```\n\n**2. Cursor-based (for large datasets):**\n```javascript\n// GET /api/users?cursor=abc123&limit=20\napp.get('/api/users', async (req, res) => {\n  const limit = parseInt(req.query.limit) || 20;\n  const cursor = req.query.cursor;\n  \n  const query = cursor \n    ? { _id: { $gt: cursor } }\n    : {};\n  \n  const users = await User.find(query)\n    .sort({ _id: 1 })\n    .limit(limit + 1); // Fetch one extra to check hasNext\n  \n  const hasNext = users.length > limit;\n  if (hasNext) users.pop();\n  \n  res.json({\n    data: users,\n    meta: {\n      hasNext,\n      nextCursor: hasNext ? users[users.length - 1]._id : null\n    }\n  });\n});\n```\n\n**3. Keyset pagination (time-based):**\n```javascript\n// GET /api/posts?after=2024-01-01T00:00:00Z&limit=20\nconst query = req.query.after\n  ? { createdAt: { $lt: new Date(req.query.after) } }\n  : {};\n\nconst posts = await Post.find(query)\n  .sort({ createdAt: -1 })\n  .limit(limit);\n```\n\n**Comparison:**\n| Type | Pros | Cons |\n|------|------|------|\n| Offset | Simple, random access | Slow for large offsets, inconsistent with changes |\n| Cursor | Consistent, performant | No random access, forward-only |\n| Keyset | Very fast, consistent | Requires sortable unique field |\n\n**Use cursor/keyset for infinite scroll, offset for traditional pagination.**"}
{"prompt": "What are the security headers I should add to my web application?", "response": "**Essential security headers:**\n\n```javascript\n// Express middleware\nconst helmet = require('helmet');\napp.use(helmet()); // Sets most headers automatically\n\n// Or manually:\napp.use((req, res, next) => {\n  // Prevent XSS attacks\n  res.setHeader('Content-Security-Policy', \n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:\");\n  \n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // Prevent MIME sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Control referrer information\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  // Force HTTPS\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  \n  // Control browser features\n  res.setHeader('Permissions-Policy', \n    'camera=(), microphone=(), geolocation=()');\n  \n  // Remove server info\n  res.removeHeader('X-Powered-By');\n  \n  next();\n});\n```\n\n**Header explanations:**\n\n| Header | Purpose |\n|--------|----------|\n| Content-Security-Policy | Controls allowed sources for scripts, styles, images |\n| X-Frame-Options | Prevents embedding in iframes (clickjacking) |\n| X-Content-Type-Options | Prevents MIME type sniffing attacks |\n| Strict-Transport-Security | Forces HTTPS connections |\n| Referrer-Policy | Controls referrer info sent with requests |\n| Permissions-Policy | Restricts browser features |\n\n**Nginx configuration:**\n```nginx\nadd_header Content-Security-Policy \"default-src 'self'\" always;\nadd_header X-Frame-Options \"DENY\" always;\nadd_header X-Content-Type-Options \"nosniff\" always;\nadd_header Strict-Transport-Security \"max-age=31536000\" always;\nadd_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n```\n\n**Testing tools:**\n- securityheaders.com\n- Mozilla Observatory\n- Chrome DevTools Security tab\n\n**CSP tip:** Start with `Content-Security-Policy-Report-Only` to test without breaking your site."}
{"prompt": "How do I write unit tests for React components?", "response": "**Testing React components with React Testing Library:**\n\n**Setup:**\n```bash\nnpm install -D @testing-library/react @testing-library/jest-dom \\\n  @testing-library/user-event vitest jsdom\n```\n\n**vitest.config.ts:**\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    environment: 'jsdom',\n    setupFiles: './src/test/setup.ts',\n    globals: true\n  }\n});\n```\n\n**src/test/setup.ts:**\n```typescript\nimport '@testing-library/jest-dom';\n```\n\n**Example component:**\n```jsx\nfunction Counter({ initialCount = 0 }) {\n  const [count, setCount] = useState(initialCount);\n  return (\n    <div>\n      <span data-testid=\"count\">{count}</span>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n      <button onClick={() => setCount(c => c - 1)}>Decrement</button>\n    </div>\n  );\n}\n```\n\n**Test file (Counter.test.tsx):**\n```typescript\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { Counter } from './Counter';\n\ndescribe('Counter', () => {\n  it('renders with initial count', () => {\n    render(<Counter initialCount={5} />);\n    expect(screen.getByTestId('count')).toHaveTextContent('5');\n  });\n\n  it('increments count when clicking increment', async () => {\n    const user = userEvent.setup();\n    render(<Counter />);\n    \n    await user.click(screen.getByRole('button', { name: /increment/i }));\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('1');\n  });\n\n  it('decrements count when clicking decrement', async () => {\n    const user = userEvent.setup();\n    render(<Counter initialCount={5} />);\n    \n    await user.click(screen.getByRole('button', { name: /decrement/i }));\n    \n    expect(screen.getByTestId('count')).toHaveTextContent('4');\n  });\n});\n```\n\n**Testing async components:**\n```typescript\nit('loads and displays data', async () => {\n  render(<UserProfile userId=\"123\" />);\n  \n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n  });\n});\n```\n\n**Best practices:**\n- Query by role/text over test IDs when possible\n- Use userEvent over fireEvent\n- Test behavior, not implementation\n- Avoid testing internal state directly"}
{"prompt": "How do I implement a responsive navigation menu?", "response": "**Responsive navigation with hamburger menu:**\n\n**HTML:**\n```html\n<nav class=\"navbar\">\n  <a href=\"/\" class=\"logo\">Logo</a>\n  \n  <button class=\"menu-toggle\" aria-label=\"Toggle menu\" aria-expanded=\"false\">\n    <span class=\"hamburger\"></span>\n  </button>\n  \n  <ul class=\"nav-links\">\n    <li><a href=\"/about\">About</a></li>\n    <li><a href=\"/services\">Services</a></li>\n    <li><a href=\"/contact\">Contact</a></li>\n  </ul>\n</nav>\n```\n\n**CSS:**\n```css\n.navbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem 2rem;\n  background: #333;\n}\n\n.logo {\n  color: white;\n  font-size: 1.5rem;\n  text-decoration: none;\n}\n\n.nav-links {\n  display: flex;\n  gap: 2rem;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n.nav-links a {\n  color: white;\n  text-decoration: none;\n}\n\n.menu-toggle {\n  display: none;\n  background: none;\n  border: none;\n  cursor: pointer;\n}\n\n.hamburger,\n.hamburger::before,\n.hamburger::after {\n  display: block;\n  width: 25px;\n  height: 3px;\n  background: white;\n  position: relative;\n  transition: transform 0.3s;\n}\n\n.hamburger::before,\n.hamburger::after {\n  content: '';\n  position: absolute;\n}\n\n.hamburger::before { top: -8px; }\n.hamburger::after { top: 8px; }\n\n/* Mobile styles */\n@media (max-width: 768px) {\n  .menu-toggle {\n    display: block;\n    z-index: 1001;\n  }\n  \n  .nav-links {\n    position: fixed;\n    top: 0;\n    right: -100%;\n    width: 70%;\n    height: 100vh;\n    flex-direction: column;\n    background: #333;\n    padding: 5rem 2rem;\n    transition: right 0.3s;\n  }\n  \n  .nav-links.open {\n    right: 0;\n  }\n  \n  /* Hamburger animation */\n  .menu-toggle.open .hamburger {\n    transform: rotate(45deg);\n  }\n  \n  .menu-toggle.open .hamburger::before {\n    transform: rotate(90deg);\n    top: 0;\n  }\n  \n  .menu-toggle.open .hamburger::after {\n    opacity: 0;\n  }\n}\n```\n\n**JavaScript:**\n```javascript\nconst toggle = document.querySelector('.menu-toggle');\nconst navLinks = document.querySelector('.nav-links');\n\ntoggle.addEventListener('click', () => {\n  const isOpen = toggle.classList.toggle('open');\n  navLinks.classList.toggle('open');\n  toggle.setAttribute('aria-expanded', isOpen);\n});\n\n// Close on link click\nnavLinks.querySelectorAll('a').forEach(link => {\n  link.addEventListener('click', () => {\n    toggle.classList.remove('open');\n    navLinks.classList.remove('open');\n  });\n});\n```\n\n**React version available with useState for toggle state.**"}
{"prompt": "How do I handle environment variables in a web application?", "response": "**Environment variables management across environments:**\n\n**1. Node.js (backend):**\n```bash\n# .env (never commit!)\nDATABASE_URL=mongodb://localhost:27017/myapp\nAPI_KEY=secret123\nNODE_ENV=development\n```\n\n```javascript\n// Load with dotenv\nimport 'dotenv/config';\n\n// Or use dotenv\nimport dotenv from 'dotenv';\ndotenv.config();\n\n// Access variables\nconst dbUrl = process.env.DATABASE_URL;\nconst isProduction = process.env.NODE_ENV === 'production';\n```\n\n**2. Vite (frontend):**\n```bash\n# .env.local\nVITE_API_URL=http://localhost:3001\nVITE_PUBLIC_KEY=pk_123\n```\n\n```javascript\n// Only VITE_ prefixed vars are exposed\nconst apiUrl = import.meta.env.VITE_API_URL;\n```\n\n**3. Next.js:**\n```bash\n# .env.local\n# Server-only\nDATABASE_URL=postgres://...\n\n# Browser-exposed (NEXT_PUBLIC_ prefix)\nNEXT_PUBLIC_API_URL=https://api.example.com\n```\n\n**4. Create React App:**\n```bash\n# .env\nREACT_APP_API_URL=https://api.example.com\n```\n\n**TypeScript type safety:**\n```typescript\n// env.d.ts\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      DATABASE_URL: string;\n      API_KEY: string;\n      NODE_ENV: 'development' | 'production' | 'test';\n    }\n  }\n}\n\nexport {};\n```\n\n**Validation with zod:**\n```typescript\nimport { z } from 'zod';\n\nconst envSchema = z.object({\n  DATABASE_URL: z.string().url(),\n  API_KEY: z.string().min(1),\n  PORT: z.string().transform(Number).default('3000'),\n});\n\nexport const env = envSchema.parse(process.env);\n```\n\n**Best practices:**\n- Never commit `.env` files\n- Use `.env.example` as template\n- Different files per environment: `.env.development`, `.env.production`\n- Validate env vars at startup\n- Use secrets management (AWS Secrets Manager, Vault) in production\n\n**.gitignore:**\n```\n.env\n.env.local\n.env.*.local\n```"}
{"prompt": "Explain the difference between SSR, SSG, and CSR in web development", "response": "**Rendering strategies comparison:**\n\n**CSR (Client-Side Rendering)**\n- JavaScript renders content in browser\n- Initial HTML is minimal shell\n- Data fetched after page load\n\n```jsx\n// React SPA (Vite, CRA)\nfunction App() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    fetch('/api/data').then(r => r.json()).then(setData);\n  }, []);\n  \n  return <div>{data?.title}</div>;\n}\n```\n\n**SSR (Server-Side Rendering)**\n- HTML generated on each request\n- Full content in initial HTML\n- Hydrated with JavaScript\n\n```jsx\n// Next.js SSR\nexport async function getServerSideProps() {\n  const data = await fetchData();\n  return { props: { data } };\n}\n\nfunction Page({ data }) {\n  return <div>{data.title}</div>;\n}\n```\n\n**SSG (Static Site Generation)**\n- HTML generated at build time\n- Pre-rendered, cached on CDN\n- Fastest possible delivery\n\n```jsx\n// Next.js SSG\nexport async function getStaticProps() {\n  const data = await fetchData();\n  return { props: { data }, revalidate: 3600 }; // ISR: rebuild hourly\n}\n```\n\n**Comparison:**\n\n| Aspect | CSR | SSR | SSG |\n|--------|-----|-----|-----|\n| Initial load | Slow (JS bundle) | Medium | Fast (cached) |\n| SEO | Poor | Good | Excellent |\n| TTFB | Fast | Slower | Fastest |\n| Server load | Low | High | None |\n| Dynamic content | Real-time | Per-request | Build-time/ISR |\n| Hosting | Static | Node server | CDN |\n\n**When to use:**\n\n- **CSR**: Dashboards, admin panels, apps behind login\n- **SSR**: E-commerce, social media, personalized content\n- **SSG**: Blogs, docs, marketing sites, landing pages\n\n**Hybrid approach (Next.js App Router):**\n```jsx\n// Server Component - rendered on server\nasync function ProductPage({ params }) {\n  const product = await getProduct(params.id); // SSR\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <AddToCart productId={product.id} /> {/* Client Component */}\n    </div>\n  );\n}\n```\n\nModern frameworks support mixing strategies per page/component."}
{"prompt": "How do I implement a search feature with autocomplete?", "response": "**Search autocomplete implementation:**\n\n**React component:**\n```jsx\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nfunction SearchAutocomplete({ onSelect }) {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeIndex, setActiveIndex] = useState(-1);\n  const [loading, setLoading] = useState(false);\n  const inputRef = useRef();\n  const listRef = useRef();\n\n  // Debounced search\n  useEffect(() => {\n    if (query.length < 2) {\n      setResults([]);\n      return;\n    }\n\n    const timer = setTimeout(async () => {\n      setLoading(true);\n      try {\n        const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`);\n        const data = await res.json();\n        setResults(data.results);\n        setIsOpen(true);\n      } finally {\n        setLoading(false);\n      }\n    }, 300);\n\n    return () => clearTimeout(timer);\n  }, [query]);\n\n  // Keyboard navigation\n  const handleKeyDown = useCallback((e) => {\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setActiveIndex(i => Math.min(i + 1, results.length - 1));\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setActiveIndex(i => Math.max(i - 1, -1));\n        break;\n      case 'Enter':\n        if (activeIndex >= 0) {\n          handleSelect(results[activeIndex]);\n        }\n        break;\n      case 'Escape':\n        setIsOpen(false);\n        break;\n    }\n  }, [results, activeIndex]);\n\n  const handleSelect = (item) => {\n    setQuery(item.name);\n    setIsOpen(false);\n    onSelect(item);\n  };\n\n  // Close on click outside\n  useEffect(() => {\n    const handler = (e) => {\n      if (!inputRef.current?.contains(e.target) && \n          !listRef.current?.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('click', handler);\n    return () => document.removeEventListener('click', handler);\n  }, []);\n\n  return (\n    <div className=\"search-container\">\n      <input\n        ref={inputRef}\n        type=\"text\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        onKeyDown={handleKeyDown}\n        onFocus={() => results.length && setIsOpen(true)}\n        placeholder=\"Search...\"\n        role=\"combobox\"\n        aria-expanded={isOpen}\n        aria-autocomplete=\"list\"\n      />\n      {loading && <span className=\"spinner\" />}\n      \n      {isOpen && results.length > 0 && (\n        <ul ref={listRef} role=\"listbox\">\n          {results.map((item, index) => (\n            <li\n              key={item.id}\n              role=\"option\"\n              aria-selected={index === activeIndex}\n              className={index === activeIndex ? 'active' : ''}\n              onClick={() => handleSelect(item)}\n            >\n              <Highlight text={item.name} query={query} />\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n\n// Highlight matching text\nfunction Highlight({ text, query }) {\n  const parts = text.split(new RegExp(`(${query})`, 'gi'));\n  return parts.map((part, i) => \n    part.toLowerCase() === query.toLowerCase() \n      ? <mark key={i}>{part}</mark> \n      : part\n  );\n}\n```\n\n**Backend search endpoint:**\n```javascript\napp.get('/api/search', async (req, res) => {\n  const { q } = req.query;\n  const results = await db.collection('items')\n    .find({ name: { $regex: q, $options: 'i' } })\n    .limit(10)\n    .toArray();\n  res.json({ results });\n});\n```\n\n**For production, consider:** Elasticsearch, Algolia, or Typesense for better search."}
{"prompt": "How do I create a reusable button component in React?", "response": "**Comprehensive reusable button component:**\n\n```tsx\nimport { forwardRef, ButtonHTMLAttributes, ReactNode } from 'react';\nimport clsx from 'clsx';\nimport styles from './Button.module.css';\n\ntype ButtonVariant = 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';\ntype ButtonSize = 'sm' | 'md' | 'lg';\n\ninterface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  size?: ButtonSize;\n  isLoading?: boolean;\n  leftIcon?: ReactNode;\n  rightIcon?: ReactNode;\n  fullWidth?: boolean;\n}\n\nexport const Button = forwardRef<HTMLButtonElement, ButtonProps>(\n  (\n    {\n      children,\n      variant = 'primary',\n      size = 'md',\n      isLoading = false,\n      leftIcon,\n      rightIcon,\n      fullWidth = false,\n      disabled,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <button\n        ref={ref}\n        disabled={disabled || isLoading}\n        className={clsx(\n          styles.button,\n          styles[variant],\n          styles[size],\n          fullWidth && styles.fullWidth,\n          isLoading && styles.loading,\n          className\n        )}\n        {...props}\n      >\n        {isLoading && <Spinner className={styles.spinner} />}\n        {!isLoading && leftIcon && (\n          <span className={styles.icon}>{leftIcon}</span>\n        )}\n        <span className={isLoading ? styles.hiddenText : undefined}>\n          {children}\n        </span>\n        {!isLoading && rightIcon && (\n          <span className={styles.icon}>{rightIcon}</span>\n        )}\n      </button>\n    );\n  }\n);\n\nButton.displayName = 'Button';\n```\n\n**Button.module.css:**\n```css\n.button {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.5rem;\n  font-weight: 500;\n  border-radius: 0.375rem;\n  transition: all 0.15s ease;\n  cursor: pointer;\n  border: none;\n}\n\n.button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Sizes */\n.sm { padding: 0.375rem 0.75rem; font-size: 0.875rem; }\n.md { padding: 0.5rem 1rem; font-size: 1rem; }\n.lg { padding: 0.75rem 1.5rem; font-size: 1.125rem; }\n\n/* Variants */\n.primary {\n  background: #3b82f6;\n  color: white;\n}\n.primary:hover:not(:disabled) { background: #2563eb; }\n\n.secondary {\n  background: #6b7280;\n  color: white;\n}\n\n.outline {\n  background: transparent;\n  border: 1px solid #3b82f6;\n  color: #3b82f6;\n}\n\n.ghost {\n  background: transparent;\n  color: #3b82f6;\n}\n.ghost:hover:not(:disabled) { background: #3b82f610; }\n\n.danger {\n  background: #ef4444;\n  color: white;\n}\n\n.fullWidth { width: 100%; }\n\n.loading { position: relative; }\n.spinner { position: absolute; }\n.hiddenText { visibility: hidden; }\n.icon { display: flex; }\n```\n\n**Usage:**\n```tsx\n<Button variant=\"primary\" size=\"lg\" onClick={handleClick}>\n  Submit\n</Button>\n\n<Button variant=\"outline\" leftIcon={<PlusIcon />}>\n  Add Item\n</Button>\n\n<Button variant=\"danger\" isLoading={isSaving}>\n  Delete\n</Button>\n\n<Button as=\"a\" href=\"/home\">  {/* As link */}\n  Go Home\n</Button>\n```"}
{"prompt": "How do I implement rate limiting in a Node.js API?", "response": "**Rate limiting strategies for Node.js:**\n\n**1. Using express-rate-limit (simple):**\n```javascript\nimport rateLimit from 'express-rate-limit';\n\n// Global rate limit\nconst globalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // 100 requests per window\n  message: { error: 'Too many requests, please try again later' },\n  standardHeaders: true, // Return rate limit info in headers\n  legacyHeaders: false,\n});\n\napp.use(globalLimiter);\n\n// Strict limit for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 5, // 5 attempts per hour\n  skipSuccessfulRequests: true, // Don't count successful logins\n});\n\napp.post('/api/login', authLimiter, loginHandler);\n```\n\n**2. Redis-backed for distributed systems:**\n```javascript\nimport { RateLimiterRedis } from 'rate-limiter-flexible';\nimport Redis from 'ioredis';\n\nconst redisClient = new Redis(process.env.REDIS_URL);\n\nconst rateLimiter = new RateLimiterRedis({\n  storeClient: redisClient,\n  keyPrefix: 'rl',\n  points: 100, // Requests\n  duration: 60, // Per 60 seconds\n  blockDuration: 60 * 10, // Block for 10 min if exceeded\n});\n\nconst rateLimitMiddleware = async (req, res, next) => {\n  try {\n    const key = req.ip; // Or req.user?.id for authenticated users\n    await rateLimiter.consume(key);\n    next();\n  } catch (rejRes) {\n    const retryAfter = Math.ceil(rejRes.msBeforeNext / 1000);\n    res.set('Retry-After', retryAfter);\n    res.status(429).json({\n      error: 'Too many requests',\n      retryAfter\n    });\n  }\n};\n\napp.use(rateLimitMiddleware);\n```\n\n**3. Token bucket algorithm:**\n```javascript\nclass TokenBucket {\n  constructor(capacity, refillRate) {\n    this.capacity = capacity;\n    this.tokens = capacity;\n    this.refillRate = refillRate; // tokens per second\n    this.lastRefill = Date.now();\n  }\n\n  consume(tokens = 1) {\n    this.refill();\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n    return false;\n  }\n\n  refill() {\n    const now = Date.now();\n    const elapsed = (now - this.lastRefill) / 1000;\n    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillRate);\n    this.lastRefill = now;\n  }\n}\n\n// Per-user buckets\nconst buckets = new Map();\n\nfunction getUserBucket(userId) {\n  if (!buckets.has(userId)) {\n    buckets.set(userId, new TokenBucket(100, 10)); // 100 capacity, 10/sec refill\n  }\n  return buckets.get(userId);\n}\n```\n\n**4. Tiered limits by user type:**\n```javascript\nconst limits = {\n  free: { points: 100, duration: 3600 },\n  pro: { points: 1000, duration: 3600 },\n  enterprise: { points: 10000, duration: 3600 }\n};\n\nconst dynamicLimiter = async (req, res, next) => {\n  const userTier = req.user?.tier || 'free';\n  const config = limits[userTier];\n  // Apply limit based on config\n};\n```\n\n**Response headers:**\n```\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 95\nX-RateLimit-Reset: 1640000000\nRetry-After: 60\n```"}
{"prompt": "How do I implement WebSocket communication in a web application?", "response": "**WebSocket implementation with reconnection and heartbeat:**\n\n**Server (Node.js with ws):**\n```javascript\nimport { WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\nconst server = createServer(app);\nconst wss = new WebSocketServer({ server });\n\n// Track connected clients\nconst clients = new Map();\n\nwss.on('connection', (ws, req) => {\n  const userId = req.url.split('userId=')[1];\n  clients.set(userId, ws);\n  \n  console.log(`Client connected: ${userId}`);\n  \n  // Heartbeat\n  ws.isAlive = true;\n  ws.on('pong', () => { ws.isAlive = true; });\n  \n  // Handle messages\n  ws.on('message', (data) => {\n    try {\n      const message = JSON.parse(data);\n      handleMessage(ws, userId, message);\n    } catch (e) {\n      ws.send(JSON.stringify({ error: 'Invalid message format' }));\n    }\n  });\n  \n  ws.on('close', () => {\n    clients.delete(userId);\n    console.log(`Client disconnected: ${userId}`);\n  });\n  \n  // Send welcome message\n  ws.send(JSON.stringify({ type: 'connected', userId }));\n});\n\n// Heartbeat interval\nsetInterval(() => {\n  wss.clients.forEach((ws) => {\n    if (!ws.isAlive) return ws.terminate();\n    ws.isAlive = false;\n    ws.ping();\n  });\n}, 30000);\n\n// Broadcast to all clients\nfunction broadcast(message, excludeUserId = null) {\n  const data = JSON.stringify(message);\n  clients.forEach((ws, id) => {\n    if (id !== excludeUserId && ws.readyState === ws.OPEN) {\n      ws.send(data);\n    }\n  });\n}\n\n// Send to specific user\nfunction sendToUser(userId, message) {\n  const ws = clients.get(userId);\n  if (ws?.readyState === ws.OPEN) {\n    ws.send(JSON.stringify(message));\n  }\n}\n```\n\n**Client (React hook):**\n```javascript\nimport { useEffect, useRef, useState, useCallback } from 'react';\n\nfunction useWebSocket(url) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastMessage, setLastMessage] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n\n  const connect = useCallback(() => {\n    const ws = new WebSocket(url);\n    wsRef.current = ws;\n\n    ws.onopen = () => {\n      setIsConnected(true);\n      reconnectAttempts.current = 0;\n      console.log('WebSocket connected');\n    };\n\n    ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      setLastMessage(data);\n    };\n\n    ws.onclose = () => {\n      setIsConnected(false);\n      // Exponential backoff reconnection\n      const delay = Math.min(1000 * 2 ** reconnectAttempts.current, 30000);\n      reconnectAttempts.current++;\n      reconnectTimeoutRef.current = setTimeout(connect, delay);\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }, [url]);\n\n  useEffect(() => {\n    connect();\n    return () => {\n      clearTimeout(reconnectTimeoutRef.current);\n      wsRef.current?.close();\n    };\n  }, [connect]);\n\n  const sendMessage = useCallback((message) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    }\n  }, []);\n\n  return { isConnected, lastMessage, sendMessage };\n}\n\n// Usage\nfunction Chat() {\n  const { isConnected, lastMessage, sendMessage } = useWebSocket(\n    `ws://localhost:3001?userId=${userId}`\n  );\n\n  useEffect(() => {\n    if (lastMessage?.type === 'chat') {\n      addMessage(lastMessage);\n    }\n  }, [lastMessage]);\n\n  return (\n    <div>\n      <span>{isConnected ? '[connected]' : '[disconnected]'}</span>\n      <button onClick={() => sendMessage({ type: 'chat', text: 'Hello' })}>\n        Send\n      </button>\n    </div>\n  );\n}\n```\n\n**For production:** Consider Socket.IO for fallback transport and rooms support."}
{"prompt": "How do I deploy a React application?", "response": "**Deployment options for React applications:**\n\n**1. Vercel (Recommended for most projects):**\n```bash\n# Install Vercel CLI\nnpm i -g vercel\n\n# Deploy\nvercel\n\n# Or connect GitHub repo at vercel.com\n```\n\n**vercel.json:**\n```json\n{\n  \"rewrites\": [\n    { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n  ]\n}\n```\n\n**2. Netlify:**\n```bash\n# Build command: npm run build\n# Publish directory: dist (or build)\n```\n\n**netlify.toml:**\n```toml\n[build]\n  command = \"npm run build\"\n  publish = \"dist\"\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n```\n\n**3. AWS S3 + CloudFront:**\n```bash\n# Build\nnpm run build\n\n# Sync to S3\naws s3 sync dist/ s3://my-bucket --delete\n\n# Invalidate CloudFront cache\naws cloudfront create-invalidation \\\n  --distribution-id XXXXX \\\n  --paths \"/*\"\n```\n\n**4. Docker:**\n```dockerfile\n# Build stage\nFROM node:20-alpine AS build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM nginx:alpine\nCOPY --from=build /app/dist /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n**nginx.conf:**\n```nginx\nserver {\n    listen 80;\n    root /usr/share/nginx/html;\n    index index.html;\n    \n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n    \n    location /assets {\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n}\n```\n\n**5. GitHub Pages:**\n```json\n// package.json\n{\n  \"homepage\": \"https://username.github.io/repo-name\",\n  \"scripts\": {\n    \"predeploy\": \"npm run build\",\n    \"deploy\": \"gh-pages -d dist\"\n  }\n}\n```\n\n**Environment variables:**\n```bash\n# Build with production env\nVITE_API_URL=https://api.prod.com npm run build\n```\n\n**CI/CD with GitHub Actions:**\n```yaml\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm ci\n      - run: npm run build\n      - uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./dist\n```\n\n**Key considerations:**\n- SPA routing needs server-side fallback to index.html\n- Enable GZIP/Brotli compression\n- Set cache headers for static assets\n- Use CDN for global distribution"}
{"prompt": "How do I create and validate forms in React with React Hook Form and Zod?", "response": "**Complete form setup with React Hook Form + Zod:**\n\n**Installation:**\n```bash\nnpm install react-hook-form zod @hookform/resolvers\n```\n\n**Define schema:**\n```typescript\nimport { z } from 'zod';\n\nexport const signupSchema = z.object({\n  email: z.string()\n    .min(1, 'Email is required')\n    .email('Invalid email address'),\n  \n  password: z.string()\n    .min(8, 'Password must be at least 8 characters')\n    .regex(/[A-Z]/, 'Must contain uppercase letter')\n    .regex(/[0-9]/, 'Must contain number'),\n  \n  confirmPassword: z.string(),\n  \n  age: z.coerce.number()\n    .min(18, 'Must be at least 18')\n    .max(120, 'Invalid age'),\n  \n  website: z.string().url().optional().or(z.literal('')),\n  \n  terms: z.boolean().refine(val => val, 'Must accept terms'),\n  \n  role: z.enum(['user', 'admin', 'moderator']),\n  \n  interests: z.array(z.string()).min(1, 'Select at least one'),\n}).refine(data => data.password === data.confirmPassword, {\n  message: 'Passwords do not match',\n  path: ['confirmPassword'],\n});\n\nexport type SignupFormData = z.infer<typeof signupSchema>;\n```\n\n**Form component:**\n```tsx\nimport { useForm, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { signupSchema, SignupFormData } from './schema';\n\nfunction SignupForm() {\n  const {\n    register,\n    handleSubmit,\n    control,\n    formState: { errors, isSubmitting },\n    watch,\n    reset,\n  } = useForm<SignupFormData>({\n    resolver: zodResolver(signupSchema),\n    defaultValues: {\n      email: '',\n      password: '',\n      confirmPassword: '',\n      terms: false,\n      role: 'user',\n      interests: [],\n    },\n  });\n\n  const onSubmit = async (data: SignupFormData) => {\n    try {\n      await api.signup(data);\n      reset();\n    } catch (error) {\n      // Handle error\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} noValidate>\n      {/* Text input */}\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          {...register('email')}\n          aria-invalid={!!errors.email}\n        />\n        {errors.email && (\n          <span role=\"alert\">{errors.email.message}</span>\n        )}\n      </div>\n\n      {/* Password with show/hide */}\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          {...register('password')}\n        />\n        {errors.password && (\n          <span role=\"alert\">{errors.password.message}</span>\n        )}\n      </div>\n\n      {/* Select with Controller */}\n      <div>\n        <label htmlFor=\"role\">Role</label>\n        <Controller\n          name=\"role\"\n          control={control}\n          render={({ field }) => (\n            <select {...field}>\n              <option value=\"user\">User</option>\n              <option value=\"admin\">Admin</option>\n              <option value=\"moderator\">Moderator</option>\n            </select>\n          )}\n        />\n      </div>\n\n      {/* Checkbox */}\n      <div>\n        <label>\n          <input type=\"checkbox\" {...register('terms')} />\n          Accept terms and conditions\n        </label>\n        {errors.terms && <span>{errors.terms.message}</span>}\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Submitting...' : 'Sign Up'}\n      </button>\n    </form>\n  );\n}\n```\n\n**Reusable input component:**\n```tsx\ninterface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  label: string;\n  error?: string;\n}\n\nconst Input = forwardRef<HTMLInputElement, InputProps>(\n  ({ label, error, ...props }, ref) => (\n    <div className=\"form-group\">\n      <label htmlFor={props.id}>{label}</label>\n      <input ref={ref} aria-invalid={!!error} {...props} />\n      {error && <span className=\"error\">{error}</span>}\n    </div>\n  )\n);\n\n// Usage\n<Input\n  label=\"Email\"\n  id=\"email\"\n  error={errors.email?.message}\n  {...register('email')}\n/>\n```"}
{"prompt": "What are some common React performance optimization techniques?", "response": "**React performance optimization strategies:**\n\n**1. Memoization:**\n```jsx\n// React.memo for components\nconst ExpensiveComponent = React.memo(({ data }) => {\n  return <div>{/* expensive render */}</div>;\n});\n\n// With custom comparison\nconst MemoizedList = React.memo(List, (prevProps, nextProps) => {\n  return prevProps.items.length === nextProps.items.length;\n});\n\n// useMemo for expensive calculations\nconst sortedData = useMemo(() => {\n  return data.sort((a, b) => a.name.localeCompare(b.name));\n}, [data]);\n\n// useCallback for stable function references\nconst handleClick = useCallback((id) => {\n  setSelected(id);\n}, []); // Empty deps = stable reference\n```\n\n**2. Virtualization for long lists:**\n```jsx\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualizedList({ items }) {\n  return (\n    <FixedSizeList\n      height={400}\n      width=\"100%\"\n      itemCount={items.length}\n      itemSize={50}\n    >\n      {({ index, style }) => (\n        <div style={style}>{items[index].name}</div>\n      )}\n    </FixedSizeList>\n  );\n}\n```\n\n**3. Code splitting:**\n```jsx\n// Route-level splitting\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Settings = lazy(() => import('./Settings'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <Routes>\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/settings\" element={<Settings />} />\n      </Routes>\n    </Suspense>\n  );\n}\n\n// Component-level splitting\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n```\n\n**4. Avoid unnecessary re-renders:**\n```jsx\n// Bad: Creates new object every render\n<Component style={{ color: 'red' }} />\n\n// Good: Stable reference\nconst style = useMemo(() => ({ color: 'red' }), []);\n<Component style={style} />\n\n// Bad: Inline function creates new reference\n<button onClick={() => handleClick(id)} />\n\n// Good: Stable callback\nconst onClick = useCallback(() => handleClick(id), [id]);\n<button onClick={onClick} />\n```\n\n**5. State management optimization:**\n```jsx\n// Split state to minimize re-renders\nconst [user, setUser] = useState(null);\nconst [posts, setPosts] = useState([]);\n// Instead of: { user, posts } in one state\n\n// Use useReducer for complex state\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n**6. Debounce expensive operations:**\n```jsx\nconst debouncedSearch = useMemo(\n  () => debounce((query) => fetchResults(query), 300),\n  []\n);\n\nuseEffect(() => {\n  debouncedSearch(searchTerm);\n  return () => debouncedSearch.cancel();\n}, [searchTerm]);\n```\n\n**7. Optimize images:**\n```jsx\n// Use next/image or similar\n<Image\n  src=\"/photo.jpg\"\n  width={800}\n  height={600}\n  loading=\"lazy\"\n  placeholder=\"blur\"\n/>\n```\n\n**8. Profiling:**\n```jsx\nimport { Profiler } from 'react';\n\n<Profiler id=\"App\" onRender={(id, phase, duration) => {\n  console.log(`${id} ${phase}: ${duration}ms`);\n}}>\n  <App />\n</Profiler>\n```\n\n**Use React DevTools Profiler** to identify slow components and unnecessary re-renders."}
{"prompt": "How do I configure Tailwind CSS in a React project?", "response": "**Tailwind CSS setup for React (Vite):**\n\n**1. Installation:**\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n**2. tailwind.config.js:**\n```javascript\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\n    './index.html',\n    './src/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#eff6ff',\n          500: '#3b82f6',\n          600: '#2563eb',\n          700: '#1d4ed8',\n        },\n        secondary: '#64748b',\n      },\n      fontFamily: {\n        sans: ['Inter', 'system-ui', 'sans-serif'],\n      },\n      spacing: {\n        '128': '32rem',\n      },\n      animation: {\n        'fade-in': 'fadeIn 0.3s ease-in-out',\n      },\n      keyframes: {\n        fadeIn: {\n          '0%': { opacity: '0' },\n          '100%': { opacity: '1' },\n        },\n      },\n    },\n  },\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n  ],\n}\n```\n\n**3. src/index.css:**\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  html {\n    @apply scroll-smooth;\n  }\n  body {\n    @apply bg-gray-50 text-gray-900 antialiased;\n  }\n}\n\n@layer components {\n  .btn {\n    @apply px-4 py-2 rounded-lg font-medium transition-colors;\n  }\n  .btn-primary {\n    @apply bg-primary-500 text-white hover:bg-primary-600;\n  }\n  .input {\n    @apply w-full px-3 py-2 border border-gray-300 rounded-lg\n           focus:ring-2 focus:ring-primary-500 focus:border-transparent;\n  }\n  .card {\n    @apply bg-white rounded-xl shadow-md p-6;\n  }\n}\n\n@layer utilities {\n  .text-balance {\n    text-wrap: balance;\n  }\n}\n```\n\n**4. Usage in components:**\n```jsx\nfunction Card({ title, children }) {\n  return (\n    <div className=\"card hover:shadow-lg transition-shadow\">\n      <h2 className=\"text-xl font-bold text-gray-900 mb-4\">{title}</h2>\n      <div className=\"text-gray-600\">{children}</div>\n    </div>\n  );\n}\n\nfunction Button({ variant = 'primary', children, ...props }) {\n  const variants = {\n    primary: 'btn btn-primary',\n    secondary: 'btn bg-gray-200 text-gray-900 hover:bg-gray-300',\n    outline: 'btn border-2 border-primary-500 text-primary-500 hover:bg-primary-50',\n  };\n  \n  return (\n    <button className={variants[variant]} {...props}>\n      {children}\n    </button>\n  );\n}\n```\n\n**5. Conditional classes with clsx:**\n```bash\nnpm install clsx\n```\n\n```jsx\nimport clsx from 'clsx';\n\nfunction Alert({ type, children }) {\n  return (\n    <div className={clsx(\n      'p-4 rounded-lg',\n      {\n        'bg-green-100 text-green-800': type === 'success',\n        'bg-red-100 text-red-800': type === 'error',\n        'bg-yellow-100 text-yellow-800': type === 'warning',\n      }\n    )}>\n      {children}\n    </div>\n  );\n}\n```\n\n**6. VS Code setup:**\n```json\n// .vscode/settings.json\n{\n  \"tailwindCSS.experimental.classRegex\": [\n    [\"clsx\\\\(([^)]*)\\\\)\", \"'([^']*)'\"],\n    [\"cva\\\\(([^)]*)\\\\)\", \"[\\\"'`]([^\\\"'`]*).*?[\\\"'`]\"]\n  ]\n}\n```\n\n**7. Dark mode:**\n```javascript\n// tailwind.config.js\ndarkMode: 'class', // or 'media'\n```\n\n```jsx\n<div className=\"bg-white dark:bg-gray-900 text-gray-900 dark:text-white\">\n  Dark mode ready!\n</div>\n```"}
