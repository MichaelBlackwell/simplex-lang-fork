name: Build Simplex Compiler

on:
  push:
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

jobs:
  build-linux:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64]

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y clang llvm libssl-dev libsqlite3-dev

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Build compiler
      run: |
        echo "=== Building Simplex Compiler for Linux ==="
        # Bootstrap: compile .sx files to .ll
        cd compiler/bootstrap
        python3 stage0.py lexer.sx
        python3 stage0.py parser.sx
        python3 stage0.py codegen.sx
        python3 stage0.py main.sx
        # Merge LLVM IR files
        python3 << 'EOF'
        import re
        def extract_function_defs(content):
            funcs = {}
            pattern = r'define\s+(?:internal\s+)?[^\s]+\s+@"?([^"(\s]+)"?\s*\('
            lines = content.split('\n')
            i = 0
            while i < len(lines):
                line = lines[i]
                m = re.match(pattern, line)
                if m:
                    func_name = m.group(1)
                    func_lines = [line]
                    i += 1
                    brace_count = line.count('{') - line.count('}')
                    while i < len(lines) and brace_count > 0:
                        func_lines.append(lines[i])
                        brace_count += lines[i].count('{') - lines[i].count('}')
                        i += 1
                    if i < len(lines) and lines[i] == '}':
                        func_lines.append(lines[i])
                        i += 1
                    funcs[func_name] = '\n'.join(func_lines)
                else:
                    i += 1
            return funcs
        def extract_strings(content):
            strings = {}
            for m in re.finditer(r'(@\.str\.[^\s]+)\s*=\s*private.*', content):
                strings[m.group(1)] = m.group(0)
            return strings
        def get_base_header(content):
            lines = content.split('\n')
            header_lines = []
            for line in lines:
                if line.startswith('define ') or line.startswith('@.str'):
                    continue
                if line.startswith('; ModuleID') or line.startswith('target ') or line.startswith('declare '):
                    header_lines.append(line)
            return '\n'.join(header_lines)
        with open('lexer.ll') as f: lexer = f.read()
        with open('parser.ll') as f: parser = f.read()
        with open('codegen.ll') as f: codegen = f.read()
        with open('main.ll') as f: main = f.read()
        header = get_base_header(lexer)
        all_strings = {}
        all_funcs = {}
        for content in [lexer, parser, codegen, main]:
            all_strings.update(extract_strings(content))
            for fn, body in extract_function_defs(content).items():
                if fn not in all_funcs:
                    all_funcs[fn] = body
        combined = header + '\n\n'
        for str_name, str_def in sorted(all_strings.items()):
            combined += str_def + '\n'
        combined += '\n'
        for fn_name, fn_body in sorted(all_funcs.items()):
            combined += fn_body + '\n\n'
        with open('sxc_combined.ll', 'w') as f:
            f.write(combined)
        print(f"Created sxc_combined.ll ({len(all_funcs)} functions)")
        EOF
        cd ../..
        # Link compiler
        clang -O2 \
          compiler/bootstrap/sxc_combined.ll \
          runtime/standalone_runtime.c \
          -o sxc-linux-x86_64 \
          -lm -lssl -lcrypto -lsqlite3 -lpthread
        # Verify
        chmod +x sxc-linux-x86_64
        ./sxc-linux-x86_64 --version || echo "Built successfully"
        # Show size
        ls -lh sxc-linux-x86_64
        
        # Pre-compile the runtime to .o for use with 'run' command
        echo "=== Pre-compiling runtime ==="
        clang -c -O2 runtime/standalone_runtime.c -o standalone_runtime.o
        ls -lh standalone_runtime.o

    - name: Run tests
      run: |
        echo "=== Running Tests ==="
        # Test compilation of a simple file
        cat > test_hello.sx << 'EOF'
        fn main() -> i64 {
            println("Hello from Simplex!");
            0
        }
        EOF
        ./sxc-linux-x86_64 test_hello.sx
        clang -O2 test_hello.ll runtime/standalone_runtime.c -o test_hello -lm -lssl -lcrypto -lsqlite3 -lpthread
        ./test_hello
        echo "Basic compilation test passed!"
        
        # Test 'run' command with runtime in same directory
        echo "=== Testing 'run' command ==="
        ./sxc-linux-x86_64 run test_hello.sx && echo "'run' command test passed!"

    - name: Prepare distribution
      run: |
        mkdir -p dist/sxc-linux-x86_64
        cp sxc-linux-x86_64 dist/sxc-linux-x86_64/
        cp standalone_runtime.o dist/sxc-linux-x86_64/
        cp runtime/standalone_runtime.c dist/sxc-linux-x86_64/
        # Create a simple README for the distribution
        cat > dist/sxc-linux-x86_64/README.txt << 'EOF'
        Simplex Compiler (sxc) - Linux x86_64

        Usage:
          ./sxc-linux-x86_64 <file.sx>        # Compile to LLVM IR
          ./sxc-linux-x86_64 run <file.sx>    # Compile and run (requires runtime)

        The 'run' command requires standalone_runtime.o to be in the current directory
        or in the same directory as the compiler binary.

        To manually compile and link:
          ./sxc-linux-x86_64 myfile.sx
          clang -O2 myfile.ll standalone_runtime.o -o myfile -lm -lssl -lcrypto -lsqlite3 -lpthread
          ./myfile
        EOF

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: sxc-linux-x86_64
        path: dist/sxc-linux-x86_64/

  build-macos:
    runs-on: macos-latest
    strategy:
      matrix:
        arch: [x86_64, arm64]

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        brew install openssl@3 sqlite3

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Build compiler
      run: |
        echo "=== Building Simplex Compiler for macOS (${{ matrix.arch }}) ==="
        # Get paths
        OPENSSL_PREFIX=$(brew --prefix openssl@3)
        SQLITE_PREFIX=$(brew --prefix sqlite3)
        # Bootstrap
        cd compiler/bootstrap
        python3 stage0.py lexer.sx
        python3 stage0.py parser.sx
        python3 stage0.py codegen.sx
        python3 stage0.py main.sx
        # Merge LLVM IR
        python3 << 'EOF'
        import re
        def extract_function_defs(content):
            funcs = {}
            pattern = r'define\s+(?:internal\s+)?[^\s]+\s+@"?([^"(\s]+)"?\s*\('
            lines = content.split('\n')
            i = 0
            while i < len(lines):
                line = lines[i]
                m = re.match(pattern, line)
                if m:
                    func_name = m.group(1)
                    func_lines = [line]
                    i += 1
                    brace_count = line.count('{') - line.count('}')
                    while i < len(lines) and brace_count > 0:
                        func_lines.append(lines[i])
                        brace_count += lines[i].count('{') - lines[i].count('}')
                        i += 1
                    if i < len(lines) and lines[i] == '}':
                        func_lines.append(lines[i])
                        i += 1
                    funcs[func_name] = '\n'.join(func_lines)
                else:
                    i += 1
            return funcs
        def extract_strings(content):
            strings = {}
            for m in re.finditer(r'(@\.str\.[^\s]+)\s*=\s*private.*', content):
                strings[m.group(1)] = m.group(0)
            return strings
        def get_base_header(content):
            lines = content.split('\n')
            header_lines = []
            for line in lines:
                if line.startswith('define ') or line.startswith('@.str'):
                    continue
                if line.startswith('; ModuleID') or line.startswith('target ') or line.startswith('declare '):
                    header_lines.append(line)
            return '\n'.join(header_lines)
        with open('lexer.ll') as f: lexer = f.read()
        with open('parser.ll') as f: parser = f.read()
        with open('codegen.ll') as f: codegen = f.read()
        with open('main.ll') as f: main = f.read()
        header = get_base_header(lexer)
        all_strings = {}
        all_funcs = {}
        for content in [lexer, parser, codegen, main]:
            all_strings.update(extract_strings(content))
            for fn, body in extract_function_defs(content).items():
                if fn not in all_funcs:
                    all_funcs[fn] = body
        combined = header + '\n\n'
        for str_name, str_def in sorted(all_strings.items()):
            combined += str_def + '\n'
        combined += '\n'
        for fn_name, fn_body in sorted(all_funcs.items()):
            combined += fn_body + '\n\n'
        with open('sxc_combined.ll', 'w') as f:
            f.write(combined)
        print(f"Created sxc_combined.ll ({len(all_funcs)} functions)")
        EOF
        cd ../..
        # Link compiler
        clang -O2 \
          -I$OPENSSL_PREFIX/include \
          -I$SQLITE_PREFIX/include \
          -L$OPENSSL_PREFIX/lib \
          -L$SQLITE_PREFIX/lib \
          compiler/bootstrap/sxc_combined.ll \
          runtime/standalone_runtime.c \
          -o sxc-macos-${{ matrix.arch }} \
          -lm -lssl -lcrypto -lsqlite3
        chmod +x sxc-macos-${{ matrix.arch }}
        ls -lh sxc-macos-${{ matrix.arch }}
        
        # Pre-compile the runtime to .o for use with 'run' command
        echo "=== Pre-compiling runtime ==="
        clang -c -O2 \
          -I$OPENSSL_PREFIX/include \
          -I$SQLITE_PREFIX/include \
          runtime/standalone_runtime.c \
          -o standalone_runtime.o
        ls -lh standalone_runtime.o

    - name: Run tests
      run: |
        OPENSSL_PREFIX=$(brew --prefix openssl@3)
        SQLITE_PREFIX=$(brew --prefix sqlite3)
        cat > test_hello.sx << 'EOF'
        fn main() -> i64 {
            println("Hello from Simplex!");
            0
        }
        EOF
        ./sxc-macos-${{ matrix.arch }} test_hello.sx
        clang -O2 \
          -I$OPENSSL_PREFIX/include -I$SQLITE_PREFIX/include \
          -L$OPENSSL_PREFIX/lib -L$SQLITE_PREFIX/lib \
          test_hello.ll runtime/standalone_runtime.c \
          -o test_hello -lm -lssl -lcrypto -lsqlite3
        ./test_hello
        
        # Test 'run' command
        echo "=== Testing 'run' command ==="
        ./sxc-macos-${{ matrix.arch }} run test_hello.sx && echo "'run' command test passed!"

    - name: Prepare distribution
      run: |
        mkdir -p dist/sxc-macos-${{ matrix.arch }}
        cp sxc-macos-${{ matrix.arch }} dist/sxc-macos-${{ matrix.arch }}/
        cp standalone_runtime.o dist/sxc-macos-${{ matrix.arch }}/
        cp runtime/standalone_runtime.c dist/sxc-macos-${{ matrix.arch }}/
        cat > dist/sxc-macos-${{ matrix.arch }}/README.txt << 'EOF'
        Simplex Compiler (sxc) - macOS

        Usage:
          ./sxc-macos-<arch> <file.sx>        # Compile to LLVM IR
          ./sxc-macos-<arch> run <file.sx>    # Compile and run (requires runtime)

        The 'run' command requires standalone_runtime.o to be in the current directory
        or in the same directory as the compiler binary.

        Dependencies (install via Homebrew):
          brew install openssl@3 sqlite3

        To manually compile and link:
          OPENSSL_PREFIX=$(brew --prefix openssl@3)
          SQLITE_PREFIX=$(brew --prefix sqlite3)
          ./sxc-macos-<arch> myfile.sx
          clang -O2 -L$OPENSSL_PREFIX/lib -L$SQLITE_PREFIX/lib \
            myfile.ll standalone_runtime.o -o myfile -lm -lssl -lcrypto -lsqlite3
          ./myfile
        EOF

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: sxc-macos-${{ matrix.arch }}
        path: dist/sxc-macos-${{ matrix.arch }}/

  build-windows:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v4

    - name: Install LLVM
      run: choco install llvm -y

    - name: Install OpenSSL
      run: choco install openssl -y

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Build compiler
      shell: bash
      run: |
        echo "=== Building Simplex Compiler for Windows ==="
        echo "Note: Windows build may have limited functionality"
        # Bootstrap
        cd compiler/bootstrap
        python stage0.py lexer.sx
        python stage0.py parser.sx
        python stage0.py codegen.sx
        python stage0.py main.sx
        # Merge LLVM IR
        python << 'EOF'
        import re
        def extract_function_defs(content):
            funcs = {}
            pattern = r'define\s+(?:internal\s+)?[^\s]+\s+@"?([^"(\s]+)"?\s*\('
            lines = content.split('\n')
            i = 0
            while i < len(lines):
                line = lines[i]
                m = re.match(pattern, line)
                if m:
                    func_name = m.group(1)
                    func_lines = [line]
                    i += 1
                    brace_count = line.count('{') - line.count('}')
                    while i < len(lines) and brace_count > 0:
                        func_lines.append(lines[i])
                        brace_count += lines[i].count('{') - lines[i].count('}')
                        i += 1
                    if i < len(lines) and lines[i] == '}':
                        func_lines.append(lines[i])
                        i += 1
                    funcs[func_name] = '\n'.join(func_lines)
                else:
                    i += 1
            return funcs
        def extract_strings(content):
            strings = {}
            for m in re.finditer(r'(@\.str\.[^\s]+)\s*=\s*private.*', content):
                strings[m.group(1)] = m.group(0)
            return strings
        def get_base_header(content):
            lines = content.split('\n')
            header_lines = []
            for line in lines:
                if line.startswith('define ') or line.startswith('@.str'):
                    continue
                if line.startswith('; ModuleID') or line.startswith('target ') or line.startswith('declare '):
                    header_lines.append(line)
            return '\n'.join(header_lines)
        with open('lexer.ll') as f: lexer = f.read()
        with open('parser.ll') as f: parser = f.read()
        with open('codegen.ll') as f: codegen = f.read()
        with open('main.ll') as f: main = f.read()
        header = get_base_header(lexer)
        all_strings = {}
        all_funcs = {}
        for content in [lexer, parser, codegen, main]:
            all_strings.update(extract_strings(content))
            for fn, body in extract_function_defs(content).items():
                if fn not in all_funcs:
                    all_funcs[fn] = body
        combined = header + '\n\n'
        for str_name, str_def in sorted(all_strings.items()):
            combined += str_def + '\n'
        combined += '\n'
        for fn_name, fn_body in sorted(all_funcs.items()):
            combined += fn_body + '\n\n'
        with open('sxc_combined.ll', 'w') as f:
            f.write(combined)
        print(f"Created sxc_combined.ll ({len(all_funcs)} functions)")
        EOF
        cd ../..
        echo "LLVM IR generated successfully"
        echo "Note: Full Windows binary requires runtime porting"
      continue-on-error: true

    - name: Upload LLVM IR artifact
      uses: actions/upload-artifact@v4
      with:
        name: sxc-windows-llvm-ir
        path: compiler/bootstrap/sxc_combined.ll
      if: always()

  release:
    needs: [build-linux, build-macos]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: List artifacts
      run: find artifacts -type f

    - name: Package releases
      run: |
        # Create tarballs/zips for each platform
        cd artifacts
        
        # Linux
        tar -czvf sxc-linux-x86_64.tar.gz -C sxc-linux-x86_64 .
        
        # macOS
        tar -czvf sxc-macos-x86_64.tar.gz -C sxc-macos-x86_64 .
        tar -czvf sxc-macos-arm64.tar.gz -C sxc-macos-arm64 .

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          artifacts/sxc-linux-x86_64.tar.gz
          artifacts/sxc-macos-x86_64.tar.gz
          artifacts/sxc-macos-arm64.tar.gz
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-suite:
    needs: [build-linux]
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y clang libssl-dev libsqlite3-dev

    - name: Download Linux binary
      uses: actions/download-artifact@v4
      with:
        name: sxc-linux-x86_64
        path: sxc-dist

    - name: Run test suite
      continue-on-error: true  # Some tests not yet supported by self-hosted compiler
      run: |
        chmod +x sxc-dist/sxc-linux-x86_64
        # Copy runtime to current directory for 'run' command to work
        cp sxc-dist/standalone_runtime.o .
        
        echo "=== Running Test Suite ==="
        PASS=0
        FAIL=0
        for category in basics types async actors; do
          echo ""
          echo "--- Testing $category ---"
          if [ -d "tests/$category" ]; then
            for test in tests/$category/*.sx; do
              name=$(basename "$test" .sx)
              echo -n "  $category/$name: "
              if sxc-dist/sxc-linux-x86_64 "$test" 2>/dev/null; then
                ll_file="${test%.sx}.ll"
                if clang -O2 "$ll_file" standalone_runtime.o -o "test_$name" -lm -lssl -lcrypto -lsqlite3 -lpthread 2>/dev/null; then
                  if timeout 10 "./test_$name" >/dev/null 2>&1; then
                    echo "PASS"
                    PASS=$((PASS + 1))
                  else
                    echo "FAIL (runtime)"
                    FAIL=$((FAIL + 1))
                  fi
                  rm -f "test_$name"
                else
                  echo "FAIL (link)"
                  FAIL=$((FAIL + 1))
                fi
                rm -f "$ll_file"
              else
                echo "FAIL (compile)"
                FAIL=$((FAIL + 1))
              fi
            done
          fi
        done
        echo ""
        echo "=== Results ==="
        echo "Passed: $PASS"
        echo "Failed: $FAIL"
        if [ $FAIL -gt 0 ]; then
          exit 1
        fi
