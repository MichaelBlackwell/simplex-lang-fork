// HTTP Server implementation
// Pure Simplex async server with io_uring support

use simplex_std::net::{TcpListener, TcpStream};
use simplex_std::io::{AsyncRead, AsyncWrite, BufReader, BufWriter};
use simplex_std::sync::{Arc, RwLock};
use simplex_std::collections::HashMap;
use crate::request::{Request, Method, Headers};
use crate::response::{Response, StatusCode};
use crate::router::Router;
use crate::middleware::Chain;

/// Server configuration
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub max_connections: usize,
    pub read_timeout_ms: u64,
    pub write_timeout_ms: u64,
    pub keep_alive: bool,
    pub max_request_size: usize,
    pub workers: usize,
}

impl ServerConfig {
    pub fn new() -> Self {
        ServerConfig {
            host: "0.0.0.0".to_string(),
            port: 8080,
            max_connections: 10000,
            read_timeout_ms: 30000,
            write_timeout_ms: 30000,
            keep_alive: true,
            max_request_size: 10 * 1024 * 1024, // 10MB
            workers: num_cpus(),
        }
    }

    pub fn host(mut self, host: &str) -> Self {
        self.host = host.to_string();
        self
    }

    pub fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }

    pub fn workers(mut self, workers: usize) -> Self {
        self.workers = workers;
        self
    }
}

/// HTTP Server
pub struct HttpServer {
    config: ServerConfig,
    router: Arc<Router>,
    middleware: Arc<Chain>,
    state: Arc<RwLock<ServerState>>,
}

struct ServerState {
    connections: usize,
    requests_handled: u64,
    bytes_sent: u64,
    bytes_received: u64,
}

impl HttpServer {
    pub fn new(config: ServerConfig) -> Self {
        HttpServer {
            config,
            router: Arc::new(Router::new()),
            middleware: Arc::new(Chain::new()),
            state: Arc::new(RwLock::new(ServerState {
                connections: 0,
                requests_handled: 0,
                bytes_sent: 0,
                bytes_received: 0,
            })),
        }
    }

    pub fn router(mut self, router: Router) -> Self {
        self.router = Arc::new(router);
        self
    }

    pub fn middleware(mut self, middleware: Chain) -> Self {
        self.middleware = Arc::new(middleware);
        self
    }

    /// Start the HTTP server
    pub async fn serve(self) -> Result<(), HttpError> {
        let addr = format!("{}:{}", self.config.host, self.config.port);
        let listener = TcpListener::bind(&addr).await?;

        println(f"[codex] HTTP server listening on {addr}");
        println(f"[codex] Workers: {self.config.workers}");

        let server = Arc::new(self);

        loop {
            match listener.accept().await {
                Ok((stream, addr)) => {
                    let server = Arc::clone(&server);
                    spawn(async move {
                        if let Err(e) = server.handle_connection(stream, addr).await {
                            eprintln(f"[codex] Connection error: {e}");
                        }
                    });
                }
                Err(e) => {
                    eprintln(f"[codex] Accept error: {e}");
                }
            }
        }
    }

    async fn handle_connection(&self, stream: TcpStream, addr: SocketAddr) -> Result<(), HttpError> {
        // Update connection count
        {
            let mut state = self.state.write().await;
            state.connections += 1;
        }

        let mut reader = BufReader::new(&stream);
        let mut writer = BufWriter::new(&stream);

        loop {
            // Parse request
            let request = match self.parse_request(&mut reader).await {
                Ok(req) => req,
                Err(HttpError::ConnectionClosed) => break,
                Err(e) => {
                    let response = Response::error(StatusCode::BadRequest, e.to_string());
                    self.write_response(&mut writer, &response).await?;
                    break;
                }
            };

            // Record request
            {
                let mut state = self.state.write().await;
                state.requests_handled += 1;
            }

            // Apply middleware and route
            let response = self.process_request(request).await;

            // Write response
            self.write_response(&mut writer, &response).await?;

            // Check keep-alive
            if !self.config.keep_alive || !response.keep_alive {
                break;
            }
        }

        // Update connection count
        {
            let mut state = self.state.write().await;
            state.connections -= 1;
        }

        Ok(())
    }

    async fn parse_request(&self, reader: &mut BufReader<&TcpStream>) -> Result<Request, HttpError> {
        // Read request line
        let line = reader.read_line().await?;
        if line.is_empty() {
            return Err(HttpError::ConnectionClosed);
        }

        let parts: Vec<&str> = line.trim().split(' ').collect();
        if parts.len() < 3 {
            return Err(HttpError::MalformedRequest("Invalid request line".to_string()));
        }

        let method = Method::from_str(parts[0])?;
        let path = parts[1].to_string();
        let version = parts[2].to_string();

        // Parse headers
        let mut headers = Headers::new();
        loop {
            let line = reader.read_line().await?;
            if line.trim().is_empty() {
                break;
            }
            if let Some((key, value)) = line.split_once(':') {
                headers.insert(key.trim().to_lowercase(), value.trim().to_string());
            }
        }

        // Parse body if present
        let body = if let Some(len) = headers.get("content-length") {
            let len: usize = len.parse().unwrap_or(0);
            if len > self.config.max_request_size {
                return Err(HttpError::RequestTooLarge);
            }
            if len > 0 {
                let mut buf = vec![0u8; len];
                reader.read_exact(&mut buf).await?;
                Some(buf)
            } else {
                None
            }
        } else {
            None
        };

        Ok(Request {
            method,
            path,
            version,
            headers,
            body,
            query: HashMap::new(),
            params: HashMap::new(),
        })
    }

    async fn process_request(&self, mut request: Request) -> Response {
        // Apply pre-middleware
        for mw in self.middleware.pre.iter() {
            match mw.before(&mut request).await {
                Ok(()) => continue,
                Err(response) => return response,
            }
        }

        // Route request
        let mut response = match self.router.route(&request) {
            Some(handler) => handler.handle(request).await,
            None => Response::error(StatusCode::NotFound, "Not found".to_string()),
        };

        // Apply post-middleware
        for mw in self.middleware.post.iter() {
            mw.after(&mut response).await;
        }

        response
    }

    async fn write_response(&self, writer: &mut BufWriter<&TcpStream>, response: &Response) -> Result<(), HttpError> {
        // Write status line
        let status_line = format!("HTTP/1.1 {} {}\r\n", response.status.code(), response.status.reason());
        writer.write_all(status_line.as_bytes()).await?;

        // Write headers
        for (key, value) in response.headers.iter() {
            let header = format!("{}: {}\r\n", key, value);
            writer.write_all(header.as_bytes()).await?;
        }

        // Content-Length
        if let Some(ref body) = response.body {
            let len_header = format!("Content-Length: {}\r\n", body.len());
            writer.write_all(len_header.as_bytes()).await?;
        }

        // End headers
        writer.write_all(b"\r\n").await?;

        // Write body
        if let Some(ref body) = response.body {
            writer.write_all(body).await?;
        }

        writer.flush().await?;
        Ok(())
    }

    /// Get server statistics
    pub async fn stats(&self) -> ServerStats {
        let state = self.state.read().await;
        ServerStats {
            connections: state.connections,
            requests_handled: state.requests_handled,
            bytes_sent: state.bytes_sent,
            bytes_received: state.bytes_received,
        }
    }
}

pub struct ServerStats {
    pub connections: usize,
    pub requests_handled: u64,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

#[derive(Debug)]
pub enum HttpError {
    IoError(String),
    MalformedRequest(String),
    ConnectionClosed,
    RequestTooLarge,
    Timeout,
}

impl From<std::io::Error> for HttpError {
    fn from(e: std::io::Error) -> Self {
        HttpError::IoError(e.to_string())
    }
}

fn num_cpus() -> usize {
    // Get CPU count from system
    @extern("sysconf", "_SC_NPROCESSORS_ONLN") as usize
}
