// sxpm - Simplex Package Manager
// Build tool and package manager for Simplex projects
// Part of Phase 2: Package Ecosystem

fn SXPM_VERSION() -> i64 { "0.1.5" }

// ============================================================================
// Help and Version
// ============================================================================

fn sxpm_show_help() {
    println("sxpm - Simplex Package Manager");
    println("");
    println("USAGE:");
    println("    sxpm <COMMAND> [OPTIONS]");
    println("");
    println("COMMANDS:");
    println("    new <name>           Create a new package");
    println("    init                 Initialize package in current directory");
    println("    build                Build the current package");
    println("    run                  Build and run the current package");
    println("    test                 Run tests");
    println("    check                Type check without building");
    println("    clean                Remove build artifacts");
    println("    add <package>        Add a dependency");
    println("    remove <package>     Remove a dependency");
    println("    update               Update dependencies");
    println("    search <query>       Search for packages");
    println("    info <package>       Show package information");
    println("    install <package>    Install a package");
    println("");
    println("OPTIONS:");
    println("    -h, --help           Show this help");
    println("    --version            Show version");
    println("    --release            Build in release mode");
    println("    -v, --verbose        Verbose output");
}

fn sxpm_show_version() {
    print("sxpm ");
    println(SXPM_VERSION());
}

// ============================================================================
// Project Templates
// ============================================================================

fn template_main_sx() -> i64 {
    "fn main() {\n    println(\"Hello, Simplex!\");\n}\n"
}

fn template_lib_sx() -> i64 {
    "// Library entry point\n\npub fn hello() -> i64 {\n    println(\"Hello from library!\");\n    0\n}\n"
}

fn template_gitignore() -> i64 {
    "/target/\n*.ll\n*.o\n*.sxb\n"
}

fn template_manifest(name: i64, is_lib: bool) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, "{\n");
    sb_append(sb, "  \"name\": \"");
    sb_append(sb, name);
    sb_append(sb, "\",\n");
    sb_append(sb, "  \"version\": \"0.1.0\",\n");
    sb_append(sb, "  \"authors\": [],\n");
    sb_append(sb, "  \"description\": \"\",\n");
    sb_append(sb, "  \"license\": \"MIT\",\n");
    sb_append(sb, "  \"build\": {\n");
    sb_append(sb, "    \"entry\": \"src/");
    if is_lib {
        sb_append(sb, "lib.sx");
    } else {
        sb_append(sb, "main.sx");
    }
    sb_append(sb, "\"\n");
    sb_append(sb, "  },\n");
    sb_append(sb, "  \"dependencies\": {}\n");
    sb_append(sb, "}\n");
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

fn template_test_sx(name: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, "// Tests for ");
    sb_append(sb, name);
    sb_append(sb, "\n\n");
    sb_append(sb, "fn test_example() {\n");
    sb_append(sb, "    // Add your tests here\n");
    sb_append(sb, "    println(\"PASS: example test\");\n");
    sb_append(sb, "}\n\n");
    sb_append(sb, "fn main() {\n");
    sb_append(sb, "    test_example();\n");
    sb_append(sb, "}\n");
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

// ============================================================================
// File System Helpers
// ============================================================================

fn path_join(dir: i64, name: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, dir);
    if string_char_at(dir, string_len(dir) - 1) != 47 {  // '/'
        sb_append_char(sb, 47);
    }
    sb_append(sb, name);
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

fn mkdir_p(path: i64) -> i64 {
    // Use mkdir intrinsic (calls intrinsic_mkdir_p which handles -p behavior)
    mkdir(path)
}

// Note: file_exists is now a built-in intrinsic
// No need to redefine it here

fn check_file_exists(path: i64) -> bool {
    file_exists(path) != 0
}

fn write_file_safe(path: i64, content: i64) -> i64 {
    write_file(path, content)
}

// ============================================================================
// Manifest Parsing
// ============================================================================

fn manifest_load(path: i64) -> i64 {
    let content: i64 = read_file(path);
    if content == 0 {
        return 0;
    }
    json_parse(content)
}

fn manifest_name(manifest: i64) -> i64 {
    let opt: i64 = json_get(manifest, "name");
    if json_is_string(opt) {
        return json_as_string(opt);
    }
    "unknown"
}

fn manifest_version(manifest: i64) -> i64 {
    let opt: i64 = json_get(manifest, "version");
    if json_is_string(opt) {
        return json_as_string(opt);
    }
    "0.0.0"
}

fn manifest_entry(manifest: i64) -> i64 {
    let build: i64 = json_get(manifest, "build");
    if json_is_object(build) {
        let entry: i64 = json_get(build, "entry");
        if json_is_string(entry) {
            return json_as_string(entry);
        }
    }
    // Auto-detect: prefer lib.sx for libraries, main.sx for binaries
    if file_exists("src/lib.sx") {
        return "src/lib.sx";
    }
    if file_exists("src/main.sx") {
        return "src/main.sx";
    }
    // Fallback to main.sx (will error if not found)
    "src/main.sx"
}

/// Check if this package is a library (has src/lib.sx)
fn is_library_package() -> bool {
    file_exists("src/lib.sx")
}

/// Get the package type as a string
fn package_type() -> i64 {
    if is_library_package() {
        "library"
    } else {
        "binary"
    }
}

fn manifest_dependencies(manifest: i64) -> i64 {
    let deps: i64 = json_get(manifest, "dependencies");
    if json_is_object(deps) {
        // Convert to vec of (name, value) pairs
        let keys: i64 = json_keys(deps);
        let result: i64 = vec_new();
        var i: i64 = 0;
        while i < vec_len(keys) {
            let key: i64 = vec_get(keys, i);
            let value: i64 = json_get(deps, key);
            // Create dependency entry: (name, value_json)
            let dep: i64 = malloc(16);
            store_ptr(dep, 0, key);
            store_ptr(dep, 1, value);
            vec_push(result, dep);
            i = i + 1;
        }
        return result;
    }
    vec_new()
}

fn manifest_to_json(manifest: i64) -> i64 {
    json_stringify(manifest)
}

fn manifest_validate(manifest: i64) -> i64 {
    // Returns a Vec of error messages (empty if valid)
    let errors: i64 = vec_new();

    // Check required fields
    let name: i64 = json_get(manifest, "name");
    if json_is_string(name) == false {
        vec_push(errors, "missing 'name' field");
    }

    let version: i64 = json_get(manifest, "version");
    if json_is_string(version) == false {
        vec_push(errors, "missing 'version' field");
    }

    errors
}

// ============================================================================
// Version Range Support (Semver)
// ============================================================================

/// Parse a semver version string into (major, minor, patch) components
/// Returns a tuple pointer: (i64, i64, i64)
fn version_parse(version: i64) -> i64 {
    let result: i64 = malloc(24)  // 3 * 8 bytes
    store_i64(result, 0, 0)       // major
    store_i64(result, 1, 0)       // minor
    store_i64(result, 2, 0)       // patch

    let parts: i64 = string_split(version, ".")
    if vec_len(parts) >= 1 {
        let major_str: i64 = vec_get(parts, 0)
        store_i64(result, 0, string_to_int(major_str))
    }
    if vec_len(parts) >= 2 {
        let minor_str: i64 = vec_get(parts, 1)
        store_i64(result, 1, string_to_int(minor_str))
    }
    if vec_len(parts) >= 3 {
        let patch_str: i64 = vec_get(parts, 2)
        // Handle pre-release suffixes like "1.0.0-beta"
        let patch_clean: i64 = string_split(patch_str, "-")
        store_i64(result, 2, string_to_int(vec_get(patch_clean, 0)))
    }
    result
}

/// Get major version from parsed version tuple
fn version_major(v: i64) -> i64 { load_i64(v, 0) }

/// Get minor version from parsed version tuple
fn version_minor(v: i64) -> i64 { load_i64(v, 1) }

/// Get patch version from parsed version tuple
fn version_patch(v: i64) -> i64 { load_i64(v, 2) }

/// Compare two versions: returns -1 if a < b, 0 if a == b, 1 if a > b
fn version_compare(a: i64, b: i64) -> i64 {
    let a_major: i64 = version_major(a)
    let b_major: i64 = version_major(b)
    if a_major < b_major { return -1 }
    if a_major > b_major { return 1 }

    let a_minor: i64 = version_minor(a)
    let b_minor: i64 = version_minor(b)
    if a_minor < b_minor { return -1 }
    if a_minor > b_minor { return 1 }

    let a_patch: i64 = version_patch(a)
    let b_patch: i64 = version_patch(b)
    if a_patch < b_patch { return -1 }
    if a_patch > b_patch { return 1 }

    0
}

/// Check if a version satisfies a version constraint
/// Supports: *, ^1.2.3, ~1.2.3, >=1.2.3, <=1.2.3, >1.2.3, <1.2.3, =1.2.3, 1.2.3
fn version_satisfies(version_str: i64, constraint: i64) -> bool {
    // Wildcard matches everything
    if string_eq(constraint, "*") {
        return true
    }

    let version: i64 = version_parse(version_str)

    // Parse constraint prefix
    var offset: i64 = 0
    var op: i64 = "="

    // Check for ^, ~, >=, <=, >, <
    if string_starts_with(constraint, "^") {
        op = "^"
        offset = 1
    } else if string_starts_with(constraint, "~") {
        op = "~"
        offset = 1
    } else if string_starts_with(constraint, ">=") {
        op = ">="
        offset = 2
    } else if string_starts_with(constraint, "<=") {
        op = "<="
        offset = 2
    } else if string_starts_with(constraint, ">") {
        op = ">"
        offset = 1
    } else if string_starts_with(constraint, "<") {
        op = "<"
        offset = 1
    } else if string_starts_with(constraint, "=") {
        op = "="
        offset = 1
    }

    let constraint_ver_str: i64 = string_slice(constraint, offset, string_len(constraint))
    let constraint_ver: i64 = version_parse(constraint_ver_str)
    let cmp: i64 = version_compare(version, constraint_ver)

    if string_eq(op, "=") {
        return cmp == 0
    }
    if string_eq(op, ">") {
        return cmp > 0
    }
    if string_eq(op, "<") {
        return cmp < 0
    }
    if string_eq(op, ">=") {
        return cmp >= 0
    }
    if string_eq(op, "<=") {
        return cmp <= 0
    }

    // ^ (caret): compatible with version, allows minor/patch updates
    // ^1.2.3 matches >=1.2.3 <2.0.0
    // ^0.2.3 matches >=0.2.3 <0.3.0
    // ^0.0.3 matches >=0.0.3 <0.0.4
    if string_eq(op, "^") {
        if cmp < 0 { return false }  // version must be >= constraint
        let v_major: i64 = version_major(version)
        let c_major: i64 = version_major(constraint_ver)
        let c_minor: i64 = version_minor(constraint_ver)
        let c_patch: i64 = version_patch(constraint_ver)

        if c_major > 0 {
            // ^1.2.3 allows changes that don't modify left-most non-zero
            return v_major == c_major
        }
        if c_minor > 0 {
            // ^0.2.3 only allows patch updates
            let v_minor: i64 = version_minor(version)
            return v_major == 0 && v_minor == c_minor
        }
        // ^0.0.3 only allows exact match
        let v_minor: i64 = version_minor(version)
        let v_patch: i64 = version_patch(version)
        return v_major == 0 && v_minor == 0 && v_patch == c_patch
    }

    // ~ (tilde): allows patch-level changes
    // ~1.2.3 matches >=1.2.3 <1.3.0
    if string_eq(op, "~") {
        if cmp < 0 { return false }  // version must be >= constraint
        let v_major: i64 = version_major(version)
        let v_minor: i64 = version_minor(version)
        let c_major: i64 = version_major(constraint_ver)
        let c_minor: i64 = version_minor(constraint_ver)
        return v_major == c_major && v_minor == c_minor
    }

    // Exact version if no operator
    cmp == 0
}

// ============================================================================
// Dependency Helpers
// ============================================================================

fn dep_name(dep: i64) -> i64 {
    load_ptr(dep, 0)
}

fn dep_value(dep: i64) -> i64 {
    load_ptr(dep, 1)
}

fn dep_is_path(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    if json_is_object(value) {
        let path: i64 = json_get(value, "path");
        return json_is_string(path);
    }
    false
}

fn dep_path(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    let path: i64 = json_get(value, "path");
    if json_is_string(path) {
        return json_as_string(path);
    }
    ""
}

fn dep_is_git(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    if json_is_object(value) {
        let git: i64 = json_get(value, "git");
        return json_is_string(git);
    }
    false
}

fn dep_git(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    let git: i64 = json_get(value, "git");
    if json_is_string(git) {
        return json_as_string(git);
    }
    ""
}

fn dep_is_registry(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    // Registry deps are just version strings or objects with "version" field
    if json_is_string(value) {
        return true;
    }
    if json_is_object(value) {
        let version: i64 = json_get(value, "version");
        return json_is_string(version);
    }
    false
}

fn dep_version(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    if json_is_string(value) {
        return json_as_string(value);
    }
    if json_is_object(value) {
        let version: i64 = json_get(value, "version");
        if json_is_string(version) {
            return json_as_string(version);
        }
    }
    "*"
}

fn dependency_new(name: i64) -> i64 {
    // Create a new dependency entry: (name, value_json)
    let dep: i64 = malloc(16);
    store_ptr(dep, 0, name);
    store_ptr(dep, 1, json_string("*"));  // Default to any version
    dep
}

fn dep_set_path(dep: i64, path: i64) -> i64 {
    let obj: i64 = json_object_new();
    json_object_set(obj, "path", json_string(path));
    store_ptr(dep, 1, obj);
    0
}

fn dep_set_git(dep: i64, url: i64) -> i64 {
    let obj: i64 = json_object_new();
    json_object_set(obj, "git", json_string(url));
    store_ptr(dep, 1, obj);
    0
}

fn dep_set_version(dep: i64, version: i64) -> i64 {
    store_ptr(dep, 1, json_string(version));
    0
}

// ============================================================================
// Command: new
// ============================================================================

fn cmd_new(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm new <name> [--lib]");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);
    var is_lib: bool = false;

    // Check for --lib flag
    var i: i64 = arg_idx + 1;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--lib") {
            is_lib = true;
        }
        i = i + 1;
    }

    // Validate name
    if string_len(name) == 0 {
        println("Error: package name cannot be empty");
        return 1;
    }

    let first_char: i64 = string_char_at(name, 0);
    if first_char >= 48 && first_char <= 57 {  // '0'-'9'
        println("Error: package name cannot start with a number");
        return 1;
    }

    // Check if directory exists
    if check_file_exists(name) {
        print("Error: directory '");
        print(name);
        println("' already exists");
        return 1;
    }

    print("Creating package: ");
    println(name);

    // Create directory structure
    mkdir_p(name);
    mkdir_p(path_join(name, "src"));
    mkdir_p(path_join(name, "tests"));

    // Write simplex.json
    let manifest_path: i64 = path_join(name, "simplex.json");
    write_file_safe(manifest_path, template_manifest(name, is_lib));
    print("  Created: ");
    println(manifest_path);

    // Write main source file
    let src_name: i64 = if is_lib { "lib.sx" } else { "main.sx" };
    let src_path: i64 = path_join(path_join(name, "src"), src_name);
    let src_content: i64 = if is_lib { template_lib_sx() } else { template_main_sx() };
    write_file_safe(src_path, src_content);
    print("  Created: ");
    println(src_path);

    // Write test file
    let test_path: i64 = path_join(path_join(name, "tests"), "test_main.sx");
    write_file_safe(test_path, template_test_sx(name));
    print("  Created: ");
    println(test_path);

    // Write .gitignore
    let gitignore_path: i64 = path_join(name, ".gitignore");
    write_file_safe(gitignore_path, template_gitignore());
    print("  Created: ");
    println(gitignore_path);

    println("");
    print("Package '");
    print(name);
    println("' created successfully!");
    println("");
    println("To get started:");
    print("  cd ");
    println(name);
    println("  sxpm build");
    if is_lib == false {
        println("  sxpm run");
    }

    0
}

// ============================================================================
// Command: init
// ============================================================================

fn cmd_init(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Check if simplex.json already exists
    if check_file_exists("simplex.json") {
        println("Error: simplex.json already exists in current directory");
        return 1;
    }

    // Get current directory name for package name
    let cwd: i64 = get_cwd();
    let name: i64 = path_basename(cwd);

    var is_lib: bool = false;

    // Check for --lib flag
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--lib") {
            is_lib = true;
        }
        i = i + 1;
    }

    print("Initializing package: ");
    println(name);

    // Create src directory if needed
    mkdir_p("src");
    mkdir_p("tests");

    // Write simplex.json
    write_file_safe("simplex.json", template_manifest(name, is_lib));
    println("  Created: simplex.json");

    // Create source file if it doesn't exist
    let src_name: i64 = if is_lib { "src/lib.sx" } else { "src/main.sx" };
    if check_file_exists(src_name) == false {
        let src_content: i64 = if is_lib { template_lib_sx() } else { template_main_sx() };
        write_file_safe(src_name, src_content);
        print("  Created: ");
        println(src_name);
    }

    // Create .gitignore if it doesn't exist
    if check_file_exists(".gitignore") == false {
        write_file_safe(".gitignore", template_gitignore());
        println("  Created: .gitignore");
    }

    println("");
    println("Package initialized successfully!");

    0
}

// ============================================================================
// Command: build
// ============================================================================

fn cmd_build(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        println("Run 'sxpm init' to create a package");
        return 1;
    }

    // Validate manifest
    let errors: i64 = manifest_validate(manifest);
    if vec_len(errors) > 0 {
        println("Error: invalid simplex.json:");
        var i: i64 = 0;
        while i < vec_len(errors) {
            print("  - ");
            println(vec_get(errors, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = manifest_name(manifest);
    let entry: i64 = manifest_entry(manifest);

    var release_mode: bool = false;
    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--release") {
            release_mode = true;
        } else if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    print("Building ");
    print(name);
    print(" v");
    println(manifest_version(manifest));

    // Check entry file exists
    if check_file_exists(entry) == false {
        print("Error: entry file not found: ");
        println(entry);
        return 1;
    }

    // Create target directory
    let target_dir: i64 = if release_mode { "target/release" } else { "target/debug" };
    mkdir_p(target_dir);

    // Resolve dependencies with lock file support
    let deps: i64 = manifest_dependencies(manifest);
    if vec_len(deps) > 0 {
        println("Resolving dependencies...");
        let resolve_result: i64 = resolve_with_lockfile(manifest, verbose);
        if resolve_result != 0 {
            println("Error: failed to resolve dependencies");
            return 1;
        }
    }

    // Build the project
    println("Compiling...");

    // Construct build command
    // For now, use sxc directly
    let sb: i64 = sb_new();
    sb_append(sb, "sxc build ");
    sb_append(sb, entry);
    sb_append(sb, " -o ");
    sb_append(sb, target_dir);
    sb_append_char(sb, 47);  // '/'
    sb_append(sb, name);

    let cmd: i64 = sb_to_string(sb);
    sb_free(sb);

    if verbose {
        print("  Running: ");
        println(cmd);
    }

    let result: i64 = process_run(cmd);

    if result == 0 {
        print("Built: ");
        print(target_dir);
        print("/");
        println(name);
    } else {
        println("Build failed");
    }

    result
}

// ============================================================================
// Command: run
// ============================================================================

fn cmd_run(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Build first
    let build_result: i64 = cmd_build(args, argc, arg_idx);
    if build_result != 0 {
        return build_result;
    }

    // Load manifest to get binary name
    let manifest: i64 = manifest_load("simplex.json");
    let name: i64 = manifest_name(manifest);

    var release_mode: bool = false;
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--release") {
            release_mode = true;
        }
        i = i + 1;
    }

    let target_dir: i64 = if release_mode { "target/release" } else { "target/debug" };
    let binary_path: i64 = path_join(target_dir, name);

    println("");
    println("Running...");
    println("---");

    let result: i64 = process_run(binary_path);

    println("---");
    result
}

// ============================================================================
// Command: test
// ============================================================================

fn cmd_test(args: i64, argc: i64, arg_idx: i64) -> i64 {
    println("Running tests...");

    // Find test files
    let test_files: i64 = find_test_files();
    let num_tests: i64 = vec_len(test_files);

    if num_tests == 0 {
        println("No test files found in tests/");
        return 0;
    }

    print("Found ");
    print(int_to_string(num_tests));
    println(" test file(s)");
    println("");

    var passed: i64 = 0;
    var failed: i64 = 0;

    var i: i64 = 0;
    while i < num_tests {
        let test_file: i64 = vec_get(test_files, i);
        print("  Running: ");
        print(test_file);
        print(" ... ");

        // Compile and run test
        let cmd: i64 = string_concat("sxc run ", test_file);
        let result: i64 = process_run(cmd);

        if result == 0 {
            println("PASS");
            passed = passed + 1;
        } else {
            println("FAIL");
            failed = failed + 1;
        }

        i = i + 1;
    }

    println("");
    println("Results:");
    print("  Passed: ");
    println(int_to_string(passed));
    print("  Failed: ");
    println(int_to_string(failed));

    if failed > 0 { 1 } else { 0 }
}

/// Find test files following naming conventions:
/// - tests/test_*.sx (preferred)
/// - tests/*_test.sx (alternative)
/// - Any .sx file in tests/ directory (fallback)
fn find_test_files() -> i64 {
    let files: i64 = vec_new();

    // List tests/ directory
    let listing: i64 = list_dir("tests");
    if listing == 0 {
        return files;
    }

    let n: i64 = vec_len(listing);
    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(listing, i);
        if string_ends_with(name, ".sx") {
            // Accept test_*.sx, *_test.sx, or any .sx file
            if string_starts_with(name, "test_") || string_ends_with(name, "_test.sx") {
                vec_push(files, path_join("tests", name));
            } else {
                // Also include other .sx files for backwards compatibility
                vec_push(files, path_join("tests", name));
            }
        }
        i = i + 1;
    }

    files
}

/// Find example files in examples/ directory
fn find_example_files() -> i64 {
    let files: i64 = vec_new();

    // List examples/ directory
    let listing: i64 = list_dir("examples");
    if listing == 0 {
        return files;
    }

    let n: i64 = vec_len(listing);
    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(listing, i);
        if string_ends_with(name, ".sx") {
            vec_push(files, path_join("examples", name));
        }
        i = i + 1;
    }

    files
}

// ============================================================================
// Command: clean
// ============================================================================

fn cmd_clean(args: i64, argc: i64, arg_idx: i64) -> i64 {
    println("Cleaning build artifacts...");

    let result: i64 = process_run("rm -rf target");

    if result == 0 {
        println("Removed target/");
    }

    result
}

// ============================================================================
// Command: update
// ============================================================================

fn cmd_update(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    println("Updating dependencies...");

    // Remove existing lock file to force re-resolution
    if check_file_exists("simplex.lock") {
        process_run("rm simplex.lock");
        if verbose {
            println("Removed existing simplex.lock");
        }
    }

    // Resolve dependencies fresh
    let result: i64 = resolve_dependencies(manifest, verbose);
    if result != 0 {
        println("Error: failed to resolve dependencies");
        return result;
    }

    // Generate new lock file
    let graph: DepGraph = build_dep_graph(manifest, verbose);
    generate_lockfile(graph, verbose);

    println("Dependencies updated successfully");
    0
}

// ============================================================================
// Command: check
// ============================================================================

fn cmd_check(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Validate manifest
    let errors: i64 = manifest_validate(manifest);
    if vec_len(errors) > 0 {
        println("Error: invalid simplex.json:");
        var i: i64 = 0;
        while i < vec_len(errors) {
            print("  - ");
            println(vec_get(errors, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = manifest_name(manifest);
    let entry: i64 = manifest_entry(manifest);

    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    print("Checking ");
    println(name);

    // Just compile to LLVM IR without linking (type checking)
    let resolve_result: i64 = resolve_with_lockfile(manifest, verbose);
    if resolve_result != 0 {
        println("Error: failed to resolve dependencies");
        return 1;
    }

    // Run compiler in check-only mode
    let sb: i64 = sb_new();
    sb_append(sb, "python3 stage0.py ");
    sb_append(sb, entry);
    sb_append(sb, " --check");
    let compile_cmd: i64 = sb_to_string(sb);

    if verbose {
        print("Running: ");
        println(compile_cmd);
    }

    let result: i64 = process_run(compile_cmd);

    if result == 0 {
        println("Check passed!");
    } else {
        println("Check failed");
    }

    result
}

// ============================================================================
// Command: add
// ============================================================================

fn cmd_add(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm add <package> [--version <ver>] [--path <path>] [--git <url>]");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);
    var version: i64 = "*";
    var path: i64 = "";
    var git: i64 = "";

    // Parse options
    var i: i64 = arg_idx + 1;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--version") && i + 1 < argc {
            version = vec_get(args, i + 1);
            i = i + 2;
        } else if string_eq(arg, "--path") && i + 1 < argc {
            path = vec_get(args, i + 1);
            i = i + 2;
        } else if string_eq(arg, "--git") && i + 1 < argc {
            git = vec_get(args, i + 1);
            i = i + 2;
        } else {
            i = i + 1;
        }
    }

    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Check if dependency already exists
    let deps: i64 = manifest_dependencies(manifest);
    var j: i64 = 0;
    while j < vec_len(deps) {
        let dep: i64 = vec_get(deps, j);
        if string_eq(dep_name(dep), package_name) {
            print("Dependency '");
            print(package_name);
            println("' already exists");
            return 1;
        }
        j = j + 1;
    }

    // Create new dependency
    let new_dep: i64 = dependency_new(package_name);
    if string_len(path) > 0 {
        dep_set_path(new_dep, path);
    } else if string_len(git) > 0 {
        dep_set_git(new_dep, git);
    } else {
        dep_set_version(new_dep, version);
    }

    vec_push(deps, new_dep);

    // Write updated manifest
    let new_json: i64 = manifest_to_json(manifest);
    write_file_safe("simplex.json", new_json);

    print("Added dependency: ");
    print(package_name);
    if string_len(path) > 0 {
        print(" (path: ");
        print(path);
        print(")");
    } else if string_len(git) > 0 {
        print(" (git: ");
        print(git);
        print(")");
    } else {
        print(" ");
        print(version);
    }
    println("");

    0
}

// ============================================================================
// Command: remove
// ============================================================================

fn cmd_remove(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm remove <package>");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);

    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Find and remove dependency
    let deps: i64 = manifest_dependencies(manifest);
    var found: bool = false;
    var i: i64 = 0;
    while i < vec_len(deps) {
        let dep: i64 = vec_get(deps, i);
        if string_eq(dep_name(dep), package_name) {
            vec_remove(deps, i);
            found = true;
            i = vec_len(deps);  // break
        } else {
            i = i + 1;
        }
    }

    if found == false {
        print("Dependency '");
        print(package_name);
        println("' not found");
        return 1;
    }

    // Write updated manifest
    let new_json: i64 = manifest_to_json(manifest);
    write_file_safe("simplex.json", new_json);

    print("Removed dependency: ");
    println(package_name);

    0
}

// ============================================================================
// Search, Info, Install Commands
// ============================================================================

fn cmd_search(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing search query");
        println("Usage: sxpm search <query>");
        return 1;
    }

    let query: i64 = vec_get(args, arg_idx);
    print("Searching for: ");
    println(query);
    println("Registry search not yet implemented");
    println("For now, use git dependencies or local paths");
    0
}

fn cmd_info(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm info <package>");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);
    print("Package: ");
    println(package_name);
    println("Registry info not yet implemented");
    0
}

fn cmd_install(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Install dependencies from simplex.json
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        println("Run 'sxpm init' to create a new project");
        return 1;
    }

    println("Installing dependencies...");
    let result: i64 = resolve_dependencies(manifest, true);
    if result == 0 {
        println("Dependencies installed successfully");
    }
    result
}

// ============================================================================
// Dependency Resolution with DAG
// ============================================================================

// Dependency graph node
// Stores: name, version, dependencies (vec of names), visited state
struct DepNode {
    name: i64,
    version: i64,
    path: i64,           // Path to dependency source
    deps: i64,           // Vec of dependency names
    state: i64           // 0=unvisited, 1=visiting, 2=visited
}

fn dep_node_new(name: i64, version: i64, path: i64) -> DepNode {
    DepNode {
        name: name,
        version: version,
        path: path,
        deps: vec_new(),
        state: 0
    }
}

// Dependency graph (DAG)
struct DepGraph {
    nodes: i64,          // HashMap<name, DepNode>
    order: i64,          // Vec of names in topological order
    has_cycle: bool,
    cycle_path: i64      // Vec of names showing cycle
}

fn dep_graph_new() -> DepGraph {
    DepGraph {
        nodes: hashmap_new(),
        order: vec_new(),
        has_cycle: false,
        cycle_path: vec_new()
    }
}

// Add a node to the graph
fn dep_graph_add_node(graph: DepGraph, name: i64, version: i64, path: i64) -> DepGraph {
    // Check if already exists
    if hashmap_contains(graph.nodes, name) == 0 {
        let node: DepNode = dep_node_new(name, version, path);
        hashmap_insert(graph.nodes, name, node);
    }
    graph
}

// Add an edge (dependency relationship) from 'from' to 'to'
fn dep_graph_add_edge(graph: DepGraph, from_name: i64, to_name: i64) -> DepGraph {
    let node_opt: i64 = hashmap_get(graph.nodes, from_name);
    if node_opt != 0 {
        let node: DepNode = node_opt;
        vec_push(node.deps, to_name);
    }
    graph
}

// DFS-based topological sort with cycle detection
// Returns: 0 = success, 1 = cycle detected
fn dep_graph_toposort(graph: DepGraph) -> i64 {
    // Reset all states
    let keys: i64 = hashmap_keys(graph.nodes);
    var i: i64 = 0;
    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);
        if node_opt != 0 {
            let node: DepNode = node_opt;
            node.state = 0;  // unvisited
        }
        i = i + 1;
    }

    // Clear previous order
    vec_clear(graph.order);
    graph.has_cycle = false;
    vec_clear(graph.cycle_path);

    // Visit all nodes
    i = 0;
    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);
        if node_opt != 0 {
            let node: DepNode = node_opt;
            if node.state == 0 {  // unvisited
                let result: i64 = dep_graph_visit(graph, name, vec_new());
                if result != 0 {
                    return 1;  // cycle detected
                }
            }
        }
        i = i + 1;
    }

    0  // success
}

// Visit a node for topological sort
fn dep_graph_visit(graph: DepGraph, name: i64, path: i64) -> i64 {
    let node_opt: i64 = hashmap_get(graph.nodes, name);
    if node_opt == 0 {
        return 0;  // Node doesn't exist, skip
    }

    let node: DepNode = node_opt;

    // Check for cycle (visiting a node that's already in the current path)
    if node.state == 1 {  // currently visiting
        graph.has_cycle = true;
        // Build cycle path
        vec_push(path, name);
        graph.cycle_path = path;
        return 1;
    }

    // Already visited
    if node.state == 2 {
        return 0;
    }

    // Mark as visiting
    node.state = 1;
    vec_push(path, name);

    // Visit all dependencies
    var i: i64 = 0;
    while i < vec_len(node.deps) {
        let dep_name: i64 = vec_get(node.deps, i);
        let result: i64 = dep_graph_visit(graph, dep_name, path);
        if result != 0 {
            return 1;  // cycle detected
        }
        i = i + 1;
    }

    // Mark as visited
    node.state = 2;
    vec_pop(path);

    // Add to order (reverse, so dependencies come first)
    vec_push(graph.order, name);

    0
}

// Print cycle error
fn dep_graph_print_cycle(graph: DepGraph) {
    println("Error: Circular dependency detected!");
    print("  Cycle: ");
    var i: i64 = 0;
    while i < vec_len(graph.cycle_path) {
        if i > 0 {
            print(" -> ");
        }
        print(vec_get(graph.cycle_path, i));
        i = i + 1;
    }
    println("");
}

// Build dependency graph from manifest
fn build_dep_graph(manifest: i64, verbose: bool) -> DepGraph {
    let graph: DepGraph = dep_graph_new();

    // Add root package
    let root_name: i64 = manifest_name(manifest);
    let root_version: i64 = manifest_version(manifest);
    graph = dep_graph_add_node(graph, root_name, root_version, ".");

    // Queue for BFS traversal
    let queue: i64 = vec_new();
    vec_push(queue, root_name);

    // Visited set to avoid re-processing
    let visited: i64 = hashmap_new();
    hashmap_insert(visited, root_name, 1);

    while vec_len(queue) > 0 {
        let current_name: i64 = vec_get(queue, 0);
        // Remove first element (shift)
        let new_queue: i64 = vec_new();
        var i: i64 = 1;
        while i < vec_len(queue) {
            vec_push(new_queue, vec_get(queue, i));
            i = i + 1;
        }
        queue = new_queue;

        // Get current package's manifest
        let current_manifest: i64 = 0;
        if string_eq(current_name, root_name) {
            current_manifest = manifest;
        } else {
            // Load manifest from dependency path
            let node_opt: i64 = hashmap_get(graph.nodes, current_name);
            if node_opt != 0 {
                let node: DepNode = node_opt;
                let manifest_path: i64 = path_join(node.path, "simplex.json");
                current_manifest = manifest_load(manifest_path);
            }
        }

        if current_manifest == 0 {
            continue;
        }

        // Process dependencies
        let deps: i64 = manifest_dependencies(current_manifest);
        i = 0;
        while i < vec_len(deps) {
            let dep: i64 = vec_get(deps, i);
            let dep_name: i64 = dep_name(dep);

            // Determine dependency path
            let dep_path: i64 = "";
            if dep_is_path(dep) {
                dep_path = dep_path(dep);
            } else if dep_is_git(dep) {
                dep_path = path_join(".simplex/deps", dep_name);
            } else {
                dep_path = path_join(".simplex/deps", dep_name);
            }

            // Add node if not exists
            let dep_manifest_path: i64 = path_join(dep_path, "simplex.json");
            let dep_manifest: i64 = manifest_load(dep_manifest_path);
            let dep_version: i64 = "0.0.0";
            if dep_manifest != 0 {
                dep_version = manifest_version(dep_manifest);
            }

            graph = dep_graph_add_node(graph, dep_name, dep_version, dep_path);

            // Add edge from current to dependency
            graph = dep_graph_add_edge(graph, current_name, dep_name);

            // Queue for processing if not visited
            if hashmap_contains(visited, dep_name) == 0 {
                hashmap_insert(visited, dep_name, 1);
                vec_push(queue, dep_name);
            }

            i = i + 1;
        }
    }

    graph
}

// Resolve dependencies with proper DAG
fn resolve_dependencies(manifest: i64, verbose: bool) -> i64 {
    if verbose {
        println("Building dependency graph...");
    }

    // First, fetch all dependencies
    let result: i64 = fetch_dependencies(manifest, verbose);
    if result != 0 {
        return result;
    }

    // Build dependency graph
    let graph: DepGraph = build_dep_graph(manifest, verbose);

    // Perform topological sort
    if verbose {
        println("Checking for cycles...");
    }

    let sort_result: i64 = dep_graph_toposort(graph);
    if sort_result != 0 {
        dep_graph_print_cycle(graph);
        return 1;
    }

    if verbose {
        println("Build order:");
        var i: i64 = 0;
        while i < vec_len(graph.order) {
            print("  ");
            print_i64(i + 1);
            print(". ");
            println(vec_get(graph.order, i));
            i = i + 1;
        }
    }

    0
}

// Fetch dependencies (download/clone as needed)
fn fetch_dependencies(manifest: i64, verbose: bool) -> i64 {
    let deps: i64 = manifest_dependencies(manifest);
    let n: i64 = vec_len(deps);

    var i: i64 = 0;
    while i < n {
        let dep: i64 = vec_get(deps, i);
        let name: i64 = dep_name(dep);

        if verbose {
            print("  Resolving: ");
            println(name);
        }

        if dep_is_path(dep) {
            // Local path dependency
            let path: i64 = dep_path(dep);
            let dep_manifest_path: i64 = path_join(path, "simplex.json");
            if check_file_exists(dep_manifest_path) == false {
                print("Error: dependency '");
                print(name);
                print("' not found at path: ");
                println(path);
                return 1;
            }
        } else if dep_is_git(dep) {
            // Git dependency - clone if needed
            let git_url: i64 = dep_git(dep);
            let cache_dir: i64 = path_join(".simplex/deps", name);

            if check_file_exists(cache_dir) == false {
                if verbose {
                    print("    Cloning from: ");
                    println(git_url);
                }

                mkdir_p(".simplex/deps");
                let clone_cmd: i64 = string_concat("git clone ", string_concat(git_url, string_concat(" ", cache_dir)));
                let result: i64 = process_run(clone_cmd);
                if result != 0 {
                    print("Error: failed to clone ");
                    println(name);
                    return 1;
                }
            }
        } else if dep_is_registry(dep) {
            // Registry dependency - download from registry
            let version_spec: i64 = dep_version(dep);
            if verbose {
                print("    Version: ");
                println(version_spec);
            }

            // For now, just check if it's cached
            let cache_dir: i64 = path_join(".simplex/deps", name);
            if check_file_exists(cache_dir) == false {
                print("Warning: registry dependency '");
                print(name);
                println("' not in cache");
                println("Registry support not yet implemented");
            }
        }

        i = i + 1;
    }

    0
}

// ============================================================================
// Lock File Generation
// ============================================================================

// Generate simplex.lock from resolved dependency graph
fn generate_lockfile(graph: DepGraph, verbose: bool) -> i64 {
    if verbose {
        println("Generating simplex.lock...");
    }

    let sb: i64 = sb_new();
    sb_append(sb, "{\n");
    sb_append(sb, "  \"version\": 1,\n");
    sb_append(sb, "  \"packages\": {\n");

    let keys: i64 = hashmap_keys(graph.nodes);
    var i: i64 = 0;
    var first: bool = true;

    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);

        if node_opt != 0 {
            let node: DepNode = node_opt;

            if first == false {
                sb_append(sb, ",\n");
            }
            first = false;

            sb_append(sb, "    \"");
            sb_append(sb, name);
            sb_append(sb, "\": {\n");

            sb_append(sb, "      \"version\": \"");
            sb_append(sb, node.version);
            sb_append(sb, "\",\n");

            sb_append(sb, "      \"source\": \"");
            if string_eq(node.path, ".") {
                sb_append(sb, "root");
            } else if string_starts_with(node.path, ".simplex/deps") {
                sb_append(sb, "registry");
            } else {
                sb_append(sb, "path");
            }
            sb_append(sb, "\",\n");

            sb_append(sb, "      \"path\": \"");
            sb_append(sb, node.path);
            sb_append(sb, "\",\n");

            // Dependencies list
            sb_append(sb, "      \"dependencies\": [");
            var j: i64 = 0;
            while j < vec_len(node.deps) {
                if j > 0 {
                    sb_append(sb, ", ");
                }
                sb_append(sb, "\"");
                sb_append(sb, vec_get(node.deps, j));
                sb_append(sb, "\"");
                j = j + 1;
            }
            sb_append(sb, "]\n");

            sb_append(sb, "    }");
        }

        i = i + 1;
    }

    sb_append(sb, "\n  }\n");
    sb_append(sb, "}\n");

    let lockfile_content: i64 = sb_to_string(sb);
    sb_free(sb);

    write_file("simplex.lock", lockfile_content);

    if verbose {
        println("  Created: simplex.lock");
    }

    0
}

// Load existing lock file
fn load_lockfile(verbose: bool) -> i64 {
    if check_file_exists("simplex.lock") == false {
        return 0;
    }

    let content: i64 = read_file("simplex.lock");
    if content == 0 {
        return 0;
    }

    let lock: i64 = json_parse(content);
    if lock == 0 {
        println("Warning: Could not parse simplex.lock");
        return 0;
    }

    if verbose {
        println("Loaded simplex.lock");
    }

    lock
}

// Check if lock file is up to date with manifest
fn lockfile_is_current(manifest: i64, lockfile: i64) -> bool {
    if lockfile == 0 {
        return false;
    }

    let packages: i64 = json_get(lockfile, "packages");
    if json_is_object(packages) == false {
        return false;
    }

    // Check all dependencies in manifest are in lockfile
    let deps: i64 = manifest_dependencies(manifest);
    var i: i64 = 0;
    while i < vec_len(deps) {
        let dep: i64 = vec_get(deps, i);
        let name: i64 = dep_name(dep);

        let locked_pkg: i64 = json_get(packages, name);
        if json_is_object(locked_pkg) == false {
            return false;
        }

        i = i + 1;
    }

    true
}

// Resolve dependencies with lock file support
fn resolve_with_lockfile(manifest: i64, verbose: bool) -> i64 {
    // Check for existing lock file
    let lockfile: i64 = load_lockfile(verbose);

    // If lock file exists and is current, use it
    if lockfile_is_current(manifest, lockfile) {
        if verbose {
            println("Using existing simplex.lock");
        }
        // Fetch any missing dependencies based on lock file
        return fetch_from_lockfile(lockfile, verbose);
    }

    // Otherwise, resolve fresh
    let result: i64 = resolve_dependencies(manifest, verbose);
    if result != 0 {
        return result;
    }

    // Generate new lock file
    let graph: DepGraph = build_dep_graph(manifest, verbose);
    generate_lockfile(graph, verbose);

    0
}

// Fetch dependencies based on lock file
fn fetch_from_lockfile(lockfile: i64, verbose: bool) -> i64 {
    let packages: i64 = json_get(lockfile, "packages");
    if json_is_object(packages) == false {
        return 1;
    }

    let n: i64 = json_object_len(packages);
    var i: i64 = 0;
    while i < n {
        let name: i64 = json_object_key_at(packages, i);
        let pkg: i64 = json_object_value_at(packages, i);

        if json_is_object(pkg) {
            let source: i64 = json_as_string(json_get(pkg, "source"));
            let path: i64 = json_as_string(json_get(pkg, "path"));

            // Skip root package
            if string_eq(source, "root") {
                i = i + 1;
                continue;
            }

            // Check if path exists
            if check_file_exists(path) == false {
                if verbose {
                    print("  Fetching: ");
                    println(name);
                }

                // For registry/git packages, we would need to re-fetch
                // For now, just warn
                print("Warning: dependency '");
                print(name);
                print("' not found at: ");
                println(path);
            }
        }

        i = i + 1;
    }

    0
}

// ============================================================================
// Helper Functions (requires runtime support)
// ============================================================================

fn path_basename(path: i64) -> i64 {
    let len: i64 = string_len(path);
    var last_slash: i64 = 0 - 1;
    var i: i64 = 0;

    while i < len {
        if string_char_at(path, i) == 47 {  // '/'
            last_slash = i;
        }
        i = i + 1;
    }

    if last_slash < 0 {
        return path;
    }

    string_slice(path, last_slash + 1, len)
}

// get_cwd and list_dir are now intrinsics - no wrapper needed

// ============================================================================
// Main Entry Point
// ============================================================================

fn main() -> i64 {
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        sxpm_show_help();
        return 0;
    }

    let cmd: i64 = vec_get(args, 1);

    // Help flags
    if string_eq(cmd, "-h") || string_eq(cmd, "--help") {
        sxpm_show_help();
        return 0;
    }

    if string_eq(cmd, "--version") {
        sxpm_show_version();
        return 0;
    }

    // Commands
    let result: i64 = 0;

    if string_eq(cmd, "new") {
        result = cmd_new(args, argc, 2);
    } else if string_eq(cmd, "init") {
        result = cmd_init(args, argc, 2);
    } else if string_eq(cmd, "build") {
        result = cmd_build(args, argc, 2);
    } else if string_eq(cmd, "run") {
        result = cmd_run(args, argc, 2);
    } else if string_eq(cmd, "test") {
        result = cmd_test(args, argc, 2);
    } else if string_eq(cmd, "clean") {
        result = cmd_clean(args, argc, 2);
    } else if string_eq(cmd, "update") {
        result = cmd_update(args, argc, 2);
    } else if string_eq(cmd, "check") {
        result = cmd_check(args, argc, 2);
    } else if string_eq(cmd, "add") {
        result = cmd_add(args, argc, 2);
    } else if string_eq(cmd, "remove") {
        result = cmd_remove(args, argc, 2);
    } else if string_eq(cmd, "search") {
        result = cmd_search(args, argc, 2);
    } else if string_eq(cmd, "info") {
        result = cmd_info(args, argc, 2);
    } else if string_eq(cmd, "install") {
        result = cmd_install(args, argc, 2);
    } else {
        print("Unknown command: ");
        println(cmd);
        println("");
        sxpm_show_help();
        result = 1;
    }

    exit(result);
}
