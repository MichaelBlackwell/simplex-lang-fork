// cursus - Simplex Bytecode Virtual Machine
// A stack-based interpreter with basic garbage collection

fn VERSION() -> i64 { string_from("0.1.3") }

fn show_help() -> i64 {
    println("cursus - Simplex Bytecode VM");
    println("");
    println("USAGE:");
    println("    cursus [OPTIONS] <FILE.sxb>");
    println("    cursus compile <FILE.sx> -o <FILE.sxb>");
    println("");
    println("OPTIONS:");
    println("    --trace         Enable instruction tracing");
    println("    --stats         Show VM statistics");
    println("    -h, --help      Show this help");
    println("    --version       Show version");
    0
}

fn show_version() -> i64 {
    println(string_concat(string_from("cursus "), VERSION()));
    0
}

// ========================================
// Bytecode Instruction Set
// ========================================

// Stack operations
fn OP_NOP() -> i64 { 0 }        // No operation
fn OP_PUSH_I64() -> i64 { 1 }   // Push i64 constant
fn OP_PUSH_STR() -> i64 { 2 }   // Push string from string table
fn OP_PUSH_TRUE() -> i64 { 3 }  // Push true
fn OP_PUSH_FALSE() -> i64 { 4 } // Push false
fn OP_POP() -> i64 { 5 }        // Pop and discard
fn OP_DUP() -> i64 { 6 }        // Duplicate top

// Arithmetic
fn OP_ADD() -> i64 { 10 }       // a + b
fn OP_SUB() -> i64 { 11 }       // a - b
fn OP_MUL() -> i64 { 12 }       // a * b
fn OP_DIV() -> i64 { 13 }       // a / b
fn OP_MOD() -> i64 { 14 }       // a % b
fn OP_NEG() -> i64 { 15 }       // -a

// Comparison
fn OP_EQ() -> i64 { 20 }        // a == b
fn OP_NE() -> i64 { 21 }        // a != b
fn OP_LT() -> i64 { 22 }        // a < b
fn OP_GT() -> i64 { 23 }        // a > b
fn OP_LE() -> i64 { 24 }        // a <= b
fn OP_GE() -> i64 { 25 }        // a >= b

// Logical
fn OP_AND() -> i64 { 30 }       // a && b
fn OP_OR() -> i64 { 31 }        // a || b
fn OP_NOT() -> i64 { 32 }       // !a

// Bitwise
fn OP_BAND() -> i64 { 35 }      // a & b
fn OP_BOR() -> i64 { 36 }       // a | b
fn OP_BXOR() -> i64 { 37 }      // a ^ b
fn OP_SHL() -> i64 { 38 }       // a << b
fn OP_SHR() -> i64 { 39 }       // a >> b

// Control flow
fn OP_JMP() -> i64 { 40 }       // Jump to address
fn OP_JMP_IF() -> i64 { 41 }    // Jump if top is true
fn OP_JMP_IF_NOT() -> i64 { 42 } // Jump if top is false
fn OP_CALL() -> i64 { 43 }      // Call function
fn OP_RET() -> i64 { 44 }       // Return from function
fn OP_HALT() -> i64 { 45 }      // Stop execution

// Variables
fn OP_LOAD_LOCAL() -> i64 { 50 }  // Load local variable
fn OP_STORE_LOCAL() -> i64 { 51 } // Store to local variable
fn OP_LOAD_GLOBAL() -> i64 { 52 } // Load global variable
fn OP_STORE_GLOBAL() -> i64 { 53 } // Store to global variable

// Memory
fn OP_ALLOC() -> i64 { 60 }     // Allocate object (size on stack)
fn OP_LOAD_FIELD() -> i64 { 61 } // Load field from object
fn OP_STORE_FIELD() -> i64 { 62 } // Store to field

// Built-in functions
fn OP_PRINT() -> i64 { 70 }     // Print top of stack
fn OP_PRINTLN() -> i64 { 71 }   // Print with newline
fn OP_STR_LEN() -> i64 { 72 }   // String length
fn OP_STR_CONCAT() -> i64 { 73 } // String concatenation
fn OP_INT_TO_STR() -> i64 { 74 } // Convert int to string

// ========================================
// VM State
// ========================================

// VM structure
// Layout: code(0), code_len(1), ip(2), stack(3), sp(4), frames(5), fp(6), globals(7), strings(8), heap(9), gc_threshold(10), trace(11)
fn cvm_new() -> i64 {
    let vm: i64 = malloc(96);
    store_ptr(vm, 0, 0);          // bytecode
    store_i64(vm, 1, 0);          // code length
    store_i64(vm, 2, 0);          // instruction pointer
    store_ptr(vm, 3, malloc(8192)); // stack (1024 slots)
    store_i64(vm, 4, 0);          // stack pointer
    store_ptr(vm, 5, malloc(1024)); // call frames (128 frames)
    store_i64(vm, 6, 0);          // frame pointer
    store_ptr(vm, 7, vec_new());  // globals
    store_ptr(vm, 8, vec_new());  // string table
    store_ptr(vm, 9, vec_new());  // heap objects for GC
    store_i64(vm, 10, 1000);      // GC threshold
    store_i64(vm, 11, 0);         // trace mode
    vm
}

fn cvm_code(vm: i64) -> i64 { load_ptr(vm, 0) }
fn cvm_set_code(vm: i64, code: i64, len: i64) -> i64 {
    store_ptr(vm, 0, code);
    store_i64(vm, 1, len);
    0
}
fn cvm_code_len(vm: i64) -> i64 { load_i64(vm, 1) }
fn cvm_ip(vm: i64) -> i64 { load_i64(vm, 2) }
fn cvm_set_ip(vm: i64, ip: i64) -> i64 { store_i64(vm, 2, ip); 0 }
fn cvm_stack(vm: i64) -> i64 { load_ptr(vm, 3) }
fn cvm_sp(vm: i64) -> i64 { load_i64(vm, 4) }
fn cvm_set_sp(vm: i64, sp: i64) -> i64 { store_i64(vm, 4, sp); 0 }
fn cvm_frames(vm: i64) -> i64 { load_ptr(vm, 5) }
fn cvm_fp(vm: i64) -> i64 { load_i64(vm, 6) }
fn cvm_set_fp(vm: i64, fp: i64) -> i64 { store_i64(vm, 6, fp); 0 }
fn cvm_globals(vm: i64) -> i64 { load_ptr(vm, 7) }
fn cvm_strings(vm: i64) -> i64 { load_ptr(vm, 8) }
fn cvm_heap(vm: i64) -> i64 { load_ptr(vm, 9) }
fn cvm_gc_threshold(vm: i64) -> i64 { load_i64(vm, 10) }
fn cvm_trace(vm: i64) -> i64 { load_i64(vm, 11) }
fn cvm_set_trace(vm: i64, t: i64) -> i64 { store_i64(vm, 11, t); 0 }

// Stack operations
fn cvm_push(vm: i64, value: i64) -> i64 {
    let stack: i64 = cvm_stack(vm);
    let sp: i64 = cvm_sp(vm);
    store_i64(stack, sp, value);
    cvm_set_sp(vm, sp + 1);
    0
}

fn cvm_pop(vm: i64) -> i64 {
    let sp: i64 = cvm_sp(vm) - 1;
    cvm_set_sp(vm, sp);
    let stack: i64 = cvm_stack(vm);
    load_i64(stack, sp)
}

fn cvm_peek(vm: i64) -> i64 {
    let stack: i64 = cvm_stack(vm);
    let sp: i64 = cvm_sp(vm);
    load_i64(stack, sp - 1)
}

fn cvm_peek_n(vm: i64, n: i64) -> i64 {
    let stack: i64 = cvm_stack(vm);
    let sp: i64 = cvm_sp(vm);
    load_i64(stack, sp - 1 - n)
}

// Read bytecode value
fn cvm_read_byte(vm: i64) -> i64 {
    let code: i64 = cvm_code(vm);
    let ip: i64 = cvm_ip(vm);
    let byte: i64 = load_i64(code, ip);
    cvm_set_ip(vm, ip + 1);
    byte
}

fn cvm_read_i64(vm: i64) -> i64 {
    // Read 8-byte value (for simplicity, assume aligned)
    let code: i64 = cvm_code(vm);
    let ip: i64 = cvm_ip(vm);
    let value: i64 = load_i64(code, ip);
    cvm_set_ip(vm, ip + 1);
    value
}

// ========================================
// Call Frame Management
// ========================================

// Frame structure in frames array: return_ip, base_sp, num_locals
fn cvm_push_frame(vm: i64, return_ip: i64, num_locals: i64) -> i64 {
    let frames: i64 = cvm_frames(vm);
    let fp: i64 = cvm_fp(vm);
    let base_sp: i64 = cvm_sp(vm) - num_locals;  // Locals are on stack

    store_i64(frames, fp * 3, return_ip);
    store_i64(frames, fp * 3 + 1, base_sp);
    store_i64(frames, fp * 3 + 2, num_locals);
    cvm_set_fp(vm, fp + 1);
    0
}

fn cvm_pop_frame(vm: i64) -> i64 {
    let fp: i64 = cvm_fp(vm) - 1;
    cvm_set_fp(vm, fp);
    let frames: i64 = cvm_frames(vm);
    load_i64(frames, fp * 3)  // return_ip
}

fn cvm_frame_base_sp(vm: i64) -> i64 {
    let frames: i64 = cvm_frames(vm);
    let fp: i64 = cvm_fp(vm);
    if fp == 0 {
        return 0;
    }
    load_i64(frames, (fp - 1) * 3 + 1)
}

// ========================================
// Garbage Collection
// ========================================

// Simple mark-and-sweep GC
// Heap objects: (mark_bit, size, data...)
fn cvm_alloc(vm: i64, size: i64) -> i64 {
    let heap: i64 = cvm_heap(vm);

    // Check if GC needed
    if vec_len(heap) >= cvm_gc_threshold(vm) {
        cvm_gc(vm);
    }

    // Allocate new object
    let obj: i64 = malloc((size + 2) * 8);  // +2 for mark bit and size
    store_i64(obj, 0, 0);     // mark = 0
    store_i64(obj, 1, size);  // size
    vec_push(heap, obj);

    obj + 16  // Return pointer to data (skip header)
}

fn cvm_gc(vm: i64) -> i64 {
    if cvm_trace(vm) == 1 {
        println("[GC] Starting collection...");
    }

    let heap: i64 = cvm_heap(vm);
    let n: i64 = vec_len(heap);

    // Mark phase - mark objects reachable from stack
    let stack: i64 = cvm_stack(vm);
    let sp: i64 = cvm_sp(vm);
    let i: i64 = 0;
    while i < sp {
        let value: i64 = load_i64(stack, i);
        cvm_gc_mark_value(vm, value);
        i = i + 1;
    }

    // Mark globals
    let globals: i64 = cvm_globals(vm);
    i = 0;
    while i < vec_len(globals) {
        let value: i64 = vec_get(globals, i);
        cvm_gc_mark_value(vm, value);
        i = i + 1;
    }

    // Sweep phase - free unmarked objects
    let new_heap: i64 = vec_new();
    let freed: i64 = 0;
    i = 0;
    while i < n {
        let obj: i64 = vec_get(heap, i);
        let mark: i64 = load_i64(obj, 0);
        if mark == 0 {
            // Free unmarked object
            freed = freed + 1;
        } else {
            // Keep marked object, reset mark for next GC
            store_i64(obj, 0, 0);
            vec_push(new_heap, obj);
        }
        i = i + 1;
    }

    store_ptr(vm, 9, new_heap);

    if cvm_trace(vm) == 1 {
        println(string_concat(string_from("[GC] Freed "), int_to_string(freed)));
        println(string_from(" objects"));
    }

    freed
}

fn cvm_gc_mark_value(vm: i64, value: i64) -> i64 {
    // Check if value looks like a heap pointer
    // This is a simple heuristic - in real VM would use tagged values
    let heap: i64 = cvm_heap(vm);
    let n: i64 = vec_len(heap);
    let i: i64 = 0;
    while i < n {
        let obj: i64 = vec_get(heap, i);
        let obj_data: i64 = obj + 16;
        if value == obj_data {
            // Mark this object
            store_i64(obj, 0, 1);
            return 1;
        }
        i = i + 1;
    }
    0
}

// ========================================
// Instruction Execution
// ========================================

fn cvm_step(vm: i64) -> i64 {
    let op: i64 = cvm_read_byte(vm);

    if cvm_trace(vm) == 1 {
        print(string_concat(string_from("["), int_to_string(cvm_ip(vm) - 1)));
        print(string_concat(string_from("] op="), int_to_string(op)));
        print(string_concat(string_from(" sp="), int_to_string(cvm_sp(vm))));
        println("");
    }

    // NOP
    if op == OP_NOP() {
        return 1;
    }

    // PUSH_I64
    if op == OP_PUSH_I64() {
        let value: i64 = cvm_read_i64(vm);
        cvm_push(vm, value);
        return 1;
    }

    // PUSH_STR
    if op == OP_PUSH_STR() {
        let idx: i64 = cvm_read_i64(vm);
        let strings: i64 = cvm_strings(vm);
        let str: i64 = vec_get(strings, idx);
        cvm_push(vm, str);
        return 1;
    }

    // PUSH_TRUE / PUSH_FALSE
    if op == OP_PUSH_TRUE() {
        cvm_push(vm, 1);
        return 1;
    }
    if op == OP_PUSH_FALSE() {
        cvm_push(vm, 0);
        return 1;
    }

    // POP
    if op == OP_POP() {
        cvm_pop(vm);
        return 1;
    }

    // DUP
    if op == OP_DUP() {
        let value: i64 = cvm_peek(vm);
        cvm_push(vm, value);
        return 1;
    }

    // Arithmetic
    if op == OP_ADD() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a + b);
        return 1;
    }
    if op == OP_SUB() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a - b);
        return 1;
    }
    if op == OP_MUL() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a * b);
        return 1;
    }
    if op == OP_DIV() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if b == 0 {
            println("Error: Division by zero");
            return 0;
        }
        cvm_push(vm, a / b);
        return 1;
    }
    if op == OP_MOD() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a % b);
        return 1;
    }
    if op == OP_NEG() {
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, 0 - a);
        return 1;
    }

    // Comparison
    if op == OP_EQ() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a == b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }
    if op == OP_NE() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a != b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }
    if op == OP_LT() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a < b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }
    if op == OP_GT() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a > b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }
    if op == OP_LE() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a <= b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }
    if op == OP_GE() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a >= b { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }

    // Logical
    if op == OP_AND() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a != 0 {
            if b != 0 {
                cvm_push(vm, 1);
            } else {
                cvm_push(vm, 0);
            }
        } else {
            cvm_push(vm, 0);
        }
        return 1;
    }
    if op == OP_OR() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        if a != 0 {
            cvm_push(vm, 1);
        } else {
            if b != 0 {
                cvm_push(vm, 1);
            } else {
                cvm_push(vm, 0);
            }
        }
        return 1;
    }
    if op == OP_NOT() {
        let a: i64 = cvm_pop(vm);
        if a == 0 { cvm_push(vm, 1); } else { cvm_push(vm, 0); }
        return 1;
    }

    // Bitwise
    if op == OP_BAND() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a & b);
        return 1;
    }
    if op == OP_BOR() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a | b);
        return 1;
    }
    if op == OP_BXOR() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, a ^ b);
        return 1;
    }

    // Control flow
    if op == OP_JMP() {
        let addr: i64 = cvm_read_i64(vm);
        cvm_set_ip(vm, addr);
        return 1;
    }
    if op == OP_JMP_IF() {
        let addr: i64 = cvm_read_i64(vm);
        let cond: i64 = cvm_pop(vm);
        if cond != 0 {
            cvm_set_ip(vm, addr);
        }
        return 1;
    }
    if op == OP_JMP_IF_NOT() {
        let addr: i64 = cvm_read_i64(vm);
        let cond: i64 = cvm_pop(vm);
        if cond == 0 {
            cvm_set_ip(vm, addr);
        }
        return 1;
    }
    if op == OP_CALL() {
        let addr: i64 = cvm_read_i64(vm);
        let num_args: i64 = cvm_read_i64(vm);
        cvm_push_frame(vm, cvm_ip(vm), num_args);
        cvm_set_ip(vm, addr);
        return 1;
    }
    if op == OP_RET() {
        let return_value: i64 = cvm_pop(vm);
        let return_ip: i64 = cvm_pop_frame(vm);
        cvm_set_sp(vm, cvm_frame_base_sp(vm) + 1);  // Keep one slot for return value
        cvm_push(vm, return_value);
        cvm_set_ip(vm, return_ip);
        return 1;
    }
    if op == OP_HALT() {
        return 0;  // Stop execution
    }

    // Variables
    if op == OP_LOAD_LOCAL() {
        let idx: i64 = cvm_read_i64(vm);
        let base: i64 = cvm_frame_base_sp(vm);
        let stack: i64 = cvm_stack(vm);
        let value: i64 = load_i64(stack, base + idx);
        cvm_push(vm, value);
        return 1;
    }
    if op == OP_STORE_LOCAL() {
        let idx: i64 = cvm_read_i64(vm);
        let value: i64 = cvm_pop(vm);
        let base: i64 = cvm_frame_base_sp(vm);
        let stack: i64 = cvm_stack(vm);
        store_i64(stack, base + idx, value);
        return 1;
    }
    if op == OP_LOAD_GLOBAL() {
        let idx: i64 = cvm_read_i64(vm);
        let globals: i64 = cvm_globals(vm);
        let value: i64 = vec_get(globals, idx);
        cvm_push(vm, value);
        return 1;
    }
    if op == OP_STORE_GLOBAL() {
        let idx: i64 = cvm_read_i64(vm);
        let value: i64 = cvm_pop(vm);
        let globals: i64 = cvm_globals(vm);
        // Extend globals if needed
        while vec_len(globals) <= idx {
            vec_push(globals, 0);
        }
        // Note: vec_set would be better here - for now globals work with initial 0 values
        return 1;
    }

    // Memory
    if op == OP_ALLOC() {
        let size: i64 = cvm_pop(vm);
        let ptr: i64 = cvm_alloc(vm, size);
        cvm_push(vm, ptr);
        return 1;
    }
    if op == OP_LOAD_FIELD() {
        let idx: i64 = cvm_read_i64(vm);
        let obj: i64 = cvm_pop(vm);
        let value: i64 = load_i64(obj, idx);
        cvm_push(vm, value);
        return 1;
    }
    if op == OP_STORE_FIELD() {
        let idx: i64 = cvm_read_i64(vm);
        let value: i64 = cvm_pop(vm);
        let obj: i64 = cvm_pop(vm);
        store_i64(obj, idx, value);
        return 1;
    }

    // Built-in functions
    if op == OP_PRINT() {
        let value: i64 = cvm_pop(vm);
        print(int_to_string(value));
        return 1;
    }
    if op == OP_PRINTLN() {
        let value: i64 = cvm_pop(vm);
        println(int_to_string(value));
        return 1;
    }
    if op == OP_STR_LEN() {
        let str: i64 = cvm_pop(vm);
        cvm_push(vm, string_len(str));
        return 1;
    }
    if op == OP_STR_CONCAT() {
        let b: i64 = cvm_pop(vm);
        let a: i64 = cvm_pop(vm);
        cvm_push(vm, string_concat(a, b));
        return 1;
    }
    if op == OP_INT_TO_STR() {
        let value: i64 = cvm_pop(vm);
        cvm_push(vm, int_to_string(value));
        return 1;
    }

    println(string_concat(string_from("Unknown opcode: "), int_to_string(op)));
    0
}

// Run the VM until halt
fn cvm_run(vm: i64) -> i64 {
    let running: i64 = 1;
    let steps: i64 = 0;

    while running == 1 {
        running = cvm_step(vm);
        steps = steps + 1;

        // Safety limit
        if steps > 10000000 {
            println("Error: Execution limit exceeded");
            return 1;
        }
    }

    if cvm_trace(vm) == 1 {
        println(string_concat(string_from("Executed "), int_to_string(steps)));
        println(string_from(" instructions"));
    }

    0
}

// ========================================
// Bytecode Compiler
// ========================================

// Compiler state for generating bytecode
// Layout: code(0), code_len(1), strings(2), labels(3), fixups(4)
fn compiler_new() -> i64 {
    let comp: i64 = malloc(40);
    store_ptr(comp, 0, malloc(65536));  // code buffer (8K instructions)
    store_i64(comp, 1, 0);              // code length
    store_ptr(comp, 2, vec_new());      // string table
    store_ptr(comp, 3, vec_new());      // labels: (name, address) pairs
    store_ptr(comp, 4, vec_new());      // fixups: (address, label_name) pairs
    comp
}

fn comp_code(comp: i64) -> i64 { load_ptr(comp, 0) }
fn comp_len(comp: i64) -> i64 { load_i64(comp, 1) }
fn comp_strings(comp: i64) -> i64 { load_ptr(comp, 2) }
fn comp_labels(comp: i64) -> i64 { load_ptr(comp, 3) }
fn comp_fixups(comp: i64) -> i64 { load_ptr(comp, 4) }

fn comp_emit(comp: i64, value: i64) -> i64 {
    let code: i64 = comp_code(comp);
    let len: i64 = comp_len(comp);
    store_i64(code, len, value);
    store_i64(comp, 1, len + 1);
    len
}

fn comp_emit_op(comp: i64, op: i64) -> i64 {
    comp_emit(comp, op)
}

fn comp_emit_i64(comp: i64, value: i64) -> i64 {
    comp_emit(comp, value)
}

fn comp_add_string(comp: i64, str: i64) -> i64 {
    let strings: i64 = comp_strings(comp);
    let idx: i64 = vec_len(strings);
    vec_push(strings, str);
    idx
}

fn comp_define_label(comp: i64, name: i64) -> i64 {
    let labels: i64 = comp_labels(comp);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_i64(pair, 1, comp_len(comp));
    vec_push(labels, pair);
    0
}

fn comp_emit_jump(comp: i64, op: i64, label: i64) -> i64 {
    comp_emit_op(comp, op);
    let addr: i64 = comp_emit(comp, 0);  // Placeholder
    // Record fixup
    let fixups: i64 = comp_fixups(comp);
    let fixup: i64 = malloc(16);
    store_i64(fixup, 0, addr);
    store_ptr(fixup, 1, label);
    vec_push(fixups, fixup);
    addr
}

fn comp_resolve_labels(comp: i64) -> i64 {
    let code: i64 = comp_code(comp);
    let labels: i64 = comp_labels(comp);
    let fixups: i64 = comp_fixups(comp);

    let i: i64 = 0;
    while i < vec_len(fixups) {
        let fixup: i64 = vec_get(fixups, i);
        let addr: i64 = load_i64(fixup, 0);
        let label_name: i64 = load_ptr(fixup, 1);

        // Find label
        let j: i64 = 0;
        let found: i64 = 0;
        while j < vec_len(labels) {
            let label: i64 = vec_get(labels, j);
            let name: i64 = load_ptr(label, 0);
            if string_eq(name, label_name) {
                let target: i64 = load_i64(label, 1);
                store_i64(code, addr, target);
                found = 1;
                j = vec_len(labels);  // break
            }
            j = j + 1;
        }

        if found == 0 {
            println(string_concat(string_from("Error: Undefined label: "), label_name));
            return 1;
        }
        i = i + 1;
    }

    0
}

// ========================================
// Simple Bytecode Assembler
// ========================================

// Assemble from text to bytecode
fn assemble(source: i64) -> i64 {
    let comp: i64 = compiler_new();
    let lines: i64 = string_split(source, string_from("\n"));
    let n: i64 = vec_len(lines);
    let i: i64 = 0;

    while i < n {
        let line: i64 = string_trim(vec_get(lines, i));

        // Skip empty lines and comments
        if string_len(line) == 0 {
            i = i + 1;
        } else {
        if string_char_at(line, 0) == 59 {
            // ; comment
            i = i + 1;
        } else {
        // Check for label (ends with :)
        if string_char_at(line, string_len(line) - 1) == 58 {
            let label_name: i64 = string_slice(line, 0, string_len(line) - 1);
            comp_define_label(comp, label_name);
            i = i + 1;
        } else {
        // Parse instruction
        assemble_instruction(comp, line);
        i = i + 1;
        }
        }
        }
    }

    // Resolve labels
    comp_resolve_labels(comp);

    comp
}

fn assemble_instruction(comp: i64, line: i64) -> i64 {
    // Split by whitespace
    let parts: i64 = string_split(line, string_from(" "));
    let op_str: i64 = vec_get(parts, 0);

    if string_eq(op_str, string_from("nop")) { comp_emit_op(comp, OP_NOP()); return 0; }
    if string_eq(op_str, string_from("halt")) { comp_emit_op(comp, OP_HALT()); return 0; }
    if string_eq(op_str, string_from("pop")) { comp_emit_op(comp, OP_POP()); return 0; }
    if string_eq(op_str, string_from("dup")) { comp_emit_op(comp, OP_DUP()); return 0; }
    if string_eq(op_str, string_from("add")) { comp_emit_op(comp, OP_ADD()); return 0; }
    if string_eq(op_str, string_from("sub")) { comp_emit_op(comp, OP_SUB()); return 0; }
    if string_eq(op_str, string_from("mul")) { comp_emit_op(comp, OP_MUL()); return 0; }
    if string_eq(op_str, string_from("div")) { comp_emit_op(comp, OP_DIV()); return 0; }
    if string_eq(op_str, string_from("mod")) { comp_emit_op(comp, OP_MOD()); return 0; }
    if string_eq(op_str, string_from("neg")) { comp_emit_op(comp, OP_NEG()); return 0; }
    if string_eq(op_str, string_from("eq")) { comp_emit_op(comp, OP_EQ()); return 0; }
    if string_eq(op_str, string_from("ne")) { comp_emit_op(comp, OP_NE()); return 0; }
    if string_eq(op_str, string_from("lt")) { comp_emit_op(comp, OP_LT()); return 0; }
    if string_eq(op_str, string_from("gt")) { comp_emit_op(comp, OP_GT()); return 0; }
    if string_eq(op_str, string_from("le")) { comp_emit_op(comp, OP_LE()); return 0; }
    if string_eq(op_str, string_from("ge")) { comp_emit_op(comp, OP_GE()); return 0; }
    if string_eq(op_str, string_from("and")) { comp_emit_op(comp, OP_AND()); return 0; }
    if string_eq(op_str, string_from("or")) { comp_emit_op(comp, OP_OR()); return 0; }
    if string_eq(op_str, string_from("not")) { comp_emit_op(comp, OP_NOT()); return 0; }
    if string_eq(op_str, string_from("println")) { comp_emit_op(comp, OP_PRINTLN()); return 0; }
    if string_eq(op_str, string_from("ret")) { comp_emit_op(comp, OP_RET()); return 0; }

    // Instructions with operands
    if string_eq(op_str, string_from("push")) {
        let operand: i64 = vec_get(parts, 1);
        comp_emit_op(comp, OP_PUSH_I64());
        comp_emit_i64(comp, string_to_int(operand));
        return 0;
    }
    if string_eq(op_str, string_from("jmp")) {
        let label: i64 = vec_get(parts, 1);
        comp_emit_jump(comp, OP_JMP(), label);
        return 0;
    }
    if string_eq(op_str, string_from("jmp_if")) {
        let label: i64 = vec_get(parts, 1);
        comp_emit_jump(comp, OP_JMP_IF(), label);
        return 0;
    }
    if string_eq(op_str, string_from("jmp_if_not")) {
        let label: i64 = vec_get(parts, 1);
        comp_emit_jump(comp, OP_JMP_IF_NOT(), label);
        return 0;
    }
    if string_eq(op_str, string_from("load_local")) {
        let idx: i64 = string_to_int(vec_get(parts, 1));
        comp_emit_op(comp, OP_LOAD_LOCAL());
        comp_emit_i64(comp, idx);
        return 0;
    }
    if string_eq(op_str, string_from("store_local")) {
        let idx: i64 = string_to_int(vec_get(parts, 1));
        comp_emit_op(comp, OP_STORE_LOCAL());
        comp_emit_i64(comp, idx);
        return 0;
    }

    println(string_concat(string_from("Unknown instruction: "), op_str));
    0
}

// ========================================
// Main Entry Point
// ========================================

fn main() -> i64 {
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        show_help();
        return 1;
    }

    let trace: i64 = 0;
    let stats: i64 = 0;
    let file: i64 = 0;
    let i: i64 = 1;

    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, string_from("-h")) {
            show_help();
            return 0;
        }
        if string_eq(arg, string_from("--help")) {
            show_help();
            return 0;
        }
        if string_eq(arg, string_from("--version")) {
            show_version();
            return 0;
        }
        if string_eq(arg, string_from("--trace")) {
            trace = 1;
            i = i + 1;
        } else {
        if string_eq(arg, string_from("--stats")) {
            stats = 1;
            i = i + 1;
        } else {
            file = arg;
            i = i + 1;
        }
        }
    }

    if file == 0 {
        println("Error: No input file specified");
        return 1;
    }

    // Check for assembly file (.sxa)
    if string_ends_with(file, string_from(".sxa")) {
        return run_assembly(file, trace, stats);
    }

    // Otherwise, assume bytecode file
    println("Error: Only .sxa (assembly) files supported in bootstrap");
    println("Use: cursus <file.sxa>");
    1
}

fn run_assembly(path: i64, trace: i64, stats: i64) -> i64 {
    let source: i64 = read_file(path);
    if source == 0 {
        println(string_concat(string_from("Error: Could not read file: "), path));
        return 1;
    }

    println(string_concat(string_from("Assembling: "), path));

    // Assemble to bytecode
    let comp: i64 = assemble(source);
    let code_len: i64 = comp_len(comp);

    println(string_concat(string_from("Code size: "), int_to_string(code_len)));
    println(string_from(" instructions"));

    // Create and run VM
    let vm: i64 = cvm_new();
    cvm_set_code(vm, comp_code(comp), code_len);
    cvm_set_trace(vm, trace);

    // Copy string table to VM
    let cvm_strs: i64 = cvm_strings(vm);
    let comp_strs: i64 = comp_strings(comp);
    let j: i64 = 0;
    while j < vec_len(comp_strs) {
        vec_push(cvm_strs, vec_get(comp_strs, j));
        j = j + 1;
    }

    println("Running...");
    println("---");

    let result: i64 = cvm_run(vm);

    println("---");

    if stats == 1 {
        println(string_concat(string_from("Stack pointer: "), int_to_string(cvm_sp(vm))));
        println(string_concat(string_from("Heap objects: "), int_to_string(vec_len(cvm_heap(vm)))));
    }

    if cvm_sp(vm) > 0 {
        println(string_concat(string_from("Result: "), int_to_string(cvm_pop(vm))));
    }

    result
}
