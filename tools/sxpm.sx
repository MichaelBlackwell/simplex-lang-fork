// sxpm - Simplex Package Manager
// Build tool and package manager for Simplex projects
// Part of Phase 2: Package Ecosystem
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex-lang

// Import shared modules
use lib::version;
use lib::safety;
use lib::platform;

// Version - now uses centralized constant
fn SXPM_VERSION() -> i64 { version::SXPM_VERSION() }

// ============================================================================
// Help and Version
// ============================================================================

fn sxpm_show_help() {
    println("sxpm - Simplex Package Manager");
    println("");
    println("USAGE:");
    println("    sxpm <COMMAND> [OPTIONS]");
    println("");
    println("COMMANDS:");
    println("    new <name>           Create a new package");
    println("    init                 Initialize package in current directory");
    println("    build                Build the current package");
    println("    run                  Build and run the current package");
    println("    test                 Run tests");
    println("    check                Type check without building");
    println("    clean                Remove build artifacts");
    println("");
    println("DEPENDENCY COMMANDS:");
    println("    add <package>        Add a dependency");
    println("    remove <package>     Remove a dependency");
    println("    install              Install dependencies (generates simplex.lock)");
    println("    update               Update dependencies and refresh lock file");
    println("");
    println("REGISTRY COMMANDS:");
    println("    search <query>       Search for packages in registry");
    println("    info <package>       Show package information");
    println("    publish              Publish package to registry");
    println("");
    println("MODEL COMMANDS:");
    println("    model list           List available/installed models");
    println("    model install <name> Download and install a model");
    println("    model remove <name>  Remove an installed model");
    println("    model info <name>    Show model information");
    println("");
    println("OPTIONS:");
    println("    -h, --help           Show this help");
    println("    --version            Show version");
    println("    --release            Build in release mode");
    println("    -v, --verbose        Verbose output");
    println("    --frozen             Use exact versions from simplex.lock");
    println("    --dry-run            Preview publish without uploading");
    println("");
    println("ENVIRONMENT VARIABLES:");
    println("    SIMPLEX_REGISTRY     Package registry URL");
    println("    SIMPLEX_API_TOKEN    API token for publishing packages");
}

fn sxpm_show_version() {
    print("sxpm ");
    println(SXPM_VERSION());
}

// ============================================================================
// Project Templates
// ============================================================================

fn template_main_sx() -> i64 {
    "fn main() {\n    println(\"Hello, Simplex!\");\n}\n"
}

fn template_lib_sx() -> i64 {
    "// Library entry point\n\npub fn hello() -> i64 {\n    println(\"Hello from library!\");\n    0\n}\n"
}

fn template_gitignore() -> i64 {
    "/target/\n*.ll\n*.o\n*.sxb\n"
}

fn template_manifest(name: i64, is_lib: bool) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, "{\n");
    sb_append(sb, "  \"name\": \"");
    sb_append(sb, name);
    sb_append(sb, "\",\n");
    sb_append(sb, "  \"version\": \"0.1.0\",\n");
    sb_append(sb, "  \"authors\": [],\n");
    sb_append(sb, "  \"description\": \"\",\n");
    sb_append(sb, "  \"license\": \"MIT\",\n");
    sb_append(sb, "  \"build\": {\n");
    sb_append(sb, "    \"entry\": \"src/");
    if is_lib {
        sb_append(sb, "lib.sx");
    } else {
        sb_append(sb, "main.sx");
    }
    sb_append(sb, "\"\n");
    sb_append(sb, "  },\n");
    sb_append(sb, "  \"dependencies\": {}\n");
    sb_append(sb, "}\n");
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

fn template_test_sx(name: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, "// Tests for ");
    sb_append(sb, name);
    sb_append(sb, "\n\n");
    sb_append(sb, "fn test_example() {\n");
    sb_append(sb, "    // Add your tests here\n");
    sb_append(sb, "    println(\"PASS: example test\");\n");
    sb_append(sb, "}\n\n");
    sb_append(sb, "fn main() {\n");
    sb_append(sb, "    test_example();\n");
    sb_append(sb, "}\n");
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

// ============================================================================
// Cross-Platform Support
// ============================================================================

/// Detect the operating system - now uses shared platform module
/// Returns: "windows", "linux", or "macos"
/// Eliminated duplication across 5+ files
fn get_os_name() -> i64 {
    platform::get_os_name()
}

/// Get the path separator for the current platform
/// Returns "/" for Unix or "\" for Windows
fn get_path_separator() -> i64 {
    let os: i64 = get_os_name();
    if string_eq(os, "windows") {
        return "\\";
    }
    "/"
}

/// Get the path separator character code for the current platform
/// Returns 47 ('/') for Unix or 92 ('\') for Windows
fn get_path_separator_char() -> i64 {
    let os: i64 = get_os_name();
    if string_eq(os, "windows") {
        return 92;  // '\'
    }
    47  // '/'
}

/// Get the user's home directory
fn get_home_dir() -> i64 {
    let os: i64 = get_os_name();
    if string_eq(os, "windows") {
        let userprofile: i64 = cli_getenv("USERPROFILE");
        if userprofile != 0 && string_len(userprofile) > 0 {
            return userprofile;
        }
        // Fallback to HOMEDRIVE + HOMEPATH
        let homedrive: i64 = cli_getenv("HOMEDRIVE");
        let homepath: i64 = cli_getenv("HOMEPATH");
        if homedrive != 0 && homepath != 0 {
            return string_concat(homedrive, homepath);
        }
        return "C:\\Users\\Default";
    }
    // Unix: use HOME
    let home: i64 = cli_getenv("HOME");
    if home != 0 && string_len(home) > 0 {
        return home;
    }
    "/tmp"
}

/// Get the command to delete a directory recursively
fn get_rmdir_command(path: i64) -> i64 {
    let os: i64 = get_os_name();
    if string_eq(os, "windows") {
        return string_concat("rmdir /s /q ", path);
    }
    string_concat("rm -rf ", path)
}

/// Get the command to delete a single file
fn get_rm_command(path: i64) -> i64 {
    let os: i64 = get_os_name();
    if string_eq(os, "windows") {
        return string_concat("del /q ", path);
    }
    string_concat("rm -f ", path)
}

// ============================================================================
// File System Helpers
// ============================================================================

fn path_join(dir: i64, name: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, dir);
    let sep_char: i64 = get_path_separator_char();
    if string_char_at(dir, string_len(dir) - 1) != sep_char {
        sb_append_char(sb, sep_char);
    }
    sb_append(sb, name);
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

fn mkdir_p(path: i64) -> i64 {
    // Use mkdir intrinsic (calls intrinsic_mkdir_p which handles -p behavior)
    mkdir(path)
}

// Note: file_exists is now a built-in intrinsic
// No need to redefine it here

fn check_file_exists(path: i64) -> bool {
    file_exists(path) != 0
}

fn write_file_safe(path: i64, content: i64) -> i64 {
    write_file(path, content)
}

// ============================================================================
// Manifest Parsing
// ============================================================================

fn manifest_load(path: i64) -> i64 {
    let content: i64 = read_file(path);
    if content == 0 {
        return 0;
    }
    json_parse(content)
}

fn manifest_name(manifest: i64) -> i64 {
    let opt: i64 = json_get(manifest, "name");
    if json_is_string(opt) {
        return json_as_string(opt);
    }
    "unknown"
}

fn manifest_version(manifest: i64) -> i64 {
    let opt: i64 = json_get(manifest, "version");
    if json_is_string(opt) {
        return json_as_string(opt);
    }
    "0.0.0"
}

fn manifest_entry(manifest: i64) -> i64 {
    let build: i64 = json_get(manifest, "build");
    if json_is_object(build) {
        let entry: i64 = json_get(build, "entry");
        if json_is_string(entry) {
            return json_as_string(entry);
        }
    }
    // Auto-detect: prefer lib.sx for libraries, main.sx for binaries
    if file_exists("src/lib.sx") {
        return "src/lib.sx";
    }
    if file_exists("src/main.sx") {
        return "src/main.sx";
    }
    // Fallback to main.sx (will error if not found)
    "src/main.sx"
}

/// Check if this package is a library (has src/lib.sx)
fn is_library_package() -> bool {
    file_exists("src/lib.sx")
}

/// Get the package type as a string
fn package_type() -> i64 {
    if is_library_package() {
        "library"
    } else {
        "binary"
    }
}

fn manifest_dependencies(manifest: i64) -> i64 {
    let deps: i64 = json_get(manifest, "dependencies");
    if json_is_object(deps) {
        // Convert to vec of (name, value) pairs
        let keys: i64 = json_keys(deps);
        let result: i64 = vec_new();
        var i: i64 = 0;
        while i < vec_len(keys) {
            let key: i64 = vec_get(keys, i);
            let value: i64 = json_get(deps, key);
            // Create dependency entry: (name, value_json)
            let dep: i64 = malloc(16);
            store_ptr(dep, 0, key);
            store_ptr(dep, 1, value);
            vec_push(result, dep);
            i = i + 1;
        }
        return result;
    }
    vec_new()
}

fn manifest_to_json(manifest: i64) -> i64 {
    json_stringify(manifest)
}

fn manifest_validate(manifest: i64) -> i64 {
    // Returns a Vec of error messages (empty if valid)
    let errors: i64 = vec_new();

    // Check required fields
    let name: i64 = json_get(manifest, "name");
    if json_is_string(name) == false {
        vec_push(errors, "missing 'name' field");
    }

    let version: i64 = json_get(manifest, "version");
    if json_is_string(version) == false {
        vec_push(errors, "missing 'version' field");
    }

    errors
}

// ============================================================================
// Version Range Support (Semver)
// ============================================================================

/// Parse a semver version string into (major, minor, patch) components
/// Returns a tuple pointer: (i64, i64, i64)
fn version_parse(version: i64) -> i64 {
    let result: i64 = malloc(24)  // 3 * 8 bytes
    store_i64(result, 0, 0)       // major
    store_i64(result, 1, 0)       // minor
    store_i64(result, 2, 0)       // patch

    let parts: i64 = string_split(version, ".")
    if vec_len(parts) >= 1 {
        let major_str: i64 = vec_get(parts, 0)
        store_i64(result, 0, string_to_int(major_str))
    }
    if vec_len(parts) >= 2 {
        let minor_str: i64 = vec_get(parts, 1)
        store_i64(result, 1, string_to_int(minor_str))
    }
    if vec_len(parts) >= 3 {
        let patch_str: i64 = vec_get(parts, 2)
        // Handle pre-release suffixes like "1.0.0-beta"
        let patch_clean: i64 = string_split(patch_str, "-")
        store_i64(result, 2, string_to_int(vec_get(patch_clean, 0)))
    }
    result
}

/// Get major version from parsed version tuple
fn version_major(v: i64) -> i64 { load_i64(v, 0) }

/// Get minor version from parsed version tuple
fn version_minor(v: i64) -> i64 { load_i64(v, 1) }

/// Get patch version from parsed version tuple
fn version_patch(v: i64) -> i64 { load_i64(v, 2) }

/// Compare two versions: returns -1 if a < b, 0 if a == b, 1 if a > b
fn version_compare(a: i64, b: i64) -> i64 {
    let a_major: i64 = version_major(a)
    let b_major: i64 = version_major(b)
    if a_major < b_major { return -1 }
    if a_major > b_major { return 1 }

    let a_minor: i64 = version_minor(a)
    let b_minor: i64 = version_minor(b)
    if a_minor < b_minor { return -1 }
    if a_minor > b_minor { return 1 }

    let a_patch: i64 = version_patch(a)
    let b_patch: i64 = version_patch(b)
    if a_patch < b_patch { return -1 }
    if a_patch > b_patch { return 1 }

    0
}

/// Check if a version satisfies a version constraint
/// Supports: *, ^1.2.3, ~1.2.3, >=1.2.3, <=1.2.3, >1.2.3, <1.2.3, =1.2.3, 1.2.3
fn version_satisfies(version_str: i64, constraint: i64) -> bool {
    // Wildcard matches everything
    if string_eq(constraint, "*") {
        return true
    }

    let version: i64 = version_parse(version_str)

    // Parse constraint prefix
    var offset: i64 = 0
    var op: i64 = "="

    // Check for ^, ~, >=, <=, >, <
    if string_starts_with(constraint, "^") {
        op = "^"
        offset = 1
    } else if string_starts_with(constraint, "~") {
        op = "~"
        offset = 1
    } else if string_starts_with(constraint, ">=") {
        op = ">="
        offset = 2
    } else if string_starts_with(constraint, "<=") {
        op = "<="
        offset = 2
    } else if string_starts_with(constraint, ">") {
        op = ">"
        offset = 1
    } else if string_starts_with(constraint, "<") {
        op = "<"
        offset = 1
    } else if string_starts_with(constraint, "=") {
        op = "="
        offset = 1
    }

    let constraint_ver_str: i64 = string_slice(constraint, offset, string_len(constraint))
    let constraint_ver: i64 = version_parse(constraint_ver_str)
    let cmp: i64 = version_compare(version, constraint_ver)

    if string_eq(op, "=") {
        return cmp == 0
    }
    if string_eq(op, ">") {
        return cmp > 0
    }
    if string_eq(op, "<") {
        return cmp < 0
    }
    if string_eq(op, ">=") {
        return cmp >= 0
    }
    if string_eq(op, "<=") {
        return cmp <= 0
    }

    // ^ (caret): compatible with version, allows minor/patch updates
    // ^1.2.3 matches >=1.2.3 <2.0.0
    // ^0.2.3 matches >=0.2.3 <0.3.0
    // ^0.0.3 matches >=0.0.3 <0.0.4
    if string_eq(op, "^") {
        if cmp < 0 { return false }  // version must be >= constraint
        let v_major: i64 = version_major(version)
        let c_major: i64 = version_major(constraint_ver)
        let c_minor: i64 = version_minor(constraint_ver)
        let c_patch: i64 = version_patch(constraint_ver)

        if c_major > 0 {
            // ^1.2.3 allows changes that don't modify left-most non-zero
            return v_major == c_major
        }
        if c_minor > 0 {
            // ^0.2.3 only allows patch updates
            let v_minor: i64 = version_minor(version)
            return v_major == 0 && v_minor == c_minor
        }
        // ^0.0.3 only allows exact match
        let v_minor: i64 = version_minor(version)
        let v_patch: i64 = version_patch(version)
        return v_major == 0 && v_minor == 0 && v_patch == c_patch
    }

    // ~ (tilde): allows patch-level changes
    // ~1.2.3 matches >=1.2.3 <1.3.0
    if string_eq(op, "~") {
        if cmp < 0 { return false }  // version must be >= constraint
        let v_major: i64 = version_major(version)
        let v_minor: i64 = version_minor(version)
        let c_major: i64 = version_major(constraint_ver)
        let c_minor: i64 = version_minor(constraint_ver)
        return v_major == c_major && v_minor == c_minor
    }

    // Exact version if no operator
    cmp == 0
}

// ============================================================================
// Dependency Helpers
// ============================================================================

fn dep_name(dep: i64) -> i64 {
    load_ptr(dep, 0)
}

fn dep_value(dep: i64) -> i64 {
    load_ptr(dep, 1)
}

fn dep_is_path(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    if json_is_object(value) {
        let path: i64 = json_get(value, "path");
        return json_is_string(path);
    }
    false
}

fn dep_path(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    let path: i64 = json_get(value, "path");
    if json_is_string(path) {
        return json_as_string(path);
    }
    ""
}

fn dep_is_git(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    if json_is_object(value) {
        let git: i64 = json_get(value, "git");
        return json_is_string(git);
    }
    false
}

fn dep_git(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    let git: i64 = json_get(value, "git");
    if json_is_string(git) {
        return json_as_string(git);
    }
    ""
}

fn dep_is_registry(dep: i64) -> bool {
    let value: i64 = dep_value(dep);
    // Registry deps are just version strings or objects with "version" field
    if json_is_string(value) {
        return true;
    }
    if json_is_object(value) {
        let version: i64 = json_get(value, "version");
        return json_is_string(version);
    }
    false
}

fn dep_version(dep: i64) -> i64 {
    let value: i64 = dep_value(dep);
    if json_is_string(value) {
        return json_as_string(value);
    }
    if json_is_object(value) {
        let version: i64 = json_get(value, "version");
        if json_is_string(version) {
            return json_as_string(version);
        }
    }
    "*"
}

fn dependency_new(name: i64) -> i64 {
    // Create a new dependency entry: (name, value_json)
    let dep: i64 = malloc(16);
    store_ptr(dep, 0, name);
    store_ptr(dep, 1, json_string("*"));  // Default to any version
    dep
}

fn dep_set_path(dep: i64, path: i64) -> i64 {
    let obj: i64 = json_object_new();
    json_object_set(obj, "path", json_string(path));
    store_ptr(dep, 1, obj);
    0
}

fn dep_set_git(dep: i64, url: i64) -> i64 {
    let obj: i64 = json_object_new();
    json_object_set(obj, "git", json_string(url));
    store_ptr(dep, 1, obj);
    0
}

fn dep_set_version(dep: i64, version: i64) -> i64 {
    store_ptr(dep, 1, json_string(version));
    0
}

// ============================================================================
// Command: new
// ============================================================================

fn cmd_new(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm new <name> [--lib]");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);
    var is_lib: bool = false;

    // Check for --lib flag
    var i: i64 = arg_idx + 1;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--lib") {
            is_lib = true;
        }
        i = i + 1;
    }

    // Validate name
    if string_len(name) == 0 {
        println("Error: package name cannot be empty");
        return 1;
    }

    let first_char: i64 = string_char_at(name, 0);
    if first_char >= 48 && first_char <= 57 {  // '0'-'9'
        println("Error: package name cannot start with a number");
        return 1;
    }

    // Check if directory exists
    if check_file_exists(name) {
        print("Error: directory '");
        print(name);
        println("' already exists");
        return 1;
    }

    print("Creating package: ");
    println(name);

    // Create directory structure
    mkdir_p(name);
    mkdir_p(path_join(name, "src"));
    mkdir_p(path_join(name, "tests"));

    // Write simplex.json
    let manifest_path: i64 = path_join(name, "simplex.json");
    write_file_safe(manifest_path, template_manifest(name, is_lib));
    print("  Created: ");
    println(manifest_path);

    // Write main source file
    let src_name: i64 = if is_lib { "lib.sx" } else { "main.sx" };
    let src_path: i64 = path_join(path_join(name, "src"), src_name);
    let src_content: i64 = if is_lib { template_lib_sx() } else { template_main_sx() };
    write_file_safe(src_path, src_content);
    print("  Created: ");
    println(src_path);

    // Write test file
    let test_path: i64 = path_join(path_join(name, "tests"), "test_main.sx");
    write_file_safe(test_path, template_test_sx(name));
    print("  Created: ");
    println(test_path);

    // Write .gitignore
    let gitignore_path: i64 = path_join(name, ".gitignore");
    write_file_safe(gitignore_path, template_gitignore());
    print("  Created: ");
    println(gitignore_path);

    println("");
    print("Package '");
    print(name);
    println("' created successfully!");
    println("");
    println("To get started:");
    print("  cd ");
    println(name);
    println("  sxpm build");
    if is_lib == false {
        println("  sxpm run");
    }

    0
}

// ============================================================================
// Command: init
// ============================================================================

fn cmd_init(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Check if simplex.json already exists
    if check_file_exists("simplex.json") {
        println("Error: simplex.json already exists in current directory");
        return 1;
    }

    // Get current directory name for package name
    let cwd: i64 = get_cwd();
    let name: i64 = path_basename(cwd);

    var is_lib: bool = false;

    // Check for --lib flag
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--lib") {
            is_lib = true;
        }
        i = i + 1;
    }

    print("Initializing package: ");
    println(name);

    // Create src directory if needed
    mkdir_p("src");
    mkdir_p("tests");

    // Write simplex.json
    write_file_safe("simplex.json", template_manifest(name, is_lib));
    println("  Created: simplex.json");

    // Create source file if it doesn't exist
    let src_name: i64 = if is_lib { "src/lib.sx" } else { "src/main.sx" };
    if check_file_exists(src_name) == false {
        let src_content: i64 = if is_lib { template_lib_sx() } else { template_main_sx() };
        write_file_safe(src_name, src_content);
        print("  Created: ");
        println(src_name);
    }

    // Create .gitignore if it doesn't exist
    if check_file_exists(".gitignore") == false {
        write_file_safe(".gitignore", template_gitignore());
        println("  Created: .gitignore");
    }

    println("");
    println("Package initialized successfully!");

    0
}

// ============================================================================
// Command: build
// ============================================================================

fn cmd_build(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        println("Run 'sxpm init' to create a package");
        return 1;
    }

    // Validate manifest
    let errors: i64 = manifest_validate(manifest);
    if vec_len(errors) > 0 {
        println("Error: invalid simplex.json:");
        var i: i64 = 0;
        while i < vec_len(errors) {
            print("  - ");
            println(vec_get(errors, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = manifest_name(manifest);
    let entry: i64 = manifest_entry(manifest);

    var release_mode: bool = false;
    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--release") {
            release_mode = true;
        } else if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    print("Building ");
    print(name);
    print(" v");
    println(manifest_version(manifest));

    // Check entry file exists
    if check_file_exists(entry) == false {
        print("Error: entry file not found: ");
        println(entry);
        return 1;
    }

    // Create target directory
    let target_dir: i64 = if release_mode { "target/release" } else { "target/debug" };
    mkdir_p(target_dir);

    // Resolve dependencies with lock file support
    let deps: i64 = manifest_dependencies(manifest);
    if vec_len(deps) > 0 {
        println("Resolving dependencies...");
        let resolve_result: i64 = resolve_with_lockfile(manifest, verbose);
        if resolve_result != 0 {
            println("Error: failed to resolve dependencies");
            return 1;
        }
    }

    // Build the project
    println("Compiling...");

    // Construct build command
    // For now, use sxc directly
    let sb: i64 = sb_new();
    sb_append(sb, "sxc build ");
    sb_append(sb, entry);
    sb_append(sb, " -o ");
    sb_append(sb, target_dir);
    sb_append_char(sb, get_path_separator_char());
    sb_append(sb, name);

    let cmd: i64 = sb_to_string(sb);
    sb_free(sb);

    if verbose {
        print("  Running: ");
        println(cmd);
    }

    let result: i64 = process_run(cmd);

    if result == 0 {
        print("Built: ");
        print(target_dir);
        print("/");
        println(name);
    } else {
        println("Build failed");
    }

    result
}

// ============================================================================
// Command: run
// ============================================================================

fn cmd_run(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Build first
    let build_result: i64 = cmd_build(args, argc, arg_idx);
    if build_result != 0 {
        return build_result;
    }

    // Load manifest to get binary name
    let manifest: i64 = manifest_load("simplex.json");
    let name: i64 = manifest_name(manifest);

    var release_mode: bool = false;
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--release") {
            release_mode = true;
        }
        i = i + 1;
    }

    let target_dir: i64 = if release_mode { "target/release" } else { "target/debug" };
    let binary_path: i64 = path_join(target_dir, name);

    println("");
    println("Running...");
    println("---");

    let result: i64 = process_run(binary_path);

    println("---");
    result
}

// ============================================================================
// Command: test
// ============================================================================

fn cmd_test(args: i64, argc: i64, arg_idx: i64) -> i64 {
    println("Running tests...");

    // Find test files
    let test_files: i64 = find_test_files();
    let num_tests: i64 = vec_len(test_files);

    if num_tests == 0 {
        println("No test files found in tests/");
        return 0;
    }

    print("Found ");
    print(int_to_string(num_tests));
    println(" test file(s)");
    println("");

    var passed: i64 = 0;
    var failed: i64 = 0;

    var i: i64 = 0;
    while i < num_tests {
        let test_file: i64 = vec_get(test_files, i);
        print("  Running: ");
        print(test_file);
        print(" ... ");

        // Compile and run test
        let cmd: i64 = string_concat("sxc run ", test_file);
        let result: i64 = process_run(cmd);

        if result == 0 {
            println("PASS");
            passed = passed + 1;
        } else {
            println("FAIL");
            failed = failed + 1;
        }

        i = i + 1;
    }

    println("");
    println("Results:");
    print("  Passed: ");
    println(int_to_string(passed));
    print("  Failed: ");
    println(int_to_string(failed));

    if failed > 0 { 1 } else { 0 }
}

/// Find test files following naming conventions:
/// - tests/test_*.sx (preferred)
/// - tests/*_test.sx (alternative)
/// - Any .sx file in tests/ directory (fallback)
fn find_test_files() -> i64 {
    let files: i64 = vec_new();

    // List tests/ directory
    let listing: i64 = list_dir("tests");
    if listing == 0 {
        return files;
    }

    let n: i64 = vec_len(listing);
    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(listing, i);
        if string_ends_with(name, ".sx") {
            // Accept test_*.sx, *_test.sx, or any .sx file
            if string_starts_with(name, "test_") || string_ends_with(name, "_test.sx") {
                vec_push(files, path_join("tests", name));
            } else {
                // Also include other .sx files for backwards compatibility
                vec_push(files, path_join("tests", name));
            }
        }
        i = i + 1;
    }

    files
}

/// Find example files in examples/ directory
fn find_example_files() -> i64 {
    let files: i64 = vec_new();

    // List examples/ directory
    let listing: i64 = list_dir("examples");
    if listing == 0 {
        return files;
    }

    let n: i64 = vec_len(listing);
    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(listing, i);
        if string_ends_with(name, ".sx") {
            vec_push(files, path_join("examples", name));
        }
        i = i + 1;
    }

    files
}

// ============================================================================
// Command: clean
// ============================================================================

fn cmd_clean(args: i64, argc: i64, arg_idx: i64) -> i64 {
    println("Cleaning build artifacts...");

    let result: i64 = process_run(get_rmdir_command("target"));

    if result == 0 {
        println("Removed target/");
    }

    result
}

// ============================================================================
// Command: update
// ============================================================================

fn cmd_update(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    println("Updating dependencies...");

    // Remove existing lock file to force re-resolution
    if check_file_exists("simplex.lock") {
        process_run(get_rm_command("simplex.lock"));
        if verbose {
            println("Removed existing simplex.lock");
        }
    }

    // Resolve dependencies fresh
    let result: i64 = resolve_dependencies(manifest, verbose);
    if result != 0 {
        println("Error: failed to resolve dependencies");
        return result;
    }

    // Generate new lock file
    let graph: DepGraph = build_dep_graph(manifest, verbose);
    generate_lockfile(graph, verbose);

    println("Dependencies updated successfully");
    0
}

// ============================================================================
// Command: check
// ============================================================================

fn cmd_check(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Validate manifest
    let errors: i64 = manifest_validate(manifest);
    if vec_len(errors) > 0 {
        println("Error: invalid simplex.json:");
        var i: i64 = 0;
        while i < vec_len(errors) {
            print("  - ");
            println(vec_get(errors, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = manifest_name(manifest);
    let entry: i64 = manifest_entry(manifest);

    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    print("Checking ");
    println(name);

    // Just compile to LLVM IR without linking (type checking)
    let resolve_result: i64 = resolve_with_lockfile(manifest, verbose);
    if resolve_result != 0 {
        println("Error: failed to resolve dependencies");
        return 1;
    }

    // Run compiler in check-only mode
    let sb: i64 = sb_new();
    sb_append(sb, "python3 stage0.py ");
    sb_append(sb, entry);
    sb_append(sb, " --check");
    let compile_cmd: i64 = sb_to_string(sb);

    if verbose {
        print("Running: ");
        println(compile_cmd);
    }

    let result: i64 = process_run(compile_cmd);

    if result == 0 {
        println("Check passed!");
    } else {
        println("Check failed");
    }

    result
}

// ============================================================================
// Command: add
// ============================================================================

fn cmd_add(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm add <package> [--version <ver>] [--path <path>] [--git <url>]");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);
    var version: i64 = "*";
    var path: i64 = "";
    var git: i64 = "";

    // Parse options
    var i: i64 = arg_idx + 1;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--version") && i + 1 < argc {
            version = vec_get(args, i + 1);
            i = i + 2;
        } else if string_eq(arg, "--path") && i + 1 < argc {
            path = vec_get(args, i + 1);
            i = i + 2;
        } else if string_eq(arg, "--git") && i + 1 < argc {
            git = vec_get(args, i + 1);
            i = i + 2;
        } else {
            i = i + 1;
        }
    }

    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Check if dependency already exists
    let deps: i64 = manifest_dependencies(manifest);
    var j: i64 = 0;
    while j < vec_len(deps) {
        let dep: i64 = vec_get(deps, j);
        if string_eq(dep_name(dep), package_name) {
            print("Dependency '");
            print(package_name);
            println("' already exists");
            return 1;
        }
        j = j + 1;
    }

    // Create new dependency
    let new_dep: i64 = dependency_new(package_name);
    if string_len(path) > 0 {
        dep_set_path(new_dep, path);
    } else if string_len(git) > 0 {
        dep_set_git(new_dep, git);
    } else {
        dep_set_version(new_dep, version);
    }

    vec_push(deps, new_dep);

    // Write updated manifest
    let new_json: i64 = manifest_to_json(manifest);
    write_file_safe("simplex.json", new_json);

    print("Added dependency: ");
    print(package_name);
    if string_len(path) > 0 {
        print(" (path: ");
        print(path);
        print(")");
    } else if string_len(git) > 0 {
        print(" (git: ");
        print(git);
        print(")");
    } else {
        print(" ");
        print(version);
    }
    println("");

    0
}

// ============================================================================
// Command: remove
// ============================================================================

fn cmd_remove(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm remove <package>");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);

    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        return 1;
    }

    // Find and remove dependency
    let deps: i64 = manifest_dependencies(manifest);
    var found: bool = false;
    var i: i64 = 0;
    while i < vec_len(deps) {
        let dep: i64 = vec_get(deps, i);
        if string_eq(dep_name(dep), package_name) {
            vec_remove(deps, i);
            found = true;
            i = vec_len(deps);  // break
        } else {
            i = i + 1;
        }
    }

    if found == false {
        print("Dependency '");
        print(package_name);
        println("' not found");
        return 1;
    }

    // Write updated manifest
    let new_json: i64 = manifest_to_json(manifest);
    write_file_safe("simplex.json", new_json);

    print("Removed dependency: ");
    println(package_name);

    0
}

// ============================================================================
// Package Registry Configuration
// ============================================================================

// Registry URL - can be overridden via SIMPLEX_REGISTRY env
fn get_registry_url() -> i64 {
    let env_url: i64 = cli_getenv("SIMPLEX_REGISTRY");
    if env_url != 0 && string_len(env_url) > 0 {
        return env_url;
    }
    // Default to Simplex package registry
    "https://registry.simplex-lang.org"
}

// Local registry cache directory
fn get_registry_cache_dir() -> i64 {
    let home: i64 = get_home_dir();
    path_join(path_join(home, ".simplex"), "registry-cache")
}

// Get API endpoint for registry operations
fn registry_api_url(endpoint: i64) -> i64 {
    let base: i64 = get_registry_url();
    let sb: i64 = sb_new();
    sb_append(sb, base);
    sb_append(sb, "/api/v1");
    sb_append(sb, endpoint);
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

// ============================================================================
// SHA256 Checksum Support
// ============================================================================

// Compute SHA256 checksum of a file using external tool
fn compute_file_sha256(path: i64) -> i64 {
    let os: i64 = get_os_name();
    let cmd: i64 = sb_new();

    if string_eq(os, "macos") {
        // macOS uses shasum
        sb_append(cmd, "shasum -a 256 \"");
        sb_append(cmd, path);
        sb_append(cmd, "\" 2>/dev/null | cut -d' ' -f1");
    } else if string_eq(os, "windows") {
        // Windows uses certutil
        sb_append(cmd, "certutil -hashfile \"");
        sb_append(cmd, path);
        sb_append(cmd, "\" SHA256 | findstr /v \"hash\"");
    } else {
        // Linux uses sha256sum
        sb_append(cmd, "sha256sum \"");
        sb_append(cmd, path);
        sb_append(cmd, "\" 2>/dev/null | cut -d' ' -f1");
    }

    let cmd_str: i64 = sb_to_string(cmd);
    sb_free(cmd);

    // Execute and capture output
    let result: i64 = process_capture(cmd_str);
    if result == 0 || string_len(result) == 0 {
        return "";
    }

    // Trim whitespace from result
    string_trim(result)
}

// Verify file checksum matches expected
fn verify_checksum(path: i64, expected: i64) -> bool {
    if string_len(expected) == 0 {
        // No checksum to verify
        return true;
    }

    let actual: i64 = compute_file_sha256(path);
    if string_len(actual) == 0 {
        println("Warning: Could not compute checksum");
        return true;  // Proceed without verification
    }

    // Handle sha256: prefix
    var expected_hash: i64 = expected;
    if string_starts_with(expected, "sha256:") {
        expected_hash = string_slice(expected, 7, string_len(expected));
    }

    string_eq(actual, expected_hash)
}

// ============================================================================
// Search, Info, Install Commands
// ============================================================================

fn cmd_search(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing search query");
        println("Usage: sxpm search <query>");
        return 1;
    }

    let query: i64 = vec_get(args, arg_idx);
    print("Searching for: ");
    println(query);
    println("");

    // Try to search the registry
    let search_url: i64 = registry_api_url("/search?q=");
    let url: i64 = string_concat(search_url, query);

    // Use curl to fetch search results
    let cmd: i64 = sb_new();
    sb_append(cmd, "curl -s \"");
    sb_append(cmd, url);
    sb_append(cmd, "\"");
    let cmd_str: i64 = sb_to_string(cmd);
    sb_free(cmd);

    let response: i64 = process_capture(cmd_str);

    if response == 0 || string_len(response) == 0 {
        println("Could not connect to registry.");
        println("");
        println("Alternative package sources:");
        println("  1. Git dependencies:");
        println("     sxpm add my-pkg --git https://github.com/user/my-pkg");
        println("");
        println("  2. Local path dependencies:");
        println("     sxpm add my-pkg --path ../my-pkg");
        println("");
        println("  3. Browse packages at: https://github.com/topics/simplex-lang");
        return 0;
    }

    // Parse JSON response
    let results: i64 = json_parse(response);
    if results == 0 {
        println("Invalid response from registry");
        return 1;
    }

    let packages: i64 = json_get(results, "packages");
    if json_is_array(packages) == false {
        println("No packages found matching query.");
        return 0;
    }

    let count: i64 = json_array_len(packages);
    if count == 0 {
        println("No packages found matching query.");
        return 0;
    }

    print("Found ");
    print(int_to_string(count));
    println(" package(s):");
    println("");

    var i: i64 = 0;
    while i < count {
        let pkg: i64 = json_get_index(packages, i);
        let name: i64 = json_as_string(json_get(pkg, "name"));
        let version: i64 = json_as_string(json_get(pkg, "version"));
        let desc: i64 = json_as_string(json_get(pkg, "description"));

        print("  ");
        print(name);
        print(" (");
        print(version);
        println(")");

        if string_len(desc) > 0 {
            print("    ");
            println(desc);
        }
        println("");

        i = i + 1;
    }

    0
}

fn cmd_info(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Error: missing package name");
        println("Usage: sxpm info <package>");
        return 1;
    }

    let package_name: i64 = vec_get(args, arg_idx);

    // Fetch package info from registry
    let info_url: i64 = registry_api_url("/packages/");
    let url: i64 = string_concat(info_url, package_name);

    let cmd: i64 = sb_new();
    sb_append(cmd, "curl -s \"");
    sb_append(cmd, url);
    sb_append(cmd, "\"");
    let cmd_str: i64 = sb_to_string(cmd);
    sb_free(cmd);

    let response: i64 = process_capture(cmd_str);

    if response == 0 || string_len(response) == 0 {
        print("Package '");
        print(package_name);
        println("' not found in registry.");
        println("");
        println("Try searching with: sxpm search <query>");
        return 1;
    }

    let pkg: i64 = json_parse(response);
    if pkg == 0 {
        println("Invalid response from registry");
        return 1;
    }

    // Check for error response
    let error: i64 = json_get(pkg, "error");
    if json_is_string(error) {
        print("Error: ");
        println(json_as_string(error));
        return 1;
    }

    println("Package Information:");
    println("====================");
    println("");

    print("Name:        ");
    println(json_as_string(json_get(pkg, "name")));

    print("Version:     ");
    println(json_as_string(json_get(pkg, "version")));

    let desc: i64 = json_as_string(json_get(pkg, "description"));
    if string_len(desc) > 0 {
        print("Description: ");
        println(desc);
    }

    let license: i64 = json_as_string(json_get(pkg, "license"));
    if string_len(license) > 0 {
        print("License:     ");
        println(license);
    }

    let repo: i64 = json_as_string(json_get(pkg, "repository"));
    if string_len(repo) > 0 {
        print("Repository:  ");
        println(repo);
    }

    let homepage: i64 = json_as_string(json_get(pkg, "homepage"));
    if string_len(homepage) > 0 {
        print("Homepage:    ");
        println(homepage);
    }

    // Show available versions
    let versions: i64 = json_get(pkg, "versions");
    if json_is_array(versions) {
        println("");
        println("Available versions:");
        var i: i64 = 0;
        let count: i64 = json_array_len(versions);
        while i < count && i < 10 {
            print("  - ");
            println(json_as_string(json_get_index(versions, i)));
            i = i + 1;
        }
        if count > 10 {
            print("  ... and ");
            print(int_to_string(count - 10));
            println(" more");
        }
    }

    // Show dependencies
    let deps: i64 = json_get(pkg, "dependencies");
    if json_is_object(deps) {
        let keys: i64 = json_keys(deps);
        if vec_len(keys) > 0 {
            println("");
            println("Dependencies:");
            var j: i64 = 0;
            while j < vec_len(keys) {
                let dep_name: i64 = vec_get(keys, j);
                let dep_ver: i64 = json_as_string(json_get(deps, dep_name));
                print("  ");
                print(dep_name);
                print(": ");
                println(dep_ver);
                j = j + 1;
            }
        }
    }

    println("");
    println("Install with: sxpm add ");
    print("              ");
    println(package_name);

    0
}

fn cmd_install(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Install dependencies from simplex.json
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        println("Run 'sxpm init' to create a new project");
        return 1;
    }

    var verbose: bool = false;
    var frozen: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        } else if string_eq(arg, "--frozen") {
            frozen = true;
        }
        i = i + 1;
    }

    println("Installing dependencies...");

    // Check for lock file
    let lockfile: i64 = load_lockfile(verbose);

    if frozen {
        // Frozen install - must have lock file
        if lockfile == 0 {
            println("Error: --frozen requires simplex.lock file");
            println("Run 'sxpm install' first to generate lock file");
            return 1;
        }
        println("Using frozen dependencies from simplex.lock");
    }

    // Resolve and fetch dependencies
    let result: i64 = resolve_with_lockfile(manifest, verbose);
    if result != 0 {
        println("Error: failed to resolve dependencies");
        return result;
    }

    // Verify checksums if using lock file
    if lockfile != 0 {
        let verify_result: i64 = verify_lockfile_checksums(lockfile, verbose);
        if verify_result != 0 {
            println("Error: checksum verification failed");
            return verify_result;
        }
    }

    println("");
    println("Dependencies installed successfully");

    // Show lock file status
    if check_file_exists("simplex.lock") {
        println("Lock file: simplex.lock (up to date)");
    }

    0
}

// ============================================================================
// Package Publishing
// ============================================================================

fn cmd_publish(args: i64, argc: i64, arg_idx: i64) -> i64 {
    // Load manifest
    let manifest: i64 = manifest_load("simplex.json");
    if manifest == 0 {
        println("Error: simplex.json not found");
        println("Run 'sxpm init' to create a package");
        return 1;
    }

    // Validate manifest
    let errors: i64 = manifest_validate(manifest);
    if vec_len(errors) > 0 {
        println("Error: invalid simplex.json:");
        var i: i64 = 0;
        while i < vec_len(errors) {
            print("  - ");
            println(vec_get(errors, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = manifest_name(manifest);
    let version: i64 = manifest_version(manifest);

    var dry_run: bool = false;
    var verbose: bool = false;

    // Parse options
    var i: i64 = arg_idx;
    while i < argc {
        let arg: i64 = vec_get(args, i);
        if string_eq(arg, "--dry-run") {
            dry_run = true;
        } else if string_eq(arg, "-v") || string_eq(arg, "--verbose") {
            verbose = true;
        }
        i = i + 1;
    }

    println("Publishing package to registry...");
    println("");
    print("  Package: ");
    println(name);
    print("  Version: ");
    println(version);

    // Check for required fields
    let description: i64 = json_as_string(json_get(manifest, "description"));
    if string_len(description) == 0 {
        println("");
        println("Warning: Package has no description");
        println("Consider adding a 'description' field to simplex.json");
    }

    let license: i64 = json_as_string(json_get(manifest, "license"));
    if string_len(license) == 0 {
        println("");
        println("Warning: Package has no license specified");
        println("Consider adding a 'license' field to simplex.json");
    }

    // Check for README
    var readme_path: i64 = "";
    if check_file_exists("README.md") {
        readme_path = "README.md";
    } else if check_file_exists("readme.md") {
        readme_path = "readme.md";
    } else if check_file_exists("README.txt") {
        readme_path = "README.txt";
    }

    if string_len(readme_path) == 0 {
        println("");
        println("Warning: No README file found");
        println("Consider adding a README.md for package documentation");
    }

    // Create package tarball
    println("");
    println("Creating package archive...");

    let tarball_name: i64 = sb_new();
    sb_append(tarball_name, name);
    sb_append(tarball_name, "-");
    sb_append(tarball_name, version);
    sb_append(tarball_name, ".tar.gz");
    let tarball_path: i64 = sb_to_string(tarball_name);
    sb_free(tarball_name);

    // Build list of files to include
    let files_to_pack: i64 = vec_new();
    vec_push(files_to_pack, "simplex.json");

    // Include source files
    if check_file_exists("src") {
        vec_push(files_to_pack, "src");
    }

    // Include README if present
    if string_len(readme_path) > 0 {
        vec_push(files_to_pack, readme_path);
    }

    // Include LICENSE if present
    if check_file_exists("LICENSE") {
        vec_push(files_to_pack, "LICENSE");
    } else if check_file_exists("LICENSE.md") {
        vec_push(files_to_pack, "LICENSE.md");
    } else if check_file_exists("LICENSE.txt") {
        vec_push(files_to_pack, "LICENSE.txt");
    }

    // Build tar command
    let tar_cmd: i64 = sb_new();
    sb_append(tar_cmd, "tar -czf \"");
    sb_append(tar_cmd, tarball_path);
    sb_append(tar_cmd, "\"");

    i = 0;
    while i < vec_len(files_to_pack) {
        sb_append(tar_cmd, " \"");
        sb_append(tar_cmd, vec_get(files_to_pack, i));
        sb_append(tar_cmd, "\"");
        i = i + 1;
    }

    let tar_cmd_str: i64 = sb_to_string(tar_cmd);
    sb_free(tar_cmd);

    if verbose {
        print("  Running: ");
        println(tar_cmd_str);
    }

    let tar_result: i64 = process_run(tar_cmd_str);
    if tar_result != 0 {
        println("Error: Failed to create package archive");
        return 1;
    }

    // Compute checksum
    let checksum: i64 = compute_file_sha256(tarball_path);
    print("  Checksum: sha256:");
    println(checksum);

    // Get file size
    let size_cmd: i64 = sb_new();
    let os: i64 = get_os_name();
    if string_eq(os, "macos") {
        sb_append(size_cmd, "stat -f%z \"");
    } else {
        sb_append(size_cmd, "stat --printf='%s' \"");
    }
    sb_append(size_cmd, tarball_path);
    sb_append(size_cmd, "\"");
    let size_str: i64 = process_capture(sb_to_string(size_cmd));
    sb_free(size_cmd);

    print("  Size: ");
    print(string_trim(size_str));
    println(" bytes");

    if dry_run {
        println("");
        println("Dry run complete. Package not published.");
        println("");
        print("Archive created: ");
        println(tarball_path);
        println("");
        println("To publish for real, run: sxpm publish");

        // Clean up tarball
        process_run(get_rm_command(tarball_path));
        return 0;
    }

    // Upload to registry
    println("");
    println("Uploading to registry...");

    // Check for API token
    let api_token: i64 = cli_getenv("SIMPLEX_API_TOKEN");
    if api_token == 0 || string_len(api_token) == 0 {
        println("");
        println("Error: No API token found");
        println("");
        println("To publish packages, you need an API token.");
        println("Set the SIMPLEX_API_TOKEN environment variable:");
        println("  export SIMPLEX_API_TOKEN=your_token_here");
        println("");
        println("Get your token at: https://registry.simplex-lang.org/tokens");

        // Clean up tarball
        process_run(get_rm_command(tarball_path));
        return 1;
    }

    // Build upload request
    let upload_url: i64 = registry_api_url("/packages");
    let upload_cmd: i64 = sb_new();
    sb_append(upload_cmd, "curl -s -X POST ");
    sb_append(upload_cmd, "-H \"Authorization: Bearer ");
    sb_append(upload_cmd, api_token);
    sb_append(upload_cmd, "\" ");
    sb_append(upload_cmd, "-H \"Content-Type: multipart/form-data\" ");
    sb_append(upload_cmd, "-F \"package=@");
    sb_append(upload_cmd, tarball_path);
    sb_append(upload_cmd, "\" ");
    sb_append(upload_cmd, "-F \"name=");
    sb_append(upload_cmd, name);
    sb_append(upload_cmd, "\" ");
    sb_append(upload_cmd, "-F \"version=");
    sb_append(upload_cmd, version);
    sb_append(upload_cmd, "\" ");
    sb_append(upload_cmd, "-F \"checksum=sha256:");
    sb_append(upload_cmd, checksum);
    sb_append(upload_cmd, "\" ");
    sb_append(upload_cmd, "\"");
    sb_append(upload_cmd, upload_url);
    sb_append(upload_cmd, "\"");

    let upload_cmd_str: i64 = sb_to_string(upload_cmd);
    sb_free(upload_cmd);

    if verbose {
        println("  Uploading...");
    }

    let response: i64 = process_capture(upload_cmd_str);

    // Clean up tarball
    process_run(get_rm_command(tarball_path));

    // Parse response
    if response == 0 || string_len(response) == 0 {
        println("Error: No response from registry");
        println("Check your network connection and try again");
        return 1;
    }

    let result: i64 = json_parse(response);
    if result == 0 {
        println("Error: Invalid response from registry");
        if verbose {
            print("Response: ");
            println(response);
        }
        return 1;
    }

    // Check for error in response
    let error: i64 = json_get(result, "error");
    if json_is_string(error) {
        println("");
        print("Error: ");
        println(json_as_string(error));
        return 1;
    }

    // Success!
    println("");
    print("Successfully published ");
    print(name);
    print(" v");
    println(version);
    println("");
    print("View at: ");
    print(get_registry_url());
    print("/packages/");
    println(name);

    0
}

// ============================================================================
// Dependency Resolution with DAG
// ============================================================================

// Dependency graph node
// Stores: name, version, dependencies (vec of names), visited state
struct DepNode {
    name: i64,
    version: i64,
    path: i64,           // Path to dependency source
    deps: i64,           // Vec of dependency names
    state: i64,          // 0=unvisited, 1=visiting, 2=visited
    constraints: i64,    // Vec of (requirer, constraint) pairs for diamond detection
    resolved_version: i64  // Final resolved version after constraint solving
}

fn dep_node_new(name: i64, version: i64, path: i64) -> DepNode {
    DepNode {
        name: name,
        version: version,
        path: path,
        deps: vec_new(),
        state: 0,
        constraints: vec_new(),
        resolved_version: version
    }
}

// Add a version constraint from a requirer package
fn dep_node_add_constraint(node: DepNode, requirer: i64, constraint: i64) {
    // Store as a pair struct (simple approach: store alternating requirer, constraint)
    vec_push(node.constraints, requirer);
    vec_push(node.constraints, constraint);
}

// Dependency graph (DAG)
struct DepGraph {
    nodes: i64,          // HashMap<name, DepNode>
    order: i64,          // Vec of names in topological order
    has_cycle: bool,
    cycle_path: i64,     // Vec of names showing cycle
    conflicts: i64       // Vec of conflict messages for diamond deps
}

fn dep_graph_new() -> DepGraph {
    DepGraph {
        nodes: hashmap_new(),
        order: vec_new(),
        has_cycle: false,
        cycle_path: vec_new(),
        conflicts: vec_new()
    }
}

// Add a node to the graph, with version constraint tracking for diamond deps
// requirer: the package requiring this dependency (empty string for root)
// constraint: the version constraint (e.g., "^1.0.0", ">=2.0")
fn dep_graph_add_node_with_constraint(graph: DepGraph, name: i64, version: i64, path: i64, requirer: i64, constraint: i64) -> DepGraph {
    if hashmap_contains(graph.nodes, name) == 0 {
        // First time seeing this dependency
        let node: DepNode = dep_node_new(name, version, path);
        if string_len(requirer) > 0 {
            dep_node_add_constraint(node, requirer, constraint);
        }
        hashmap_insert(graph.nodes, name, node);
    } else {
        // Diamond dependency: this package is already required by another
        let node_opt: i64 = hashmap_get(graph.nodes, name);
        if node_opt != 0 {
            let existing: DepNode = node_opt;

            // Track the new constraint
            if string_len(requirer) > 0 {
                dep_node_add_constraint(existing, requirer, constraint);
            }

            // Check if the existing version satisfies the new constraint
            if string_len(constraint) > 0 {
                if version_satisfies(existing.version, constraint) == false {
                    // Version conflict detected!
                    let msg: i64 = string_concat("Diamond dependency conflict for '", name);
                    msg = string_concat(msg, "': ");
                    msg = string_concat(msg, requirer);
                    msg = string_concat(msg, " requires ");
                    msg = string_concat(msg, constraint);
                    msg = string_concat(msg, " but resolved version is ");
                    msg = string_concat(msg, existing.version);
                    vec_push(graph.conflicts, msg);
                }
            }
        }
    }
    graph
}

// Add a node to the graph (backwards compatible version)
fn dep_graph_add_node(graph: DepGraph, name: i64, version: i64, path: i64) -> DepGraph {
    dep_graph_add_node_with_constraint(graph, name, version, path, "", "*")
}

// Add an edge (dependency relationship) from 'from' to 'to'
fn dep_graph_add_edge(graph: DepGraph, from_name: i64, to_name: i64) -> DepGraph {
    let node_opt: i64 = hashmap_get(graph.nodes, from_name);
    if node_opt != 0 {
        let node: DepNode = node_opt;
        vec_push(node.deps, to_name);
    }
    graph
}

// DFS-based topological sort with cycle detection
// Returns: 0 = success, 1 = cycle detected
fn dep_graph_toposort(graph: DepGraph) -> i64 {
    // Reset all states
    let keys: i64 = hashmap_keys(graph.nodes);
    var i: i64 = 0;
    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);
        if node_opt != 0 {
            let node: DepNode = node_opt;
            node.state = 0;  // unvisited
        }
        i = i + 1;
    }

    // Clear previous order
    vec_clear(graph.order);
    graph.has_cycle = false;
    vec_clear(graph.cycle_path);

    // Visit all nodes
    i = 0;
    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);
        if node_opt != 0 {
            let node: DepNode = node_opt;
            if node.state == 0 {  // unvisited
                let result: i64 = dep_graph_visit(graph, name, vec_new());
                if result != 0 {
                    return 1;  // cycle detected
                }
            }
        }
        i = i + 1;
    }

    0  // success
}

// Visit a node for topological sort
fn dep_graph_visit(graph: DepGraph, name: i64, path: i64) -> i64 {
    let node_opt: i64 = hashmap_get(graph.nodes, name);
    if node_opt == 0 {
        return 0;  // Node doesn't exist, skip
    }

    let node: DepNode = node_opt;

    // Check for cycle (visiting a node that's already in the current path)
    if node.state == 1 {  // currently visiting
        graph.has_cycle = true;
        // Build cycle path
        vec_push(path, name);
        graph.cycle_path = path;
        return 1;
    }

    // Already visited
    if node.state == 2 {
        return 0;
    }

    // Mark as visiting
    node.state = 1;
    vec_push(path, name);

    // Visit all dependencies
    var i: i64 = 0;
    while i < vec_len(node.deps) {
        let dep_name: i64 = vec_get(node.deps, i);
        let result: i64 = dep_graph_visit(graph, dep_name, path);
        if result != 0 {
            return 1;  // cycle detected
        }
        i = i + 1;
    }

    // Mark as visited
    node.state = 2;
    vec_pop(path);

    // Add to order (reverse, so dependencies come first)
    vec_push(graph.order, name);

    0
}

// Print cycle error
fn dep_graph_print_cycle(graph: DepGraph) {
    println("Error: Circular dependency detected!");
    print("  Cycle: ");
    var i: i64 = 0;
    while i < vec_len(graph.cycle_path) {
        if i > 0 {
            print(" -> ");
        }
        print(vec_get(graph.cycle_path, i));
        i = i + 1;
    }
    println("");
}

// Check if graph has any version conflicts (diamond dependency issues)
fn dep_graph_has_conflicts(graph: DepGraph) -> bool {
    vec_len(graph.conflicts) > 0
}

// Print all version conflicts
fn dep_graph_print_conflicts(graph: DepGraph) {
    println("Error: Version conflicts detected (diamond dependencies):");
    var i: i64 = 0;
    while i < vec_len(graph.conflicts) {
        print("  ");
        println(vec_get(graph.conflicts, i));
        i = i + 1;
    }
    println("");
    println("Hint: Update version constraints to allow a compatible version,");
    println("      or pin all dependents to the same version.");
}

// Show all constraints for a node (debugging helper)
fn dep_node_print_constraints(node: DepNode) {
    print("Constraints for '");
    print(node.name);
    print("' (resolved: ");
    print(node.version);
    println("):");
    var i: i64 = 0;
    while i < vec_len(node.constraints) {
        let requirer: i64 = vec_get(node.constraints, i);
        let constraint: i64 = vec_get(node.constraints, i + 1);
        print("  - required by '");
        print(requirer);
        print("': ");
        println(constraint);
        i = i + 2;
    }
}

// Build dependency graph from manifest
fn build_dep_graph(manifest: i64, verbose: bool) -> DepGraph {
    let graph: DepGraph = dep_graph_new();

    // Add root package
    let root_name: i64 = manifest_name(manifest);
    let root_version: i64 = manifest_version(manifest);
    graph = dep_graph_add_node(graph, root_name, root_version, ".");

    // Queue for BFS traversal
    let queue: i64 = vec_new();
    vec_push(queue, root_name);

    // Visited set to avoid re-processing
    let visited: i64 = hashmap_new();
    hashmap_insert(visited, root_name, 1);

    while vec_len(queue) > 0 {
        let current_name: i64 = vec_get(queue, 0);
        // Remove first element (shift)
        let new_queue: i64 = vec_new();
        var i: i64 = 1;
        while i < vec_len(queue) {
            vec_push(new_queue, vec_get(queue, i));
            i = i + 1;
        }
        queue = new_queue;

        // Get current package's manifest
        let current_manifest: i64 = 0;
        if string_eq(current_name, root_name) {
            current_manifest = manifest;
        } else {
            // Load manifest from dependency path
            let node_opt: i64 = hashmap_get(graph.nodes, current_name);
            if node_opt != 0 {
                let node: DepNode = node_opt;
                let manifest_path: i64 = path_join(node.path, "simplex.json");
                current_manifest = manifest_load(manifest_path);
            }
        }

        if current_manifest == 0 {
            continue;
        }

        // Process dependencies
        let deps: i64 = manifest_dependencies(current_manifest);
        i = 0;
        while i < vec_len(deps) {
            let dep: i64 = vec_get(deps, i);
            let dep_name: i64 = dep_name(dep);

            // Determine dependency path
            let dep_path: i64 = "";
            if dep_is_path(dep) {
                dep_path = dep_path(dep);
            } else if dep_is_git(dep) {
                dep_path = path_join(".simplex/deps", dep_name);
            } else {
                dep_path = path_join(".simplex/deps", dep_name);
            }

            // Add node if not exists
            let dep_manifest_path: i64 = path_join(dep_path, "simplex.json");
            let dep_manifest: i64 = manifest_load(dep_manifest_path);
            let actual_version: i64 = "0.0.0";
            if dep_manifest != 0 {
                actual_version = manifest_version(dep_manifest);
            }

            // Get version constraint from dependency spec (for diamond conflict detection)
            let constraint: i64 = dep_version(dep);
            if string_len(constraint) == 0 {
                constraint = "*";  // No constraint means any version
            }

            // Use constraint-aware add to detect diamond conflicts
            graph = dep_graph_add_node_with_constraint(graph, dep_name, actual_version, dep_path, current_name, constraint);

            // Add edge from current to dependency
            graph = dep_graph_add_edge(graph, current_name, dep_name);

            // Queue for processing if not visited
            if hashmap_contains(visited, dep_name) == 0 {
                hashmap_insert(visited, dep_name, 1);
                vec_push(queue, dep_name);
            }

            i = i + 1;
        }
    }

    graph
}

// Resolve dependencies with proper DAG
fn resolve_dependencies(manifest: i64, verbose: bool) -> i64 {
    if verbose {
        println("Building dependency graph...");
    }

    // First, fetch all dependencies
    let result: i64 = fetch_dependencies(manifest, verbose);
    if result != 0 {
        return result;
    }

    // Build dependency graph
    let graph: DepGraph = build_dep_graph(manifest, verbose);

    // Check for diamond dependency conflicts
    if dep_graph_has_conflicts(graph) {
        dep_graph_print_conflicts(graph);
        return 1;
    }

    // Perform topological sort
    if verbose {
        println("Checking for cycles...");
    }

    let sort_result: i64 = dep_graph_toposort(graph);
    if sort_result != 0 {
        dep_graph_print_cycle(graph);
        return 1;
    }

    if verbose {
        println("Build order:");
        var i: i64 = 0;
        while i < vec_len(graph.order) {
            print("  ");
            print_i64(i + 1);
            print(". ");
            println(vec_get(graph.order, i));
            i = i + 1;
        }
    }

    0
}

// Fetch dependencies (download/clone as needed)
fn fetch_dependencies(manifest: i64, verbose: bool) -> i64 {
    let deps: i64 = manifest_dependencies(manifest);
    let n: i64 = vec_len(deps);

    var i: i64 = 0;
    while i < n {
        let dep: i64 = vec_get(deps, i);
        let name: i64 = dep_name(dep);

        if verbose {
            print("  Resolving: ");
            println(name);
        }

        if dep_is_path(dep) {
            // Local path dependency
            let path: i64 = dep_path(dep);
            let dep_manifest_path: i64 = path_join(path, "simplex.json");
            if check_file_exists(dep_manifest_path) == false {
                print("Error: dependency '");
                print(name);
                print("' not found at path: ");
                println(path);
                return 1;
            }
        } else if dep_is_git(dep) {
            // Git dependency - clone if needed
            let git_url: i64 = dep_git(dep);
            let cache_dir: i64 = path_join(".simplex/deps", name);

            if check_file_exists(cache_dir) == false {
                if verbose {
                    print("    Cloning from: ");
                    println(git_url);
                }

                mkdir_p(".simplex/deps");
                let clone_cmd: i64 = string_concat("git clone ", string_concat(git_url, string_concat(" ", cache_dir)));
                let result: i64 = process_run(clone_cmd);
                if result != 0 {
                    print("Error: failed to clone ");
                    println(name);
                    return 1;
                }
            }
        } else if dep_is_registry(dep) {
            // Registry dependency - download from registry
            let version_spec: i64 = dep_version(dep);
            if verbose {
                print("    Version: ");
                println(version_spec);
            }

            // For now, just check if it's cached
            let cache_dir: i64 = path_join(".simplex/deps", name);
            if check_file_exists(cache_dir) == false {
                print("Warning: registry dependency '");
                print(name);
                println("' not in cache");
                println("Registry support not yet implemented");
            }
        }

        i = i + 1;
    }

    0
}

// ============================================================================
// Lock File Generation (TOML format with SHA256 checksums)
// ============================================================================

// Determine source type for a dependency
fn get_source_type(path: i64) -> i64 {
    if string_eq(path, ".") {
        return "root";
    } else if string_starts_with(path, ".simplex/deps") {
        return "registry";
    } else {
        return "path";
    }
}

// Compute checksum for a package directory
fn compute_package_checksum(path: i64) -> i64 {
    // For root package, skip checksum
    if string_eq(path, ".") {
        return "";
    }

    // Hash the simplex.json file as the package identifier
    let manifest_path: i64 = path_join(path, "simplex.json");
    if check_file_exists(manifest_path) {
        return compute_file_sha256(manifest_path);
    }

    ""
}

// Generate simplex.lock from resolved dependency graph (TOML format)
fn generate_lockfile(graph: DepGraph, verbose: bool) -> i64 {
    if verbose {
        println("Generating simplex.lock...");
    }

    let sb: i64 = sb_new();

    // Header comment
    sb_append(sb, "# simplex.lock - DO NOT EDIT MANUALLY\n");
    sb_append(sb, "# Generated by sxpm ");
    sb_append(sb, SXPM_VERSION());
    sb_append(sb, "\n");
    sb_append(sb, "# This file pins exact dependency versions for reproducible builds.\n");
    sb_append(sb, "\n");

    // Metadata section
    sb_append(sb, "[metadata]\n");
    sb_append(sb, "version = 1\n");
    sb_append(sb, "generated = \"");
    // Add timestamp (simplified - just date)
    let timestamp: i64 = process_capture("date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo unknown");
    sb_append(sb, string_trim(timestamp));
    sb_append(sb, "\"\n");
    sb_append(sb, "\n");

    let keys: i64 = hashmap_keys(graph.nodes);
    var i: i64 = 0;

    while i < vec_len(keys) {
        let name: i64 = vec_get(keys, i);
        let node_opt: i64 = hashmap_get(graph.nodes, name);

        if node_opt != 0 {
            let node: DepNode = node_opt;

            // Skip root package in lock file output
            if string_eq(node.path, ".") == false {
                sb_append(sb, "[[package]]\n");

                sb_append(sb, "name = \"");
                sb_append(sb, name);
                sb_append(sb, "\"\n");

                sb_append(sb, "version = \"");
                sb_append(sb, node.version);
                sb_append(sb, "\"\n");

                // Compute and add checksum
                let checksum: i64 = compute_package_checksum(node.path);
                if string_len(checksum) > 0 {
                    sb_append(sb, "checksum = \"sha256:");
                    sb_append(sb, checksum);
                    sb_append(sb, "\"\n");
                }

                sb_append(sb, "source = \"");
                sb_append(sb, get_source_type(node.path));
                sb_append(sb, "\"\n");

                // Add path for non-registry sources
                if string_eq(get_source_type(node.path), "path") {
                    sb_append(sb, "path = \"");
                    sb_append(sb, node.path);
                    sb_append(sb, "\"\n");
                }

                // Dependencies list
                if vec_len(node.deps) > 0 {
                    sb_append(sb, "dependencies = [");
                    var j: i64 = 0;
                    while j < vec_len(node.deps) {
                        if j > 0 {
                            sb_append(sb, ", ");
                        }
                        sb_append(sb, "\"");
                        sb_append(sb, vec_get(node.deps, j));
                        sb_append(sb, "\"");
                        j = j + 1;
                    }
                    sb_append(sb, "]\n");
                }

                sb_append(sb, "\n");
            }
        }

        i = i + 1;
    }

    let lockfile_content: i64 = sb_to_string(sb);
    sb_free(sb);

    write_file("simplex.lock", lockfile_content);

    if verbose {
        println("  Created: simplex.lock");
    }

    0
}

// ============================================================================
// TOML Lock File Parsing
// ============================================================================

// Parsed package entry from lock file
struct LockedPackage {
    name: i64,
    version: i64,
    checksum: i64,
    source: i64,
    path: i64,
    dependencies: i64   // Vec of dependency names
}

fn locked_package_new() -> LockedPackage {
    LockedPackage {
        name: "",
        version: "",
        checksum: "",
        source: "",
        path: "",
        dependencies: vec_new()
    }
}

// Parse a TOML-style lock file into a list of packages
fn parse_lockfile_toml(content: i64) -> i64 {
    let packages: i64 = vec_new();
    var current: LockedPackage = locked_package_new();
    var in_package: bool = false;

    // Split content by lines
    let lines: i64 = string_split(content, "\n");
    var i: i64 = 0;

    while i < vec_len(lines) {
        let line: i64 = string_trim(vec_get(lines, i));

        // Skip comments and empty lines
        if string_len(line) == 0 || string_starts_with(line, "#") {
            i = i + 1;
            continue;
        }

        // Check for [[package]] header
        if string_eq(line, "[[package]]") {
            // Save previous package if any
            if in_package && string_len(current.name) > 0 {
                vec_push(packages, current);
            }
            current = locked_package_new();
            in_package = true;
            i = i + 1;
            continue;
        }

        // Skip [metadata] section
        if string_eq(line, "[metadata]") {
            in_package = false;
            i = i + 1;
            continue;
        }

        // Parse key = value lines within [[package]]
        if in_package {
            let eq_pos: i64 = string_find(line, "=");
            if eq_pos > 0 {
                let key: i64 = string_trim(string_slice(line, 0, eq_pos));
                var value: i64 = string_trim(string_slice(line, eq_pos + 1, string_len(line)));

                // Remove quotes from value
                if string_starts_with(value, "\"") && string_ends_with(value, "\"") {
                    value = string_slice(value, 1, string_len(value) - 1);
                }

                if string_eq(key, "name") {
                    current.name = value;
                } else if string_eq(key, "version") {
                    current.version = value;
                } else if string_eq(key, "checksum") {
                    current.checksum = value;
                } else if string_eq(key, "source") {
                    current.source = value;
                } else if string_eq(key, "path") {
                    current.path = value;
                } else if string_eq(key, "dependencies") {
                    // Parse array: ["dep1", "dep2"]
                    if string_starts_with(value, "[") {
                        value = string_slice(value, 1, string_len(value));
                    }
                    if string_ends_with(value, "]") {
                        value = string_slice(value, 0, string_len(value) - 1);
                    }
                    let deps: i64 = string_split(value, ",");
                    var j: i64 = 0;
                    while j < vec_len(deps) {
                        var dep: i64 = string_trim(vec_get(deps, j));
                        // Remove quotes
                        if string_starts_with(dep, "\"") {
                            dep = string_slice(dep, 1, string_len(dep));
                        }
                        if string_ends_with(dep, "\"") {
                            dep = string_slice(dep, 0, string_len(dep) - 1);
                        }
                        if string_len(dep) > 0 {
                            vec_push(current.dependencies, dep);
                        }
                        j = j + 1;
                    }
                }
            }
        }

        i = i + 1;
    }

    // Save last package
    if in_package && string_len(current.name) > 0 {
        vec_push(packages, current);
    }

    packages
}

// Load existing lock file (TOML format)
fn load_lockfile(verbose: bool) -> i64 {
    if check_file_exists("simplex.lock") == false {
        return 0;
    }

    let content: i64 = read_file("simplex.lock");
    if content == 0 {
        return 0;
    }

    let packages: i64 = parse_lockfile_toml(content);

    if verbose {
        print("Loaded simplex.lock (");
        print(int_to_string(vec_len(packages)));
        println(" packages)");
    }

    packages
}

// Check if lock file is up to date with manifest
fn lockfile_is_current(manifest: i64, lockfile: i64) -> bool {
    if lockfile == 0 {
        return false;
    }

    // lockfile is now a Vec of LockedPackage
    let packages: i64 = lockfile;

    // Build a set of locked package names
    let locked_names: i64 = hashmap_new();
    var i: i64 = 0;
    while i < vec_len(packages) {
        let pkg: LockedPackage = vec_get(packages, i);
        hashmap_insert(locked_names, pkg.name, 1);
        i = i + 1;
    }

    // Check all dependencies in manifest are in lockfile
    let deps: i64 = manifest_dependencies(manifest);
    i = 0;
    while i < vec_len(deps) {
        let dep: i64 = vec_get(deps, i);
        let name: i64 = dep_name(dep);

        if hashmap_contains(locked_names, name) == 0 {
            return false;
        }

        i = i + 1;
    }

    true
}

// Resolve dependencies with lock file support
fn resolve_with_lockfile(manifest: i64, verbose: bool) -> i64 {
    // Check for existing lock file
    let lockfile: i64 = load_lockfile(verbose);

    // If lock file exists and is current, use it
    if lockfile_is_current(manifest, lockfile) {
        if verbose {
            println("Using existing simplex.lock");
        }
        // Fetch any missing dependencies based on lock file
        return fetch_from_lockfile(lockfile, verbose);
    }

    // Otherwise, resolve fresh
    let result: i64 = resolve_dependencies(manifest, verbose);
    if result != 0 {
        return result;
    }

    // Generate new lock file
    let graph: DepGraph = build_dep_graph(manifest, verbose);
    generate_lockfile(graph, verbose);

    0
}

// Fetch dependencies based on lock file
fn fetch_from_lockfile(lockfile: i64, verbose: bool) -> i64 {
    let packages: i64 = lockfile;

    var i: i64 = 0;
    while i < vec_len(packages) {
        let pkg: LockedPackage = vec_get(packages, i);

        // Determine path based on source
        var path: i64 = pkg.path;
        if string_len(path) == 0 {
            if string_eq(pkg.source, "registry") {
                path = path_join(".simplex/deps", pkg.name);
            }
        }

        // Skip if no path to check
        if string_len(path) == 0 {
            i = i + 1;
            continue;
        }

        // Check if path exists
        if check_file_exists(path) == false {
            if verbose {
                print("  Fetching: ");
                print(pkg.name);
                print(" v");
                println(pkg.version);
            }

            // For registry packages, download from registry
            if string_eq(pkg.source, "registry") {
                let result: i64 = download_from_registry(pkg.name, pkg.version, path, verbose);
                if result != 0 {
                    print("Warning: Could not download '");
                    print(pkg.name);
                    println("' from registry");
                }
            } else {
                print("Warning: dependency '");
                print(pkg.name);
                print("' not found at: ");
                println(path);
            }
        }

        i = i + 1;
    }

    0
}

// Verify checksums from lock file
fn verify_lockfile_checksums(lockfile: i64, verbose: bool) -> i64 {
    let packages: i64 = lockfile;
    var errors: i64 = 0;

    var i: i64 = 0;
    while i < vec_len(packages) {
        let pkg: LockedPackage = vec_get(packages, i);

        // Skip packages without checksums
        if string_len(pkg.checksum) == 0 {
            i = i + 1;
            continue;
        }

        // Determine path
        var path: i64 = pkg.path;
        if string_len(path) == 0 {
            if string_eq(pkg.source, "registry") {
                path = path_join(".simplex/deps", pkg.name);
            }
        }

        if string_len(path) == 0 {
            i = i + 1;
            continue;
        }

        // Verify checksum
        let manifest_path: i64 = path_join(path, "simplex.json");
        if check_file_exists(manifest_path) {
            if verify_checksum(manifest_path, pkg.checksum) == false {
                print("Error: Checksum mismatch for '");
                print(pkg.name);
                println("'");
                print("  Expected: ");
                println(pkg.checksum);
                let actual: i64 = compute_file_sha256(manifest_path);
                print("  Actual:   sha256:");
                println(actual);
                errors = errors + 1;
            } else if verbose {
                print("  Verified: ");
                println(pkg.name);
            }
        }

        i = i + 1;
    }

    errors
}

// Download package from registry
fn download_from_registry(name: i64, version: i64, dest_path: i64, verbose: bool) -> i64 {
    // Construct download URL
    let download_url: i64 = registry_api_url("/packages/");
    let sb: i64 = sb_new();
    sb_append(sb, download_url);
    sb_append(sb, name);
    sb_append(sb, "/");
    sb_append(sb, version);
    sb_append(sb, "/download");
    let url: i64 = sb_to_string(sb);
    sb_free(sb);

    if verbose {
        print("    Downloading from: ");
        println(url);
    }

    // Create destination directory
    mkdir_p(path_join(".simplex", "deps"));

    // Download tarball
    let tarball_path: i64 = string_concat(dest_path, ".tar.gz");
    let download_cmd: i64 = sb_new();
    sb_append(download_cmd, "curl -sL -o \"");
    sb_append(download_cmd, tarball_path);
    sb_append(download_cmd, "\" \"");
    sb_append(download_cmd, url);
    sb_append(download_cmd, "\"");
    let cmd_str: i64 = sb_to_string(download_cmd);
    sb_free(download_cmd);

    let result: i64 = process_run(cmd_str);
    if result != 0 {
        return result;
    }

    // Check if tarball was downloaded
    if check_file_exists(tarball_path) == false {
        return 1;
    }

    // Extract tarball
    mkdir_p(dest_path);
    let extract_cmd: i64 = sb_new();
    sb_append(extract_cmd, "tar -xzf \"");
    sb_append(extract_cmd, tarball_path);
    sb_append(extract_cmd, "\" -C \"");
    sb_append(extract_cmd, dest_path);
    sb_append(extract_cmd, "\" --strip-components=1");
    let extract_str: i64 = sb_to_string(extract_cmd);
    sb_free(extract_cmd);

    result = process_run(extract_str);

    // Clean up tarball
    process_run(get_rm_command(tarball_path));

    result
}

// ============================================================================
// Helper Functions (requires runtime support)
// ============================================================================

fn path_basename(path: i64) -> i64 {
    let len: i64 = string_len(path);
    var last_slash: i64 = 0 - 1;
    var i: i64 = 0;
    let sep_char: i64 = get_path_separator_char();

    while i < len {
        let c: i64 = string_char_at(path, i);
        // Check for both '/' and '\' on Windows for compatibility
        if c == sep_char || c == 47 || c == 92 {
            last_slash = i;
        }
        i = i + 1;
    }

    if last_slash < 0 {
        return path;
    }

    string_slice(path, last_slash + 1, len)
}

// get_cwd and list_dir are now intrinsics - no wrapper needed

// ============================================================================
// Build Cache System
// ============================================================================

// Cache entry for a source file
struct CacheEntry {
    source_path: i64,    // Path to source file
    mtime: i64,          // Last modification time
    hash: i64,           // Content hash (for more robust checking)
    ll_path: i64,        // Path to compiled .ll file
    deps: i64            // Vec of dependency source paths
}

fn cache_entry_new(source_path: i64) -> CacheEntry {
    CacheEntry {
        source_path: source_path,
        mtime: file_mtime(source_path),
        hash: "",
        ll_path: "",
        deps: vec_new()
    }
}

// Cache directory paths
fn cache_dir() -> i64 {
    ".simplex/cache"
}

fn cache_meta_path() -> i64 {
    ".simplex/cache/meta.json"
}

// Initialize cache directory
fn cache_init() {
    mkdir_p(".simplex");
    mkdir_p(".simplex/cache");
}

// Simple hash function for source file content
fn hash_file_content(path: i64) -> i64 {
    let content: i64 = file_read(path);
    if string_len(content) == 0 {
        return "0";
    }

    // Simple FNV-1a style hash as string
    var hash: i64 = 2166136261;  // FNV offset basis
    var i: i64 = 0;
    let len: i64 = string_len(content);

    while i < len {
        let c: i64 = string_char_at(content, i);
        hash = (hash * 16777619) + c;  // FNV prime
        // Keep hash manageable
        hash = hash % 9999999999;
        i = i + 1;
    }

    int_to_string(hash)
}

// Check if a source file needs recompilation
fn needs_recompile(source_path: i64, cache: i64) -> bool {
    // Get cached entry for this file
    let entry_opt: i64 = hashmap_get(cache, source_path);
    if entry_opt == 0 {
        // Not in cache - needs compile
        return true;
    }

    let entry: CacheEntry = entry_opt;

    // Check modification time first (fast check)
    let current_mtime: i64 = file_mtime(source_path);
    if current_mtime != entry.mtime {
        // File was modified - needs recompile
        return true;
    }

    // Check if .ll file exists
    if check_file_exists(entry.ll_path) == false {
        return true;
    }

    // Check dependencies
    var i: i64 = 0;
    while i < vec_len(entry.deps) {
        let dep_path: i64 = vec_get(entry.deps, i);
        if needs_recompile(dep_path, cache) {
            return true;
        }
        i = i + 1;
    }

    false
}

// Load cache metadata from disk
fn cache_load() -> i64 {
    let cache: i64 = hashmap_new();

    if check_file_exists(cache_meta_path()) == false {
        return cache;
    }

    let content: i64 = file_read(cache_meta_path());
    if string_len(content) == 0 {
        return cache;
    }

    let json: i64 = json_parse_simple(content);
    if json == 0 {
        return cache;
    }

    // Parse entries array
    let entries: i64 = json_get(json, "entries");
    if json_is_array(entries) == false {
        return cache;
    }

    var i: i64 = 0;
    while i < json_array_len(entries) {
        let entry_json: i64 = json_get_index(entries, i);

        let source_path: i64 = json_as_string(json_get(entry_json, "source"));
        let entry: CacheEntry = CacheEntry {
            source_path: source_path,
            mtime: json_as_i64(json_get(entry_json, "mtime")),
            hash: json_as_string(json_get(entry_json, "hash")),
            ll_path: json_as_string(json_get(entry_json, "ll_path")),
            deps: vec_new()
        };

        // Load deps
        let deps_json: i64 = json_get(entry_json, "deps");
        if json_is_array(deps_json) {
            var j: i64 = 0;
            while j < json_array_len(deps_json) {
                vec_push(entry.deps, json_as_string(json_get_index(deps_json, j)));
                j = j + 1;
            }
        }

        hashmap_insert(cache, source_path, entry);
        i = i + 1;
    }

    cache
}

// Save cache metadata to disk
fn cache_save(cache: i64) {
    let sb: i64 = sb_new();
    sb_append(sb, "{\n  \"entries\": [\n");

    let keys: i64 = hashmap_keys(cache);
    var i: i64 = 0;
    while i < vec_len(keys) {
        let key: i64 = vec_get(keys, i);
        let entry_opt: i64 = hashmap_get(cache, key);
        if entry_opt != 0 {
            let entry: CacheEntry = entry_opt;

            if i > 0 {
                sb_append(sb, ",\n");
            }
            sb_append(sb, "    {\n");
            sb_append(sb, "      \"source\": \"");
            sb_append(sb, entry.source_path);
            sb_append(sb, "\",\n");
            sb_append(sb, "      \"mtime\": ");
            sb_append(sb, int_to_string(entry.mtime));
            sb_append(sb, ",\n");
            sb_append(sb, "      \"hash\": \"");
            sb_append(sb, entry.hash);
            sb_append(sb, "\",\n");
            sb_append(sb, "      \"ll_path\": \"");
            sb_append(sb, entry.ll_path);
            sb_append(sb, "\",\n");
            sb_append(sb, "      \"deps\": [");

            var j: i64 = 0;
            while j < vec_len(entry.deps) {
                if j > 0 {
                    sb_append(sb, ", ");
                }
                sb_append(sb, "\"");
                sb_append(sb, vec_get(entry.deps, j));
                sb_append(sb, "\"");
                j = j + 1;
            }

            sb_append(sb, "]\n");
            sb_append(sb, "    }");
        }
        i = i + 1;
    }

    sb_append(sb, "\n  ]\n}\n");
    file_write(cache_meta_path(), sb_to_string(sb));
}

// Update cache entry after compilation
fn cache_update(cache: i64, source_path: i64, ll_path: i64, deps: i64) {
    let entry: CacheEntry = CacheEntry {
        source_path: source_path,
        mtime: file_mtime(source_path),
        hash: hash_file_content(source_path),
        ll_path: ll_path,
        deps: deps
    };
    hashmap_insert(cache, source_path, entry);
}

// Clear cache for a specific file
fn cache_invalidate(cache: i64, source_path: i64) {
    hashmap_remove(cache, source_path);
}

// Clear all cache
fn cache_clear() {
    if check_file_exists(cache_meta_path()) {
        remove_path(cache_meta_path());
    }
}

// ============================================================================
// Model Management for SLM Provisioning
// ============================================================================

// Model directory paths
fn models_global_dir() -> i64 {
    let home: i64 = get_home_dir();
    path_join(path_join(home, ".simplex"), "models")
}

fn models_local_dir() -> i64 {
    ".simplex/models"
}

// Model registry URL (can be overridden via SIMPLEX_MODEL_REGISTRY env)
fn models_registry_url() -> i64 {
    let env_url: i64 = cli_getenv("SIMPLEX_MODEL_REGISTRY");
    if string_len(env_url) > 0 {
        return env_url;
    }
    "https://raw.githubusercontent.com/anthropics/simplex-models/main/registry.json"
}

// Built-in model definitions (when registry unavailable)
fn builtin_models() -> i64 {
    let models: i64 = json_object();

    // Cognitive model for anima.think()
    let cognitive: i64 = json_object();
    json_object_set_sx(cognitive, "name", json_string_sx("simplex-cognitive-7b"));
    json_object_set_sx(cognitive, "description", json_string_sx("Default reasoning model for anima.think()"));
    json_object_set_sx(cognitive, "size", json_string_sx("4.1GB"));
    json_object_set_sx(cognitive, "quantization", json_string_sx("Q4_K_M"));
    json_object_set_sx(cognitive, "url", json_string_sx("https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.2-GGUF/resolve/main/mistral-7b-instruct-v0.2.Q4_K_M.gguf"));
    json_object_set_sx(cognitive, "sha256", json_string_sx(""));
    json_object_set_sx(models, "simplex-cognitive-7b", cognitive);

    // Lightweight cognitive model
    let cognitive_sm: i64 = json_object();
    json_object_set_sx(cognitive_sm, "name", json_string_sx("simplex-cognitive-1b"));
    json_object_set_sx(cognitive_sm, "description", json_string_sx("Lightweight model for resource-constrained environments"));
    json_object_set_sx(cognitive_sm, "size", json_string_sx("700MB"));
    json_object_set_sx(cognitive_sm, "quantization", json_string_sx("Q4_K_M"));
    json_object_set_sx(cognitive_sm, "url", json_string_sx("https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF/resolve/main/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf"));
    json_object_set_sx(cognitive_sm, "sha256", json_string_sx(""));
    json_object_set_sx(models, "simplex-cognitive-1b", cognitive_sm);

    // Embedding model for mnemonic memory
    let embed: i64 = json_object();
    json_object_set_sx(embed, "name", json_string_sx("simplex-mnemonic-embed"));
    json_object_set_sx(embed, "description", json_string_sx("Embedding model for memory recall and semantic search"));
    json_object_set_sx(embed, "size", json_string_sx("134MB"));
    json_object_set_sx(embed, "quantization", json_string_sx("F16"));
    json_object_set_sx(embed, "url", json_string_sx("https://huggingface.co/nomic-ai/nomic-embed-text-v1.5-GGUF/resolve/main/nomic-embed-text-v1.5.Q8_0.gguf"));
    json_object_set_sx(embed, "sha256", json_string_sx(""));
    json_object_set_sx(models, "simplex-mnemonic-embed", embed);

    models
}

// Check if model is installed
fn model_is_installed(name: i64) -> bool {
    let global_path: i64 = path_join(models_global_dir(), name);
    let gguf_path: i64 = string_concat(global_path, ".gguf");
    if check_file_exists(gguf_path) {
        return true;
    }
    let local_path: i64 = path_join(models_local_dir(), name);
    let local_gguf: i64 = string_concat(local_path, ".gguf");
    check_file_exists(local_gguf)
}

// Get model file path
fn model_path(name: i64) -> i64 {
    let global_path: i64 = path_join(models_global_dir(), name);
    let gguf_path: i64 = string_concat(global_path, ".gguf");
    if check_file_exists(gguf_path) {
        return gguf_path;
    }
    let local_path: i64 = path_join(models_local_dir(), name);
    string_concat(local_path, ".gguf")
}

// List models
fn cmd_model_list(args: i64, argc: i64, arg_idx: i64) -> i64 {
    println("Available Models:");
    println("================");
    println("");

    let models: i64 = builtin_models();
    let keys: i64 = json_keys(models);
    let n: i64 = vec_len(keys);
    let i: i64 = 0;

    while i < n {
        let name: i64 = vec_get(keys, i);
        let model: i64 = json_get_sx(models, name);
        let desc: i64 = json_as_string(json_get_sx(model, "description"));
        let size: i64 = json_as_string(json_get_sx(model, "size"));

        print("  ");
        print(name);
        if model_is_installed(name) {
            print(" [installed]");
        }
        println("");
        print("    ");
        println(desc);
        print("    Size: ");
        println(size);
        println("");

        i = i + 1;
    }

    0
}

// Install a model
fn cmd_model_install(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm model install <name>");
        println("");
        println("Available models:");
        let models: i64 = builtin_models();
        let keys: i64 = json_keys(models);
        let n: i64 = vec_len(keys);
        let i: i64 = 0;
        while i < n {
            print("  ");
            println(vec_get(keys, i));
            i = i + 1;
        }
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);

    // Check if already installed
    if model_is_installed(name) {
        print("Model '");
        print(name);
        println("' is already installed.");
        print("Path: ");
        println(model_path(name));
        return 0;
    }

    // Look up model in registry
    let models: i64 = builtin_models();
    let model: i64 = json_get_sx(models, name);

    if json_is_null(model) {
        print("Unknown model: ");
        println(name);
        println("Run 'sxpm model list' to see available models.");
        return 1;
    }

    let url: i64 = json_as_string(json_get_sx(model, "url"));
    let size: i64 = json_as_string(json_get_sx(model, "size"));

    print("Installing model: ");
    println(name);
    print("Size: ");
    println(size);
    println("");

    // Ensure models directory exists
    mkdir_p(models_global_dir());

    let dest_path: i64 = path_join(models_global_dir(), name);
    let dest_gguf: i64 = string_concat(dest_path, ".gguf");

    print("Downloading to: ");
    println(dest_gguf);
    println("");
    println("Note: Download will use curl. For large models this may take several minutes.");
    println("");

    // Download using curl
    let cmd: i64 = sb_new();
    sb_append(cmd, "curl -L -# -o \"");
    sb_append(cmd, dest_gguf);
    sb_append(cmd, "\" \"");
    sb_append(cmd, url);
    sb_append(cmd, "\"");
    let cmd_str: i64 = sb_to_string(cmd);
    sb_free(cmd);

    let result: i64 = process_run(cmd_str);

    if result == 0 {
        println("");
        print("Model '");
        print(name);
        println("' installed successfully!");
        print("Path: ");
        println(dest_gguf);
    } else {
        print("Failed to download model. Exit code: ");
        print_i64(result);
        println("");
    }

    result
}

// Remove a model
fn cmd_model_remove(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm model remove <name>");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);

    if !model_is_installed(name) {
        print("Model '");
        print(name);
        println("' is not installed.");
        return 1;
    }

    let path: i64 = model_path(name);
    print("Removing model: ");
    println(path);

    remove_path(path);

    print("Model '");
    print(name);
    println("' removed.");

    0
}

// Show model info
fn cmd_model_info(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm model info <name>");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);
    let models: i64 = builtin_models();
    let model: i64 = json_get_sx(models, name);

    if json_is_null(model) {
        print("Unknown model: ");
        println(name);
        return 1;
    }

    println("Model Information:");
    println("==================");
    print("Name:         ");
    println(json_as_string(json_get_sx(model, "name")));
    print("Description:  ");
    println(json_as_string(json_get_sx(model, "description")));
    print("Size:         ");
    println(json_as_string(json_get_sx(model, "size")));
    print("Quantization: ");
    println(json_as_string(json_get_sx(model, "quantization")));
    print("Installed:    ");
    if model_is_installed(name) {
        println("Yes");
        print("Path:         ");
        println(model_path(name));
    } else {
        println("No");
    }
    print("URL:          ");
    println(json_as_string(json_get_sx(model, "url")));

    0
}

// Model command dispatcher
fn cmd_model(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm model <subcommand>");
        println("");
        println("Subcommands:");
        println("  list           List available/installed models");
        println("  install <name> Download and install a model");
        println("  remove <name>  Remove an installed model");
        println("  info <name>    Show model information");
        return 1;
    }

    let subcmd: i64 = vec_get(args, arg_idx);

    if string_eq(subcmd, "list") {
        return cmd_model_list(args, argc, arg_idx + 1);
    } else if string_eq(subcmd, "install") {
        return cmd_model_install(args, argc, arg_idx + 1);
    } else if string_eq(subcmd, "remove") {
        return cmd_model_remove(args, argc, arg_idx + 1);
    } else if string_eq(subcmd, "info") {
        return cmd_model_info(args, argc, arg_idx + 1);
    } else {
        print("Unknown model subcommand: ");
        println(subcmd);
        return 1;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main() -> i64 {
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        sxpm_show_help();
        return 0;
    }

    let cmd: i64 = vec_get(args, 1);

    // Help flags
    if string_eq(cmd, "-h") || string_eq(cmd, "--help") {
        sxpm_show_help();
        return 0;
    }

    if string_eq(cmd, "--version") {
        sxpm_show_version();
        return 0;
    }

    // Commands
    let result: i64 = 0;

    if string_eq(cmd, "new") {
        result = cmd_new(args, argc, 2);
    } else if string_eq(cmd, "init") {
        result = cmd_init(args, argc, 2);
    } else if string_eq(cmd, "build") {
        result = cmd_build(args, argc, 2);
    } else if string_eq(cmd, "run") {
        result = cmd_run(args, argc, 2);
    } else if string_eq(cmd, "test") {
        result = cmd_test(args, argc, 2);
    } else if string_eq(cmd, "clean") {
        result = cmd_clean(args, argc, 2);
    } else if string_eq(cmd, "update") {
        result = cmd_update(args, argc, 2);
    } else if string_eq(cmd, "check") {
        result = cmd_check(args, argc, 2);
    } else if string_eq(cmd, "add") {
        result = cmd_add(args, argc, 2);
    } else if string_eq(cmd, "remove") {
        result = cmd_remove(args, argc, 2);
    } else if string_eq(cmd, "search") {
        result = cmd_search(args, argc, 2);
    } else if string_eq(cmd, "info") {
        result = cmd_info(args, argc, 2);
    } else if string_eq(cmd, "install") {
        result = cmd_install(args, argc, 2);
    } else if string_eq(cmd, "publish") {
        result = cmd_publish(args, argc, 2);
    } else if string_eq(cmd, "model") {
        result = cmd_model(args, argc, 2);
    } else {
        print("Unknown command: ");
        println(cmd);
        println("");
        sxpm_show_help();
        result = 1;
    }

    exit(result);
}
