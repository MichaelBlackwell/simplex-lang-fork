// Minimal Simplex Lexer
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics

// Token types as enum
enum TokenKind {
    Eof,
    Ident,
    Int,
    String,
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub
}

// Lexer state - we pass this to all functions instead of using self
fn lexer_new(source: i64) -> i64 {
    // Allocate lexer state: source(0), pos(1), len(2)
    let lexer: i64 = malloc(24);
    store_ptr(lexer, 0, source);
    store_i64(lexer, 1, 0);
    let len: i64 = string_len(source);
    store_i64(lexer, 2, len);
    lexer
}

fn lexer_pos(lexer: i64) -> i64 {
    load_i64(lexer, 1)
}

fn lexer_len(lexer: i64) -> i64 {
    load_i64(lexer, 2)
}

fn lexer_source(lexer: i64) -> i64 {
    load_ptr(lexer, 0)
}

fn lexer_at_end(lexer: i64) -> bool {
    let pos: i64 = lexer_pos(lexer);
    let len: i64 = lexer_len(lexer);
    pos >= len
}

fn lexer_peek(lexer: i64) -> i64 {
    if lexer_at_end(lexer) {
        0
    } else {
        let src: i64 = lexer_source(lexer);
        let pos: i64 = lexer_pos(lexer);
        string_char_at(src, pos)
    }
}

fn lexer_advance(lexer: i64) -> i64 {
    let c: i64 = lexer_peek(lexer);
    if c != 0 {
        let pos: i64 = lexer_pos(lexer);
        store_i64(lexer, 1, pos + 1);
    }
    c
}

fn is_whitespace(c: i64) -> bool {
    if c == 32 { return true; }
    if c == 9 { return true; }
    if c == 10 { return true; }
    if c == 13 { return true; }
    false
}

fn is_digit(c: i64) -> bool {
    if c >= 48 {
        if c <= 57 { true }
        else { false }
    } else {
        false
    }
}

fn is_alpha(c: i64) -> bool {
    // a-z: 97-122
    if c >= 97 {
        if c <= 122 { return true; }
    }
    // A-Z: 65-90
    if c >= 65 {
        if c <= 90 { return true; }
    }
    false
}

fn is_ident_start(c: i64) -> bool {
    if is_alpha(c) { return true; }
    if c == 95 { return true; }
    false
}

fn is_ident_continue(c: i64) -> bool {
    if is_ident_start(c) { return true; }
    if is_digit(c) { return true; }
    false
}

fn lexer_skip_whitespace(lexer: i64) -> i64 {
    while is_whitespace(lexer_peek(lexer)) {
        lexer_advance(lexer);
    }
    0
}

fn lexer_skip_line_comment(lexer: i64) -> i64 {
    while lexer_peek(lexer) != 10 {
        if lexer_at_end(lexer) {
            return 0;
        }
        lexer_advance(lexer);
    }
    0
}

// Create a token - returns ptr to token struct
// Token: kind(0), text(1), pos(2)
fn token_new(kind: i64, text: i64, pos: i64) -> i64 {
    let tok: i64 = malloc(24);
    store_i64(tok, 0, kind);
    store_ptr(tok, 1, text);
    store_i64(tok, 2, pos);
    tok
}

fn token_kind(tok: i64) -> i64 {
    load_i64(tok, 0)
}

fn token_text(tok: i64) -> i64 {
    load_ptr(tok, 1)
}

// Check if identifier matches keyword
fn check_keyword(text: i64) -> i64 {
    if string_eq(text, "fn") { return TokenKind::KwFn; }
    if string_eq(text, "let") { return TokenKind::KwLet; }
    if string_eq(text, "if") { return TokenKind::KwIf; }
    if string_eq(text, "else") { return TokenKind::KwElse; }
    if string_eq(text, "while") { return TokenKind::KwWhile; }
    if string_eq(text, "return") { return TokenKind::KwReturn; }
    if string_eq(text, "enum") { return TokenKind::KwEnum; }
    if string_eq(text, "true") { return TokenKind::KwTrue; }
    if string_eq(text, "false") { return TokenKind::KwFalse; }
    if string_eq(text, "pub") { return TokenKind::KwPub; }
    TokenKind::Ident
}

// Main tokenizer function
fn lexer_next_token(lexer: i64) -> i64 {
    lexer_skip_whitespace(lexer);

    if lexer_at_end(lexer) {
        return token_new(TokenKind::Eof, string_from(""), lexer_pos(lexer));
    }

    let start: i64 = lexer_pos(lexer);
    let c: i64 = lexer_advance(lexer);

    // Single character tokens
    if c == 40 { return token_new(TokenKind::LParen, string_from("("), start); }
    if c == 41 { return token_new(TokenKind::RParen, string_from(")"), start); }
    if c == 123 { return token_new(TokenKind::LBrace, string_from("{"), start); }
    if c == 125 { return token_new(TokenKind::RBrace, string_from("}"), start); }
    if c == 91 { return token_new(TokenKind::LBracket, string_from("["), start); }
    if c == 93 { return token_new(TokenKind::RBracket, string_from("]"), start); }
    if c == 44 { return token_new(TokenKind::Comma, string_from(","), start); }
    if c == 59 { return token_new(TokenKind::Semi, string_from(";"), start); }
    if c == 43 { return token_new(TokenKind::Plus, string_from("+"), start); }
    if c == 42 { return token_new(TokenKind::Star, string_from("*"), start); }
    if c == 46 { return token_new(TokenKind::Dot, string_from("."), start); }

    // Two character tokens
    if c == 58 {
        if lexer_peek(lexer) == 58 {
            lexer_advance(lexer);
            return token_new(TokenKind::DoubleColon, string_from("::"), start);
        }
        return token_new(TokenKind::Colon, string_from(":"), start);
    }

    if c == 45 {
        if lexer_peek(lexer) == 62 {
            lexer_advance(lexer);
            return token_new(TokenKind::Arrow, string_from("->"), start);
        }
        return token_new(TokenKind::Minus, string_from("-"), start);
    }

    if c == 61 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::EqEq, string_from("=="), start);
        }
        return token_new(TokenKind::Eq, string_from("="), start);
    }

    if c == 33 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Ne, string_from("!="), start);
        }
        return token_new(TokenKind::Bang, string_from("!"), start);
    }

    if c == 60 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Le, string_from("<="), start);
        }
        return token_new(TokenKind::Lt, string_from("<"), start);
    }

    if c == 62 {
        if lexer_peek(lexer) == 61 {
            lexer_advance(lexer);
            return token_new(TokenKind::Ge, string_from(">="), start);
        }
        return token_new(TokenKind::Gt, string_from(">"), start);
    }

    if c == 47 {
        if lexer_peek(lexer) == 47 {
            lexer_skip_line_comment(lexer);
            return lexer_next_token(lexer);
        }
        return token_new(TokenKind::Slash, string_from("/"), start);
    }

    // Identifiers and keywords
    if is_ident_start(c) {
        while is_ident_continue(lexer_peek(lexer)) {
            lexer_advance(lexer);
        }
        let end: i64 = lexer_pos(lexer);
        let text: i64 = string_slice(lexer_source(lexer), start, end);
        let kind: i64 = check_keyword(text);
        return token_new(kind, text, start);
    }

    // Numbers
    if is_digit(c) {
        while is_digit(lexer_peek(lexer)) {
            lexer_advance(lexer);
        }
        let end: i64 = lexer_pos(lexer);
        let text: i64 = string_slice(lexer_source(lexer), start, end);
        return token_new(TokenKind::Int, text, start);
    }

    // String literals
    if c == 34 {
        while lexer_peek(lexer) != 34 {
            if lexer_at_end(lexer) {
                return token_new(TokenKind::Eof, string_from(""), start);
            }
            lexer_advance(lexer);
        }
        lexer_advance(lexer);
        let end: i64 = lexer_pos(lexer);
        let text: i64 = string_slice(lexer_source(lexer), start + 1, end - 1);
        return token_new(TokenKind::String, text, start);
    }

    // Unknown character - return EOF for now
    token_new(TokenKind::Eof, string_from(""), start)
}

// Tokenize entire source into a list
fn tokenize(source: i64) -> i64 {
    let lexer: i64 = lexer_new(source);
    let tokens: i64 = vec_new();

    while true {
        let tok: i64 = lexer_next_token(lexer);
        vec_push(tokens, tok);
        if token_kind(tok) == TokenKind::Eof {
            return tokens;
        }
    }

    tokens
}
// Minimal Simplex Parser
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics
// Uses early returns instead of else-if chains

// AST node tags - using i64 since stage1 doesn't have proper enums for everything
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }

// Parser state - we pass this to all functions
fn parser_new(tokens: i64) -> i64 {
    // Allocate parser: tokens(0), pos(1), len(2)
    let parser: i64 = malloc(24);
    store_ptr(parser, 0, tokens);
    store_i64(parser, 1, 0);
    let len: i64 = vec_len(tokens);
    store_i64(parser, 2, len);
    parser
}

fn parser_tokens(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn parser_pos(parser: i64) -> i64 {
    load_i64(parser, 1)
}

fn parser_len(parser: i64) -> i64 {
    load_i64(parser, 2)
}

fn parser_at_end(parser: i64) -> bool {
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    pos >= len
}

fn parser_current(parser: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    vec_get(tokens, pos)
}

fn parser_advance(parser: i64) -> i64 {
    let tok: i64 = parser_current(parser);
    let pos: i64 = parser_pos(parser);
    store_i64(parser, 1, pos + 1);
    tok
}

fn parser_check(parser: i64, kind: i64) -> bool {
    if parser_at_end(parser) { return false; }
    let tok: i64 = parser_current(parser);
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_match(parser: i64, kind: i64) -> bool {
    if parser_check(parser, kind) {
        parser_advance(parser);
        return true;
    }
    false
}

fn parser_expect(parser: i64, kind: i64) -> i64 {
    if parser_check(parser, kind) {
        return parser_advance(parser);
    }
    // Error - return null for now
    0
}

// AST node constructors

// Item: FnDef
// Layout: tag(0), name(1), params(2), ret_ty(3), body(4)
fn ast_fn_def(name: i64, params: i64, ret_ty: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_FN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, params);
    store_ptr(node, 3, ret_ty);
    store_ptr(node, 4, body);
    node
}

// Item: EnumDef
// Layout: tag(0), name(1), variants(2)
fn ast_enum_def(name: i64, variants: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_ENUM());
    store_ptr(node, 1, name);
    store_ptr(node, 2, variants);
    node
}

// Stmt: Let
// Layout: tag(0), name(1), ty(2), init(3)
fn ast_let(name: i64, ty: i64, init: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, STMT_LET());
    store_ptr(node, 1, name);
    store_ptr(node, 2, ty);
    store_ptr(node, 3, init);
    node
}

// Stmt: Expr
// Layout: tag(0), expr(1)
fn ast_expr_stmt(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_EXPR());
    store_ptr(node, 1, expr);
    node
}

// Stmt: Return
// Layout: tag(0), expr(1)
fn ast_return(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_RETURN());
    store_ptr(node, 1, expr);
    node
}

// Expr: Int literal
// Layout: tag(0), value(1)
fn ast_int(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INT());
    store_i64(node, 1, value);
    node
}

// Expr: Bool literal
// Layout: tag(0), value(1)
fn ast_bool(value: bool) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BOOL());
    store_i64(node, 1, value);
    node
}

// Expr: String literal
// Layout: tag(0), value(1)
fn ast_string(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_STRING());
    store_ptr(node, 1, value);
    node
}

// Expr: Identifier
// Layout: tag(0), name(1)
fn ast_ident(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_IDENT());
    store_ptr(node, 1, name);
    node
}

// Expr: Path (Type::Variant)
// Layout: tag(0), segments(1)
fn ast_path(segments: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_PATH());
    store_ptr(node, 1, segments);
    node
}

// Expr: Call
// Layout: tag(0), callee(1), args(2)
fn ast_call(callee: i64, args: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_CALL());
    store_ptr(node, 1, callee);
    store_ptr(node, 2, args);
    node
}

// Expr: Binary
// Layout: tag(0), op(1), left(2), right(3)
fn ast_binary(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_BINARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, left);
    store_ptr(node, 3, right);
    node
}

// Expr: Unary
// Layout: tag(0), op(1), operand(2)
fn ast_unary(op: i64, operand: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_UNARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, operand);
    node
}

// Expr: If
// Layout: tag(0), cond(1), then_block(2), else_block(3)
fn ast_if(cond: i64, then_block: i64, else_block: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_IF());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, then_block);
    store_ptr(node, 3, else_block);
    node
}

// Expr: While
// Layout: tag(0), cond(1), body(2)
fn ast_while(cond: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_WHILE());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, body);
    node
}

// Expr: Block
// Layout: tag(0), stmts(1), result(2)
fn ast_block(stmts: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_BLOCK());
    store_ptr(node, 1, stmts);
    store_ptr(node, 2, result);
    node
}

// Param: name, type
// Layout: name(0), ty(1)
fn ast_param(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Binary operator codes
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }

// Unary operator codes
fn OP_NEG() -> i64 { 0 }
fn OP_NOT() -> i64 { 1 }

// Parse primary expression
fn parse_primary(parser: i64) -> i64 {
    // Integer literal
    if parser_check(parser, TokenKind::Int) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        let value: i64 = string_to_int(text);
        return ast_int(value);
    }

    // Boolean literals
    if parser_check(parser, TokenKind::KwTrue) {
        parser_advance(parser);
        return ast_bool(true);
    }
    if parser_check(parser, TokenKind::KwFalse) {
        parser_advance(parser);
        return ast_bool(false);
    }

    // String literal
    if parser_check(parser, TokenKind::String) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_string(text);
    }

    // Identifier or path
    if parser_check(parser, TokenKind::Ident) {
        let tok: i64 = parser_advance(parser);
        let name: i64 = token_text(tok);

        // Check for path (::)
        if parser_check(parser, TokenKind::DoubleColon) {
            let segments: i64 = vec_new();
            vec_push(segments, name);

            while parser_match(parser, TokenKind::DoubleColon) {
                if parser_check(parser, TokenKind::Ident) {
                    let seg_tok: i64 = parser_advance(parser);
                    let seg_name: i64 = token_text(seg_tok);
                    vec_push(segments, seg_name);
                }
            }
            return ast_path(segments);
        }

        // Check for function call
        if parser_check(parser, TokenKind::LParen) {
            parser_advance(parser);
            let args: i64 = vec_new();

            if parser_check(parser, TokenKind::RParen) {
                // Empty args
            } else {
                let first_arg: i64 = parse_expr(parser);
                vec_push(args, first_arg);

                while parser_match(parser, TokenKind::Comma) {
                    let arg: i64 = parse_expr(parser);
                    vec_push(args, arg);
                }
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_call(ast_ident(name), args);
        }

        return ast_ident(name);
    }

    // Parenthesized expression
    if parser_match(parser, TokenKind::LParen) {
        let expr: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return expr;
    }

    // If expression
    if parser_check(parser, TokenKind::KwIf) {
        return parse_if(parser);
    }

    // While expression
    if parser_check(parser, TokenKind::KwWhile) {
        return parse_while(parser);
    }

    // Block expression
    if parser_check(parser, TokenKind::LBrace) {
        return parse_block(parser);
    }

    // Error - return null
    0
}

// Parse unary expression
fn parse_unary(parser: i64) -> i64 {
    if parser_match(parser, TokenKind::Minus) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NEG(), operand);
    }
    if parser_match(parser, TokenKind::Bang) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NOT(), operand);
    }
    parse_primary(parser)
}

// Parse multiplicative expression
fn parse_multiplicative(parser: i64) -> i64 {
    let left: i64 = parse_unary(parser);

    while true {
        if parser_match(parser, TokenKind::Star) {
            let right: i64 = parse_unary(parser);
            left = ast_binary(OP_MUL(), left, right);
        } else {
            if parser_match(parser, TokenKind::Slash) {
                let right: i64 = parse_unary(parser);
                left = ast_binary(OP_DIV(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse additive expression
fn parse_additive(parser: i64) -> i64 {
    let left: i64 = parse_multiplicative(parser);

    while true {
        if parser_match(parser, TokenKind::Plus) {
            let right: i64 = parse_multiplicative(parser);
            left = ast_binary(OP_ADD(), left, right);
        } else {
            if parser_match(parser, TokenKind::Minus) {
                let right: i64 = parse_multiplicative(parser);
                left = ast_binary(OP_SUB(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse comparison expression
fn parse_comparison(parser: i64) -> i64 {
    let left: i64 = parse_additive(parser);

    if parser_match(parser, TokenKind::EqEq) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_EQ(), left, right);
    }
    if parser_match(parser, TokenKind::Ne) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_NE(), left, right);
    }
    if parser_match(parser, TokenKind::Lt) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_LT(), left, right);
    }
    if parser_match(parser, TokenKind::Gt) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_GT(), left, right);
    }
    if parser_match(parser, TokenKind::Le) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_LE(), left, right);
    }
    if parser_match(parser, TokenKind::Ge) {
        let right: i64 = parse_additive(parser);
        return ast_binary(OP_GE(), left, right);
    }
    left
}

// Parse expression
fn parse_expr(parser: i64) -> i64 {
    parse_comparison(parser)
}

// Parse block
fn parse_block(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::LBrace);
    let stmts: i64 = vec_new();
    let result: i64 = 0;

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_block(stmts, result);
        }

        // Check for statement vs expression
        if parser_check(parser, TokenKind::KwLet) {
            let stmt: i64 = parse_let(parser);
            vec_push(stmts, stmt);
        } else {
            if parser_check(parser, TokenKind::KwReturn) {
                let stmt: i64 = parse_return(parser);
                vec_push(stmts, stmt);
            } else {
                // Expression - could be statement or result
                let expr: i64 = parse_expr(parser);

                if parser_match(parser, TokenKind::Semi) {
                    // Expression statement
                    vec_push(stmts, ast_expr_stmt(expr));
                } else {
                    // Result expression (no semicolon)
                    result = expr;
                }
            }
        }
    }

    ast_block(stmts, result)
}

// Parse if expression
fn parse_if(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwIf);
    let cond: i64 = parse_expr(parser);
    let then_block: i64 = parse_block(parser);
    let else_block: i64 = 0;

    if parser_match(parser, TokenKind::KwElse) {
        // Check if it's else-if or else block
        if parser_check(parser, TokenKind::KwIf) {
            else_block = parse_if(parser);
        } else {
            else_block = parse_block(parser);
        }
    }

    ast_if(cond, then_block, else_block)
}

// Parse while expression
fn parse_while(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwWhile);
    let cond: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_while(cond, body)
}

// Parse let statement
fn parse_let(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwLet);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init)
}

// Parse return statement
fn parse_return(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwReturn);
    let expr: i64 = 0;

    if parser_check(parser, TokenKind::Semi) {
        // return;
    } else {
        expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_return(expr)
}

// Parse type (simple: just identifier for now)
fn parse_type(parser: i64) -> i64 {
    let tok: i64 = parser_expect(parser, TokenKind::Ident);
    token_text(tok)
}

// Parse function parameters
fn parse_params(parser: i64) -> i64 {
    let params: i64 = vec_new();
    parser_expect(parser, TokenKind::LParen);

    if parser_check(parser, TokenKind::RParen) {
        parser_advance(parser);
        return params;
    }

    // First param
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Colon);
    let ty: i64 = parse_type(parser);
    vec_push(params, ast_param(name, ty));

    // More params
    while parser_match(parser, TokenKind::Comma) {
        let pname_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let pname: i64 = token_text(pname_tok);
        parser_expect(parser, TokenKind::Colon);
        let pty: i64 = parse_type(parser);
        vec_push(params, ast_param(pname, pty));
    }

    parser_expect(parser, TokenKind::RParen);
    params
}

// Parse function definition
fn parse_fn(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFn);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    let params: i64 = parse_params(parser);

    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    let body: i64 = parse_block(parser);
    ast_fn_def(name, params, ret_ty, body)
}

// Parse enum definition
fn parse_enum(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwEnum);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let variants: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_enum_def(name, variants);
        }

        let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let var_name: i64 = token_text(var_tok);
        vec_push(variants, var_name);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_enum_def(name, variants)
}

// Parse a single item (fn or enum)
fn parse_item(parser: i64) -> i64 {
    // Skip pub keyword if present
    parser_match(parser, TokenKind::KwPub);

    if parser_check(parser, TokenKind::KwFn) {
        return parse_fn(parser);
    }
    if parser_check(parser, TokenKind::KwEnum) {
        return parse_enum(parser);
    }

    // Unknown item
    0
}

// Parse entire program
fn parse_program(tokens: i64) -> i64 {
    let parser: i64 = parser_new(tokens);
    let items: i64 = vec_new();

    while true {
        if parser_at_end(parser) {
            return items;
        }

        // Skip EOF tokens
        if parser_check(parser, TokenKind::Eof) {
            return items;
        }

        let item: i64 = parse_item(parser);
        if item != 0 {
            vec_push(items, item);
        }
    }

    items
}
// Minimal Simplex Code Generator
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics
// Outputs LLVM IR

// Codegen state
fn codegen_new() -> i64 {
    // Allocate codegen: output(0), temp_counter(1), label_counter(2), enums(3), locals(4)
    let cg: i64 = malloc(40);
    store_ptr(cg, 0, string_from(""));
    store_i64(cg, 1, 0);
    store_i64(cg, 2, 0);
    store_ptr(cg, 3, vec_new());  // registered enums: vec of (name, variants)
    store_ptr(cg, 4, vec_new());  // local variables in current function
    cg
}

fn cg_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_next_temp(cg: i64) -> i64 {
    let t: i64 = load_i64(cg, 1);
    store_i64(cg, 1, t + 1);
    t
}

fn cg_next_label(cg: i64) -> i64 {
    let l: i64 = load_i64(cg, 2);
    store_i64(cg, 2, l + 1);
    l
}

fn cg_enums(cg: i64) -> i64 {
    load_ptr(cg, 3)
}

fn cg_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_clear_locals(cg: i64) -> i64 {
    store_ptr(cg, 4, vec_new());
    0
}

// Emit to output buffer
fn emit(cg: i64, s: i64) -> i64 {
    let out: i64 = cg_output(cg);
    let new_out: i64 = string_concat(out, s);
    store_ptr(cg, 0, new_out);
    0
}

fn emit_line(cg: i64, s: i64) -> i64 {
    emit(cg, s);
    emit(cg, "\n");
    0
}

// Register an enum
fn register_enum(cg: i64, name: i64, variants: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, variants);
    vec_push(enums, entry);
    0
}

// Look up enum variant index
fn lookup_variant(cg: i64, enum_name: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, enum_name) {
            let variants: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(variants);
            let j: i64 = 0;
            while j < m {
                let v: i64 = vec_get(variants, j);
                if string_eq(v, var_name) {
                    return j;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Check if local exists
fn has_local(cg: i64, name: i64) -> bool {
    let locals: i64 = cg_locals(cg);
    let n: i64 = vec_len(locals);
    let i: i64 = 0;
    while i < n {
        let local: i64 = vec_get(locals, i);
        if string_eq(local, name) {
            return true;
        }
        i = i + 1;
    }
    false
}

fn add_local(cg: i64, name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    vec_push(locals, name);
    0
}

// Generate expression - returns the LLVM value (temp name or literal)
fn gen_expr(cg: i64, expr: i64) -> i64 {
    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == EXPR_INT() {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == EXPR_BOOL() {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("1");
        }
        return string_from("0");
    }

    // String literal - allocate and initialize
    if tag == EXPR_STRING() {
        let value: i64 = load_ptr(expr, 1);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        // Emit global string constant and load
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
        emit(cg, int_to_string(t));
        emit_line(cg, ")");

        return temp;
    }

    // Identifier - load from local
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = load i64, ptr %local.");
        emit_line(cg, name);

        return temp;
    }

    // Path - enum variant
    if tag == EXPR_PATH() {
        let segments: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(segments);
        if len == 2 {
            let enum_name: i64 = vec_get(segments, 0);
            let var_name: i64 = vec_get(segments, 1);
            let idx: i64 = lookup_variant(cg, enum_name, var_name);
            return int_to_string(idx);
        }
        return string_from("0");
    }

    // Function call
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);

        // Get function name
        let callee_name: i64 = load_ptr(callee, 1);

        // Generate args
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Emit call
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(");

        i = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Binary operation
    if tag == EXPR_BINARY() {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = ");

        if op == OP_ADD() { emit(cg, "add i64 "); }
        if op == OP_SUB() { emit(cg, "sub i64 "); }
        if op == OP_MUL() { emit(cg, "mul i64 "); }
        if op == OP_DIV() { emit(cg, "sdiv i64 "); }
        if op == OP_EQ() { emit(cg, "icmp eq i64 "); }
        if op == OP_NE() { emit(cg, "icmp ne i64 "); }
        if op == OP_LT() { emit(cg, "icmp slt i64 "); }
        if op == OP_GT() { emit(cg, "icmp sgt i64 "); }
        if op == OP_LE() { emit(cg, "icmp sle i64 "); }
        if op == OP_GE() { emit(cg, "icmp sge i64 "); }

        emit(cg, left_val);
        emit(cg, ", ");
        emit_line(cg, right_val);

        return temp;
    }

    // Unary operation
    if tag == EXPR_UNARY() {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        let val: i64 = gen_expr(cg, operand);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);

        if op == OP_NEG() {
            emit(cg, " = sub i64 0, ");
            emit_line(cg, val);
        }
        if op == OP_NOT() {
            emit(cg, " = xor i1 ");
            emit(cg, val);
            emit_line(cg, ", 1");
        }

        return temp;
    }

    // If expression
    if tag == EXPR_IF() {
        return gen_if(cg, expr);
    }

    // While expression
    if tag == EXPR_WHILE() {
        return gen_while(cg, expr);
    }

    // Block expression
    if tag == EXPR_BLOCK() {
        return gen_block(cg, expr);
    }

    string_from("0")
}

// Generate if expression
fn gen_if(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let then_block: i64 = load_ptr(expr, 2);
    let else_block: i64 = load_ptr(expr, 3);

    let cond_val: i64 = gen_expr(cg, cond);

    let l: i64 = cg_next_label(cg);
    let then_lbl: i64 = string_concat("then", int_to_string(l));
    let else_lbl: i64 = string_concat("else", int_to_string(l));
    let end_lbl: i64 = string_concat("end", int_to_string(l));

    // Branch
    emit(cg, "  br i1 ");
    emit(cg, cond_val);
    emit(cg, ", label %");
    emit(cg, then_lbl);
    emit(cg, ", label %");
    emit_line(cg, else_lbl);

    // Then block
    emit(cg, then_lbl);
    emit_line(cg, ":");
    let then_val: i64 = gen_block(cg, then_block);
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Else block
    emit(cg, else_lbl);
    emit_line(cg, ":");
    let else_val: i64 = string_from("0");
    if else_block != 0 {
        else_val = gen_expr(cg, else_block);
    }
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End - phi node
    emit(cg, end_lbl);
    emit_line(cg, ":");
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));

    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = phi i64 [ ");
    emit(cg, then_val);
    emit(cg, ", %");
    emit(cg, then_lbl);
    emit(cg, " ], [ ");
    emit(cg, else_val);
    emit(cg, ", %");
    emit(cg, else_lbl);
    emit_line(cg, " ]");

    temp
}

// Generate while expression
fn gen_while(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let body: i64 = load_ptr(expr, 2);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let body_lbl: i64 = string_concat("body", int_to_string(l));
    let end_lbl: i64 = string_concat("endloop", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let cond_val: i64 = gen_expr(cg, cond);
    emit(cg, "  br i1 ");
    emit(cg, cond_val);
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body
    emit(cg, body_lbl);
    emit_line(cg, ":");
    gen_block(cg, body);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate block
fn gen_block(cg: i64, block: i64) -> i64 {
    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);

    let n: i64 = vec_len(stmts);
    let i: i64 = 0;
    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        gen_stmt(cg, stmt);
        i = i + 1;
    }

    if result != 0 {
        return gen_expr(cg, result);
    }

    string_from("0")
}

// Generate statement
fn gen_stmt(cg: i64, stmt: i64) -> i64 {
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        let init: i64 = load_ptr(stmt, 3);

        // Declare local variable
        emit(cg, "  %local.");
        emit(cg, name);
        emit_line(cg, " = alloca i64");
        add_local(cg, name);

        // Initialize if there's an init expression
        if init != 0 {
            let val: i64 = gen_expr(cg, init);
            emit(cg, "  store i64 ");
            emit(cg, val);
            emit(cg, ", ptr %local.");
            emit_line(cg, name);
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        gen_expr(cg, expr);
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            let val: i64 = gen_expr(cg, expr);
            emit(cg, "  ret i64 ");
            emit_line(cg, val);
        } else {
            emit_line(cg, "  ret void");
        }
        return 0;
    }

    0
}

// Generate function
fn gen_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let params: i64 = load_ptr(fn_def, 2);
    let ret_ty: i64 = load_ptr(fn_def, 3);
    let body: i64 = load_ptr(fn_def, 4);

    cg_clear_locals(cg);

    // Function signature
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, name);
    emit(cg, "\"(");

    // Parameters
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Copy params to locals
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname);
        i = i + 1;
    }

    // Generate body
    let result: i64 = gen_block(cg, body);

    // Return
    if ret_ty != 0 {
        emit(cg, "  ret i64 ");
        emit_line(cg, result);
    } else {
        emit_line(cg, "  ret void");
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Generate enum (just register it)
fn gen_enum(cg: i64, enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    register_enum(cg, name, variants);
    0
}

// Generate item
fn gen_item(cg: i64, item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == TAG_FN() {
        return gen_fn(cg, item);
    }
    if tag == TAG_ENUM() {
        return gen_enum(cg, item);
    }
    0
}

// Generate program header
fn gen_header(cg: i64) -> i64 {
    emit_line(cg, "; ModuleID = 'simplex_program'");
    emit_line(cg, "target triple = \"x86_64-apple-macosx14.0.0\"");
    emit_line(cg, "");
    emit_line(cg, "declare ptr @malloc(i64)");
    emit_line(cg, "declare void @intrinsic_println(ptr)");
    emit_line(cg, "declare ptr @intrinsic_int_to_string(i64)");
    emit_line(cg, "declare ptr @intrinsic_string_new(ptr)");
    emit_line(cg, "");
    0
}

// Generate entire program
fn gen_program(items: i64) -> i64 {
    let cg: i64 = codegen_new();
    gen_header(cg);

    // First pass: register enums
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        i = i + 1;
    }

    cg_output(cg)
}
// Minimal Simplex Compiler - Main Entry Point
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics

// External runtime functions we need
// Note: These are provided by the simplex runtime

fn main() {
    // Get command line args
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        println("Usage: sxc <source.sx>");
        return;
    }

    // Get source file path
    let path: i64 = vec_get(args, 1);

    // Read source file
    let source: i64 = read_file(path);
    if source == 0 {
        println("Error: Could not read file");
        return;
    }

    // Tokenize
    let tokens: i64 = tokenize(source);

    // Parse
    let items: i64 = parse_program(tokens);

    // Generate code
    let output: i64 = gen_program(items);

    // Write output
    let out_path: i64 = string_replace_ext(path, ".ll");
    write_file(out_path, output);

    println("Compilation successful.");
    0
}

// Helper to replace file extension
fn string_replace_ext(path: i64, new_ext: i64) -> i64 {
    // Find last dot
    let len: i64 = string_len(path);
    let i: i64 = len - 1;
    while i >= 0 {
        let c: i64 = string_char_at(path, i);
        if c == 46 {
            // Found dot
            let base: i64 = string_slice(path, 0, i);
            return string_concat(base, new_ext);
        }
        i = i - 1;
    }
    // No dot found, just append
    string_concat(path, new_ext)
}
