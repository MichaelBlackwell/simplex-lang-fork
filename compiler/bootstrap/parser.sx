// Minimal Simplex Parser
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics
// Uses early returns instead of else-if chains

// Token types enum - duplicated from lexer.sx for standalone compilation
enum TokenKind {
    Eof,
    Ident,
    Int,
    String,
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    DotDot,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub,
    KwStruct,
    KwImpl,
    KwSelf,
    KwMatch,
    FatArrow,
    Underscore,
    AmpAmp,
    PipePipe,
    Percent,
    Amp,
    Pipe,
    Caret,
    LtLt,
    GtGt,
    KwBreak,
    KwContinue
}

// AST node tags - using i64 since stage1 doesn't have proper enums for everything
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }

// Parser state - we pass this to all functions
fn parser_new(tokens: i64) -> i64 {
    // Allocate parser: tokens(0), pos(1), len(2)
    let parser: i64 = malloc(24);
    store_ptr(parser, 0, tokens);
    store_i64(parser, 1, 0);
    let len: i64 = vec_len(tokens);
    store_i64(parser, 2, len);
    parser
}

fn parser_tokens(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn parser_pos(parser: i64) -> i64 {
    load_i64(parser, 1)
}

fn parser_len(parser: i64) -> i64 {
    load_i64(parser, 2)
}

fn parser_at_end(parser: i64) -> bool {
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    pos >= len
}

fn parser_current(parser: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    vec_get(tokens, pos)
}

fn parser_advance(parser: i64) -> i64 {
    let tok: i64 = parser_current(parser);
    let pos: i64 = parser_pos(parser);
    store_i64(parser, 1, pos + 1);
    tok
}

fn parser_check(parser: i64, kind: i64) -> bool {
    if parser_at_end(parser) { return false; }
    let tok: i64 = parser_current(parser);
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_match(parser: i64, kind: i64) -> bool {
    if parser_check(parser, kind) {
        parser_advance(parser);
        return true;
    }
    false
}

fn parser_expect(parser: i64, kind: i64) -> i64 {
    if parser_check(parser, kind) {
        return parser_advance(parser);
    }
    // Error - return null for now
    0
}

// AST node constructors

// Item: FnDef
// Layout: tag(0), name(1), params(2), ret_ty(3), body(4)
fn ast_fn_def(name: i64, params: i64, ret_ty: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_FN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, params);
    store_ptr(node, 3, ret_ty);
    store_ptr(node, 4, body);
    node
}

// Item: EnumDef
// Layout: tag(0), name(1), variants(2)
fn ast_enum_def(name: i64, variants: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_ENUM());
    store_ptr(node, 1, name);
    store_ptr(node, 2, variants);
    node
}

// Stmt: Let
// Layout: tag(0), name(1), ty(2), init_expr(3)
fn ast_let(name: i64, ty: i64, init_expr: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, STMT_LET());
    store_ptr(node, 1, name);
    store_ptr(node, 2, ty);
    store_ptr(node, 3, init_expr);
    node
}

// Stmt: Expr
// Layout: tag(0), expr(1)
fn ast_expr_stmt(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_EXPR());
    store_ptr(node, 1, expr);
    node
}

// Stmt: Return
// Layout: tag(0), expr(1)
fn ast_return(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_RETURN());
    store_ptr(node, 1, expr);
    node
}

fn ast_break() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_BREAK());
    node
}

fn ast_continue() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_CONTINUE());
    node
}

// Stmt: Assign
// Layout: tag(0), name(1), value(2)
fn ast_assign(name: i64, value: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, STMT_ASSIGN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, value);
    node
}

// Expr: Int literal
// Layout: tag(0), value(1)
fn ast_int(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INT());
    store_i64(node, 1, value);
    node
}

// Expr: Bool literal
// Layout: tag(0), value(1)
fn ast_bool(value: bool) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BOOL());
    store_i64(node, 1, value);
    node
}

// Expr: String literal
// Layout: tag(0), value(1)
fn ast_string(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_STRING());
    store_ptr(node, 1, value);
    node
}

// Expr: Identifier
// Layout: tag(0), name(1)
fn ast_ident(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_IDENT());
    store_ptr(node, 1, name);
    node
}

// Expr: Path (Type::Variant)
// Layout: tag(0), segments(1)
fn ast_path(segments: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_PATH());
    store_ptr(node, 1, segments);
    node
}

// Expr: Call
// Layout: tag(0), callee(1), args(2)
fn ast_call(callee: i64, args: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_CALL());
    store_ptr(node, 1, callee);
    store_ptr(node, 2, args);
    node
}

// Expr: Binary
// Layout: tag(0), op(1), left(2), right(3)
fn ast_binary(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_BINARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, left);
    store_ptr(node, 3, right);
    node
}

// Expr: Unary
// Layout: tag(0), op(1), operand(2)
fn ast_unary(op: i64, operand: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_UNARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, operand);
    node
}

// Expr: If
// Layout: tag(0), cond(1), then_block(2), else_block(3)
fn ast_if(cond: i64, then_block: i64, else_block: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_IF());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, then_block);
    store_ptr(node, 3, else_block);
    node
}

// Expr: While
// Layout: tag(0), cond(1), body(2)
fn ast_while(cond: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_WHILE());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, body);
    node
}

// Expr: For (range-based)
// Layout: tag(0), var_name(1), start(2), end(3), body(4)
fn ast_for(var_name: i64, start: i64, end: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, EXPR_FOR());
    store_ptr(node, 1, var_name);
    store_ptr(node, 2, start);
    store_ptr(node, 3, end);
    store_ptr(node, 4, body);
    node
}

// Expr: Match
// Layout: tag(0), scrutinee(1), arms(2)
// Each arm is (pattern, result) where pattern is an expr (Ident for wildcards, Path for enum variants)
fn ast_match(scrutinee: i64, arms: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_MATCH());
    store_ptr(node, 1, scrutinee);
    store_ptr(node, 2, arms);
    node
}

// Match arm: pattern(0), result(1)
fn ast_match_arm(pattern: i64, result: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, pattern);
    store_ptr(node, 1, result);
    node
}

// Expr: Block
// Layout: tag(0), stmts(1), result(2)
fn ast_block(stmts: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_BLOCK());
    store_ptr(node, 1, stmts);
    store_ptr(node, 2, result);
    node
}

// Item: StructDef
// Layout: tag(0), name(1), fields(2)
// fields is vec of (name, type) pairs
fn ast_struct_def(name: i64, fields: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_STRUCT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, fields);
    node
}

// Item: Impl block
// Layout: tag(0), type_name(1), methods(2)
fn ast_impl(type_name: i64, methods: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_IMPL());
    store_ptr(node, 1, type_name);
    store_ptr(node, 2, methods);
    node
}

// Expr: StructLit
// Layout: tag(0), name(1), field_inits(2)
// field_inits is vec of (name, expr) pairs
fn ast_struct_lit(name: i64, field_inits: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_STRUCT_LIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, field_inits);
    node
}

// Expr: FieldAccess
// Layout: tag(0), object(1), field_name(2)
fn ast_field_access(object: i64, field_name: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FIELD());
    store_ptr(node, 1, object);
    store_ptr(node, 2, field_name);
    node
}

// Expr: MethodCall
// Layout: tag(0), object(1), method_name(2), args(3)
fn ast_method_call(object: i64, method_name: i64, args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_METHOD_CALL());
    store_ptr(node, 1, object);
    store_ptr(node, 2, method_name);
    store_ptr(node, 3, args);
    node
}

// Param: name, type
// Layout: name(0), ty(1)
fn ast_param(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Binary operator codes
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }

// Unary operator codes
fn OP_NEG() -> i64 { 0 }
fn OP_NOT() -> i64 { 1 }

// Parse primary expression
fn parse_primary(parser: i64) -> i64 {
    // Integer literal
    if parser_check(parser, TokenKind::Int) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        let value: i64 = string_to_int(text);
        return ast_int(value);
    }

    // Boolean literals
    if parser_check(parser, TokenKind::KwTrue) {
        parser_advance(parser);
        return ast_bool(true);
    }
    if parser_check(parser, TokenKind::KwFalse) {
        parser_advance(parser);
        return ast_bool(false);
    }

    // String literal
    if parser_check(parser, TokenKind::String) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_string(text);
    }

    // 'self' keyword as identifier
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        return ast_ident(string_from("self"));
    }

    // Identifier or path
    if parser_check(parser, TokenKind::Ident) {
        let tok: i64 = parser_advance(parser);
        let name: i64 = token_text(tok);

        // Check for path (::)
        if parser_check(parser, TokenKind::DoubleColon) {
            let segments: i64 = vec_new();
            vec_push(segments, name);

            while parser_match(parser, TokenKind::DoubleColon) {
                if parser_check(parser, TokenKind::Ident) {
                    let seg_tok: i64 = parser_advance(parser);
                    let seg_name: i64 = token_text(seg_tok);
                    vec_push(segments, seg_name);
                }
            }
            return ast_path(segments);
        }

        // Check for function call
        if parser_check(parser, TokenKind::LParen) {
            parser_advance(parser);
            let args: i64 = vec_new();

            if parser_check(parser, TokenKind::RParen) {
                // Empty args
            } else {
                let first_arg: i64 = parse_expr(parser);
                vec_push(args, first_arg);

                while parser_match(parser, TokenKind::Comma) {
                    let arg: i64 = parse_expr(parser);
                    vec_push(args, arg);
                }
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_call(ast_ident(name), args);
        }

        // Struct literal syntax disabled for now - conflicts with if/while blocks
        // The ambiguity is: `x { field: val }` vs `if x { ... }`
        // Both start with `Ident {` but have different meanings.
        // TODO: Re-enable with better disambiguation (look ahead for Ident:)

        return ast_ident(name);
    }

    // Parenthesized expression
    if parser_match(parser, TokenKind::LParen) {
        let expr: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return expr;
    }

    // If expression
    if parser_check(parser, TokenKind::KwIf) {
        return parse_if(parser);
    }

    // While expression
    if parser_check(parser, TokenKind::KwWhile) {
        return parse_while(parser);
    }

    // For expression
    if parser_check(parser, TokenKind::KwFor) {
        return parse_for(parser);
    }

    // Match expression
    if parser_check(parser, TokenKind::KwMatch) {
        return parse_match(parser);
    }

    // Block expression
    if parser_check(parser, TokenKind::LBrace) {
        return parse_block(parser);
    }

    // Error - advance past unrecognized token to prevent infinite loop
    if parser_at_end(parser) == false {
        parser_advance(parser);
    }
    0
}

// Parse postfix expression (field access: expr.field, method call: expr.method(args))
fn parse_postfix(parser: i64) -> i64 {
    let expr: i64 = parse_primary(parser);

    while true {
        if parser_match(parser, TokenKind::Dot) {
            let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let name: i64 = token_text(name_tok);

            // Check if this is a method call (followed by '(')
            if parser_check(parser, TokenKind::LParen) {
                parser_advance(parser);
                let args: i64 = vec_new();

                if parser_check(parser, TokenKind::RParen) {
                    // Empty args
                } else {
                    let first_arg: i64 = parse_expr(parser);
                    vec_push(args, first_arg);

                    while parser_match(parser, TokenKind::Comma) {
                        let arg: i64 = parse_expr(parser);
                        vec_push(args, arg);
                    }
                }

                parser_expect(parser, TokenKind::RParen);
                expr = ast_method_call(expr, name, args);
            } else {
                // Field access
                expr = ast_field_access(expr, name);
            }
        } else {
            return expr;
        }
    }

    expr
}

// Parse unary expression
fn parse_unary(parser: i64) -> i64 {
    if parser_match(parser, TokenKind::Minus) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NEG(), operand);
    }
    if parser_match(parser, TokenKind::Bang) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NOT(), operand);
    }
    parse_postfix(parser)
}

// Parse multiplicative expression
fn parse_multiplicative(parser: i64) -> i64 {
    let left: i64 = parse_unary(parser);

    while true {
        if parser_match(parser, TokenKind::Star) {
            let right: i64 = parse_unary(parser);
            left = ast_binary(OP_MUL(), left, right);
        } else {
            if parser_match(parser, TokenKind::Slash) {
                let right: i64 = parse_unary(parser);
                left = ast_binary(OP_DIV(), left, right);
            } else {
                if parser_match(parser, TokenKind::Percent) {
                    let right: i64 = parse_unary(parser);
                    left = ast_binary(OP_MOD(), left, right);
                } else {
                    return left;
                }
            }
        }
    }
    left
}

// Parse additive expression
fn parse_additive(parser: i64) -> i64 {
    let left: i64 = parse_multiplicative(parser);

    while true {
        if parser_match(parser, TokenKind::Plus) {
            let right: i64 = parse_multiplicative(parser);
            left = ast_binary(OP_ADD(), left, right);
        } else {
            if parser_match(parser, TokenKind::Minus) {
                let right: i64 = parse_multiplicative(parser);
                left = ast_binary(OP_SUB(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse shift expression (<< >>)
fn parse_shift(parser: i64) -> i64 {
    let left: i64 = parse_additive(parser);

    while true {
        if parser_match(parser, TokenKind::LtLt) {
            let right: i64 = parse_additive(parser);
            left = ast_binary(OP_SHL(), left, right);
        } else {
            if parser_match(parser, TokenKind::GtGt) {
                let right: i64 = parse_additive(parser);
                left = ast_binary(OP_SHR(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse comparison expression
fn parse_comparison(parser: i64) -> i64 {
    let left: i64 = parse_shift(parser);

    if parser_match(parser, TokenKind::EqEq) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_EQ(), left, right);
    }
    if parser_match(parser, TokenKind::Ne) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_NE(), left, right);
    }
    if parser_match(parser, TokenKind::Lt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LT(), left, right);
    }
    if parser_match(parser, TokenKind::Gt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GT(), left, right);
    }
    if parser_match(parser, TokenKind::Le) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LE(), left, right);
    }
    if parser_match(parser, TokenKind::Ge) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GE(), left, right);
    }
    left
}

// Parse bitwise AND expression (&)
fn parse_bitand(parser: i64) -> i64 {
    let left: i64 = parse_comparison(parser);

    while parser_match(parser, TokenKind::Amp) {
        let right: i64 = parse_comparison(parser);
        left = ast_binary(OP_BITAND(), left, right);
    }
    left
}

// Parse bitwise XOR expression (^)
fn parse_bitxor(parser: i64) -> i64 {
    let left: i64 = parse_bitand(parser);

    while parser_match(parser, TokenKind::Caret) {
        let right: i64 = parse_bitand(parser);
        left = ast_binary(OP_BITXOR(), left, right);
    }
    left
}

// Parse bitwise OR expression (|)
fn parse_bitor(parser: i64) -> i64 {
    let left: i64 = parse_bitxor(parser);

    while parser_match(parser, TokenKind::Pipe) {
        let right: i64 = parse_bitxor(parser);
        left = ast_binary(OP_BITOR(), left, right);
    }
    left
}

// Parse logical AND expression (&&)
fn parse_and(parser: i64) -> i64 {
    let left: i64 = parse_bitor(parser);

    while parser_match(parser, TokenKind::AmpAmp) {
        let right: i64 = parse_bitor(parser);
        left = ast_binary(OP_AND(), left, right);
    }
    left
}

// Parse logical OR expression (||)
fn parse_or(parser: i64) -> i64 {
    let left: i64 = parse_and(parser);

    while parser_match(parser, TokenKind::PipePipe) {
        let right: i64 = parse_and(parser);
        left = ast_binary(OP_OR(), left, right);
    }
    left
}

// Parse expression
fn parse_expr(parser: i64) -> i64 {
    parse_or(parser)
}

// Parse block
fn parse_block(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::LBrace);
    let stmts: i64 = vec_new();
    let result: i64 = 0;

    while true {
        // Check for EOF to prevent infinite loop on incomplete input
        if parser_at_end(parser) {
            return ast_block(stmts, result);
        }

        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_block(stmts, result);
        }

        // Check for statement vs expression
        if parser_check(parser, TokenKind::KwLet) {
            let stmt: i64 = parse_let(parser);
            vec_push(stmts, stmt);
        } else {
            if parser_check(parser, TokenKind::KwReturn) {
                let stmt: i64 = parse_return(parser);
                vec_push(stmts, stmt);
            } else {
                if parser_check(parser, TokenKind::KwBreak) {
                    parser_advance(parser);
                    parser_expect(parser, TokenKind::Semi);
                    let stmt: i64 = ast_break();
                    vec_push(stmts, stmt);
                } else {
                    if parser_check(parser, TokenKind::KwContinue) {
                        parser_advance(parser);
                        parser_expect(parser, TokenKind::Semi);
                        let stmt: i64 = ast_continue();
                        vec_push(stmts, stmt);
                    } else {
                // Expression - could be statement, assignment, or result
                let expr: i64 = parse_expr(parser);

                // Check for assignment: ident = expr;
                if parser_match(parser, TokenKind::Eq) {
                    // This is an assignment statement
                    // expr should be an identifier
                    let expr_tag: i64 = load_i64(expr, 0);
                    if expr_tag == EXPR_IDENT() {
                        let name: i64 = load_ptr(expr, 1);
                        let value: i64 = parse_expr(parser);
                        parser_match(parser, TokenKind::Semi);
                        vec_push(stmts, ast_assign(name, value));
                    } else {
                        // Invalid assignment target, treat as expression
                        parser_match(parser, TokenKind::Semi);
                        vec_push(stmts, ast_expr_stmt(expr));
                    }
                } else {
                    if parser_match(parser, TokenKind::Semi) {
                        // Expression statement with explicit semicolon
                        vec_push(stmts, ast_expr_stmt(expr));
                    } else {
                        // No semicolon - check if more statements follow
                        if parser_check(parser, TokenKind::RBrace) {
                            // Next is }, so this is the result expression
                            result = expr;
                        } else {
                            // More statements follow, so this is an implicit statement
                            // (if/while don't need semicolons when followed by more code)
                            vec_push(stmts, ast_expr_stmt(expr));
                        }
                    }
                }
                    }
                }
            }
        }
    }

    ast_block(stmts, result)
}

// Parse if expression
fn parse_if(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwIf);
    let cond: i64 = parse_expr(parser);
    let then_block: i64 = parse_block(parser);
    let else_block: i64 = 0;

    if parser_match(parser, TokenKind::KwElse) {
        // Check if it's else-if or else block
        if parser_check(parser, TokenKind::KwIf) {
            else_block = parse_if(parser);
        } else {
            else_block = parse_block(parser);
        }
    }

    ast_if(cond, then_block, else_block)
}

// Parse while expression
fn parse_while(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwWhile);
    let cond: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_while(cond, body)
}

// Parse for expression: for i in start..end { body }
fn parse_for(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFor);
    let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let var_name: i64 = token_text(var_tok);
    parser_expect(parser, TokenKind::KwIn);
    let start: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::DotDot);
    let end: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_for(var_name, start, end, body)
}

// Parse match expression: match expr { pattern => result, ... }
fn parse_match(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMatch);
    let scrutinee: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::LBrace);

    let arms: i64 = vec_new();

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_match(scrutinee, arms);
        }

        // Parse pattern - could be:
        // - Underscore: wildcard
        // - Path: EnumName::Variant
        // - Ident: variable or enum variant
        let pattern: i64 = 0;
        if parser_match(parser, TokenKind::Underscore) {
            // Wildcard pattern - use null to indicate wildcard
            pattern = 0;
        } else {
            // Parse as expression (will handle paths and identifiers)
            pattern = parse_expr(parser);
        }

        parser_expect(parser, TokenKind::FatArrow);

        // Parse arm result (could be block or expression)
        let result: i64 = 0;
        if parser_check(parser, TokenKind::LBrace) {
            result = parse_block(parser);
        } else {
            result = parse_expr(parser);
        }

        vec_push(arms, ast_match_arm(pattern, result));

        // Optional comma between arms
        parser_match(parser, TokenKind::Comma);
    }

    ast_match(scrutinee, arms)
}

// Parse let statement
fn parse_let(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwLet);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse return statement
fn parse_return(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwReturn);
    let expr: i64 = 0;

    if parser_check(parser, TokenKind::Semi) {
        // return;
    } else {
        expr = parse_expr(parser);
    }

    parser_expect(parser, TokenKind::Semi);
    ast_return(expr)
}

// Parse type (simple: just identifier for now)
fn parse_type(parser: i64) -> i64 {
    let tok: i64 = parser_expect(parser, TokenKind::Ident);
    token_text(tok)
}

// Parse function parameters
fn parse_params(parser: i64) -> i64 {
    let params: i64 = vec_new();
    parser_expect(parser, TokenKind::LParen);

    if parser_check(parser, TokenKind::RParen) {
        parser_advance(parser);
        return params;
    }

    // First param - accept either Ident or 'self' keyword
    let name: i64 = 0;
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        name = string_from("self");
    } else {
        let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        name = token_text(name_tok);
    }
    parser_expect(parser, TokenKind::Colon);
    let ty: i64 = parse_type(parser);
    vec_push(params, ast_param(name, ty));

    // More params
    while parser_match(parser, TokenKind::Comma) {
        let pname: i64 = 0;
        if parser_check(parser, TokenKind::KwSelf) {
            parser_advance(parser);
            pname = string_from("self");
        } else {
            let pname_tok: i64 = parser_expect(parser, TokenKind::Ident);
            pname = token_text(pname_tok);
        }
        parser_expect(parser, TokenKind::Colon);
        let pty: i64 = parse_type(parser);
        vec_push(params, ast_param(pname, pty));
    }

    parser_expect(parser, TokenKind::RParen);
    params
}

// Parse function definition
fn parse_fn(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFn);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    let params: i64 = parse_params(parser);

    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    let body: i64 = parse_block(parser);
    ast_fn_def(name, params, ret_ty, body)
}

// Parse enum definition
fn parse_enum(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwEnum);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let variants: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_enum_def(name, variants);
        }

        let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let var_name: i64 = token_text(var_tok);
        vec_push(variants, var_name);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_enum_def(name, variants)
}

// Parse struct definition
fn parse_struct(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwStruct);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let fields: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_struct_def(name, fields);
        }

        // Parse field: name: Type
        let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let field_name: i64 = token_text(field_name_tok);
        parser_expect(parser, TokenKind::Colon);
        let field_ty: i64 = parse_type(parser);

        // Create field pair (name, type)
        let field: i64 = malloc(16);
        store_ptr(field, 0, field_name);
        store_ptr(field, 1, field_ty);
        vec_push(fields, field);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_struct_def(name, fields)
}

// Parse impl block: impl TypeName { fn ... fn ... }
fn parse_impl(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwImpl);
    let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let type_name: i64 = token_text(type_name_tok);

    let methods: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_impl(type_name, methods);
        }

        // Skip pub keyword if present
        parser_match(parser, TokenKind::KwPub);

        // Parse method (must be fn)
        if parser_check(parser, TokenKind::KwFn) {
            let method: i64 = parse_fn(parser);
            vec_push(methods, method);
        }
    }

    ast_impl(type_name, methods)
}

// Parse a single item (fn, enum, or struct)
fn parse_item(parser: i64) -> i64 {
    // Skip pub keyword if present
    parser_match(parser, TokenKind::KwPub);

    if parser_check(parser, TokenKind::KwFn) {
        return parse_fn(parser);
    }
    if parser_check(parser, TokenKind::KwEnum) {
        return parse_enum(parser);
    }
    if parser_check(parser, TokenKind::KwStruct) {
        return parse_struct(parser);
    }
    if parser_check(parser, TokenKind::KwImpl) {
        return parse_impl(parser);
    }

    // Unknown item
    0
}

// Parse entire program
fn parse_program(tokens: i64) -> i64 {
    let parser: i64 = parser_new(tokens);
    let items: i64 = vec_new();

    while true {
        if parser_at_end(parser) {
            return items;
        }

        // Skip EOF tokens
        if parser_check(parser, TokenKind::Eof) {
            return items;
        }

        let item: i64 = parse_item(parser);
        if item != 0 {
            vec_push(items, item);
        }
    }

    items
}
