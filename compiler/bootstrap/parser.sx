// Simplex Parser
// Self-hosted parser supporting full language features:
// - impl blocks, self keyword, for loops, match expressions
// - traits and impl Trait for Type
// - generic functions with type parameters
// - struct literals with lookahead disambiguation
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex-lang

// Token types enum - duplicated from lexer.sx for standalone compilation
enum TokenKind {
    Eof,
    Ident,
    Int,
    Float,
    String,
    FString,   // f"..." interpolated string
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semi,
    Arrow,
    DoubleColon,
    DotDot,
    Eq,
    EqEq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,
    Plus,
    Minus,
    Star,
    Slash,
    Bang,
    Dot,
    KwFn,
    KwLet,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwEnum,
    KwTrue,
    KwFalse,
    KwPub,
    KwStruct,
    KwImpl,
    KwSelf,
    KwMatch,
    FatArrow,
    Underscore,
    AmpAmp,
    PipePipe,
    Percent,
    Amp,
    Pipe,
    Caret,
    LtLt,
    GtGt,
    KwBreak,
    KwLoop,
    KwContinue,
    Question,
    KwTrait,
    KwType,
    KwUse,
    KwMod,
    KwConst,
    KwAsync,
    KwAwait,
    KwYield,
    KwDyn,
    // Actor model keywords
    KwActor,
    KwReceive,
    KwInit,
    // AI/Cognitive keywords
    KwSpecialist,
    KwInfer,
    KwHive,
    KwAnima,
    // Mutable binding
    KwVar,
    // Mutable reference keyword
    KwMut,
    // Spawn expression
    KwSpawn,
    // Where clause
    KwWhere,
    // Belief guard tokens
    At,              // @ symbol for belief guards
    KwConfidence,    // confidence(belief_id)
    KwDerivative,    // .derivative accessor
    // Attribute tokens
    Hash             // # for #[attr] syntax
}

// AST node tags - using i64 since stage1 doesn't have proper enums for everything
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }
fn TAG_TRAIT() -> i64 { 4 }
fn TAG_IMPL_TRAIT() -> i64 { 5 }  // impl Trait for Type
fn TAG_MOD() -> i64 { 6 }         // mod name;
fn TAG_USE() -> i64 { 7 }         // use name::item;
fn TAG_ACTOR() -> i64 { 8 }       // actor definition
fn TAG_SPECIALIST() -> i64 { 9 }  // AI specialist
fn TAG_HIVE() -> i64 { 10 }       // cognitive hive
fn TAG_ANIMA() -> i64 { 11 }      // cognitive soul
fn TAG_TYPE_ALIAS() -> i64 { 12 } // type alias: type Name = Type;

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }
fn EXPR_TRY() -> i64 { 16 }  // expr? - early return on error
fn EXPR_AWAIT() -> i64 { 17 }  // expr.await - await future
fn EXPR_FSTRING() -> i64 { 18 }  // f"..." - interpolated string
fn EXPR_YIELD() -> i64 { 19 }    // yield expr - generator yield
fn EXPR_SPAWN() -> i64 { 20 }    // spawn Type - spawn actor/specialist
fn EXPR_ARRAY() -> i64 { 21 }    // [a, b, c] - array literal
fn EXPR_FLOAT() -> i64 { 22 }    // floating point literal
fn EXPR_CLOSURE() -> i64 { 23 }  // (params) => expr - closure/lambda
fn EXPR_INFER() -> i64 { 24 }    // infer(prompt) - AI inference
fn EXPR_TUPLE() -> i64 { 25 }    // (a, b, c) - tuple literal
fn EXPR_LOOP() -> i64 { 26 }     // loop { ... break value } - infinite loop with break
fn EXPR_INDEX() -> i64 { 27 }    // expr[index] - array/tuple indexing
fn EXPR_WHILE_LET() -> i64 { 28 } // while let Pattern = expr { body } - pattern-matching loop
fn EXPR_BREAK() -> i64 { 29 }    // break [value] - break from loop
fn EXPR_STRUCT_PAT() -> i64 { 30 } // TypeName { field1, field2: binding, .. } - struct pattern
fn EXPR_OR_PAT() -> i64 { 31 }   // Pattern1 | Pattern2 - or pattern
fn EXPR_CAST() -> i64 { 32 }     // expr as Type - type cast
fn EXPR_METHOD() -> i64 { 33 }   // method reference - Type::method
fn EXPR_STRUCT() -> i64 { 34 }   // struct expression marker

// Belief guard expressions
fn EXPR_CONFIDENCE() -> i64 { 35 }    // confidence(belief_id)
fn EXPR_DERIVATIVE() -> i64 { 36 }    // expr.derivative
fn EXPR_BELIEF_GUARD() -> i64 { 37 }  // belief_expr cmp value
fn EXPR_BELIEF_AND() -> i64 { 38 }    // guard && guard
fn EXPR_BELIEF_OR() -> i64 { 39 }     // guard || guard

// Parser state - we pass this to all functions
fn parser_new(tokens: i64) -> i64 {
    // Allocate parser: tokens(0), pos(1), len(2), errors(3), pending_gt(4)
    let parser: i64 = malloc(40);
    store_ptr(parser, 0, tokens);
    store_i64(parser, 1, 0);
    let len: i64 = vec_len(tokens);
    store_i64(parser, 2, len);
    store_i64(parser, 3, 0);
    store_i64(parser, 4, 0);  // pending_gt count for handling >> in nested generics
    parser
}

// Get/set pending_gt count for handling >> in nested generics
fn parser_pending_gt(parser: i64) -> i64 {
    load_i64(parser, 4)
}

fn parser_set_pending_gt(parser: i64, count: i64) -> i64 {
    store_i64(parser, 4, count);
    0
}

fn parser_error_count(parser: i64) -> i64 {
    load_i64(parser, 3)
}

fn parser_add_error(parser: i64, msg: i64) -> i64 {
    let count: i64 = load_i64(parser, 3);
    store_i64(parser, 3, count + 1);
    println(string_concat(string_from("Parse error: "), msg));
    0
}

fn parser_tokens(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn parser_pos(parser: i64) -> i64 {
    load_i64(parser, 1)
}

fn parser_len(parser: i64) -> i64 {
    load_i64(parser, 2)
}

fn parser_at_end(parser: i64) -> bool {
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    pos >= len
}

fn parser_current(parser: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    vec_get(tokens, pos)
}

// Peek ahead n tokens (0 = current, 1 = next, etc.)
fn parser_peek(parser: i64, n: i64) -> i64 {
    let tokens: i64 = parser_tokens(parser);
    let pos: i64 = parser_pos(parser);
    let len: i64 = parser_len(parser);
    if pos + n >= len {
        return 0;  // Return null for out of bounds
    }
    vec_get(tokens, pos + n)
}

// Check if token at offset n has the given kind
fn parser_peek_check(parser: i64, n: i64, kind: i64) -> bool {
    let tok: i64 = parser_peek(parser, n);
    if tok == 0 { return false; }
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_advance(parser: i64) -> i64 {
    let tok: i64 = parser_current(parser);
    let pos: i64 = parser_pos(parser);
    store_i64(parser, 1, pos + 1);
    tok
}

fn parser_check(parser: i64, kind: i64) -> bool {
    if parser_at_end(parser) { return false; }
    let tok: i64 = parser_current(parser);
    let tok_kind: i64 = token_kind(tok);
    tok_kind == kind
}

fn parser_match(parser: i64, kind: i64) -> bool {
    if parser_check(parser, kind) {
        parser_advance(parser);
        return true;
    }
    false
}

fn parser_expect(parser: i64, kind: i64) -> i64 {
    if parser_check(parser, kind) {
        return parser_advance(parser);
    }
    // Error - report and continue
    parser_add_error(parser, string_from("unexpected token"));
    0
}

// AST node constructors

// Item: FnDef
// Layout: tag(0), name(1), type_params(2), params(3), ret_ty(4), body(5)
fn ast_fn_def(name: i64, type_params: i64, params: i64, ret_ty: i64, body: i64, is_async: i64) -> i64 {
    let node: i64 = malloc(56);
    store_i64(node, 0, TAG_FN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);  // vec of type param names, or 0 for non-generic
    store_ptr(node, 3, params);
    store_ptr(node, 4, ret_ty);
    store_ptr(node, 5, body);
    store_i64(node, 6, is_async);     // 1 if async fn, 0 otherwise
    node
}

fn ast_fn_is_async(node: i64) -> i64 {
    load_i64(node, 6)
}

// Item: EnumDef
// Layout: tag(0), name(1), variants(2)
fn ast_enum_def(name: i64, variants: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_ENUM());
    store_ptr(node, 1, name);
    store_ptr(node, 2, variants);
    node
}

// Stmt: Let
// Layout: tag(0), name(1), ty(2), init_expr(3)
fn ast_let(name: i64, ty: i64, init_expr: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, STMT_LET());
    store_ptr(node, 1, name);
    store_ptr(node, 2, ty);
    store_ptr(node, 3, init_expr);
    node
}

// Stmt: Expr
// Layout: tag(0), expr(1)
fn ast_expr_stmt(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_EXPR());
    store_ptr(node, 1, expr);
    node
}

// Stmt: Return
// Layout: tag(0), expr(1)
fn ast_return(expr: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, STMT_RETURN());
    store_ptr(node, 1, expr);
    node
}

fn ast_break() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_BREAK());
    node
}

fn ast_continue() -> i64 {
    let node: i64 = malloc(8);
    store_i64(node, 0, STMT_CONTINUE());
    node
}

// Stmt: Assign
// Layout: tag(0), name(1), value(2)
fn ast_assign(name: i64, value: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, STMT_ASSIGN());
    store_ptr(node, 1, name);
    store_ptr(node, 2, value);
    node
}

// Expr: Int literal
// Layout: tag(0), value(1)
fn ast_int(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INT());
    store_i64(node, 1, value);
    node
}

// Expr: Bool literal
// Layout: tag(0), value(1)
fn ast_bool(value: bool) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BOOL());
    store_i64(node, 1, value);
    node
}

// Expr: String literal
// Layout: tag(0), value(1)
fn ast_string(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_STRING());
    store_ptr(node, 1, value);
    node
}

// Expr: FString (interpolated string)
// Layout: tag(0), parts(1), exprs(2)
// parts is a vec of string segments, exprs is a vec of expressions
fn ast_fstring(parts: i64, exprs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FSTRING());
    store_ptr(node, 1, parts);
    store_ptr(node, 2, exprs);
    node
}

// Expr: Identifier
// Layout: tag(0), name(1)
fn ast_ident(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_IDENT());
    store_ptr(node, 1, name);
    node
}

// Expr: Path (Type::Variant)
// Layout: tag(0), segments(1)
fn ast_path(segments: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_PATH());
    store_ptr(node, 1, segments);
    node
}

// Expr: Call
// Layout: tag(0), callee(1), args(2), type_args(3)
fn ast_call(callee: i64, args: i64) -> i64 {
    ast_call_generic(callee, args, 0)
}

fn ast_call_generic(callee: i64, args: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_CALL());
    store_ptr(node, 1, callee);
    store_ptr(node, 2, args);
    store_ptr(node, 3, type_args);  // vec of type names, or 0 for non-generic
    node
}

// Expr: Binary
// Layout: tag(0), op(1), left(2), right(3)
fn ast_binary(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_BINARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, left);
    store_ptr(node, 3, right);
    node
}

// Expr: Unary
// Layout: tag(0), op(1), operand(2)
fn ast_unary(op: i64, operand: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_UNARY());
    store_i64(node, 1, op);
    store_ptr(node, 2, operand);
    node
}

// Expr: If
// Layout: tag(0), cond(1), then_block(2), else_block(3)
fn ast_if(cond: i64, then_block: i64, else_block: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_IF());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, then_block);
    store_ptr(node, 3, else_block);
    node
}

// Expr: While
// Layout: tag(0), cond(1), body(2)
fn ast_while(cond: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_WHILE());
    store_ptr(node, 1, cond);
    store_ptr(node, 2, body);
    node
}

// Expr: While-let (pattern-matching loop)
// Layout: tag(0), pattern(1), scrutinee(2), body(3)
fn ast_while_let(pattern: i64, scrutinee: i64, body: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_WHILE_LET());
    store_ptr(node, 1, pattern);
    store_ptr(node, 2, scrutinee);
    store_ptr(node, 3, body);
    node
}

// Expr: Loop (infinite loop with break value)
// Layout: tag(0), body(1)
fn ast_loop(body: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_LOOP());
    store_ptr(node, 1, body);
    node
}

// Expr: Break with value (for loop expressions)
// Layout: tag(0), value(1) - value is 0 if no value
fn ast_break_value(value: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_BREAK());
    store_ptr(node, 1, value);
    node
}

// Expr: For (range-based)
// Layout: tag(0), var_name(1), start(2), end(3), body(4)
fn ast_for(var_name: i64, start: i64, end: i64, body: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, EXPR_FOR());
    store_ptr(node, 1, var_name);
    store_ptr(node, 2, start);
    store_ptr(node, 3, end);
    store_ptr(node, 4, body);
    node
}

// Expr: Match
// Layout: tag(0), scrutinee(1), arms(2)
// Each arm is (pattern, result) where pattern is an expr (Ident for wildcards, Path for enum variants)
fn ast_match(scrutinee: i64, arms: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_MATCH());
    store_ptr(node, 1, scrutinee);
    store_ptr(node, 2, arms);
    node
}

// Match arm: pattern(0), guard(1), result(2)
// guard is 0 if no guard, otherwise an expression
fn ast_match_arm(pattern: i64, guard: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_ptr(node, 0, pattern);
    store_ptr(node, 1, guard);
    store_ptr(node, 2, result);
    node
}

// Expr: Block
// Layout: tag(0), stmts(1), result(2)
fn ast_block(stmts: i64, result: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_BLOCK());
    store_ptr(node, 1, stmts);
    store_ptr(node, 2, result);
    node
}

// Item: StructDef
// Layout: tag(0), name(1), type_params(2), fields(3)
// type_params is vec of type param names, or 0 for non-generic
// fields is vec of (name, type) pairs
fn ast_struct_def(name: i64, type_params: i64, fields: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_STRUCT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, type_params);
    store_ptr(node, 3, fields);
    node
}

// Item: Impl block
// Layout: tag(0), type_name(1), methods(2)
fn ast_impl(type_name: i64, methods: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_IMPL());
    store_ptr(node, 1, type_name);
    store_ptr(node, 2, methods);
    node
}

// Item: Trait definition
// Layout: tag(0), name(1), method_sigs(2)
fn ast_trait(name: i64, method_sigs: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_TRAIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, method_sigs);  // vec of fn signatures (name, params, ret_ty)
    node
}

// Item: Impl Trait for Type
// Layout: tag(0), trait_name(1), type_name(2), methods(3), assoc_types(4)
fn ast_impl_trait(trait_name: i64, type_name: i64, methods: i64, assoc_types: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_IMPL_TRAIT());
    store_ptr(node, 1, trait_name);
    store_ptr(node, 2, type_name);
    store_ptr(node, 3, methods);
    store_ptr(node, 4, assoc_types);  // vec of (name, type) pairs
    node
}

// Associated type mapping
// Layout: name(0), type(1)
fn ast_assoc_type(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Method signature (for traits)
// Layout: name(0), params(1), ret_ty(2)
fn ast_method_sig(name: i64, params: i64, ret_ty: i64) -> i64 {
    let node: i64 = malloc(24);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    node
}

// Default method (trait method with body)
// Layout: name(0), params(1), ret_ty(2), fn_def(3)
fn ast_default_method(name: i64, params: i64, ret_ty: i64, fn_def: i64) -> i64 {
    let node: i64 = malloc(32);
    store_ptr(node, 0, name);
    store_ptr(node, 1, params);
    store_ptr(node, 2, ret_ty);
    store_ptr(node, 3, fn_def);
    node
}

// Item: Module declaration (mod name;)
// Layout: tag(0), name(1)
fn ast_mod(name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_MOD());
    store_ptr(node, 1, name);
    node
}

// Item: Use statement (use path::item;)
// Layout: tag(0), path(1)  -- path is vec of strings
fn ast_use(path: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, TAG_USE());
    store_ptr(node, 1, path);
    node
}

// Extended use statement with nested imports and glob support
// Layout: tag(0), path(1), imports(2), is_glob(3)
fn ast_use_ext(path: i64, imports: i64, is_glob: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_USE());
    store_ptr(node, 1, path);
    store_ptr(node, 2, imports);
    store_i64(node, 3, is_glob);
    node
}

// Item: Type alias (type Name = Type;)
// Layout: tag(0), name(1), target_type(2)
fn ast_type_alias(name: i64, target_type: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, TAG_TYPE_ALIAS());
    store_ptr(node, 1, name);
    store_ptr(node, 2, target_type);
    node
}

fn ast_type_alias_name(node: i64) -> i64 {
    load_ptr(node, 1)
}

fn ast_type_alias_target(node: i64) -> i64 {
    load_ptr(node, 2)
}

// Item: Actor definition
// Layout: tag(0), name(1), state_fields(2), receive_handlers(3), init_fn(4)
fn ast_actor(name: i64, state_fields: i64, handlers: i64, init_fn: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_ACTOR());
    store_ptr(node, 1, name);
    store_ptr(node, 2, state_fields);
    store_ptr(node, 3, handlers);
    store_ptr(node, 4, init_fn);
    node
}

// Item: AI Specialist definition
// Layout: tag(0), name(1), capabilities(2), knowledge(3), methods(4)
fn ast_specialist(name: i64, config: i64, state_fields: i64, handlers: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_SPECIALIST());
    store_ptr(node, 1, name);
    store_ptr(node, 2, config);
    store_ptr(node, 3, state_fields);
    store_ptr(node, 4, handlers);
    node
}

// Item: Cognitive Hive definition
// Layout: tag(0), name(1), specialists(2), routing(3)
fn ast_hive(name: i64, specialists: i64, routing: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, TAG_HIVE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, specialists);
    store_ptr(node, 3, routing);
    node
}

// Item: Cognitive Hive with mnemonic definition
// Layout: tag(0), name(1), specialists(2), routing(3), mnemonic(4)
fn ast_hive_with_mnemonic(name: i64, specialists: i64, routing: i64, mnemonic: i64) -> i64 {
    let node: i64 = malloc(40);
    store_i64(node, 0, TAG_HIVE());
    store_ptr(node, 1, name);
    store_ptr(node, 2, specialists);
    store_ptr(node, 3, routing);
    store_ptr(node, 4, mnemonic);  // vec of mnemonic block configs
    node
}

// Item: Anima (Cognitive Soul) definition
// Layout: tag(0), name(1), identity(2), memory(3), beliefs(4), slm(5), persistence(6)
fn ast_anima(name: i64, identity: i64, memory: i64, beliefs: i64, slm: i64, persistence: i64) -> i64 {
    let node: i64 = malloc(56);
    store_i64(node, 0, TAG_ANIMA());
    store_ptr(node, 1, name);
    store_ptr(node, 2, identity);    // vec of key-value pairs
    store_ptr(node, 3, memory);      // vec of key-value pairs
    store_ptr(node, 4, beliefs);     // vec of key-value pairs
    store_ptr(node, 5, slm);         // vec of key-value pairs
    store_ptr(node, 6, persistence); // vec of key-value pairs
    node
}

// Expr: StructLit
// Layout: tag(0), name(1), field_inits(2), type_args(3)
// field_inits is vec of (name, expr) pairs
fn ast_struct_lit(name: i64, field_inits: i64, type_args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_STRUCT_LIT());
    store_ptr(node, 1, name);
    store_ptr(node, 2, field_inits);
    store_ptr(node, 3, type_args);
    node
}

// Expr: FieldAccess
// Layout: tag(0), object(1), field_name(2)
fn ast_field_access(object: i64, field_name: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_FIELD());
    store_ptr(node, 1, object);
    store_ptr(node, 2, field_name);
    node
}

// Expr: MethodCall
// Layout: tag(0), object(1), method_name(2), args(3)
fn ast_method_call(object: i64, method_name: i64, args: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_METHOD_CALL());
    store_ptr(node, 1, object);
    store_ptr(node, 2, method_name);
    store_ptr(node, 3, args);
    node
}

// Expr: Try (? operator)
// Layout: tag(0), inner(1)
fn ast_try(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_TRY());
    store_ptr(node, 1, inner);
    node
}

// Expr: Await (.await)
// Layout: tag(0), inner(1)
fn ast_await(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_AWAIT());
    store_ptr(node, 1, inner);
    node
}

// Expr: Yield (yield expr)
// Layout: tag(0), inner(1)
fn ast_yield(inner: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_YIELD());
    store_ptr(node, 1, inner);
    node
}

// Expr: Spawn (spawn TypeName)
// Layout: tag(0), type_name(1)
fn ast_spawn(type_name: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_SPAWN());
    store_ptr(node, 1, type_name);
    node
}

// Expr: Array literal [a, b, c]
// Layout: tag(0), elements(1)
fn ast_array(elements: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_ARRAY());
    store_ptr(node, 1, elements);
    node
}

// Expr: Float literal
// Layout: tag(0), text(1) - store as string for precision
fn ast_float(text: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_FLOAT());
    store_ptr(node, 1, text);
    node
}

// Expr: Infer - AI model inference
// Layout: tag(0), prompt(1)
fn ast_infer(prompt: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_INFER());
    store_ptr(node, 1, prompt);
    node
}

// Expr: Tuple literal (a, b, c)
// Layout: tag(0), elements(1)
fn ast_tuple(elements: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_TUPLE());
    store_ptr(node, 1, elements);
    node
}

// Pattern: Struct pattern - TypeName { field1, field2: binding, .. }
// Layout: tag(0), type_name(1), fields(2), has_rest(3)
// fields is a vec of (field_name, binding) pairs
fn ast_struct_pattern(type_name: i64, fields: i64, has_rest: i64) -> i64 {
    let node: i64 = malloc(32);
    store_i64(node, 0, EXPR_STRUCT_PAT());
    store_ptr(node, 1, type_name);
    store_ptr(node, 2, fields);
    store_i64(node, 3, has_rest);
    node
}

// Pattern: Or pattern - Pattern1 | Pattern2 | ...
// Layout: tag(0), alternatives(1)
// alternatives is a vec of pattern nodes
fn ast_or_pattern(alternatives: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_OR_PAT());
    store_ptr(node, 1, alternatives);
    node
}

// Expr: Loop - infinite loop with break value
// Layout: tag(0), body(1)
fn ast_loop(body: i64) -> i64 {
    let node: i64 = malloc(16);
    store_i64(node, 0, EXPR_LOOP());
    store_ptr(node, 1, body);
    node
}

// Expr: Index - array/tuple indexing expr[index]
// Layout: tag(0), base(1), index(2)
fn ast_index(base: i64, index: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_INDEX());
    store_ptr(node, 1, base);
    store_ptr(node, 2, index);
    node
}

// Param: name, type
// Layout: name(0), ty(1)
fn ast_param(name: i64, ty: i64) -> i64 {
    let node: i64 = malloc(16);
    store_ptr(node, 0, name);
    store_ptr(node, 1, ty);
    node
}

// Closure: (params) => body
// Layout: tag(0), params(1), body(2)
fn ast_closure(params: i64, body: i64) -> i64 {
    let node: i64 = malloc(24);
    store_i64(node, 0, EXPR_CLOSURE());
    store_ptr(node, 1, params);
    store_ptr(node, 2, body);
    node
}

// Binary operator codes
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }

// Unary operator codes
fn OP_NEG() -> i64 { 0 }
fn OP_NOT() -> i64 { 1 }

// Parse f-string content into parts and expressions
// Content like "Hello {name}, you are {age} years old" becomes:
// parts = ["Hello ", ", you are ", " years old"]
// exprs = [ident(name), ident(age)]
// Supports:
// - Full expressions: f"{obj.method()}", f"{a + b}"
// - Escaped braces: f"{{literal}}" produces "{literal}"
// - Format specifiers: f"{value:format}" (format string extracted but stored separately)
fn parse_fstring(parser: i64, content: i64) -> i64 {
    let parts: i64 = vec_new();
    let exprs: i64 = vec_new();
    let formats: i64 = vec_new();  // Format specifiers (parallel to exprs)
    let current: i64 = string_from("");
    let len: i64 = string_len(content);
    let i: i64 = 0;

    while i < len {
        let c: i64 = string_char_at(content, i);
        if c == 123 {  // '{'
            // Check for escaped brace: {{
            if i + 1 < len {
                let next: i64 = string_char_at(content, i + 1);
                if next == 123 {
                    // {{ produces literal {
                    current = string_concat(current, string_from_char(123));
                    i = i + 2;
                    continue;
                }
            }

            // Found expression start
            vec_push(parts, current);
            current = string_from("");
            i = i + 1;

            // Extract expression text until ':' (format spec) or '}' (close)
            // Track brace depth for nested expressions like {arr[i]}
            let expr_text: i64 = string_from("");
            let format_spec: i64 = string_from("");
            let depth: i64 = 1;
            let in_format: i64 = 0;  // 0 = parsing expr, 1 = parsing format

            while i < len {
                let ec: i64 = string_char_at(content, i);
                if ec == 123 {  // '{'
                    depth = depth + 1;
                    if in_format == 1 {
                        format_spec = string_concat(format_spec, string_from_char(ec));
                    } else {
                        expr_text = string_concat(expr_text, string_from_char(ec));
                    }
                } else {
                    if ec == 125 {  // '}'
                        depth = depth - 1;
                        if depth == 0 {
                            i = i + 1;
                            break;
                        }
                        if in_format == 1 {
                            format_spec = string_concat(format_spec, string_from_char(ec));
                        } else {
                            expr_text = string_concat(expr_text, string_from_char(ec));
                        }
                    } else {
                        if ec == 58 {  // ':'
                            // Only treat as format separator at depth 1, and if not already in format
                            if depth == 1 {
                                if in_format == 0 {
                                    in_format = 1;
                                } else {
                                    format_spec = string_concat(format_spec, string_from_char(ec));
                                }
                            } else {
                                // Nested colon (e.g., in ternary or slice), keep in expression
                                if in_format == 1 {
                                    format_spec = string_concat(format_spec, string_from_char(ec));
                                } else {
                                    expr_text = string_concat(expr_text, string_from_char(ec));
                                }
                            }
                        } else {
                            if in_format == 1 {
                                format_spec = string_concat(format_spec, string_from_char(ec));
                            } else {
                                expr_text = string_concat(expr_text, string_from_char(ec));
                            }
                        }
                    }
                }
                i = i + 1;
            }

            // Parse the expression text using the full expression parser
            // Tokenize the expression text and create a sub-parser
            let expr_tokens: i64 = tokenize(expr_text);
            let expr_parser: i64 = parser_new(expr_tokens);
            let parsed_expr: i64 = parse_expr(expr_parser);

            vec_push(exprs, parsed_expr);
            vec_push(formats, format_spec);
        } else {
            if c == 125 {  // '}'
                // Check for escaped brace: }}
                if i + 1 < len {
                    let next: i64 = string_char_at(content, i + 1);
                    if next == 125 {
                        // }} produces literal }
                        current = string_concat(current, string_from_char(125));
                        i = i + 2;
                        continue;
                    }
                }
                // Single } outside interpolation - just include it
                current = string_concat(current, string_from_char(c));
                i = i + 1;
            } else {
                current = string_concat(current, string_from_char(c));
                i = i + 1;
            }
        }
    }

    // Add remaining part
    vec_push(parts, current);

    return ast_fstring(parts, exprs);
}

// Parse primary expression
fn parse_primary(parser: i64) -> i64 {
    // Float literal (check before Int to handle properly)
    if parser_check(parser, TokenKind::Float) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_float(text);
    }

    // Integer literal
    if parser_check(parser, TokenKind::Int) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        let value: i64 = string_to_int(text);
        return ast_int(value);
    }

    // Boolean literals
    if parser_check(parser, TokenKind::KwTrue) {
        parser_advance(parser);
        return ast_bool(true);
    }
    if parser_check(parser, TokenKind::KwFalse) {
        parser_advance(parser);
        return ast_bool(false);
    }

    // String literal
    if parser_check(parser, TokenKind::String) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return ast_string(text);
    }

    // FString literal (interpolated string)
    if parser_check(parser, TokenKind::FString) {
        let tok: i64 = parser_advance(parser);
        let text: i64 = token_text(tok);
        return parse_fstring(parser, text);
    }

    // Yield expression (for generators)
    if parser_check(parser, TokenKind::KwYield) {
        parser_advance(parser);
        let inner: i64 = parse_expr(parser);
        return ast_yield(inner);
    }

    // Spawn expression (spawn TypeName)
    if parser_check(parser, TokenKind::KwSpawn) {
        parser_advance(parser);
        let type_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_tok);
        return ast_spawn(type_name);
    }

    // Infer expression (infer(prompt)) - AI model inference
    if parser_check(parser, TokenKind::KwInfer) {
        parser_advance(parser);
        parser_expect(parser, TokenKind::LParen);
        let prompt: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);
        return ast_infer(prompt);
    }

    // Array literal [a, b, c]
    if parser_check(parser, TokenKind::LBracket) {
        parser_advance(parser);
        let elements: i64 = vec_new();
        if parser_check(parser, TokenKind::RBracket) == false {
            let first: i64 = parse_expr(parser);
            vec_push(elements, first);
            while parser_match(parser, TokenKind::Comma) {
                let elem: i64 = parse_expr(parser);
                vec_push(elements, elem);
            }
        }
        parser_expect(parser, TokenKind::RBracket);
        return ast_array(elements);
    }

    // 'self' keyword as identifier
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        return ast_ident(string_from("self"));
    }

    // Identifier or path
    if parser_check(parser, TokenKind::Ident) {
        let tok: i64 = parser_advance(parser);
        let name: i64 = token_text(tok);

        // Check for turbofish syntax: foo::<T1, T2>(args)
        // Must check before path handling because :: followed by < is turbofish, not path
        let call_type_args: i64 = 0;
        if parser_check(parser, TokenKind::DoubleColon) {
            // Peek ahead: if next is < then it's turbofish, otherwise it's a path
            // We need to consume :: and check
            parser_advance(parser);
            if parser_check(parser, TokenKind::Lt) {
                // Turbofish!
                parser_advance(parser);
                call_type_args = vec_new();
                // Parse type arguments (can be Ident or Int for const generics)
                if parser_check(parser, TokenKind::Ident) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else if parser_check(parser, TokenKind::Int) {
                    let type_tok: i64 = parser_advance(parser);
                    vec_push(call_type_args, token_text(type_tok));
                } else {
                    parser_add_error(parser, "Expected type or const value");
                }
                while parser_match(parser, TokenKind::Comma) {
                    if parser_check(parser, TokenKind::Ident) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else if parser_check(parser, TokenKind::Int) {
                        let next_type: i64 = parser_advance(parser);
                        vec_push(call_type_args, token_text(next_type));
                    } else {
                        parser_add_error(parser, "Expected type or const value");
                    }
                }
                parser_expect(parser, TokenKind::Gt);
            } else {
                // Path - could be Type::Variant or Type::function()
                if parser_check(parser, TokenKind::Ident) {
                    let seg_tok: i64 = parser_advance(parser);
                    let seg_name: i64 = token_text(seg_tok);

                    // Check if followed by ( for associated function call
                    if parser_check(parser, TokenKind::LParen) {
                        // Type::function(args) - mangle to Type_function
                        let mangled_name: i64 = string_concat(name, "_");
                        mangled_name = string_concat(mangled_name, seg_name);
                        parser_advance(parser);  // consume (
                        let args: i64 = vec_new();
                        if parser_check(parser, TokenKind::RParen) == false {
                            let first_arg: i64 = parse_expr(parser);
                            vec_push(args, first_arg);
                            while parser_match(parser, TokenKind::Comma) {
                                let arg: i64 = parse_expr(parser);
                                vec_push(args, arg);
                            }
                        }
                        parser_expect(parser, TokenKind::RParen);
                        return ast_call(ast_ident(mangled_name), args);
                    }

                    // Path: Name::Variant (possibly with more segments)
                    let segments: i64 = vec_new();
                    vec_push(segments, name);
                    vec_push(segments, seg_name);

                    while parser_match(parser, TokenKind::DoubleColon) {
                        if parser_check(parser, TokenKind::Ident) {
                            let next_seg: i64 = parser_advance(parser);
                            vec_push(segments, token_text(next_seg));
                        }
                    }
                    return ast_path(segments);
                }
            }
        }

        // Check for function call
        if parser_check(parser, TokenKind::LParen) {
            parser_advance(parser);
            let args: i64 = vec_new();

            if parser_check(parser, TokenKind::RParen) {
                // Empty args
            } else {
                let first_arg: i64 = parse_expr(parser);
                vec_push(args, first_arg);

                while parser_match(parser, TokenKind::Comma) {
                    let arg: i64 = parse_expr(parser);
                    vec_push(args, arg);
                }
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_call_generic(ast_ident(name), args, call_type_args);
        }

        // Struct literal syntax: Name { field: value, ... }
        // Disambiguate from `if cond { ... }` by checking if { is followed by:
        // - `}` (empty struct literal)
        // - `Ident :` (field initialization)
        if parser_check(parser, TokenKind::LBrace) {
            // Look ahead to see if this is a struct literal
            let is_struct_lit: bool = false;

            // Check for empty struct: Name { }
            if parser_peek_check(parser, 1, TokenKind::RBrace) {
                is_struct_lit = true;
            }
            // Check for field init: Name { field: value }
            if parser_peek_check(parser, 1, TokenKind::Ident) {
                if parser_peek_check(parser, 2, TokenKind::Colon) {
                    is_struct_lit = true;
                }
            }

            if is_struct_lit {
                parser_advance(parser);  // consume {
                let field_inits: i64 = vec_new();

                while parser_check(parser, TokenKind::RBrace) == false {
                    // Parse field: name: value
                    let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let field_name: i64 = token_text(field_name_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let field_value: i64 = parse_expr(parser);

                    // Create field init pair (name, value)
                    let field_init: i64 = malloc(16);
                    store_ptr(field_init, 0, field_name);
                    store_ptr(field_init, 1, field_value);
                    vec_push(field_inits, field_init);

                    // Optional comma
                    if parser_check(parser, TokenKind::RBrace) == false {
                        parser_match(parser, TokenKind::Comma);
                    }
                }

                parser_expect(parser, TokenKind::RBrace);
                return ast_struct_lit(name, field_inits, call_type_args);
            }
        }

        return ast_ident(name);
    }

    // Parenthesized expression or closure: (expr) or (params) => body
    if parser_check(parser, TokenKind::LParen) {
        // Check if this is a closure: () => body, (x) => body, or (x: i64) => body
        // Lookahead to determine if this is a closure
        let is_closure: bool = false;

        // () => body  - empty params closure
        if parser_peek_check(parser, 1, TokenKind::RParen) {
            if parser_peek_check(parser, 2, TokenKind::FatArrow) {
                is_closure = true;
            }
        }
        // (ident) => body  - untyped single param closure
        if parser_peek_check(parser, 1, TokenKind::Ident) {
            if parser_peek_check(parser, 2, TokenKind::RParen) {
                if parser_peek_check(parser, 3, TokenKind::FatArrow) {
                    is_closure = true;
                }
            }
        }
        // (ident, ...) => body  - untyped multi param closure
        if parser_peek_check(parser, 1, TokenKind::Ident) {
            if parser_peek_check(parser, 2, TokenKind::Comma) {
                is_closure = true;
            }
        }
        // (ident : type) => body  - typed closure with params
        if parser_peek_check(parser, 1, TokenKind::Ident) {
            if parser_peek_check(parser, 2, TokenKind::Colon) {
                is_closure = true;
            }
        }

        if is_closure {
            parser_advance(parser);  // consume (
            let params: i64 = vec_new();

            // Parse params if not empty
            if parser_check(parser, TokenKind::RParen) == false {
                // Parse first param: name or name : type
                let p_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let p_name: i64 = token_text(p_name_tok);
                let p_type: i64 = 0;
                if parser_match(parser, TokenKind::Colon) {
                    p_type = parse_type(parser);
                }
                vec_push(params, ast_param(p_name, p_type));

                // Parse more params
                while parser_match(parser, TokenKind::Comma) {
                    let pn_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let pn: i64 = token_text(pn_tok);
                    let pt: i64 = 0;
                    if parser_match(parser, TokenKind::Colon) {
                        pt = parse_type(parser);
                    }
                    vec_push(params, ast_param(pn, pt));
                }
            }

            parser_expect(parser, TokenKind::RParen);
            parser_expect(parser, TokenKind::FatArrow);
            let body: i64 = parse_expr(parser);
            return ast_closure(params, body);
        }

        // Not a closure - parenthesized expression or tuple
        parser_advance(parser);  // consume (

        // Check for empty tuple ()
        if parser_check(parser, TokenKind::RParen) {
            parser_advance(parser);
            let empty_elems: i64 = vec_new();
            return ast_tuple(empty_elems);
        }

        let first_expr: i64 = parse_expr(parser);

        // Check for comma - if present, it's a tuple
        if parser_check(parser, TokenKind::Comma) {
            let elements: i64 = vec_new();
            vec_push(elements, first_expr);

            while parser_match(parser, TokenKind::Comma) {
                // Handle trailing comma
                if parser_check(parser, TokenKind::RParen) {
                    break;
                }
                let elem: i64 = parse_expr(parser);
                vec_push(elements, elem);
            }

            parser_expect(parser, TokenKind::RParen);
            return ast_tuple(elements);
        }

        // Single expression in parentheses - just grouping
        parser_expect(parser, TokenKind::RParen);
        return first_expr;
    }

    // If expression
    if parser_check(parser, TokenKind::KwIf) {
        return parse_if(parser);
    }

    // While expression
    if parser_check(parser, TokenKind::KwWhile) {
        return parse_while(parser);
    }

    // Loop expression: loop { body }
    if parser_check(parser, TokenKind::KwLoop) {
        parser_advance(parser);
        let body: i64 = parse_block(parser);
        return ast_loop(body);
    }

    // Break expression with optional value: break [expr]
    if parser_check(parser, TokenKind::KwBreak) {
        parser_advance(parser);
        // Check if there's a value to break with
        if parser_check(parser, TokenKind::LBrace) == false {
            if parser_check(parser, TokenKind::RBrace) == false {
                if parser_check(parser, TokenKind::Semi) == false {
                    if parser_at_end(parser) == false {
                        let value: i64 = parse_expr(parser);
                        return ast_break_value(value);
                    }
                }
            }
        }
        return ast_break_value(0);
    }

    // For expression
    if parser_check(parser, TokenKind::KwFor) {
        return parse_for(parser);
    }

    // Match expression
    if parser_check(parser, TokenKind::KwMatch) {
        return parse_match(parser);
    }

    // Block expression
    if parser_check(parser, TokenKind::LBrace) {
        return parse_block(parser);
    }

    // Error - advance past unrecognized token to prevent infinite loop
    if parser_at_end(parser) == false {
        parser_advance(parser);
    }
    0
}

// Parse postfix expression (field access: expr.field, method call: expr.method(args), try: expr?, await: expr.await)
fn parse_postfix(parser: i64) -> i64 {
    let expr: i64 = parse_primary(parser);

    while true {
        if parser_match(parser, TokenKind::Dot) {
            // Check for .await keyword
            if parser_check(parser, TokenKind::KwAwait) {
                parser_advance(parser);
                expr = ast_await(expr);
            } else {
                let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let name: i64 = token_text(name_tok);

                // Check for turbofish on method: .method::<T>()
                let method_type_args: i64 = 0;
                if parser_check(parser, TokenKind::DoubleColon) {
                    parser_advance(parser);
                    if parser_check(parser, TokenKind::Lt) {
                        parser_advance(parser);
                        method_type_args = vec_new();
                        // Parse type arguments
                        while true {
                            if parser_check(parser, TokenKind::Gt) {
                                parser_advance(parser);
                                break;
                            }
                            let ty_arg: i64 = parse_type(parser);
                            vec_push(method_type_args, ty_arg);
                            if parser_match(parser, TokenKind::Comma) == false {
                                if parser_check(parser, TokenKind::Gt) == false {
                                    break;
                                }
                            }
                        }
                        // Encode type args in name: method_i64_String
                        if vec_len(method_type_args) > 0 {
                            let j: i64 = 0;
                            while j < vec_len(method_type_args) {
                                name = string_concat(name, "_");
                                name = string_concat(name, vec_get(method_type_args, j));
                                j = j + 1;
                            }
                        }
                    }
                }

                // Check if this is a method call (followed by '(')
                if parser_check(parser, TokenKind::LParen) {
                    parser_advance(parser);
                    let args: i64 = vec_new();

                    if parser_check(parser, TokenKind::RParen) {
                        // Empty args
                    } else {
                        let first_arg: i64 = parse_expr(parser);
                        vec_push(args, first_arg);

                        while parser_match(parser, TokenKind::Comma) {
                            let arg: i64 = parse_expr(parser);
                            vec_push(args, arg);
                        }
                    }

                    parser_expect(parser, TokenKind::RParen);
                    expr = ast_method_call(expr, name, args);
                } else {
                    // Field access
                    expr = ast_field_access(expr, name);
                }
            }
        } else {
            // Try operator: expr?
            if parser_match(parser, TokenKind::Question) {
                expr = ast_try(expr);
            } else {
                return expr;
            }
        }
    }

    expr
}

// Parse unary expression
fn parse_unary(parser: i64) -> i64 {
    if parser_match(parser, TokenKind::Minus) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NEG(), operand);
    }
    if parser_match(parser, TokenKind::Bang) {
        let operand: i64 = parse_unary(parser);
        return ast_unary(OP_NOT(), operand);
    }
    parse_postfix(parser)
}

// Parse multiplicative expression
fn parse_multiplicative(parser: i64) -> i64 {
    let left: i64 = parse_unary(parser);

    while true {
        if parser_match(parser, TokenKind::Star) {
            let right: i64 = parse_unary(parser);
            left = ast_binary(OP_MUL(), left, right);
        } else {
            if parser_match(parser, TokenKind::Slash) {
                let right: i64 = parse_unary(parser);
                left = ast_binary(OP_DIV(), left, right);
            } else {
                if parser_match(parser, TokenKind::Percent) {
                    let right: i64 = parse_unary(parser);
                    left = ast_binary(OP_MOD(), left, right);
                } else {
                    return left;
                }
            }
        }
    }
    left
}

// Parse additive expression
fn parse_additive(parser: i64) -> i64 {
    let left: i64 = parse_multiplicative(parser);

    while true {
        if parser_match(parser, TokenKind::Plus) {
            let right: i64 = parse_multiplicative(parser);
            left = ast_binary(OP_ADD(), left, right);
        } else {
            if parser_match(parser, TokenKind::Minus) {
                let right: i64 = parse_multiplicative(parser);
                left = ast_binary(OP_SUB(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse shift expression (<< >>)
fn parse_shift(parser: i64) -> i64 {
    let left: i64 = parse_additive(parser);

    while true {
        if parser_match(parser, TokenKind::LtLt) {
            let right: i64 = parse_additive(parser);
            left = ast_binary(OP_SHL(), left, right);
        } else {
            if parser_match(parser, TokenKind::GtGt) {
                let right: i64 = parse_additive(parser);
                left = ast_binary(OP_SHR(), left, right);
            } else {
                return left;
            }
        }
    }
    left
}

// Parse comparison expression
fn parse_comparison(parser: i64) -> i64 {
    let left: i64 = parse_shift(parser);

    if parser_match(parser, TokenKind::EqEq) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_EQ(), left, right);
    }
    if parser_match(parser, TokenKind::Ne) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_NE(), left, right);
    }
    if parser_match(parser, TokenKind::Lt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LT(), left, right);
    }
    if parser_match(parser, TokenKind::Gt) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GT(), left, right);
    }
    if parser_match(parser, TokenKind::Le) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_LE(), left, right);
    }
    if parser_match(parser, TokenKind::Ge) {
        let right: i64 = parse_shift(parser);
        return ast_binary(OP_GE(), left, right);
    }
    left
}

// Parse bitwise AND expression (&)
fn parse_bitand(parser: i64) -> i64 {
    let left: i64 = parse_comparison(parser);

    while parser_match(parser, TokenKind::Amp) {
        let right: i64 = parse_comparison(parser);
        left = ast_binary(OP_BITAND(), left, right);
    }
    left
}

// Parse bitwise XOR expression (^)
fn parse_bitxor(parser: i64) -> i64 {
    let left: i64 = parse_bitand(parser);

    while parser_match(parser, TokenKind::Caret) {
        let right: i64 = parse_bitand(parser);
        left = ast_binary(OP_BITXOR(), left, right);
    }
    left
}

// Parse bitwise OR expression (|)
fn parse_bitor(parser: i64) -> i64 {
    let left: i64 = parse_bitxor(parser);

    while parser_match(parser, TokenKind::Pipe) {
        let right: i64 = parse_bitxor(parser);
        left = ast_binary(OP_BITOR(), left, right);
    }
    left
}

// Parse logical AND expression (&&)
fn parse_and(parser: i64) -> i64 {
    let left: i64 = parse_bitor(parser);

    while parser_match(parser, TokenKind::AmpAmp) {
        let right: i64 = parse_bitor(parser);
        left = ast_binary(OP_AND(), left, right);
    }
    left
}

// Parse logical OR expression (||)
fn parse_or(parser: i64) -> i64 {
    let left: i64 = parse_and(parser);

    while parser_match(parser, TokenKind::PipePipe) {
        let right: i64 = parse_and(parser);
        left = ast_binary(OP_OR(), left, right);
    }
    left
}

// Parse expression
fn parse_expr(parser: i64) -> i64 {
    parse_or(parser)
}

// Parse block
fn parse_block(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::LBrace);
    let stmts: i64 = vec_new();
    let result: i64 = 0;

    while true {
        // Check for EOF to prevent infinite loop on incomplete input
        if parser_at_end(parser) {
            return ast_block(stmts, result);
        }

        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_block(stmts, result);
        }

        // Check for statement vs expression
        if parser_check(parser, TokenKind::KwLet) {
            let stmt: i64 = parse_let(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwVar) {
            // var is like let but for mutable bindings
            let stmt: i64 = parse_var(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwReturn) {
            let stmt: i64 = parse_return(parser);
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwBreak) {
            parser_advance(parser);
            // Check if there's a value to break with
            var break_value: i64 = 0;
            if parser_check(parser, TokenKind::LBrace) == false {
                if parser_check(parser, TokenKind::RBrace) == false {
                    if parser_check(parser, TokenKind::Semi) == false {
                        if parser_at_end(parser) == false {
                            break_value = parse_expr(parser);
                        }
                    }
                }
            }
            parser_match(parser, TokenKind::Semi);  // Semicolon optional
            let stmt: i64 = ast_expr_stmt(ast_break_value(break_value));
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwContinue) {
            parser_advance(parser);
            parser_match(parser, TokenKind::Semi);  // Semicolon optional
            let stmt: i64 = ast_continue();
            vec_push(stmts, stmt);
        } else {
        if parser_check(parser, TokenKind::KwUse) {
            // Use statement inside block (for local imports)
            let use_item: i64 = parse_use(parser);
            vec_push(stmts, ast_expr_stmt(use_item));
        } else {
            // Expression - could be statement, assignment, or result
            let expr: i64 = parse_expr(parser);

            // Check for assignment: ident = expr;
            if parser_match(parser, TokenKind::Eq) {
                // This is an assignment statement
                // expr should be an identifier
                let expr_tag: i64 = load_i64(expr, 0);
                if expr_tag == EXPR_IDENT() {
                    let name: i64 = load_ptr(expr, 1);
                    let value: i64 = parse_expr(parser);
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_assign(name, value));
                } else {
                    // Invalid assignment target, treat as expression
                    parser_match(parser, TokenKind::Semi);
                    vec_push(stmts, ast_expr_stmt(expr));
                }
            } else {
                if parser_match(parser, TokenKind::Semi) {
                    // Expression statement with explicit semicolon
                    vec_push(stmts, ast_expr_stmt(expr));
                } else {
                    // No semicolon - check if more statements follow
                    if parser_check(parser, TokenKind::RBrace) {
                        // Next is }, so this is the result expression
                        result = expr;
                    } else {
                        // More statements follow, so this is an implicit statement
                        // (if/while don't need semicolons when followed by more code)
                        vec_push(stmts, ast_expr_stmt(expr));
                    }
                }
            }
        }
        }
        }
        }
        }
        }
    }

    ast_block(stmts, result)
}

// Parse var statement (mutable binding)
fn parse_var(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwVar);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    // Semicolon is optional
    parser_match(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse single pattern (without or-alternatives)
fn parse_pattern_single(parser: i64) -> i64 {
    // Check for wildcard pattern: _
    if parser_match(parser, TokenKind::Underscore) {
        return 0;  // 0 indicates wildcard
    }

    // Check for tuple pattern: (p1, p2, ...)
    if parser_check(parser, TokenKind::LParen) {
        parser_advance(parser);  // consume (

        // Empty tuple pattern ()
        if parser_check(parser, TokenKind::RParen) {
            parser_advance(parser);
            let empty_elems: i64 = vec_new();
            return ast_tuple(empty_elems);
        }

        let elements: i64 = vec_new();
        let first_pat: i64 = parse_pattern(parser);
        vec_push(elements, first_pat);

        while parser_match(parser, TokenKind::Comma) {
            // Handle trailing comma
            if parser_check(parser, TokenKind::RParen) {
                break;
            }
            let elem_pat: i64 = parse_pattern(parser);
            vec_push(elements, elem_pat);
        }

        parser_expect(parser, TokenKind::RParen);
        return ast_tuple(elements);
    }

    // Parse identifier (could be enum variant, struct, or binding)
    if parser_check(parser, TokenKind::Ident) {
        let name_tok: i64 = parser_advance(parser);
        let name: i64 = token_text(name_tok);

        // Check for :: path separator (enum variant: EnumName::Variant)
        if parser_match(parser, TokenKind::DoubleColon) {
            let variant_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let variant: i64 = token_text(variant_tok);

            // Build segments vector for path [EnumName, Variant]
            let segments: i64 = vec_new();
            vec_push(segments, name);
            vec_push(segments, variant);

            // Check for (bindings...) - enum variant with payload
            if parser_match(parser, TokenKind::LParen) {
                let args: i64 = vec_new();
                while true {
                    if parser_check(parser, TokenKind::RParen) {
                        parser_advance(parser);
                        // Create call-like node for enum pattern: EnumName::Variant(bindings)
                        let path: i64 = ast_path(segments);
                        return ast_call(path, args);
                    }
                    vec_push(args, parse_pattern(parser));
                    if parser_check(parser, TokenKind::Comma) {
                        parser_advance(parser);
                    }
                }
            }

            // Plain path without parens: EnumName::Variant
            return ast_path(segments);
        }

        // Check for struct pattern: TypeName { field1, field2: binding, .. }
        if parser_check(parser, TokenKind::LBrace) {
            parser_advance(parser);  // consume {
            let fields: i64 = vec_new();
            let has_rest: i64 = 0;

            while parser_check(parser, TokenKind::RBrace) == false {
                // Check for .. (rest pattern)
                if parser_match(parser, TokenKind::DotDot) {
                    has_rest = 1;
                    break;
                }

                // Parse field pattern: field_name or field_name: binding
                let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let field_name: i64 = token_text(field_tok);
                let binding: i64 = field_name;  // Default: shorthand field binding

                // Check for : binding
                if parser_match(parser, TokenKind::Colon) {
                    binding = parse_pattern(parser);
                }

                // Create field entry: (field_name, binding)
                let field_entry: i64 = malloc(16);
                store_ptr(field_entry, 0, field_name);
                store_ptr(field_entry, 1, binding);
                vec_push(fields, field_entry);

                if parser_check(parser, TokenKind::Comma) {
                    parser_advance(parser);
                } else {
                    break;
                }
            }
            parser_expect(parser, TokenKind::RBrace);

            // Create struct pattern node: EXPR_STRUCT_PAT(type_name, fields, has_rest)
            return ast_struct_pattern(name, fields, has_rest);
        }

        // Check for (bindings...) after simple name (Some, Ok, etc.)
        if parser_match(parser, TokenKind::LParen) {
            let args: i64 = vec_new();
            while true {
                if parser_check(parser, TokenKind::RParen) {
                    parser_advance(parser);
                    // Create call node to represent enum variant with payload: Some(x)
                    let callee: i64 = ast_ident(name);
                    return ast_call(callee, args);
                }
                vec_push(args, parse_pattern(parser));
                if parser_check(parser, TokenKind::Comma) {
                    parser_advance(parser);
                }
            }
        }

        // Simple identifier - either enum variant without payload (None) or binding
        return ast_ident(name);
    }

    // Fallback - parse as expression (handles literals, etc.)
    parse_expr(parser)
}

// Parse pattern for if-let and match expressions
// Returns an expression node (path/call for enum variants, ident for bindings, tuple, 0 for wildcard)
// Supports or-patterns: Pattern1 | Pattern2 | ...
fn parse_pattern(parser: i64) -> i64 {
    let first: i64 = parse_pattern_single(parser);

    // Check for or-pattern: Pattern | Pattern | ...
    if parser_check(parser, TokenKind::Pipe) {
        let alternatives: i64 = vec_new();
        vec_push(alternatives, first);

        while parser_match(parser, TokenKind::Pipe) {
            let alt: i64 = parse_pattern_single(parser);
            vec_push(alternatives, alt);
        }

        return ast_or_pattern(alternatives);
    }

    first
}

// Parse if expression (including if-let)
fn parse_if(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwIf);

    // Check for if-let: if let Pattern = scrutinee { then } else { else }
    if parser_match(parser, TokenKind::KwLet) {
        // Parse pattern
        let pattern: i64 = parse_pattern(parser);
        parser_expect(parser, TokenKind::Eq);
        let scrutinee: i64 = parse_expr(parser);
        let then_block: i64 = parse_block(parser);

        // Parse optional else
        let else_block: i64 = 0;
        if parser_match(parser, TokenKind::KwElse) {
            if parser_check(parser, TokenKind::KwIf) {
                else_block = parse_if(parser);
            } else {
                else_block = parse_block(parser);
            }
        } else {
            // Default else returns unit (0)
            else_block = ast_block(vec_new(), ast_int(0));
        }

        // Desugar to match expression:
        // match scrutinee { pattern => then_block, _ => else_block }
        let arms: i64 = vec_new();
        vec_push(arms, ast_match_arm(pattern, 0, then_block));
        vec_push(arms, ast_match_arm(0, 0, else_block));  // 0 pattern = wildcard
        return ast_match(scrutinee, arms);
    }

    // Regular if expression
    let cond: i64 = parse_expr(parser);
    let then_block: i64 = parse_block(parser);
    let else_block: i64 = 0;

    if parser_match(parser, TokenKind::KwElse) {
        // Check if it's else-if or else block
        if parser_check(parser, TokenKind::KwIf) {
            else_block = parse_if(parser);
        } else {
            else_block = parse_block(parser);
        }
    }

    ast_if(cond, then_block, else_block)
}

// Parse while expression (including while-let)
fn parse_while(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwWhile);

    // Check for while-let: while let Pattern = scrutinee { body }
    if parser_match(parser, TokenKind::KwLet) {
        let pattern: i64 = parse_pattern(parser);
        parser_expect(parser, TokenKind::Eq);
        let scrutinee: i64 = parse_expr(parser);
        let body: i64 = parse_block(parser);
        return ast_while_let(pattern, scrutinee, body);
    }

    // Regular while expression
    let cond: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_while(cond, body)
}

// Parse for expression: for i in start..end { body }
fn parse_for(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFor);
    let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let var_name: i64 = token_text(var_tok);
    parser_expect(parser, TokenKind::KwIn);
    let start: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::DotDot);
    let end: i64 = parse_expr(parser);
    let body: i64 = parse_block(parser);
    ast_for(var_name, start, end, body)
}

// Parse match expression: match expr { pattern => result, ... }
fn parse_match(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMatch);
    let scrutinee: i64 = parse_expr(parser);
    parser_expect(parser, TokenKind::LBrace);

    let arms: i64 = vec_new();

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_match(scrutinee, arms);
        }

        // Parse pattern - could be:
        // - Underscore: wildcard
        // - Path: EnumName::Variant
        // - Ident: variable or enum variant
        let pattern: i64 = 0;
        if parser_match(parser, TokenKind::Underscore) {
            // Wildcard pattern - use null to indicate wildcard
            pattern = 0;
        } else {
            // Parse pattern (handles paths, identifiers, and bindings)
            pattern = parse_pattern(parser);
        }

        // Parse optional guard: if condition
        let guard: i64 = 0;
        if parser_match(parser, TokenKind::KwIf) {
            guard = parse_expr(parser);
        }

        parser_expect(parser, TokenKind::FatArrow);

        // Parse arm result (could be block or expression)
        let result: i64 = 0;
        if parser_check(parser, TokenKind::LBrace) {
            result = parse_block(parser);
        } else {
            result = parse_expr(parser);
        }

        vec_push(arms, ast_match_arm(pattern, guard, result));

        // Optional comma between arms
        parser_match(parser, TokenKind::Comma);
    }

    ast_match(scrutinee, arms)
}

// Parse let statement
fn parse_let(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwLet);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let ty: i64 = 0;
    if parser_match(parser, TokenKind::Colon) {
        ty = parse_type(parser);
    }

    let init_expr: i64 = 0;
    if parser_match(parser, TokenKind::Eq) {
        init_expr = parse_expr(parser);
    }

    // Semicolon is optional (allows more concise single-line syntax)
    parser_match(parser, TokenKind::Semi);
    ast_let(name, ty, init_expr)
}

// Parse return statement
fn parse_return(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwReturn);
    let expr: i64 = 0;

    // Check if there's an expression to return
    // Return without value if we see semicolon, closing brace, or end
    if parser_check(parser, TokenKind::Semi) {
        // return;
    } else {
        if parser_check(parser, TokenKind::RBrace) {
            // return } - no value
        } else {
            expr = parse_expr(parser);
        }
    }

    // Semicolon is optional
    parser_match(parser, TokenKind::Semi);
    ast_return(expr)
}

// Parse type: handles simple idents, Self, Self::AssocType, tuples, dyn Trait, and reference types (&T, &str)
fn parse_type(parser: i64) -> i64 {
    // Check for reference type (&T, &str, &mut T)
    if parser_check(parser, TokenKind::Amp) {
        parser_advance(parser);  // consume '&'
        // Check for &mut (mutable reference)
        let is_mut: bool = false;
        if parser_check(parser, TokenKind::KwMut) {
            parser_advance(parser);  // consume 'mut'
            is_mut = true;
        }
        // Parse the inner type recursively
        let inner_type: i64 = parse_type(parser);
        // Return "&Type" or "&mut Type" as the type string
        if is_mut {
            return string_concat(string_from("&mut "), inner_type);
        }
        return string_concat(string_from("&"), inner_type);
    }

    // Check for tuple type: (T1, T2, ...)
    if parser_check(parser, TokenKind::LParen) {
        parser_advance(parser);  // consume (

        // Empty tuple type ()
        if parser_check(parser, TokenKind::RParen) {
            parser_advance(parser);
            return string_from("()");
        }

        let type_elems: i64 = vec_new();
        let first_ty: i64 = parse_type(parser);
        vec_push(type_elems, first_ty);

        while parser_match(parser, TokenKind::Comma) {
            // Handle trailing comma
            if parser_check(parser, TokenKind::RParen) {
                break;
            }
            let elem_ty: i64 = parse_type(parser);
            vec_push(type_elems, elem_ty);
        }

        parser_expect(parser, TokenKind::RParen);

        // Build tuple type string: (T1, T2, ...)
        let result: i64 = string_from("(");
        let n: i64 = vec_len(type_elems);
        let i: i64 = 0;
        while i < n {
            if i > 0 {
                result = string_concat(result, string_from(", "));
            }
            result = string_concat(result, vec_get(type_elems, i));
            i = i + 1;
        }
        result = string_concat(result, string_from(")"));
        return result;
    }

    // Check for dyn keyword (dynamic trait object)
    if parser_check(parser, TokenKind::KwDyn) {
        parser_advance(parser);  // consume 'dyn'
        let trait_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let trait_name: i64 = token_text(trait_tok);
        // Return "dyn:TraitName" as the type string - will be resolved in codegen
        return string_concat(string_from("dyn:"), trait_name);
    }
    // Check for Self keyword
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        // Check for Self::AssocType syntax
        if parser_check(parser, TokenKind::DoubleColon) {
            parser_advance(parser);  // consume ::
            let assoc_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let assoc_name: i64 = token_text(assoc_tok);
            // Return "Self::TypeName" as the type string - will be resolved in codegen
            return string_concat(string_from("Self::"), assoc_name);
        }
        // Just Self - refers to the implementing type
        return string_from("Self");
    }
    // Regular identifier type
    let tok: i64 = parser_expect(parser, TokenKind::Ident);
    let type_name: i64 = token_text(tok);

    // Phase 36: Handle generic type arguments like Option<i64>, Result<T, E>, Vec<T>
    if parser_check(parser, TokenKind::Lt) {
        parser_advance(parser);  // consume <
        let type_args: i64 = vec_new();

        // First type argument
        let first_arg: i64 = parse_type(parser);
        vec_push(type_args, first_arg);

        // Additional type arguments
        while parser_match(parser, TokenKind::Comma) {
            let arg: i64 = parse_type(parser);
            vec_push(type_args, arg);
        }

        // Handle > or >> (for nested generics like Option<Option<i64>>)
        // Check if we have a pending > from a previous >>
        let pending: i64 = parser_pending_gt(parser);
        if pending > 0 {
            // Use the pending > instead of consuming a token
            parser_set_pending_gt(parser, pending - 1);
        } else {
            // Need to consume a > token
            if parser_check(parser, TokenKind::Gt) {
                parser_advance(parser);
            } else {
                if parser_check(parser, TokenKind::GtGt) {
                    // >> token - consume it but save one > for the outer generic
                    parser_advance(parser);
                    parser_set_pending_gt(parser, parser_pending_gt(parser) + 1);
                } else {
                    parser_add_error(parser, string_from("expected '>' in type"));
                }
            }
        }

        // Build type string: Name<Arg1, Arg2, ...>
        let result: i64 = string_concat(type_name, string_from("<"));
        let n: i64 = vec_len(type_args);
        let i: i64 = 0;
        while i < n {
            if i > 0 {
                result = string_concat(result, string_from(", "));
            }
            result = string_concat(result, vec_get(type_args, i));
            i = i + 1;
        }
        result = string_concat(result, string_from(">"));
        return result;
    }

    type_name
}

// Parse function parameters
fn parse_params(parser: i64) -> i64 {
    let params: i64 = vec_new();
    parser_expect(parser, TokenKind::LParen);

    if parser_check(parser, TokenKind::RParen) {
        parser_advance(parser);
        return params;
    }

    // First param - accept Ident, 'self', '&self', or '&mut self'
    let name: i64 = 0;
    let ty: i64 = 0;
    if parser_check(parser, TokenKind::Amp) {
        // &self or &mut self
        parser_advance(parser);  // consume &
        // Check for 'mut' identifier before self
        if parser_check(parser, TokenKind::Ident) {
            let tok: i64 = parser_current(parser);
            if string_eq(token_text(tok), "mut") {
                parser_advance(parser);  // consume mut
                parser_expect(parser, TokenKind::KwSelf);
                name = string_from("self");
                ty = string_from("&mut Self");
            } else {
                // Not mut, should not happen in normal code
                // Try to recover
                parser_expect(parser, TokenKind::KwSelf);
                name = string_from("self");
                ty = string_from("&Self");
            }
        } else {
            parser_expect(parser, TokenKind::KwSelf);
            name = string_from("self");
            ty = string_from("&Self");
        }
    } else {
    if parser_check(parser, TokenKind::KwSelf) {
        parser_advance(parser);
        name = string_from("self");
        // Check if self has explicit type (self: Type) or implicit (bare self)
        if parser_check(parser, TokenKind::Colon) {
            parser_advance(parser);
            ty = parse_type(parser);
        } else {
            // Bare self - type is implicit (Self)
            ty = string_from("Self");
        }
    } else {
        let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        name = token_text(name_tok);
        parser_expect(parser, TokenKind::Colon);
        ty = parse_type(parser);
    }
    }
    vec_push(params, ast_param(name, ty));

    // More params
    while parser_match(parser, TokenKind::Comma) {
        let pname: i64 = 0;
        let pty: i64 = 0;
        if parser_check(parser, TokenKind::Amp) {
            // &self or &mut self
            parser_advance(parser);  // consume &
            // Check for 'mut' identifier before self
            if parser_check(parser, TokenKind::Ident) {
                let tok: i64 = parser_current(parser);
                if string_eq(token_text(tok), "mut") {
                    parser_advance(parser);  // consume mut
                    parser_expect(parser, TokenKind::KwSelf);
                    pname = string_from("self");
                    pty = string_from("&mut Self");
                } else {
                    // Not mut, should not happen in normal code
                    parser_expect(parser, TokenKind::KwSelf);
                    pname = string_from("self");
                    pty = string_from("&Self");
                }
            } else {
                parser_expect(parser, TokenKind::KwSelf);
                pname = string_from("self");
                pty = string_from("&Self");
            }
        } else if parser_check(parser, TokenKind::KwSelf) {
            parser_advance(parser);
            pname = string_from("self");
            if parser_check(parser, TokenKind::Colon) {
                parser_advance(parser);
                pty = parse_type(parser);
            } else {
                pty = string_from("Self");
            }
        } else {
            let pname_tok: i64 = parser_expect(parser, TokenKind::Ident);
            pname = token_text(pname_tok);
            parser_expect(parser, TokenKind::Colon);
            pty = parse_type(parser);
        }
        vec_push(params, ast_param(pname, pty));
    }

    parser_expect(parser, TokenKind::RParen);
    params
}

// Parse type parameters: <T, U, V> or <T: Trait, U: Bound>
// Returns a vec of type param strings. For bounded params, stores as "name:bound"
// For const params, stores as "const:name"
fn parse_type_params(parser: i64) -> i64 {
    if parser_check(parser, TokenKind::Lt) == false {
        return 0;  // No type params
    }
    parser_advance(parser);  // consume <

    let type_params: i64 = vec_new();

    // First type param (may be const or type with optional bound)
    if parser_check(parser, TokenKind::KwConst) {
        // const N: Type
        parser_advance(parser);
        let tok: i64 = parser_expect(parser, TokenKind::Ident);
        parser_expect(parser, TokenKind::Colon);
        parse_type(parser);  // Skip the type for now
        // Store with "const:" prefix to distinguish
        vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
    } else {
        if parser_check(parser, TokenKind::Ident) {
            let tok: i64 = parser_advance(parser);
            let param_name: i64 = token_text(tok);
            // Check for trait bound: T: Trait
            if parser_match(parser, TokenKind::Colon) {
                if parser_check(parser, TokenKind::Ident) {
                    let bound_tok: i64 = parser_advance(parser);
                    // Store as "T:Trait" - type param with bound
                    param_name = string_concat(param_name, ":");
                    param_name = string_concat(param_name, token_text(bound_tok));
                    // Handle additional bounds with + (e.g., T: A + B)
                    while parser_match(parser, TokenKind::Plus) {
                        if parser_check(parser, TokenKind::Ident) {
                            let extra_bound: i64 = parser_advance(parser);
                            param_name = string_concat(param_name, "+");
                            param_name = string_concat(param_name, token_text(extra_bound));
                        }
                    }
                }
            }
            vec_push(type_params, param_name);
        }
    }

    // Additional type params
    while parser_match(parser, TokenKind::Comma) {
        if parser_check(parser, TokenKind::KwConst) {
            parser_advance(parser);
            let tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Colon);
            parse_type(parser);
            vec_push(type_params, string_concat(string_from("const:"), token_text(tok)));
        } else {
            if parser_check(parser, TokenKind::Ident) {
                let tok: i64 = parser_advance(parser);
                let param_name: i64 = token_text(tok);
                // Check for trait bound
                if parser_match(parser, TokenKind::Colon) {
                    if parser_check(parser, TokenKind::Ident) {
                        let bound_tok: i64 = parser_advance(parser);
                        param_name = string_concat(param_name, ":");
                        param_name = string_concat(param_name, token_text(bound_tok));
                        while parser_match(parser, TokenKind::Plus) {
                            if parser_check(parser, TokenKind::Ident) {
                                let extra_bound: i64 = parser_advance(parser);
                                param_name = string_concat(param_name, "+");
                                param_name = string_concat(param_name, token_text(extra_bound));
                            }
                        }
                    }
                }
                vec_push(type_params, param_name);
            }
        }
    }

    parser_expect(parser, TokenKind::Gt);
    type_params
}

// Parse function definition (is_async: 1 if preceded by async keyword)
fn parse_fn(parser: i64, is_async: i64) -> i64 {
    parser_expect(parser, TokenKind::KwFn);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let params: i64 = parse_params(parser);

    let ret_ty: i64 = 0;
    if parser_match(parser, TokenKind::Arrow) {
        ret_ty = parse_type(parser);
    }

    // Parse optional where clause: where T: Trait, U: OtherTrait + Another
    if parser_match(parser, TokenKind::KwWhere) {
        // Parse where clause constraints and merge into type_params
        while true {
            if parser_check(parser, TokenKind::LBrace) {
                break;  // Body starts
            }
            if parser_check(parser, TokenKind::Ident) {
                let constraint_tok: i64 = parser_advance(parser);
                let constraint_name: i64 = token_text(constraint_tok);

                if parser_match(parser, TokenKind::Colon) {
                    // Parse trait bounds
                    if parser_check(parser, TokenKind::Ident) {
                        let bound_tok: i64 = parser_advance(parser);
                        let bound_str: i64 = string_concat(constraint_name, ":");
                        bound_str = string_concat(bound_str, token_text(bound_tok));

                        // Handle + for multiple bounds
                        while parser_match(parser, TokenKind::Plus) {
                            if parser_check(parser, TokenKind::Ident) {
                                let extra: i64 = parser_advance(parser);
                                bound_str = string_concat(bound_str, "+");
                                bound_str = string_concat(bound_str, token_text(extra));
                            }
                        }

                        // Add or update type parameter with this constraint
                        vec_push(type_params, bound_str);
                    }
                }

                // Skip comma between constraints
                parser_match(parser, TokenKind::Comma);
            } else {
                break;
            }
        }
    }

    let body: i64 = parse_block(parser);
    ast_fn_def(name, type_params, params, ret_ty, body, is_async)
}

// Parse enum definition with optional type parameters
// enum Option<T> { None, Some(T) }
fn parse_enum(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwEnum);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters <T, U, ...>
    let type_params: i64 = vec_new();
    if parser_match(parser, TokenKind::Lt) {
        while true {
            if parser_check(parser, TokenKind::Gt) {
                parser_advance(parser);
                return parse_enum_body(parser, name, type_params);
            }
            let tp_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let tp_name: i64 = token_text(tp_tok);
            vec_push(type_params, tp_name);
            if parser_check(parser, TokenKind::Comma) {
                parser_advance(parser);
            }
        }
    }

    parse_enum_body(parser, name, type_params)
}

// Parse enum body after name and type params
fn parse_enum_body(parser: i64, name: i64, type_params: i64) -> i64 {
    let variants: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_enum_def(name, variants);
        }

        let var_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let var_name: i64 = token_text(var_tok);

        // Check for variant payload: Some(T)
        if parser_match(parser, TokenKind::LParen) {
            // Parse payload types (skip them, not stored)
            parse_enum_payload(parser);
        }

        vec_push(variants, var_name);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_enum_def(name, variants)
}

// Parse enum variant payload types: (T), (T, E)
fn parse_enum_payload(parser: i64) -> i64 {
    while true {
        if parser_check(parser, TokenKind::RParen) {
            parser_advance(parser);
            return 0;
        }
        parse_type(parser);
        parser_match(parser, TokenKind::Comma);
    }
    0
}

// Parse struct definition with optional type parameters
// struct Name<T, U> { field: T, ... }
fn parse_struct(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwStruct);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    // Parse optional type parameters
    let type_params: i64 = parse_type_params(parser);

    let fields: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_struct_def(name, type_params, fields);
        }

        // Parse field: name: Type
        let field_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let field_name: i64 = token_text(field_name_tok);
        parser_expect(parser, TokenKind::Colon);
        let field_ty: i64 = parse_type(parser);

        // Create field pair (name, type)
        let field: i64 = malloc(16);
        store_ptr(field, 0, field_name);
        store_ptr(field, 1, field_ty);
        vec_push(fields, field);

        // Optional comma
        parser_match(parser, TokenKind::Comma);
    }

    ast_struct_def(name, type_params, fields)
}

// Parse trait definition: trait Name { type AssocType; fn method(...) -> Type; }
fn parse_trait(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwTrait);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);

    let method_sigs: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_trait(name, method_sigs);
        }

        // Check for associated type: type Name;
        if parser_check(parser, TokenKind::KwType) {
            parser_advance(parser);
            let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            parser_expect(parser, TokenKind::Semi);
            // Store associated type as a method sig with null params (to distinguish)
            vec_push(method_sigs, ast_method_sig(token_text(type_name_tok), 0, 0));
        } else {
            // Parse method signature: fn name(params) -> Type;
            // OR default method: fn name(params) -> Type { body }
            let is_async: i64 = 0;
            if parser_check(parser, TokenKind::KwAsync) {
                parser_advance(parser);
                is_async = 1;
            }
            parser_expect(parser, TokenKind::KwFn);
            let method_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let method_name: i64 = token_text(method_name_tok);
            let params: i64 = parse_params(parser);

            let ret_ty: i64 = 0;
            if parser_match(parser, TokenKind::Arrow) {
                ret_ty = parse_type(parser);
            }

            // Check for semicolon (signature only) or brace (default impl)
            if parser_check(parser, TokenKind::Semi) {
                parser_advance(parser);
                vec_push(method_sigs, ast_method_sig(method_name, params, ret_ty));
            } else if parser_check(parser, TokenKind::LBrace) {
                // Default method implementation - parse full function
                let body: i64 = parse_block(parser);
                let default_fn: i64 = ast_fn_def(method_name, 0, params, ret_ty, body, is_async);
                // Store default method (with body field set)
                vec_push(method_sigs, ast_default_method(method_name, params, ret_ty, default_fn));
            }
        }
    }

    ast_trait(name, method_sigs)
}

// Parse impl block: impl TypeName { ... } or impl TraitName for TypeName { ... }
fn parse_impl(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwImpl);
    let first_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let first_name: i64 = token_text(first_name_tok);

    // Check if this is "impl Trait for Type" syntax
    if parser_check(parser, TokenKind::KwFor) {
        parser_advance(parser);  // consume 'for'
        let type_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let type_name: i64 = token_text(type_name_tok);

        let methods: i64 = vec_new();
        let assoc_types: i64 = vec_new();
        parser_expect(parser, TokenKind::LBrace);

        while parser_check(parser, TokenKind::RBrace) == false {
            parser_match(parser, TokenKind::KwPub);
            // Check for associated type definition: type Name = Type;
            if parser_check(parser, TokenKind::KwType) {
                parser_advance(parser);
                let assoc_name_tok: i64 = parser_expect(parser, TokenKind::Ident);
                let assoc_name: i64 = token_text(assoc_name_tok);
                parser_expect(parser, TokenKind::Eq);     // =
                let assoc_ty: i64 = parse_type(parser);   // Type
                parser_expect(parser, TokenKind::Semi);   // ;
                // Store the associated type mapping
                vec_push(assoc_types, ast_assoc_type(assoc_name, assoc_ty));
            } else {
                // Check for async fn
                let is_async: i64 = 0;
                if parser_check(parser, TokenKind::KwAsync) {
                    parser_advance(parser);
                    is_async = 1;
                }
                let method: i64 = parse_fn(parser, is_async);
                vec_push(methods, method);
            }
        }
        parser_advance(parser);  // consume }

        return ast_impl_trait(first_name, type_name, methods, assoc_types);
    }

    // Regular impl block: impl TypeName { ... }
    let methods: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while true {
        if parser_check(parser, TokenKind::RBrace) {
            parser_advance(parser);
            return ast_impl(first_name, methods);
        }

        // Skip pub keyword if present
        parser_match(parser, TokenKind::KwPub);

        // Check for async fn
        let is_async: i64 = 0;
        if parser_check(parser, TokenKind::KwAsync) {
            parser_advance(parser);
            is_async = 1;
        }

        // Parse method (must be fn)
        if parser_check(parser, TokenKind::KwFn) {
            let method: i64 = parse_fn(parser, is_async);
            vec_push(methods, method);
        }
    }

    ast_impl(first_name, methods)
}

// Parse mod declaration: mod name;
fn parse_mod(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwMod);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Semi);
    ast_mod(name)
}

// Parse use statement: use name::item;
// Also supports:
//   use name::*;           (glob import)
//   use name::{A, B, C};   (nested imports)
fn parse_use(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwUse);
    let path: i64 = vec_new();
    let imports: i64 = vec_new();  // For nested imports {A, B}
    let is_glob: i64 = 0;

    // Parse first segment
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    vec_push(path, token_text(name_tok));

    // Parse remaining segments (::name or ::* or ::{...})
    while parser_match(parser, TokenKind::DoubleColon) {
        // Check for glob: use path::*
        if parser_match(parser, TokenKind::Star) {
            is_glob = 1;
            break;
        }

        // Check for nested imports: use path::{A, B, C}
        if parser_check(parser, TokenKind::LBrace) {
            parser_advance(parser);  // consume {
            while parser_check(parser, TokenKind::RBrace) == false {
                let import_tok: i64 = parser_expect(parser, TokenKind::Ident);
                vec_push(imports, token_text(import_tok));
                if parser_check(parser, TokenKind::Comma) {
                    parser_advance(parser);
                } else {
                    break;
                }
            }
            parser_expect(parser, TokenKind::RBrace);
            break;
        }

        // Regular segment
        let seg_tok: i64 = parser_expect(parser, TokenKind::Ident);
        vec_push(path, token_text(seg_tok));
    }

    parser_expect(parser, TokenKind::Semi);
    // Create use node with path, imports list (for nested), and glob flag
    ast_use_ext(path, imports, is_glob)
}

// Parse type alias: type Name = Type;
fn parse_type_alias(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwType);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::Eq);
    let target_type: i64 = parse_type(parser);
    parser_expect(parser, TokenKind::Semi);
    ast_type_alias(name, target_type)
}

// Parse actor definition
// actor Name { var field: Type = init, init(params) { }, receive MsgName(params) -> RetType { } }
fn parse_actor(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwActor);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();
    let init_fn: i64 = 0;

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in actor"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for init block
        if parser_check(parser, TokenKind::KwInit) {
            parser_advance(parser);
            // parse_params handles LParen and RParen internally
            let init_params: i64 = parse_params(parser);
            let body: i64 = parse_block(parser);
            let init_node: i64 = malloc(16);
            store_ptr(init_node, 0, init_params);
            store_ptr(init_node, 1, body);
            init_fn = init_node;
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            // Parse optional belief guard: @ confidence(id) < 0.5
            let belief_guard: i64 = 0;
            if parser_check(parser, TokenKind::At) {
                parser_advance(parser);  // consume '@'
                belief_guard = parse_belief_guard(parser);
            }
            let body: i64 = parse_block(parser);
            // Handler: msg_name(0), params(1), ret_type(2), body(3), belief_guard(4)
            let handler: i64 = malloc(40);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            store_ptr(handler, 4, belief_guard);  // 0 if no guard
            vec_push(handlers, handler);
        } else {
            parser_add_error(parser, string_from("Unexpected token in actor"));
            parser_advance(parser);
        }
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_actor(name, state_fields, handlers, init_fn)
}

// Parse specialist definition (like actor but with model config)
// specialist Name { model: "str", var field: Type = init, receive MsgName(params) -> RetType { } }
fn parse_specialist(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwSpecialist);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let config: i64 = vec_new();  // model config key-value pairs
    let state_fields: i64 = vec_new();
    let handlers: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in specialist"));
            return 0;
        }

        // Check for var (state variable)
        if parser_check(parser, TokenKind::KwVar) {
            parser_advance(parser);
            let field_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let field_name: i64 = token_text(field_tok);
            parser_expect(parser, TokenKind::Colon);
            let field_type: i64 = parse_type(parser);
            let init_val: i64 = 0;
            if parser_check(parser, TokenKind::Eq) {
                parser_advance(parser);
                init_val = parse_expr(parser);
            }
            let field: i64 = malloc(24);
            store_ptr(field, 0, field_name);
            store_ptr(field, 1, field_type);
            store_ptr(field, 2, init_val);
            vec_push(state_fields, field);
            parser_match(parser, TokenKind::Semi);
        } else {
        // Check for receive handler
        if parser_check(parser, TokenKind::KwReceive) {
            parser_advance(parser);
            let msg_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let msg_name: i64 = token_text(msg_tok);
            let params: i64 = vec_new();
            if parser_check(parser, TokenKind::LParen) {
                // parse_params handles LParen and RParen internally
                params = parse_params(parser);
            }
            let ret_type: i64 = string_from("void");
            if parser_check(parser, TokenKind::Arrow) {
                parser_advance(parser);
                ret_type = parse_type(parser);
            }
            // Parse optional belief guard: @ confidence(id) < 0.5
            let belief_guard: i64 = 0;
            if parser_check(parser, TokenKind::At) {
                parser_advance(parser);  // consume '@'
                belief_guard = parse_belief_guard(parser);
            }
            let body: i64 = parse_block(parser);
            // Handler: msg_name(0), params(1), ret_type(2), body(3), belief_guard(4)
            let handler: i64 = malloc(40);
            store_ptr(handler, 0, msg_name);
            store_ptr(handler, 1, params);
            store_ptr(handler, 2, ret_type);
            store_ptr(handler, 3, body);
            store_ptr(handler, 4, belief_guard);  // 0 if no guard
            vec_push(handlers, handler);
        } else {
            // Config property: name: value (string or number)
            let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
            let prop_name: i64 = token_text(prop_tok);
            parser_expect(parser, TokenKind::Colon);
            let prop_val: i64 = parse_expr(parser);
            let prop: i64 = malloc(16);
            store_ptr(prop, 0, prop_name);
            store_ptr(prop, 1, prop_val);
            vec_push(config, prop);
            parser_match(parser, TokenKind::Comma);
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_specialist(name, config, state_fields, handlers)
}

// Parse hive definition
// hive Name { specialists: [...], router: X, strategy: Y, mnemonic { ... } }
fn parse_hive(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwHive);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let specialists: i64 = vec_new();
    let routing: i64 = vec_new();
    let mnemonic: i64 = vec_new();  // mnemonic config blocks

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in hive"));
            return 0;
        }

        let prop_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let prop_name: i64 = token_text(prop_tok);

        // Check for mnemonic block (no colon, just brace)
        if string_eq(prop_name, string_from("mnemonic")) {
            if parser_check(parser, TokenKind::LBrace) {
                // Parse mnemonic sub-blocks: episodic, semantic, beliefs
                parser_advance(parser);
                while parser_check(parser, TokenKind::RBrace) == false {
                    let block_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    let block_name: i64 = token_text(block_tok);
                    parser_expect(parser, TokenKind::Colon);
                    let block_config: i64 = parse_config_block(parser);
                    let block: i64 = malloc(16);
                    store_ptr(block, 0, block_name);
                    store_ptr(block, 1, block_config);
                    vec_push(mnemonic, block);
                    parser_match(parser, TokenKind::Comma);
                }
                parser_expect(parser, TokenKind::RBrace);
            }
        } else {
            parser_expect(parser, TokenKind::Colon);

            // Parse array of specialist names or identifier value
            if parser_check(parser, TokenKind::LBracket) {
                parser_advance(parser);
                let items: i64 = vec_new();
                while parser_check(parser, TokenKind::RBracket) == false {
                    let item_tok: i64 = parser_expect(parser, TokenKind::Ident);
                    vec_push(items, token_text(item_tok));
                    parser_match(parser, TokenKind::Comma);
                }
                parser_expect(parser, TokenKind::RBracket);

                if string_eq(prop_name, string_from("specialists")) {
                    specialists = items;
                }
            } else {
                // Simple identifier value (router, strategy, etc.)
                if parser_check(parser, TokenKind::Ident) {
                    let val_tok: i64 = parser_advance(parser);
                    let val: i64 = token_text(val_tok);
                    // Store in routing for now (we can extend later)
                    vec_push(routing, prop_name);
                    vec_push(routing, val);
                }
            }
        }
        parser_match(parser, TokenKind::Comma);
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_hive_with_mnemonic(name, specialists, routing, mnemonic)
}

// Parse a block of key-value pairs { key: value, ... }
fn parse_config_block(parser: i64) -> i64 {
    let config: i64 = vec_new();
    parser_expect(parser, TokenKind::LBrace);

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            return config;
        }

        let key_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let key: i64 = token_text(key_tok);
        parser_expect(parser, TokenKind::Colon);

        // Parse value - can be string, array, or expression
        let val: i64 = 0;
        if parser_check(parser, TokenKind::LBracket) {
            // Array of strings
            parser_advance(parser);
            let items: i64 = vec_new();
            while parser_check(parser, TokenKind::RBracket) == false {
                if parser_check(parser, TokenKind::String) {
                    let s_tok: i64 = parser_advance(parser);
                    vec_push(items, token_text(s_tok));
                } else {
                    if parser_check(parser, TokenKind::Ident) {
                        let i_tok: i64 = parser_advance(parser);
                        vec_push(items, token_text(i_tok));
                    } else {
                        parser_advance(parser);
                    }
                }
                parser_match(parser, TokenKind::Comma);
            }
            parser_expect(parser, TokenKind::RBracket);
            val = items;
        } else {
            val = parse_expr(parser);
        }

        let pair: i64 = malloc(16);
        store_ptr(pair, 0, key);
        store_ptr(pair, 1, val);
        vec_push(config, pair);
        parser_match(parser, TokenKind::Comma);
    }

    parser_expect(parser, TokenKind::RBrace);
    config
}

// Parse anima definition (cognitive soul)
// anima Name { identity { ... } memory { ... } beliefs { ... } slm { ... } persistence { ... } }
fn parse_anima(parser: i64) -> i64 {
    parser_expect(parser, TokenKind::KwAnima);
    let name_tok: i64 = parser_expect(parser, TokenKind::Ident);
    let name: i64 = token_text(name_tok);
    parser_expect(parser, TokenKind::LBrace);

    let identity: i64 = vec_new();
    let memory: i64 = vec_new();
    let beliefs: i64 = vec_new();
    let slm: i64 = vec_new();
    let persistence: i64 = vec_new();

    while parser_check(parser, TokenKind::RBrace) == false {
        if parser_at_end(parser) {
            parser_add_error(parser, string_from("Unexpected end of file in anima"));
            return 0;
        }

        let block_tok: i64 = parser_expect(parser, TokenKind::Ident);
        let block_name: i64 = token_text(block_tok);

        if string_eq(block_name, string_from("identity")) {
            identity = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("memory")) {
            memory = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("beliefs")) {
            beliefs = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("slm")) {
            slm = parse_config_block(parser);
        } else {
        if string_eq(block_name, string_from("persistence")) {
            persistence = parse_config_block(parser);
        } else {
            parser_add_error(parser, string_concat(string_from("Unknown anima block: "), block_name));
            // Skip unknown block
            if parser_check(parser, TokenKind::LBrace) {
                parser_advance(parser);
                let depth: i64 = 1;
                while depth > 0 {
                    if parser_check(parser, TokenKind::LBrace) {
                        depth = depth + 1;
                    }
                    if parser_check(parser, TokenKind::RBrace) {
                        depth = depth - 1;
                    }
                    parser_advance(parser);
                }
            }
        }
        }
        }
        }
        }
    }

    parser_expect(parser, TokenKind::RBrace);
    ast_anima(name, identity, memory, beliefs, slm, persistence)
}

// Skip any attributes (#[...]) before an item
fn skip_attributes(parser: i64) -> i64 {
    while parser_check(parser, TokenKind::Hash) {
        parser_advance(parser);  // consume #
        if parser_check(parser, TokenKind::LBracket) {
            parser_advance(parser);  // consume [
            // Skip tokens until we find the closing ]
            let depth: i64 = 1;
            while depth > 0 {
                if parser_at_end(parser) {
                    return 0;
                }
                if parser_check(parser, TokenKind::LBracket) {
                    depth = depth + 1;
                }
                if parser_check(parser, TokenKind::RBracket) {
                    depth = depth - 1;
                    if depth == 0 {
                        parser_advance(parser);  // consume final ]
                        return skip_attributes(parser);  // check for more attributes
                    }
                }
                parser_advance(parser);
            }
        }
    }
    0
}

// Parse a single item (fn, enum, or struct)
fn parse_item(parser: i64) -> i64 {
    // Skip any attributes (#[test], #[no_learn], etc.)
    skip_attributes(parser);

    // Skip pub keyword if present
    parser_match(parser, TokenKind::KwPub);

    // Skip attributes again in case they come after pub
    skip_attributes(parser);

    // Check for async fn
    if parser_check(parser, TokenKind::KwAsync) {
        parser_advance(parser);
        if parser_check(parser, TokenKind::KwFn) {
            return parse_fn(parser, 1);  // async fn
        }
        // async without fn - error
        parser_add_error(parser, string_from("expected 'fn' after 'async'"));
        return 0;
    }

    if parser_check(parser, TokenKind::KwFn) {
        return parse_fn(parser, 0);  // regular fn
    }
    if parser_check(parser, TokenKind::KwEnum) {
        return parse_enum(parser);
    }
    if parser_check(parser, TokenKind::KwStruct) {
        return parse_struct(parser);
    }
    if parser_check(parser, TokenKind::KwImpl) {
        return parse_impl(parser);
    }
    if parser_check(parser, TokenKind::KwTrait) {
        return parse_trait(parser);
    }
    if parser_check(parser, TokenKind::KwMod) {
        return parse_mod(parser);
    }
    if parser_check(parser, TokenKind::KwUse) {
        return parse_use(parser);
    }
    if parser_check(parser, TokenKind::KwType) {
        return parse_type_alias(parser);
    }
    if parser_check(parser, TokenKind::KwActor) {
        return parse_actor(parser);
    }
    if parser_check(parser, TokenKind::KwSpecialist) {
        return parse_specialist(parser);
    }
    if parser_check(parser, TokenKind::KwHive) {
        return parse_hive(parser);
    }
    if parser_check(parser, TokenKind::KwAnima) {
        return parse_anima(parser);
    }

    // Unknown item
    0
}

// ========================================
// Belief Guard Parsing
// ========================================

// Parse belief guard: confidence(id) < 0.5 && confidence(id).derivative < -0.1
fn parse_belief_guard(parser: i64) -> i64 {
    return parse_belief_or(parser);
}

// Parse OR expression in belief guards
fn parse_belief_or(parser: i64) -> i64 {
    let left: i64 = parse_belief_and(parser);

    while parser_check(parser, TokenKind::PipePipe) {
        parser_advance(parser);
        let right: i64 = parse_belief_and(parser);
        let node: i64 = malloc(24);
        store_i64(node, 0, EXPR_BELIEF_OR());
        store_ptr(node, 1, left);
        store_ptr(node, 2, right);
        left = node;
    }

    return left;
}

// Parse AND expression in belief guards
fn parse_belief_and(parser: i64) -> i64 {
    let left: i64 = parse_belief_comparison(parser);

    while parser_check(parser, TokenKind::AmpAmp) {
        parser_advance(parser);
        let right: i64 = parse_belief_comparison(parser);
        let node: i64 = malloc(24);
        store_i64(node, 0, EXPR_BELIEF_AND());
        store_ptr(node, 1, left);
        store_ptr(node, 2, right);
        left = node;
    }

    return left;
}

// Parse comparison in belief guards
fn parse_belief_comparison(parser: i64) -> i64 {
    let left: i64 = parse_belief_primary(parser);

    // Check for comparison operator
    if parser_check(parser, TokenKind::Lt) {
        let op: i64 = OP_LT();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }
    if parser_check(parser, TokenKind::Le) {
        let op: i64 = OP_LE();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }
    if parser_check(parser, TokenKind::Gt) {
        let op: i64 = OP_GT();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }
    if parser_check(parser, TokenKind::Ge) {
        let op: i64 = OP_GE();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }
    if parser_check(parser, TokenKind::EqEq) {
        let op: i64 = OP_EQ();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }
    if parser_check(parser, TokenKind::Ne) {
        let op: i64 = OP_NE();
        parser_advance(parser);
        let right: i64 = parse_expr(parser);
        let node: i64 = malloc(32);
        store_i64(node, 0, EXPR_BELIEF_GUARD());
        store_ptr(node, 1, left);
        store_i64(node, 2, op);
        store_ptr(node, 3, right);
        return node;
    }

    return left;
}

// Parse primary belief expression: confidence(id) or confidence(id).derivative
fn parse_belief_primary(parser: i64) -> i64 {
    // confidence(belief_id)
    if parser_check(parser, TokenKind::KwConfidence) {
        parser_advance(parser);
        parser_expect(parser, TokenKind::LParen);
        let belief_id: i64 = parse_expr(parser);
        parser_expect(parser, TokenKind::RParen);

        let node: i64 = malloc(16);
        store_i64(node, 0, EXPR_CONFIDENCE());
        store_ptr(node, 1, belief_id);

        // Check for .derivative
        if parser_check(parser, TokenKind::Dot) {
            parser_advance(parser);
            if parser_check(parser, TokenKind::KwDerivative) {
                parser_advance(parser);
                let der_node: i64 = malloc(16);
                store_i64(der_node, 0, EXPR_DERIVATIVE());
                store_ptr(der_node, 1, node);
                return der_node;
            } else {
                parser_add_error(parser, string_from("Expected 'derivative' after '.'"));
                return node;
            }
        }

        return node;
    }

    // Parenthesized expression
    if parser_check(parser, TokenKind::LParen) {
        parser_advance(parser);
        let expr: i64 = parse_belief_guard(parser);
        parser_expect(parser, TokenKind::RParen);
        return expr;
    }

    // Negation: !guard
    if parser_check(parser, TokenKind::Bang) {
        parser_advance(parser);
        let inner: i64 = parse_belief_primary(parser);
        // Represent as BELIEF_AND with negation (we'll use unary not in codegen)
        let node: i64 = malloc(16);
        store_i64(node, 0, EXPR_UNARY());
        store_i64(node, 1, OP_NOT());
        store_ptr(node, 2, inner);
        return node;
    }

    parser_add_error(parser, string_from("Expected belief guard expression (confidence(...))"));
    return 0;
}

// Parse result: items(0), error_count(1)
fn parse_result_new(items: i64, error_count: i64) -> i64 {
    let result: i64 = malloc(16);
    store_ptr(result, 0, items);
    store_i64(result, 1, error_count);
    result
}

fn parse_result_items(result: i64) -> i64 {
    load_ptr(result, 0)
}

fn parse_result_errors(result: i64) -> i64 {
    load_i64(result, 1)
}

// Parse entire program
fn parse_program(tokens: i64) -> i64 {
    let parser: i64 = parser_new(tokens);
    let items: i64 = vec_new();

    while true {
        if parser_at_end(parser) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        // Skip EOF tokens
        if parser_check(parser, TokenKind::Eof) {
            let errors: i64 = parser_error_count(parser);
            return parse_result_new(items, errors);
        }

        let item: i64 = parse_item(parser);
        if item != 0 {
            vec_push(items, item);
        } else {
            // Unknown item - skip token and report error
            parser_add_error(parser, string_from("unexpected token at top level"));
            parser_advance(parser);
        }
    }

    let errors: i64 = parser_error_count(parser);
    parse_result_new(items, errors)
}
