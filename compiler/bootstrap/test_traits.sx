// Test traits and impl blocks

trait Addable {
    fn add_val(&self, other: i64) -> i64;
}

struct Number {
    value: i64,
}

impl Addable for Number {
    fn add_val(&self, other: i64) -> i64 {
        self.value + other
    }
}

fn test_trait_method() -> i64 {
    let n = Number { value: 10 };
    n.add_val(5)  // Should be 15
}

// Test impl block without trait (inherent methods)
struct Counter {
    count: i64,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }

    fn increment(&self) -> i64 {
        self.count + 1
    }

    fn get(&self) -> i64 {
        self.count
    }
}

fn test_inherent_methods() -> i64 {
    let c = Counter { count: 10 };
    c.increment()  // Should be 11
}

fn test_static_method() -> i64 {
    let c: Counter = Counter::new();
    c.get()  // Should be 0
}

fn main() -> i64 {
    var passed = 0;

    print("Testing trait method...\n");
    let r1 = test_trait_method();
    print("Result: ");
    print_i64(r1);
    print("\n");
    if r1 == 15 {
        print("trait_method: PASS\n");
        passed = passed + 1;
    } else {
        print("trait_method: FAIL\n");
    }

    print("\nTesting inherent methods...\n");
    let r2 = test_inherent_methods();
    print("Result: ");
    print_i64(r2);
    print("\n");
    if r2 == 11 {
        print("inherent_method: PASS\n");
        passed = passed + 1;
    } else {
        print("inherent_method: FAIL\n");
    }

    print("\nTesting static method...\n");
    let r3 = test_static_method();
    print("Result: ");
    print_i64(r3);
    print("\n");
    if r3 == 0 {
        print("static_method: PASS\n");
        passed = passed + 1;
    } else {
        print("static_method: FAIL\n");
    }

    print("\n=== Summary ===\n");
    print("Passed: ");
    print_i64(passed);
    print(" / 3\n");

    passed
}
