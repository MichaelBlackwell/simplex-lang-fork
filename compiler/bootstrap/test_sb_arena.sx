// Test StringBuilder and Arena Intrinsics

// ============ STRINGBUILDER CREATION ============

// Test creating a new StringBuilder
fn test_sb_new() -> i64 {
    let sb = sb_new();
    if sb != 0 {
        sb_free(sb);
        1
    } else {
        0
    }
}

// Test creating StringBuilder with capacity
fn test_sb_new_cap() -> i64 {
    let sb = sb_new_cap(4096);
    if sb != 0 {
        sb_free(sb);
        1
    } else {
        0
    }
}

// ============ STRINGBUILDER APPEND ============

// Test appending a string
fn test_sb_append() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Hello");
    let result = sb_to_string(sb);
    let len = string_len(result);
    sb_free(sb);

    if len == 5 {
        1
    } else {
        0
    }
}

// Test appending multiple strings
fn test_sb_append_multiple() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Hello");
    sb_append(sb, " ");
    sb_append(sb, "World");
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "Hello World") == 1 {
        1
    } else {
        0
    }
}

// Test appending a character
fn test_sb_append_char() -> i64 {
    let sb = sb_new();
    sb_append_char(sb, 65);  // 'A'
    sb_append_char(sb, 66);  // 'B'
    sb_append_char(sb, 67);  // 'C'
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "ABC") == 1 {
        1
    } else {
        0
    }
}

// Test appending an integer
fn test_sb_append_i64() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Value: ");
    sb_append_i64(sb, 42);
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "Value: 42") == 1 {
        1
    } else {
        0
    }
}

// Test appending negative integer
fn test_sb_append_negative() -> i64 {
    let sb = sb_new();
    sb_append_i64(sb, -123);
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "-123") == 1 {
        1
    } else {
        0
    }
}

// ============ STRINGBUILDER LENGTH ============

// Test sb_len on empty
fn test_sb_len_empty() -> i64 {
    let sb = sb_new();
    let len = sb_len(sb);
    sb_free(sb);

    if len == 0 {
        1
    } else {
        0
    }
}

// Test sb_len after appends
fn test_sb_len_after_append() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Hello");
    let len1 = sb_len(sb);
    sb_append(sb, "World");
    let len2 = sb_len(sb);
    sb_free(sb);

    if len1 == 5 && len2 == 10 {
        1
    } else {
        0
    }
}

// ============ STRINGBUILDER CLEAR ============

// Test sb_clear
fn test_sb_clear() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Hello World");
    sb_clear(sb);
    let len = sb_len(sb);
    sb_free(sb);

    if len == 0 {
        1
    } else {
        0
    }
}

// Test sb_clear then reuse
fn test_sb_clear_reuse() -> i64 {
    let sb = sb_new();
    sb_append(sb, "First");
    sb_clear(sb);
    sb_append(sb, "Second");
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "Second") == 1 {
        1
    } else {
        0
    }
}

// ============ STRINGBUILDER BUILD ============

// Test building complex string
fn test_sb_build_complex() -> i64 {
    let sb = sb_new();
    sb_append(sb, "Name: ");
    sb_append(sb, "Test");
    sb_append(sb, ", Age: ");
    sb_append_i64(sb, 25);
    sb_append(sb, ", Score: ");
    sb_append_i64(sb, 100);
    let result = sb_to_string(sb);
    sb_free(sb);

    if string_eq(result, "Name: Test, Age: 25, Score: 100") == 1 {
        1
    } else {
        0
    }
}

// Test building in loop
fn test_sb_build_loop() -> i64 {
    let sb = sb_new();
    for i in 0..5 {
        sb_append_i64(sb, i);
    }
    let result = sb_to_string(sb);
    sb_free(sb);

    // "01234"
    if string_eq(result, "01234") == 1 {
        1
    } else {
        0
    }
}

// ============ ARENA CREATION ============

// Test creating an arena
fn test_arena_create() -> i64 {
    let arena = arena_create(4096);
    if arena != 0 {
        arena_free(arena);
        1
    } else {
        0
    }
}

// Test creating arena with different sizes
fn test_arena_create_sizes() -> i64 {
    let a1 = arena_create(1024);
    let a2 = arena_create(8192);
    let a3 = arena_create(65536);

    let result = a1 != 0 && a2 != 0 && a3 != 0;

    arena_free(a1);
    arena_free(a2);
    arena_free(a3);

    if result {
        1
    } else {
        0
    }
}

// ============ ARENA ALLOCATION ============

// Test arena allocation
fn test_arena_alloc() -> i64 {
    let arena = arena_create(4096);
    let ptr = arena_alloc(arena, 64);

    let result = ptr != 0;
    arena_free(arena);

    if result {
        1
    } else {
        0
    }
}

// Test multiple arena allocations
fn test_arena_alloc_multiple() -> i64 {
    let arena = arena_create(4096);

    let p1 = arena_alloc(arena, 100);
    let p2 = arena_alloc(arena, 200);
    let p3 = arena_alloc(arena, 300);

    // All should be valid and different
    let result = p1 != 0 && p2 != 0 && p3 != 0 && p1 != p2 && p2 != p3;

    arena_free(arena);

    if result {
        1
    } else {
        0
    }
}

// Test arena_used tracking
fn test_arena_used() -> i64 {
    let arena = arena_create(4096);

    let used_before = arena_used(arena);
    arena_alloc(arena, 100);
    let used_after = arena_used(arena);

    arena_free(arena);

    // used should increase (with alignment, might be more than 100)
    if used_before == 0 && used_after >= 100 {
        1
    } else {
        0
    }
}

// Test arena allocation fills up
fn test_arena_used_accumulates() -> i64 {
    let arena = arena_create(4096);

    arena_alloc(arena, 100);
    let used1 = arena_used(arena);

    arena_alloc(arena, 200);
    let used2 = arena_used(arena);

    arena_alloc(arena, 300);
    let used3 = arena_used(arena);

    arena_free(arena);

    // Each allocation should increase used amount
    if used1 < used2 && used2 < used3 {
        1
    } else {
        0
    }
}

// ============ ARENA RESET ============

// Test arena reset
fn test_arena_reset() -> i64 {
    let arena = arena_create(4096);

    arena_alloc(arena, 1000);
    arena_alloc(arena, 1000);
    let used_before = arena_used(arena);

    arena_reset(arena);
    let used_after = arena_used(arena);

    arena_free(arena);

    if used_before > 0 && used_after == 0 {
        1
    } else {
        0
    }
}

// Test arena reset and reuse
fn test_arena_reset_reuse() -> i64 {
    let arena = arena_create(4096);

    // First batch
    arena_alloc(arena, 500);
    arena_alloc(arena, 500);

    arena_reset(arena);

    // Second batch (should succeed since we reset)
    let p1 = arena_alloc(arena, 500);
    let p2 = arena_alloc(arena, 500);

    arena_free(arena);

    if p1 != 0 && p2 != 0 {
        1
    } else {
        0
    }
}

// Test arena overflow returns null
fn test_arena_overflow() -> i64 {
    let arena = arena_create(100);  // Small arena

    let p1 = arena_alloc(arena, 50);   // Should succeed
    let p2 = arena_alloc(arena, 200);  // Should fail (overflow)

    arena_free(arena);

    if p1 != 0 && p2 == 0 {
        1
    } else {
        0
    }
}

fn main() -> i64 {
    var passed = 0;
    var total = 22;

    print("=== StringBuilder and Arena Tests ===\n\n");

    // StringBuilder creation
    print("Testing sb_new...\n");
    if test_sb_new() == 1 {
        print("sb_new: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_new: FAIL\n");
    }

    print("\nTesting sb_new_cap...\n");
    if test_sb_new_cap() == 1 {
        print("sb_new_cap: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_new_cap: FAIL\n");
    }

    // StringBuilder append
    print("\nTesting sb_append...\n");
    if test_sb_append() == 1 {
        print("sb_append: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_append: FAIL\n");
    }

    print("\nTesting sb_append_multiple...\n");
    if test_sb_append_multiple() == 1 {
        print("sb_append_multiple: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_append_multiple: FAIL\n");
    }

    print("\nTesting sb_append_char...\n");
    if test_sb_append_char() == 1 {
        print("sb_append_char: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_append_char: FAIL\n");
    }

    print("\nTesting sb_append_i64...\n");
    if test_sb_append_i64() == 1 {
        print("sb_append_i64: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_append_i64: FAIL\n");
    }

    print("\nTesting sb_append_negative...\n");
    if test_sb_append_negative() == 1 {
        print("sb_append_negative: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_append_negative: FAIL\n");
    }

    // StringBuilder length
    print("\nTesting sb_len_empty...\n");
    if test_sb_len_empty() == 1 {
        print("sb_len_empty: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_len_empty: FAIL\n");
    }

    print("\nTesting sb_len_after_append...\n");
    if test_sb_len_after_append() == 1 {
        print("sb_len_after_append: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_len_after_append: FAIL\n");
    }

    // StringBuilder clear
    print("\nTesting sb_clear...\n");
    if test_sb_clear() == 1 {
        print("sb_clear: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_clear: FAIL\n");
    }

    print("\nTesting sb_clear_reuse...\n");
    if test_sb_clear_reuse() == 1 {
        print("sb_clear_reuse: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_clear_reuse: FAIL\n");
    }

    // StringBuilder build
    print("\nTesting sb_build_complex...\n");
    if test_sb_build_complex() == 1 {
        print("sb_build_complex: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_build_complex: FAIL\n");
    }

    print("\nTesting sb_build_loop...\n");
    if test_sb_build_loop() == 1 {
        print("sb_build_loop: PASS\n");
        passed = passed + 1;
    } else {
        print("sb_build_loop: FAIL\n");
    }

    // Arena creation
    print("\nTesting arena_create...\n");
    if test_arena_create() == 1 {
        print("arena_create: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_create: FAIL\n");
    }

    print("\nTesting arena_create_sizes...\n");
    if test_arena_create_sizes() == 1 {
        print("arena_create_sizes: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_create_sizes: FAIL\n");
    }

    // Arena allocation
    print("\nTesting arena_alloc...\n");
    if test_arena_alloc() == 1 {
        print("arena_alloc: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_alloc: FAIL\n");
    }

    print("\nTesting arena_alloc_multiple...\n");
    if test_arena_alloc_multiple() == 1 {
        print("arena_alloc_multiple: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_alloc_multiple: FAIL\n");
    }

    print("\nTesting arena_used...\n");
    if test_arena_used() == 1 {
        print("arena_used: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_used: FAIL\n");
    }

    print("\nTesting arena_used_accumulates...\n");
    if test_arena_used_accumulates() == 1 {
        print("arena_used_accumulates: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_used_accumulates: FAIL\n");
    }

    // Arena reset
    print("\nTesting arena_reset...\n");
    if test_arena_reset() == 1 {
        print("arena_reset: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_reset: FAIL\n");
    }

    print("\nTesting arena_reset_reuse...\n");
    if test_arena_reset_reuse() == 1 {
        print("arena_reset_reuse: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_reset_reuse: FAIL\n");
    }

    print("\nTesting arena_overflow...\n");
    if test_arena_overflow() == 1 {
        print("arena_overflow: PASS\n");
        passed = passed + 1;
    } else {
        print("arena_overflow: FAIL\n");
    }

    print("\n=== Summary ===\n");
    print("Passed: ");
    print_i64(passed);
    print(" / ");
    print_i64(total);
    print("\n");

    passed
}
