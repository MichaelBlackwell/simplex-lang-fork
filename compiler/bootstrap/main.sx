// Minimal Simplex Compiler - Main Entry Point
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics

// External runtime functions we need
// Note: These are provided by the simplex runtime

fn main() {
    // Get command line args
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 2 {
        println("Usage: sxc <source.sx>");
        return;
    }

    // Get source file path
    let path: i64 = vec_get(args, 1);

    // Read source file
    let source: i64 = read_file(path);
    if source == 0 {
        println("Error: Could not read file");
        return;
    }

    // Tokenize
    let tokens: i64 = tokenize(source);

    // Parse
    let items: i64 = parse_program(tokens);

    // Extract module name from path for unique string prefixes
    let module_name: i64 = get_module_name(path);

    // Generate code with module name
    let output: i64 = gen_program_with_module(items, module_name);

    // Write output
    let out_path: i64 = string_replace_ext(path, ".ll");
    write_file(out_path, output);

    println("Compilation successful.");
    0
}

// Helper to replace file extension
fn string_replace_ext(path: i64, new_ext: i64) -> i64 {
    // Find last dot
    let len: i64 = string_len(path);
    let i: i64 = len - 1;
    while i >= 0 {
        let c: i64 = string_char_at(path, i);
        if c == 46 {
            // Found dot
            let base: i64 = string_slice(path, 0, i);
            return string_concat(base, new_ext);
        }
        i = i - 1;
    }
    // No dot found, just append
    string_concat(path, new_ext)
}

// Extract module name from path (basename without extension)
// e.g., "lexer.sx" -> "lexer", "foo/bar/parser.sx" -> "parser"
fn get_module_name(path: i64) -> i64 {
    let len: i64 = string_len(path);

    // Find last slash to get basename
    let start: i64 = 0;
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(path, i);
        if c == 47 {
            // ASCII for '/'
            start = i + 1;
        }
        i = i + 1;
    }

    // Find last dot to strip extension
    let end: i64 = len;
    i = len - 1;
    while i >= start {
        let c: i64 = string_char_at(path, i);
        if c == 46 {
            // ASCII for '.'
            end = i;
            i = 0;  // Break
        }
        i = i - 1;
    }

    string_slice(path, start, end)
}
