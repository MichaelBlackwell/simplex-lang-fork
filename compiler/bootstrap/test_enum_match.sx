// Test Enums and Match Expressions

// Simple enum with unit variants
enum Color {
    Red,
    Green,
    Blue,
}

// Enum with associated data
enum Option {
    Some(i64),
    None,
}

// Result-like enum with two payload variants
enum Result {
    Ok(i64),
    Err(i64),
}

// Test creating simple enum variants
fn test_simple_enum() -> i64 {
    let red = Color::Red;
    let green = Color::Green;
    let blue = Color::Blue;

    // All should be valid pointers (non-zero)
    if red != 0 && green != 0 && blue != 0 {
        1
    } else {
        0
    }
}

// Test match on simple enum
fn test_match_simple() -> i64 {
    let color = Color::Green;

    let result = match color {
        Color::Red => 1,
        Color::Green => 2,
        Color::Blue => 3,
    };

    if result == 2 {
        1
    } else {
        0
    }
}

// Test match with wildcard
fn test_match_wildcard() -> i64 {
    let color = Color::Blue;

    let result = match color {
        Color::Red => 10,
        _ => 99,
    };

    if result == 99 {
        1
    } else {
        0
    }
}

// Test Option enum with Some
fn test_option_some() -> i64 {
    let opt = Some(42);

    if opt != 0 {
        1
    } else {
        0
    }
}

// Test Option enum with None
fn test_option_none() -> i64 {
    let opt: i64 = Option::None;

    // None is still allocated (non-zero pointer)
    if opt != 0 {
        1
    } else {
        0
    }
}

// Test match with binding extraction
fn test_match_binding() -> i64 {
    let opt = Some(42);

    let result = match opt {
        Some(x) => x,
        None => 0,
    };

    if result == 42 {
        1
    } else {
        0
    }
}

// Test match extracts correct value
fn test_match_extract_value() -> i64 {
    let opt = Some(123);

    let value = match opt {
        Some(v) => v + 1,
        None => 0,
    };

    if value == 124 {
        1
    } else {
        0
    }
}

// Test Result Ok variant
fn test_result_ok() -> i64 {
    let res = Ok(100);

    let value = match res {
        Ok(v) => v,
        Err(e) => e * -1,
    };

    if value == 100 {
        1
    } else {
        0
    }
}

// Test Result Err variant
fn test_result_err() -> i64 {
    let res = Err(500);

    let value = match res {
        Ok(v) => v,
        Err(e) => e,
    };

    if value == 500 {
        1
    } else {
        0
    }
}

// Test match with variable binding pattern
fn test_match_variable_binding() -> i64 {
    let x = 42;

    let result = match x {
        n => n * 2,
    };

    if result == 84 {
        1
    } else {
        0
    }
}

// Test multiple matches in sequence
fn test_multiple_matches() -> i64 {
    let a = Some(10);
    let b = Some(20);
    let c = Option::None;

    let va = match a {
        Some(x) => x,
        None => 0,
    };

    let vb = match b {
        Some(x) => x,
        None => 0,
    };

    let vc = match c {
        Some(x) => x,
        None => -1,
    };

    if va == 10 && vb == 20 && vc == -1 {
        1
    } else {
        0
    }
}

// Test match with computation in arm
fn test_match_computation() -> i64 {
    let opt = Some(5);

    let result = match opt {
        Some(x) => x * x + x,
        None => 0,
    };

    // 5*5 + 5 = 30
    if result == 30 {
        1
    } else {
        0
    }
}

fn main() -> i64 {
    var passed = 0;
    var total = 12;

    print("=== Enum and Match Expression Tests ===\n\n");

    print("Testing simple enum creation...\n");
    if test_simple_enum() == 1 {
        print("simple_enum: PASS\n");
        passed = passed + 1;
    } else {
        print("simple_enum: FAIL\n");
    }

    print("\nTesting match on simple enum...\n");
    if test_match_simple() == 1 {
        print("match_simple: PASS\n");
        passed = passed + 1;
    } else {
        print("match_simple: FAIL\n");
    }

    print("\nTesting match with wildcard...\n");
    if test_match_wildcard() == 1 {
        print("match_wildcard: PASS\n");
        passed = passed + 1;
    } else {
        print("match_wildcard: FAIL\n");
    }

    print("\nTesting Option Some...\n");
    if test_option_some() == 1 {
        print("option_some: PASS\n");
        passed = passed + 1;
    } else {
        print("option_some: FAIL\n");
    }

    print("\nTesting Option None...\n");
    if test_option_none() == 1 {
        print("option_none: PASS\n");
        passed = passed + 1;
    } else {
        print("option_none: FAIL\n");
    }

    print("\nTesting match with binding...\n");
    if test_match_binding() == 1 {
        print("match_binding: PASS\n");
        passed = passed + 1;
    } else {
        print("match_binding: FAIL\n");
    }

    print("\nTesting match extract value...\n");
    if test_match_extract_value() == 1 {
        print("match_extract_value: PASS\n");
        passed = passed + 1;
    } else {
        print("match_extract_value: FAIL\n");
    }

    print("\nTesting Result Ok...\n");
    if test_result_ok() == 1 {
        print("result_ok: PASS\n");
        passed = passed + 1;
    } else {
        print("result_ok: FAIL\n");
    }

    print("\nTesting Result Err...\n");
    if test_result_err() == 1 {
        print("result_err: PASS\n");
        passed = passed + 1;
    } else {
        print("result_err: FAIL\n");
    }

    print("\nTesting match variable binding...\n");
    if test_match_variable_binding() == 1 {
        print("match_variable_binding: PASS\n");
        passed = passed + 1;
    } else {
        print("match_variable_binding: FAIL\n");
    }

    print("\nTesting multiple matches...\n");
    if test_multiple_matches() == 1 {
        print("multiple_matches: PASS\n");
        passed = passed + 1;
    } else {
        print("multiple_matches: FAIL\n");
    }

    print("\nTesting match computation...\n");
    if test_match_computation() == 1 {
        print("match_computation: PASS\n");
        passed = passed + 1;
    } else {
        print("match_computation: FAIL\n");
    }

    print("\n=== Summary ===\n");
    print("Passed: ");
    print_i64(passed);
    print(" / ");
    print_i64(total);
    print("\n");

    passed
}
