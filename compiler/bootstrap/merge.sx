// LLVM IR Merge Tool - Optimized version
// Uses HashMaps for O(1) duplicate detection
// Uses StringBuilder for efficient string building

// Merge state with HashMaps for fast lookups
fn merge_state_new() -> i64 {
    // Allocate: decl_set(0), func_map(1), strings(2), string_counter(3), decl_order(4), func_order(5)
    let state: i64 = malloc(48);
    store_ptr(state, 0, hashset_new());   // decl_set - for O(1) duplicate check
    store_ptr(state, 1, hashmap_new());   // func_map - name -> body
    store_ptr(state, 2, vec_new());       // strings - (old_label, new_label, content)
    store_i64(state, 3, 0);               // string_counter
    store_ptr(state, 4, vec_new());       // decl_order - preserves insertion order
    store_ptr(state, 5, vec_new());       // func_order - preserves insertion order
    state
}

fn merge_decl_set(state: i64) -> i64 {
    load_ptr(state, 0)
}

fn merge_func_map(state: i64) -> i64 {
    load_ptr(state, 1)
}

fn merge_strings(state: i64) -> i64 {
    load_ptr(state, 2)
}

fn merge_decl_order(state: i64) -> i64 {
    load_ptr(state, 4)
}

fn merge_func_order(state: i64) -> i64 {
    load_ptr(state, 5)
}

fn merge_next_string_id(state: i64) -> i64 {
    let id: i64 = load_i64(state, 3);
    store_i64(state, 3, id + 1);
    id
}

// O(1) declaration check and add using HashSet
fn add_declaration(state: i64, decl: i64) -> i64 {
    let decl_set: i64 = merge_decl_set(state);
    if hashset_contains(decl_set, decl) == false {
        hashset_insert(decl_set, decl);
        vec_push(merge_decl_order(state), decl);
    }
    0
}

// O(1) function check and add using HashMap
fn add_function(state: i64, name: i64, body: i64) -> i64 {
    let func_map: i64 = merge_func_map(state);
    if hashmap_contains(func_map, name) == false {
        hashmap_insert(func_map, name, body);
        vec_push(merge_func_order(state), name);
    }
    0
}

// Add string constant with new unified label
fn add_string_constant(state: i64, old_label: i64, content: i64) -> i64 {
    let id: i64 = merge_next_string_id(state);
    let new_label: i64 = string_concat("@.str.", int_to_string(id));
    let strings: i64 = merge_strings(state);
    let triple: i64 = malloc(24);
    store_ptr(triple, 0, old_label);
    store_ptr(triple, 1, new_label);
    store_ptr(triple, 2, content);
    vec_push(strings, triple);
    0
}

// Fast string starts_with using intrinsic
fn starts_with(s: i64, prefix: i64) -> bool {
    string_starts_with(s, prefix)
}

// Find character using string_find
fn find_char(s: i64, c: i64) -> i64 {
    let needle: i64 = string_from_char(c);
    string_find(s, needle, 0)
}

// Extract function name from define line
fn extract_function_name(line: i64) -> i64 {
    let at_pos: i64 = find_char(line, 64);  // '@'
    if at_pos < 0 {
        return "";
    }

    let after_at: i64 = string_slice(line, at_pos + 1, string_len(line));
    if string_len(after_at) == 0 {
        return "";
    }

    if string_char_at(after_at, 0) == 34 {
        // Quoted: find closing quote
        let rest: i64 = string_slice(after_at, 1, string_len(after_at));
        let end: i64 = find_char(rest, 34);
        if end >= 0 {
            return string_slice(rest, 0, end);
        }
    } else {
        // Unquoted: find (
        let end: i64 = find_char(after_at, 40);  // '('
        if end >= 0 {
            return string_slice(after_at, 0, end);
        }
    }
    ""
}

// Process file using StringBuilder for body accumulation
fn process_file(state: i64, filename: i64) -> i64 {
    let content: i64 = read_file(filename);
    if content == 0 {
        print("Error: Could not read file: ");
        println(filename);
        return 1;
    }

    let lines: i64 = string_lines(content);
    let n: i64 = vec_len(lines);
    var i: i64 = 0;
    var in_function: i64 = 0;
    var current_name: i64 = "";
    let body_builder: i64 = sb_new();

    while i < n {
        let line: i64 = vec_get(lines, i);

        // Check for string constant: @.str.
        if starts_with(line, "@.str.") {
            let eq_pos: i64 = find_char(line, 61);  // '='
            if eq_pos > 0 {
                let old_label: i64 = string_trim(string_slice(line, 0, eq_pos - 1));
                let content_part: i64 = string_trim(string_slice(line, eq_pos + 2, string_len(line)));
                add_string_constant(state, old_label, content_part);
            }
            i = i + 1;
            continue;
        }

        // Check for function definition
        if starts_with(line, "define ") {
            current_name = extract_function_name(line);
            sb_clear(body_builder);
            sb_append(body_builder, line);
            sb_append_char(body_builder, 10);  // newline
            in_function = 1;
            i = i + 1;
            continue;
        }

        // If in function, accumulate lines
        if in_function != 0 {
            sb_append(body_builder, line);
            sb_append_char(body_builder, 10);

            // Check for end of function
            let trimmed: i64 = string_trim(line);
            if string_eq(trimmed, "}") {
                let full_body: i64 = sb_to_string(body_builder);
                add_function(state, current_name, full_body);
                in_function = 0;
            }
            i = i + 1;
            continue;
        }

        // Check for declaration
        if starts_with(line, "declare ") {
            let decl: i64 = string_trim(line);
            add_declaration(state, decl);
        }

        i = i + 1;
    }

    sb_free(body_builder);
    0
}

// Build string replacement map for efficient batch replacement
fn build_replacement_map(strings: i64) -> i64 {
    let map: i64 = hashmap_new();
    let n: i64 = vec_len(strings);
    var i: i64 = 0;
    while i < n {
        let triple: i64 = vec_get(strings, i);
        let old_label: i64 = load_ptr(triple, 0);
        let new_label: i64 = load_ptr(triple, 1);
        hashmap_insert(map, old_label, new_label);
        i = i + 1;
    }
    map
}

// Replace all string labels in a function body
// Uses a single-pass approach with StringBuilder
fn replace_labels_in_body(body: i64, replacement_map: i64) -> i64 {
    // Simple approach: for each old label, replace with new
    // This is still O(n*m) but much faster with string_replace intrinsic
    let result: i64 = body;
    let keys: i64 = hashmap_keys(replacement_map);
    let n: i64 = vec_len(keys);

    // Sort by length descending to avoid partial matches
    // (e.g., @.str.10 should be replaced before @.str.1)
    let sorted: i64 = sort_strings_by_length_desc(keys);

    var i: i64 = 0;
    while i < n {
        let old_label: i64 = vec_get(sorted, i);
        let new_label_opt: i64 = hashmap_get(replacement_map, old_label);
        if option_is_some(new_label_opt) {
            let new_label: i64 = option_unwrap(new_label_opt);
            result = string_replace(result, old_label, new_label);
        }
        i = i + 1;
    }
    result
}

// Sort strings by length descending (longest first)
fn sort_strings_by_length_desc(strings: i64) -> i64 {
    let n: i64 = vec_len(strings);
    if n <= 1 {
        return strings;
    }

    // Build (length, string) pairs for sorting
    let pairs: i64 = vec_new();
    var i: i64 = 0;
    while i < n {
        let s: i64 = vec_get(strings, i);
        let pair: i64 = malloc(16);
        store_i64(pair, 0, string_len(s));
        store_ptr(pair, 1, s);
        vec_push(pairs, pair);
        i = i + 1;
    }

    // Insertion sort (good for small n, which is typical)
    i = 1;
    while i < n {
        let key: i64 = vec_get(pairs, i);
        let key_len: i64 = load_i64(key, 0);
        var j: i64 = i - 1;

        // Shift elements to make room
        while j >= 0 {
            let curr: i64 = vec_get(pairs, j);
            let curr_len: i64 = load_i64(curr, 0);
            if curr_len < key_len {
                // Swap curr and j+1
                vec_set(pairs, j + 1, curr);
                j = j - 1;
            } else {
                j = 0 - 2;  // Break (j will be -1 after decrement check)
            }
        }
        if j >= 0 - 1 {
            vec_set(pairs, j + 1, key);
        }
        i = i + 1;
    }

    // Extract sorted strings
    let result: i64 = vec_new();
    i = 0;
    while i < n {
        let pair: i64 = vec_get(pairs, i);
        let s: i64 = load_ptr(pair, 1);
        vec_push(result, s);
        i = i + 1;
    }
    result
}

// Replace string labels in all functions
fn replace_string_labels(state: i64) -> i64 {
    let strings: i64 = merge_strings(state);
    let num_strings: i64 = vec_len(strings);

    if num_strings == 0 {
        return 0;
    }

    let replacement_map: i64 = build_replacement_map(strings);
    let func_map: i64 = merge_func_map(state);
    let func_order: i64 = merge_func_order(state);
    let n: i64 = vec_len(func_order);

    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(func_order, i);
        let body_opt: i64 = hashmap_get(func_map, name);
        if option_is_some(body_opt) {
            let body: i64 = option_unwrap(body_opt);
            let new_body: i64 = replace_labels_in_body(body, replacement_map);
            hashmap_insert(func_map, name, new_body);
        }
        i = i + 1;
    }
    0
}

// Write output file using StringBuilder
fn write_output(state: i64, output_path: i64) -> i64 {
    let sb: i64 = sb_new_cap(1024 * 1024);  // 1MB initial capacity

    sb_append(sb, "; ModuleID = \"simplex_program\"\n");
    sb_append(sb, "target triple = \"x86_64-apple-macosx14.0.0\"\n\n");

    // Write declarations in order
    let decl_order: i64 = merge_decl_order(state);
    let num_decls: i64 = vec_len(decl_order);
    var i: i64 = 0;
    while i < num_decls {
        let decl: i64 = vec_get(decl_order, i);
        sb_append(sb, decl);
        sb_append_char(sb, 10);
        i = i + 1;
    }
    sb_append_char(sb, 10);

    // Write functions in order
    let func_order: i64 = merge_func_order(state);
    let func_map: i64 = merge_func_map(state);
    let num_funcs: i64 = vec_len(func_order);
    i = 0;
    while i < num_funcs {
        let name: i64 = vec_get(func_order, i);
        let body_opt: i64 = hashmap_get(func_map, name);
        if option_is_some(body_opt) {
            let body: i64 = option_unwrap(body_opt);
            sb_append(sb, body);
            sb_append_char(sb, 10);
        }
        i = i + 1;
    }

    // Write string constants
    let strings: i64 = merge_strings(state);
    let num_strings: i64 = vec_len(strings);
    if num_strings > 0 {
        sb_append(sb, "\n; String constants\n");
        i = 0;
        while i < num_strings {
            let triple: i64 = vec_get(strings, i);
            let new_label: i64 = load_ptr(triple, 1);
            let content: i64 = load_ptr(triple, 2);
            sb_append(sb, new_label);
            sb_append(sb, " = ");
            sb_append(sb, content);
            sb_append_char(sb, 10);
            i = i + 1;
        }
    }

    let result: i64 = sb_to_string(sb);
    write_file(output_path, result);
    sb_free(sb);
    0
}

fn main() {
    let args: i64 = get_args();
    let argc: i64 = vec_len(args);

    if argc < 3 {
        println("Usage: merge output.ll input1.ll input2.ll ...");
        return;
    }

    let output_path: i64 = vec_get(args, 1);
    let state: i64 = merge_state_new();

    // Process each input file
    var i: i64 = 2;
    while i < argc {
        let input_path: i64 = vec_get(args, i);
        print("Processing: ");
        println(input_path);
        process_file(state, input_path);
        i = i + 1;
    }

    // Replace string labels in functions
    println("Replacing string labels...");
    replace_string_labels(state);

    // Write output
    println("Writing output...");
    write_output(state, output_path);

    let num_files: i64 = argc - 2;
    print("Merged ");
    print(int_to_string(num_files));
    println(" files successfully");
}
