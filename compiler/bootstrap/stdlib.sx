// Simplex Standard Library
// Phase 2: Minimal stdlib - uses C runtime for core types
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under MIT License - see LICENSE file
// https://github.com/senuamedia/simplex-lang
//
// Core types (Option, Result, Vec, HashMap, HashSet, JSON) are provided
// by the C runtime (standalone_runtime.c). This file contains only
// utility functions and Simplex-specific helpers.

// ============================================================================
// Additional Vec utilities (not in C runtime)
// ============================================================================

fn vec_map(v: i64, f: i64) -> i64 {
    // Note: requires function pointer support
    let result: i64 = vec_new();
    let n: i64 = vec_len(v);
    var i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(v, i);
        // Would need: let mapped: i64 = call_fn(f, item);
        vec_push(result, item);  // For now, just copy
        i = i + 1;
    }
    result
}

fn vec_filter(v: i64, pred: i64) -> i64 {
    // Note: requires function pointer support
    let result: i64 = vec_new();
    let n: i64 = vec_len(v);
    var i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(v, i);
        // Would need: if call_fn(pred, item) { vec_push(result, item); }
        vec_push(result, item);  // For now, just copy all
        i = i + 1;
    }
    result
}

fn vec_fold(v: i64, init: i64, f: i64) -> i64 {
    // Note: requires function pointer support
    var acc: i64 = init;
    let n: i64 = vec_len(v);
    var i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(v, i);
        // Would need: acc = call_fn(f, acc, item);
        i = i + 1;
    }
    acc
}

// ============================================================================
// Printing utilities
// ============================================================================

fn print_vec_i64(v: i64) {
    print("[");
    let n: i64 = vec_len(v);
    var i: i64 = 0;
    while i < n {
        if i > 0 { print(", "); }
        print(int_to_string(vec_get(v, i)));
        i = i + 1;
    }
    println("]");
}

fn print_vec_str(v: i64) {
    print("[");
    let n: i64 = vec_len(v);
    var i: i64 = 0;
    while i < n {
        if i > 0 { print(", "); }
        print("\"");
        print(vec_get(v, i));
        print("\"");
        i = i + 1;
    }
    println("]");
}

// ============================================================================
// Assertion helpers (for tests)
// ============================================================================

fn assert(cond: bool, msg: i64) {
    if cond == false {
        print("ASSERTION FAILED: ");
        println(msg);
    }
}

fn assert_eq(expected: i64, actual: i64, msg: i64) {
    if expected != actual {
        print("ASSERTION FAILED: ");
        print(msg);
        print(" - expected ");
        print(int_to_string(expected));
        print(", got ");
        println(int_to_string(actual));
    }
}

fn assert_str_eq(expected: i64, actual: i64, msg: i64) {
    if string_eq(expected, actual) == false {
        print("ASSERTION FAILED: ");
        print(msg);
        print(" - expected '");
        print(expected);
        print("', got '");
        print(actual);
        println("'");
    }
}

// ============================================================================
// Math utilities
// ============================================================================

fn min(a: i64, b: i64) -> i64 {
    if a < b { a } else { b }
}

fn max(a: i64, b: i64) -> i64 {
    if a > b { a } else { b }
}

fn abs(x: i64) -> i64 {
    if x < 0 { 0 - x } else { x }
}

fn clamp(x: i64, lo: i64, hi: i64) -> i64 {
    if x < lo { lo }
    else if x > hi { hi }
    else { x }
}

// ============================================================================
// String utilities (supplements intrinsics)
// ============================================================================

fn string_repeat(s: i64, count: i64) -> i64 {
    let sb: i64 = sb_new();
    var i: i64 = 0;
    while i < count {
        sb_append(sb, s);
        i = i + 1;
    }
    let result: i64 = sb_to_string(sb);
    sb_free(sb);
    result
}

fn string_pad_left(s: i64, width: i64, pad_char: i64) -> i64 {
    let len: i64 = string_len(s);
    if len >= width {
        return s;
    }
    let pad_str: i64 = string_from_char(pad_char);
    let padding: i64 = string_repeat(pad_str, width - len);
    string_concat(padding, s)
}

fn string_pad_right(s: i64, width: i64, pad_char: i64) -> i64 {
    let len: i64 = string_len(s);
    if len >= width {
        return s;
    }
    let pad_str: i64 = string_from_char(pad_char);
    let padding: i64 = string_repeat(pad_str, width - len);
    string_concat(s, padding)
}

fn is_digit(c: i64) -> bool {
    c >= 48 && c <= 57  // '0' to '9'
}

fn is_alpha(c: i64) -> bool {
    (c >= 65 && c <= 90) || (c >= 97 && c <= 122)  // A-Z or a-z
}

fn is_whitespace(c: i64) -> bool {
    c == 32 || c == 9 || c == 10 || c == 13  // space, tab, newline, carriage return
}
