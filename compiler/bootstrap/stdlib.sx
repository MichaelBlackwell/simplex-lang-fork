// Simplex Standard Library
// Phase 22: Core types and utilities

// ============================================================================
// Option<T> - Represents an optional value
// ============================================================================
// None = 0
// Some(value) = pointer to box containing value

fn option_none() -> i64 {
    0
}

fn option_some(value: i64) -> i64 {
    let box: i64 = malloc(8);
    store_i64(box, 0, value);
    box
}

fn option_is_none(opt: i64) -> bool {
    opt == 0
}

fn option_is_some(opt: i64) -> bool {
    opt != 0
}

fn option_unwrap(opt: i64) -> i64 {
    if opt == 0 {
        println("panic: unwrap on None");
        return 0;
    }
    load_i64(opt, 0)
}

fn option_unwrap_or(opt: i64, default: i64) -> i64 {
    if opt == 0 {
        return default;
    }
    load_i64(opt, 0)
}

fn option_map(opt: i64, f: i64) -> i64 {
    if opt == 0 {
        return 0;
    }
    // Note: f is a function pointer - requires indirect call support
    let val: i64 = load_i64(opt, 0);
    option_some(val)  // For now, just wrap without applying f
}

// ============================================================================
// Result<T, E> - Represents success or error
// ============================================================================
// Layout: tag(0), value(1)
// tag=0: Ok(value)
// tag=1: Err(error)

fn result_ok(value: i64) -> i64 {
    let res: i64 = malloc(16);
    store_i64(res, 0, 0);  // Ok tag
    store_i64(res, 1, value);
    res
}

fn result_err(error: i64) -> i64 {
    let res: i64 = malloc(16);
    store_i64(res, 0, 1);  // Err tag
    store_i64(res, 1, error);
    res
}

fn result_is_ok(res: i64) -> bool {
    load_i64(res, 0) == 0
}

fn result_is_err(res: i64) -> bool {
    load_i64(res, 0) == 1
}

fn result_unwrap(res: i64) -> i64 {
    if load_i64(res, 0) == 1 {
        println("panic: unwrap on Err");
        return 0;
    }
    load_i64(res, 1)
}

fn result_unwrap_err(res: i64) -> i64 {
    if load_i64(res, 0) == 0 {
        println("panic: unwrap_err on Ok");
        return 0;
    }
    load_i64(res, 1)
}

fn result_unwrap_or(res: i64, default: i64) -> i64 {
    if load_i64(res, 0) == 1 {
        return default;
    }
    load_i64(res, 1)
}

fn result_ok_or(opt: i64, err: i64) -> i64 {
    // Convert Option to Result
    if opt == 0 {
        return result_err(err);
    }
    result_ok(load_i64(opt, 0))
}

// ============================================================================
// Vec operations
// ============================================================================

fn vec_map(v: i64, f: i64) -> i64 {
    // Creates a new vec with f applied to each element
    // Note: f is a function pointer
    let result: i64 = vec_new();
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        let elem: i64 = vec_get(v, i);
        // For now, just copy (can't call f without proper fn ptr support)
        vec_push(result, elem);
        i = i + 1;
    }
    result
}

fn vec_filter(v: i64, pred: i64) -> i64 {
    // Creates a new vec with elements where pred returns true
    let result: i64 = vec_new();
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        let elem: i64 = vec_get(v, i);
        // For now, include all (can't call pred without proper fn ptr support)
        vec_push(result, elem);
        i = i + 1;
    }
    result
}

fn vec_fold(v: i64, init: i64, f: i64) -> i64 {
    // Reduces vec to single value using f(acc, elem)
    let acc: i64 = init;
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        let elem: i64 = vec_get(v, i);
        // For now, just return init (can't call f)
        i = i + 1;
    }
    acc
}

fn vec_sum(v: i64) -> i64 {
    let sum: i64 = 0;
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        sum = sum + vec_get(v, i);
        i = i + 1;
    }
    sum
}

fn vec_find(v: i64, value: i64) -> i64 {
    // Returns index of first occurrence, or -1 if not found
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        if vec_get(v, i) == value {
            return i;
        }
        i = i + 1;
    }
    0 - 1
}

fn vec_contains(v: i64, value: i64) -> bool {
    vec_find(v, value) >= 0
}

fn vec_reverse(v: i64) -> i64 {
    let result: i64 = vec_new();
    let len: i64 = vec_len(v);
    let i: i64 = len - 1;
    while i >= 0 {
        vec_push(result, vec_get(v, i));
        i = i - 1;
    }
    result
}

fn vec_clone(v: i64) -> i64 {
    let result: i64 = vec_new();
    let len: i64 = vec_len(v);
    let i: i64 = 0;
    while i < len {
        vec_push(result, vec_get(v, i));
        i = i + 1;
    }
    result
}

fn vec_clear(v: i64) -> i64 {
    // Note: This creates a new empty vec, doesn't modify in place
    vec_new()
}

fn vec_first(v: i64) -> i64 {
    if vec_len(v) == 0 {
        return option_none();
    }
    option_some(vec_get(v, 0))
}

fn vec_last(v: i64) -> i64 {
    let len: i64 = vec_len(v);
    if len == 0 {
        return option_none();
    }
    option_some(vec_get(v, len - 1))
}

// ============================================================================
// String utilities
// ============================================================================

fn string_is_empty(s: i64) -> bool {
    string_len(s) == 0
}

fn string_starts_with(s: i64, prefix: i64) -> bool {
    let s_len: i64 = string_len(s);
    let p_len: i64 = string_len(prefix);
    if p_len > s_len {
        return false;
    }
    let sub: i64 = string_slice(s, 0, p_len);
    string_eq(sub, prefix)
}

fn string_ends_with(s: i64, suffix: i64) -> bool {
    let s_len: i64 = string_len(s);
    let suf_len: i64 = string_len(suffix);
    if suf_len > s_len {
        return false;
    }
    let sub: i64 = string_slice(s, s_len - suf_len, s_len);
    string_eq(sub, suffix)
}

fn string_contains(haystack: i64, needle: i64) -> bool {
    string_find(haystack, needle) >= 0
}

fn string_find(haystack: i64, needle: i64) -> i64 {
    // Returns index of first occurrence of needle, or -1 if not found
    let h_len: i64 = string_len(haystack);
    let n_len: i64 = string_len(needle);
    if n_len > h_len {
        return 0 - 1;
    }
    if n_len == 0 {
        return 0;
    }
    let i: i64 = 0;
    while i <= h_len - n_len {
        let sub: i64 = string_slice(haystack, i, i + n_len);
        if string_eq(sub, needle) {
            return i;
        }
        i = i + 1;
    }
    0 - 1
}

fn string_split(s: i64, delim: i64) -> i64 {
    // Returns vec of strings split by delimiter
    let result: i64 = vec_new();
    let s_len: i64 = string_len(s);
    let d_len: i64 = string_len(delim);
    
    if d_len == 0 {
        vec_push(result, s);
        return result;
    }
    
    let start: i64 = 0;
    let i: i64 = 0;
    while i <= s_len - d_len {
        let sub: i64 = string_slice(s, i, i + d_len);
        if string_eq(sub, delim) {
            vec_push(result, string_slice(s, start, i));
            start = i + d_len;
            i = start;
        } else {
            i = i + 1;
        }
    }
    // Add remaining
    vec_push(result, string_slice(s, start, s_len));
    result
}

fn string_join(parts: i64, sep: i64) -> i64 {
    // Joins vec of strings with separator
    let len: i64 = vec_len(parts);
    if len == 0 {
        return string_from("");
    }
    let result: i64 = vec_get(parts, 0);
    let i: i64 = 1;
    while i < len {
        result = string_concat(result, sep);
        result = string_concat(result, vec_get(parts, i));
        i = i + 1;
    }
    result
}

fn string_trim(s: i64) -> i64 {
    // Trim whitespace from both ends
    let len: i64 = string_len(s);
    let start: i64 = 0;
    let end: i64 = len;
    
    // Find first non-whitespace
    while start < len {
        let c: i64 = string_char_at(s, start);
        if c != 32 {
            if c != 9 {
                if c != 10 {
                    if c != 13 {
                        break;
                    }
                }
            }
        }
        start = start + 1;
    }
    
    // Find last non-whitespace
    while end > start {
        let c: i64 = string_char_at(s, end - 1);
        if c != 32 {
            if c != 9 {
                if c != 10 {
                    if c != 13 {
                        break;
                    }
                }
            }
        }
        end = end - 1;
    }
    
    string_slice(s, start, end)
}

fn string_repeat(s: i64, count: i64) -> i64 {
    let result: i64 = string_from("");
    let i: i64 = 0;
    while i < count {
        result = string_concat(result, s);
        i = i + 1;
    }
    result
}

fn string_replace(s: i64, old: i64, new: i64) -> i64 {
    // Replace all occurrences of old with new
    let parts: i64 = string_split(s, old);
    string_join(parts, new)
}

fn string_to_upper(s: i64) -> i64 {
    let len: i64 = string_len(s);
    let result: i64 = string_from("");
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(s, i);
        // a-z: 97-122 -> A-Z: 65-90
        if c >= 97 {
            if c <= 122 {
                c = c - 32;
            }
        }
        result = string_concat(result, string_from_char(c));
        i = i + 1;
    }
    result
}

fn string_to_lower(s: i64) -> i64 {
    let len: i64 = string_len(s);
    let result: i64 = string_from("");
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(s, i);
        // A-Z: 65-90 -> a-z: 97-122
        if c >= 65 {
            if c <= 90 {
                c = c + 32;
            }
        }
        result = string_concat(result, string_from_char(c));
        i = i + 1;
    }
    result
}

fn string_to_int(s: i64) -> i64 {
    // Parse integer from string
    let len: i64 = string_len(s);
    if len == 0 {
        return 0;
    }
    
    let result: i64 = 0;
    let i: i64 = 0;
    let negative: bool = false;
    
    // Check for negative
    if string_char_at(s, 0) == 45 {  // '-'
        negative = true;
        i = 1;
    }
    
    while i < len {
        let c: i64 = string_char_at(s, i);
        if c >= 48 {
            if c <= 57 {
                result = result * 10 + (c - 48);
            }
        }
        i = i + 1;
    }
    
    if negative {
        return 0 - result;
    }
    result
}

// ============================================================================
// Math utilities
// ============================================================================

fn min(a: i64, b: i64) -> i64 {
    if a < b { a } else { b }
}

fn max(a: i64, b: i64) -> i64 {
    if a > b { a } else { b }
}

fn abs(n: i64) -> i64 {
    if n < 0 { 0 - n } else { n }
}

fn clamp(n: i64, low: i64, high: i64) -> i64 {
    if n < low { low } else { if n > high { high } else { n } }
}

// ============================================================================
// Assertions for testing
// ============================================================================

fn assert(condition: bool, msg: i64) -> i64 {
    if condition == false {
        println(string_concat(string_from("ASSERTION FAILED: "), msg));
        return 1;
    }
    0
}

fn assert_eq(a: i64, b: i64, msg: i64) -> i64 {
    if a != b {
        println(string_concat(string_from("ASSERTION FAILED: "), msg));
        println(string_concat(string_from("  expected: "), int_to_string(b)));
        println(string_concat(string_from("  actual: "), int_to_string(a)));
        return 1;
    }
    0
}

fn assert_str_eq(a: i64, b: i64, msg: i64) -> i64 {
    if string_eq(a, b) == false {
        println(string_concat(string_from("ASSERTION FAILED: "), msg));
        println(string_concat(string_from("  expected: "), b));
        println(string_concat(string_from("  actual: "), a));
        return 1;
    }
    0
}

// ============================================================================
// HashMap - Simple hash table with string keys
// ============================================================================
// Layout: buckets(0), size(1), capacity(2)
// Each bucket is a vec of (key, value) pairs

fn HASHMAP_INITIAL_CAPACITY() -> i64 { 16 }

fn hashmap_new() -> i64 {
    let capacity: i64 = HASHMAP_INITIAL_CAPACITY();
    let map: i64 = malloc(24);
    let buckets: i64 = malloc(capacity * 8);
    
    // Initialize all buckets to empty vecs
    let i: i64 = 0;
    while i < capacity {
        store_ptr(buckets + i * 8, 0, vec_new());
        i = i + 1;
    }
    
    store_ptr(map, 0, buckets);
    store_i64(map, 1, 0);  // size
    store_i64(map, 2, capacity);
    map
}

fn hashmap_hash(key: i64) -> i64 {
    // Simple hash function for strings
    let len: i64 = string_len(key);
    let hash: i64 = 0;
    let i: i64 = 0;
    while i < len {
        hash = hash * 31 + string_char_at(key, i);
        i = i + 1;
    }
    // Make positive
    if hash < 0 {
        hash = 0 - hash;
    }
    hash
}

fn hashmap_get_bucket(map: i64, key: i64) -> i64 {
    let buckets: i64 = load_ptr(map, 0);
    let capacity: i64 = load_i64(map, 2);
    let index: i64 = hashmap_hash(key) % capacity;
    load_ptr(buckets + index * 8, 0)
}

fn hashmap_find_in_bucket(bucket: i64, key: i64) -> i64 {
    // Returns index in bucket or -1
    let len: i64 = vec_len(bucket);
    let i: i64 = 0;
    while i < len {
        let pair: i64 = vec_get(bucket, i);
        let k: i64 = load_ptr(pair, 0);
        if string_eq(k, key) {
            return i;
        }
        i = i + 1;
    }
    0 - 1
}

fn hashmap_set(map: i64, key: i64, value: i64) -> i64 {
    let bucket: i64 = hashmap_get_bucket(map, key);
    let idx: i64 = hashmap_find_in_bucket(bucket, key);
    
    if idx >= 0 {
        // Update existing
        let pair: i64 = vec_get(bucket, idx);
        store_i64(pair, 1, value);
    } else {
        // Insert new
        let pair: i64 = malloc(16);
        store_ptr(pair, 0, key);
        store_i64(pair, 1, value);
        vec_push(bucket, pair);
        
        // Increment size
        let size: i64 = load_i64(map, 1);
        store_i64(map, 1, size + 1);
    }
    0
}

fn hashmap_get(map: i64, key: i64) -> i64 {
    // Returns Option<value>
    let bucket: i64 = hashmap_get_bucket(map, key);
    let idx: i64 = hashmap_find_in_bucket(bucket, key);
    
    if idx < 0 {
        return option_none();
    }
    let pair: i64 = vec_get(bucket, idx);
    option_some(load_i64(pair, 1))
}

fn hashmap_contains(map: i64, key: i64) -> bool {
    let bucket: i64 = hashmap_get_bucket(map, key);
    hashmap_find_in_bucket(bucket, key) >= 0
}

fn hashmap_remove(map: i64, key: i64) -> i64 {
    // Returns removed value as Option
    let bucket: i64 = hashmap_get_bucket(map, key);
    let idx: i64 = hashmap_find_in_bucket(bucket, key);
    
    if idx < 0 {
        return option_none();
    }
    
    let pair: i64 = vec_get(bucket, idx);
    let value: i64 = load_i64(pair, 1);
    
    // Remove from bucket (swap with last and pop)
    let last_idx: i64 = vec_len(bucket) - 1;
    if idx != last_idx {
        let last: i64 = vec_get(bucket, last_idx);
        // Note: We can't actually modify vec in place, so this is a simplified version
    }
    
    // Decrement size
    let size: i64 = load_i64(map, 1);
    store_i64(map, 1, size - 1);
    
    option_some(value)
}

fn hashmap_size(map: i64) -> i64 {
    load_i64(map, 1)
}

fn hashmap_is_empty(map: i64) -> bool {
    load_i64(map, 1) == 0
}

fn hashmap_keys(map: i64) -> i64 {
    // Returns vec of all keys
    let result: i64 = vec_new();
    let buckets: i64 = load_ptr(map, 0);
    let capacity: i64 = load_i64(map, 2);
    
    let i: i64 = 0;
    while i < capacity {
        let bucket: i64 = load_ptr(buckets + i * 8, 0);
        let len: i64 = vec_len(bucket);
        let j: i64 = 0;
        while j < len {
            let pair: i64 = vec_get(bucket, j);
            vec_push(result, load_ptr(pair, 0));
            j = j + 1;
        }
        i = i + 1;
    }
    result
}

fn hashmap_values(map: i64) -> i64 {
    // Returns vec of all values
    let result: i64 = vec_new();
    let buckets: i64 = load_ptr(map, 0);
    let capacity: i64 = load_i64(map, 2);

    let i: i64 = 0;
    while i < capacity {
        let bucket: i64 = load_ptr(buckets + i * 8, 0);
        let len: i64 = vec_len(bucket);
        let j: i64 = 0;
        while j < len {
            let pair: i64 = vec_get(bucket, j);
            vec_push(result, load_i64(pair, 1));
            j = j + 1;
        }
        i = i + 1;
    }
    result
}

// ============================================================================
// Command-line Argument Parsing
// ============================================================================

// ArgParser stores parsed arguments
// Structure: [args vec, flags map, options map, positionals vec]
fn argparser_new() -> i64 {
    let parser: i64 = malloc(32);
    store_ptr(parser, 0, get_args());      // raw args
    store_ptr(parser, 1, hashmap_new());   // flags (--flag)
    store_ptr(parser, 2, hashmap_new());   // options (--key=value)
    store_ptr(parser, 3, vec_new());       // positional args
    parser
}

fn argparser_args(parser: i64) -> i64 {
    load_ptr(parser, 0)
}

fn argparser_flags(parser: i64) -> i64 {
    load_ptr(parser, 1)
}

fn argparser_options(parser: i64) -> i64 {
    load_ptr(parser, 2)
}

fn argparser_positionals(parser: i64) -> i64 {
    load_ptr(parser, 3)
}

// Parse command line arguments
fn argparser_parse(parser: i64) -> i64 {
    let args: i64 = argparser_args(parser);
    let flags: i64 = argparser_flags(parser);
    let opts: i64 = argparser_options(parser);
    let positionals: i64 = argparser_positionals(parser);

    let i: i64 = 1;  // Skip program name
    let n: i64 = vec_len(args);

    while i < n {
        let arg: i64 = vec_get(args, i);

        // Check for --flag or --key=value
        if string_starts_with(arg, string_from("--")) {
            let rest: i64 = string_slice(arg, 2, string_len(arg));

            // Check for =
            let eq_pos: i64 = string_find(rest, string_from("="));
            if eq_pos >= 0 {
                // --key=value
                let key: i64 = string_slice(rest, 0, eq_pos);
                let value: i64 = string_slice(rest, eq_pos + 1, string_len(rest));
                hashmap_set(opts, key, value);
            } else {
                // --flag
                hashmap_set(flags, rest, 1);
            }
        } else {
            if string_starts_with(arg, string_from("-")) {
                // Short flag like -v, -h
                let flag: i64 = string_slice(arg, 1, string_len(arg));
                hashmap_set(flags, flag, 1);
            } else {
                // Positional argument
                vec_push(positionals, arg);
            }
        }

        i = i + 1;
    }
    parser
}

// Check if a flag is set (e.g., --verbose or -v)
fn argparser_has_flag(parser: i64, name: i64) -> bool {
    let flags: i64 = argparser_flags(parser);
    hashmap_contains(flags, name)
}

// Get option value (e.g., --output=file.txt)
fn argparser_get_option(parser: i64, name: i64) -> i64 {
    let opts: i64 = argparser_options(parser);
    hashmap_get(opts, name)
}

// Get option value or default
fn argparser_get_option_or(parser: i64, name: i64, default_val: i64) -> i64 {
    let result: i64 = argparser_get_option(parser, name);
    if option_is_none(result) {
        return default_val;
    }
    option_unwrap(result)
}

// Get positional argument by index
fn argparser_positional(parser: i64, index: i64) -> i64 {
    let positionals: i64 = argparser_positionals(parser);
    if index >= vec_len(positionals) {
        return option_none();
    }
    option_some(vec_get(positionals, index))
}

// Get number of positional arguments
fn argparser_positional_count(parser: i64) -> i64 {
    vec_len(argparser_positionals(parser))
}

// Simple helpers for direct access
fn arg_count() -> i64 {
    vec_len(get_args())
}

fn arg_get(index: i64) -> i64 {
    let args: i64 = get_args();
    if index >= vec_len(args) {
        return string_from("");
    }
    vec_get(args, index)
}

fn arg_has(flag: i64) -> bool {
    // Check if any argument matches the flag
    let args: i64 = get_args();
    let n: i64 = vec_len(args);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(args, i), flag) {
            return true;
        }
        i = i + 1;
    }
    false
}

// ============================================================================
// Assertions and Error Handling
// ============================================================================

fn assert_true(condition: bool, message: i64) -> i64 {
    if condition == false {
        panic(string_concat(string_from("Assertion failed: "), message));
    }
    0
}

fn assert_false(condition: bool, message: i64) -> i64 {
    if condition == true {
        panic(string_concat(string_from("Assertion failed (expected false): "), message));
    }
    0
}

fn assert_eq_i64(left: i64, right: i64, message: i64) -> i64 {
    if left != right {
        let err: i64 = string_concat(message, string_from(": "));
        let err2: i64 = string_concat(err, int_to_string(left));
        let err3: i64 = string_concat(err2, string_from(" != "));
        let err4: i64 = string_concat(err3, int_to_string(right));
        panic(err4);
    }
    0
}

fn assert_eq_str(left: i64, right: i64, message: i64) -> i64 {
    if string_eq(left, right) == false {
        let err: i64 = string_concat(message, string_from(": '"));
        let err2: i64 = string_concat(err, left);
        let err3: i64 = string_concat(err2, string_from("' != '"));
        let err4: i64 = string_concat(err3, right);
        let err5: i64 = string_concat(err4, string_from("'"));
        panic(err5);
    }
    0
}

fn assert_not_null(ptr: i64, message: i64) -> i64 {
    if ptr == 0 {
        panic(string_concat(string_from("Null pointer: "), message));
    }
    0
}

fn unreachable(message: i64) -> i64 {
    panic(string_concat(string_from("Unreachable code reached: "), message));
    0
}

fn todo(message: i64) -> i64 {
    panic(string_concat(string_from("Not implemented: "), message));
    0
}
