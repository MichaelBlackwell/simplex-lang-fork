// Test Bitwise Operators and Tuples

// ============ BITWISE AND (&) ============

// Test basic bitwise AND
fn test_bitwise_and() -> i64 {
    let a = 12;  // 0b1100
    let b = 10;  // 0b1010
    let result = a & b;
    // 1100 & 1010 = 1000 = 8
    if result == 8 {
        1
    } else {
        0
    }
}

// Test AND with all bits set
fn test_and_all_bits() -> i64 {
    let a = 255;  // 0xFF
    let b = 15;   // 0x0F
    let result = a & b;
    if result == 15 {
        1
    } else {
        0
    }
}

// Test AND masking
fn test_and_mask() -> i64 {
    let value = 245;  // 0b11110101
    let mask = 15;    // 0b00001111
    let low_nibble = value & mask;
    if low_nibble == 5 {
        1
    } else {
        0
    }
}

// ============ BITWISE OR (|) ============

// Test basic bitwise OR
fn test_bitwise_or() -> i64 {
    let a = 12;  // 0b1100
    let b = 10;  // 0b1010
    let result = a | b;
    // 1100 | 1010 = 1110 = 14
    if result == 14 {
        1
    } else {
        0
    }
}

// Test OR combining flags
fn test_or_flags() -> i64 {
    let flag_read = 1;    // 0b001
    let flag_write = 2;   // 0b010
    let flag_exec = 4;    // 0b100
    let permissions = flag_read | flag_write | flag_exec;
    if permissions == 7 {
        1
    } else {
        0
    }
}

// ============ BITWISE XOR (^) ============

// Test basic bitwise XOR
fn test_bitwise_xor() -> i64 {
    let a = 12;  // 0b1100
    let b = 10;  // 0b1010
    let result = a ^ b;
    // 1100 ^ 1010 = 0110 = 6
    if result == 6 {
        1
    } else {
        0
    }
}

// Test XOR toggle
fn test_xor_toggle() -> i64 {
    let value = 10;  // 0b1010
    let toggled = value ^ 15;  // Toggle low 4 bits (0b1111)
    // 1010 ^ 1111 = 0101 = 5
    if toggled == 5 {
        1
    } else {
        0
    }
}

// Test XOR self cancellation
fn test_xor_cancel() -> i64 {
    let a = 42;
    let result = a ^ a;  // XOR with self = 0
    if result == 0 {
        1
    } else {
        0
    }
}

// ============ LEFT SHIFT (<<) ============

// Test basic left shift
fn test_left_shift() -> i64 {
    let a = 1;
    let result = a << 4;
    // 1 << 4 = 16
    if result == 16 {
        1
    } else {
        0
    }
}

// Test left shift multiply
fn test_shift_multiply() -> i64 {
    let a = 5;
    let times_8 = a << 3;  // Multiply by 8
    if times_8 == 40 {
        1
    } else {
        0
    }
}

// Test multiple shifts
fn test_multiple_shifts() -> i64 {
    let a = 1;
    let b = a << 1;  // 2
    let c = b << 1;  // 4
    let d = c << 1;  // 8
    if b == 2 && c == 4 && d == 8 {
        1
    } else {
        0
    }
}

// ============ RIGHT SHIFT (>>) ============

// Test basic right shift
fn test_right_shift() -> i64 {
    let a = 16;
    let result = a >> 2;
    // 16 >> 2 = 4
    if result == 4 {
        1
    } else {
        0
    }
}

// Test right shift divide
fn test_shift_divide() -> i64 {
    let a = 64;
    let divided = a >> 3;  // Divide by 8
    if divided == 8 {
        1
    } else {
        0
    }
}

// Test extracting bits
fn test_extract_bits() -> i64 {
    let value = 214;  // 0b11010110
    let high_nibble = (value >> 4) & 15;
    // 11010110 >> 4 = 00001101 = 13
    // 13 & 15 = 13
    if high_nibble == 13 {
        1
    } else {
        0
    }
}

// ============ COMBINED OPERATIONS ============

// Test bit manipulation pattern
fn test_set_bit() -> i64 {
    let value = 0;
    let bit_pos = 3;
    let with_bit = value | (1 << bit_pos);  // Set bit 3
    if with_bit == 8 {
        1
    } else {
        0
    }
}

// Test clear bit pattern
fn test_clear_bit() -> i64 {
    let value = 15;  // 0b1111
    let bit_pos = 2;
    let mask = 1 << bit_pos;  // 0100 = 4
    let inverted = mask ^ 15;  // 4 ^ 15 = 11 (0b1011)
    let cleared = value & inverted;
    // 1111 & 1011 = 1011 = 11
    if cleared == 11 {
        1
    } else {
        0
    }
}

// Test toggle bit pattern
fn test_toggle_bit() -> i64 {
    let value = 10;  // 0b1010
    let bit_pos = 1;
    let toggled = value ^ (1 << bit_pos);
    // 1010 ^ 0010 = 1000 = 8
    if toggled == 8 {
        1
    } else {
        0
    }
}

// Test check bit pattern
fn test_check_bit() -> i64 {
    let value = 10;  // 0b1010
    let bit3_set = (value >> 3) & 1;  // Bit 3 is set (1)
    let bit2_set = (value >> 2) & 1;  // Bit 2 is not set (0)
    if bit3_set == 1 && bit2_set == 0 {
        1
    } else {
        0
    }
}

// ============ TUPLES ============

// Test creating empty tuple (unit)
fn test_unit_tuple() -> i64 {
    let unit = ();
    // Unit is represented as 0
    if unit == 0 {
        1
    } else {
        0
    }
}

// Test creating tuple with literal elements
fn test_create_tuple() -> i64 {
    let t = (10, 20, 30);
    // Tuple is a non-zero pointer
    if t != 0 {
        1
    } else {
        0
    }
}

// Test tuple with different values
fn test_tuple_values() -> i64 {
    let t1 = (1, 2);
    let t2 = (100, 200);
    // Both should be valid pointers, different from each other
    if t1 != 0 && t2 != 0 && t1 != t2 {
        1
    } else {
        0
    }
}

// Test two-element tuple
fn test_tuple_pair() -> i64 {
    let pair = (42, 99);
    if pair != 0 {
        1
    } else {
        0
    }
}

// Test tuple in expression context
fn test_tuple_expression() -> i64 {
    let sum = 5 + 10;
    let prod = 5 * 10;
    // Create tuple from computed values using intermediate vars
    let t = (sum, prod);
    if t != 0 {
        1
    } else {
        0
    }
}

fn main() -> i64 {
    var passed = 0;
    var total = 23;

    print("=== Bitwise Operators and Tuples Tests ===\n\n");

    // Bitwise AND
    print("Testing bitwise_and...\n");
    if test_bitwise_and() == 1 {
        print("bitwise_and: PASS\n");
        passed = passed + 1;
    } else {
        print("bitwise_and: FAIL\n");
    }

    print("\nTesting and_all_bits...\n");
    if test_and_all_bits() == 1 {
        print("and_all_bits: PASS\n");
        passed = passed + 1;
    } else {
        print("and_all_bits: FAIL\n");
    }

    print("\nTesting and_mask...\n");
    if test_and_mask() == 1 {
        print("and_mask: PASS\n");
        passed = passed + 1;
    } else {
        print("and_mask: FAIL\n");
    }

    // Bitwise OR
    print("\nTesting bitwise_or...\n");
    if test_bitwise_or() == 1 {
        print("bitwise_or: PASS\n");
        passed = passed + 1;
    } else {
        print("bitwise_or: FAIL\n");
    }

    print("\nTesting or_flags...\n");
    if test_or_flags() == 1 {
        print("or_flags: PASS\n");
        passed = passed + 1;
    } else {
        print("or_flags: FAIL\n");
    }

    // Bitwise XOR
    print("\nTesting bitwise_xor...\n");
    if test_bitwise_xor() == 1 {
        print("bitwise_xor: PASS\n");
        passed = passed + 1;
    } else {
        print("bitwise_xor: FAIL\n");
    }

    print("\nTesting xor_toggle...\n");
    if test_xor_toggle() == 1 {
        print("xor_toggle: PASS\n");
        passed = passed + 1;
    } else {
        print("xor_toggle: FAIL\n");
    }

    print("\nTesting xor_cancel...\n");
    if test_xor_cancel() == 1 {
        print("xor_cancel: PASS\n");
        passed = passed + 1;
    } else {
        print("xor_cancel: FAIL\n");
    }

    // Left shift
    print("\nTesting left_shift...\n");
    if test_left_shift() == 1 {
        print("left_shift: PASS\n");
        passed = passed + 1;
    } else {
        print("left_shift: FAIL\n");
    }

    print("\nTesting shift_multiply...\n");
    if test_shift_multiply() == 1 {
        print("shift_multiply: PASS\n");
        passed = passed + 1;
    } else {
        print("shift_multiply: FAIL\n");
    }

    print("\nTesting multiple_shifts...\n");
    if test_multiple_shifts() == 1 {
        print("multiple_shifts: PASS\n");
        passed = passed + 1;
    } else {
        print("multiple_shifts: FAIL\n");
    }

    // Right shift
    print("\nTesting right_shift...\n");
    if test_right_shift() == 1 {
        print("right_shift: PASS\n");
        passed = passed + 1;
    } else {
        print("right_shift: FAIL\n");
    }

    print("\nTesting shift_divide...\n");
    if test_shift_divide() == 1 {
        print("shift_divide: PASS\n");
        passed = passed + 1;
    } else {
        print("shift_divide: FAIL\n");
    }

    print("\nTesting extract_bits...\n");
    if test_extract_bits() == 1 {
        print("extract_bits: PASS\n");
        passed = passed + 1;
    } else {
        print("extract_bits: FAIL\n");
    }

    // Combined operations
    print("\nTesting set_bit...\n");
    if test_set_bit() == 1 {
        print("set_bit: PASS\n");
        passed = passed + 1;
    } else {
        print("set_bit: FAIL\n");
    }

    print("\nTesting clear_bit...\n");
    if test_clear_bit() == 1 {
        print("clear_bit: PASS\n");
        passed = passed + 1;
    } else {
        print("clear_bit: FAIL\n");
    }

    print("\nTesting toggle_bit...\n");
    if test_toggle_bit() == 1 {
        print("toggle_bit: PASS\n");
        passed = passed + 1;
    } else {
        print("toggle_bit: FAIL\n");
    }

    print("\nTesting check_bit...\n");
    if test_check_bit() == 1 {
        print("check_bit: PASS\n");
        passed = passed + 1;
    } else {
        print("check_bit: FAIL\n");
    }

    // Tuples
    print("\nTesting unit_tuple...\n");
    if test_unit_tuple() == 1 {
        print("unit_tuple: PASS\n");
        passed = passed + 1;
    } else {
        print("unit_tuple: FAIL\n");
    }

    print("\nTesting create_tuple...\n");
    if test_create_tuple() == 1 {
        print("create_tuple: PASS\n");
        passed = passed + 1;
    } else {
        print("create_tuple: FAIL\n");
    }

    print("\nTesting tuple_values...\n");
    if test_tuple_values() == 1 {
        print("tuple_values: PASS\n");
        passed = passed + 1;
    } else {
        print("tuple_values: FAIL\n");
    }

    print("\nTesting tuple_pair...\n");
    if test_tuple_pair() == 1 {
        print("tuple_pair: PASS\n");
        passed = passed + 1;
    } else {
        print("tuple_pair: FAIL\n");
    }

    print("\nTesting tuple_expression...\n");
    if test_tuple_expression() == 1 {
        print("tuple_expression: PASS\n");
        passed = passed + 1;
    } else {
        print("tuple_expression: FAIL\n");
    }

    print("\n=== Summary ===\n");
    print("Passed: ");
    print_i64(passed);
    print(" / ");
    print_i64(total);
    print("\n");

    passed
}
