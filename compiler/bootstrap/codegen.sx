// Minimal Simplex Code Generator
// CONSTRAINT: Only uses features stage1 supports
// No: impl, self, for, match, traits, generics
// Outputs LLVM IR

// AST tags - duplicated from parser.sx for standalone compilation
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }

// Binary operators - must match parser.sx
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }
fn OP_NEG() -> i64 { 100 }
fn OP_NOT() -> i64 { 101 }

// Codegen state
fn codegen_new() -> i64 {
    // Allocate codegen: output(0), temp_counter(1), label_counter(2), enums(3), locals(4), strings(5), terminated(6), structs(7), var_types(8), loop_stack(9), loop_depth(10), pre_alloca_queue(11), module_name(12)
    let cg: i64 = malloc(104);
    store_ptr(cg, 0, string_from(""));
    store_i64(cg, 1, 0);
    store_i64(cg, 2, 0);
    store_ptr(cg, 3, vec_new());  // registered enums: vec of (name, variants)
    store_ptr(cg, 4, vec_new());  // local variables in current function
    store_ptr(cg, 5, vec_new());  // string constants: vec of string values
    store_i64(cg, 6, 0);          // terminated flag (set after ret)
    store_ptr(cg, 7, vec_new());  // registered structs: vec of (name, fields)
    store_ptr(cg, 8, vec_new());  // variable types: vec of (name, type_name) pairs
    store_ptr(cg, 9, vec_new());  // loop_stack: vec of (continue_label, break_label) pairs
    store_i64(cg, 10, 0);         // loop_depth: current depth in loop stack
    store_ptr(cg, 11, vec_new()); // pre_alloca_queue: pre-allocated local names in order
    store_ptr(cg, 12, string_from("mod")); // module_name: prefix for string constants
    cg
}

fn cg_module_name(cg: i64) -> i64 {
    load_ptr(cg, 12)
}

fn cg_set_module_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 12, name);
    0
}

fn cg_alloca_queue(cg: i64) -> i64 {
    load_ptr(cg, 11)
}

fn cg_clear_alloca_queue(cg: i64) -> i64 {
    store_ptr(cg, 11, vec_new());
    0
}

fn cg_push_alloca(cg: i64, unique_name: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    vec_push(queue, unique_name);
    0
}

fn cg_pop_alloca(cg: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    let len: i64 = vec_len(queue);
    if len == 0 {
        return 0;
    }
    let name: i64 = vec_get(queue, 0);
    // Shift queue (remove first element by building new vec)
    let new_queue: i64 = vec_new();
    let i: i64 = 1;
    while i < len {
        vec_push(new_queue, vec_get(queue, i));
        i = i + 1;
    }
    store_ptr(cg, 11, new_queue);
    name
}

// Collect all local variable names from a block (recursive)
// Returns a vector of variable names in declaration order
fn collect_locals_from_expr(expr: i64, result: i64) -> i64 {
    if expr == 0 {
        return 0;
    }
    let tag: i64 = load_i64(expr, 0);

    // Block - process stmts and result expr
    if tag == EXPR_BLOCK() {
        let stmts: i64 = load_ptr(expr, 1);
        let result_expr: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(stmts);
        let i: i64 = 0;
        while i < n {
            let stmt: i64 = vec_get(stmts, i);
            collect_locals_from_stmt(stmt, result);
            i = i + 1;
        }
        if result_expr != 0 {
            collect_locals_from_expr(result_expr, result);
        }
        return 0;
    }

    // If expression - process then/else blocks
    if tag == EXPR_IF() {
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        collect_locals_from_expr(then_block, result);
        if else_block != 0 {
            collect_locals_from_expr(else_block, result);
        }
        return 0;
    }

    // While expression - process body
    if tag == EXPR_WHILE() {
        let body: i64 = load_ptr(expr, 2);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // For expression - collect loop var and process body
    if tag == EXPR_FOR() {
        let var_name: i64 = load_ptr(expr, 1);
        vec_push(result, var_name);
        let body: i64 = load_ptr(expr, 4);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // Match expression - process arms
    if tag == EXPR_MATCH() {
        let arms: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(arms);
        let i: i64 = 0;
        while i < n {
            let arm: i64 = vec_get(arms, i);
            let body: i64 = load_ptr(arm, 1);
            collect_locals_from_expr(body, result);
            i = i + 1;
        }
        return 0;
    }

    0
}

fn collect_locals_from_stmt(stmt: i64, result: i64) -> i64 {
    if stmt == 0 {
        return 0;
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement - collect the variable name
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        vec_push(result, name);
        // Also check init expression for nested blocks
        let init_expr: i64 = load_ptr(stmt, 3);
        if init_expr != 0 {
            collect_locals_from_expr(init_expr, result);
        }
        return 0;
    }

    // Expression statement - check for blocks
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        collect_locals_from_expr(expr, result);
        return 0;
    }

    // Return statement - check expression
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            collect_locals_from_expr(expr, result);
        }
        return 0;
    }

    0
}

fn collect_locals_from_block(block: i64) -> i64 {
    let result: i64 = vec_new();
    collect_locals_from_expr(block, result);
    result
}

fn cg_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_next_temp(cg: i64) -> i64 {
    let t: i64 = load_i64(cg, 1);
    store_i64(cg, 1, t + 1);
    t
}

fn cg_next_label(cg: i64) -> i64 {
    let l: i64 = load_i64(cg, 2);
    store_i64(cg, 2, l + 1);
    l
}

fn cg_enums(cg: i64) -> i64 {
    load_ptr(cg, 3)
}

fn cg_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_clear_locals(cg: i64) -> i64 {
    store_ptr(cg, 4, vec_new());
    store_ptr(cg, 8, vec_new());  // Also clear var_types
    store_ptr(cg, 9, vec_new());  // Also clear loop_stack
    store_i64(cg, 10, 0);         // Reset loop_depth
    0
}

fn cg_strings(cg: i64) -> i64 {
    load_ptr(cg, 5)
}

// Variable type tracking for method calls
fn cg_var_types(cg: i64) -> i64 {
    load_ptr(cg, 8)
}

// Add variable type: stores (var_name, type_name) pair
fn add_var_type(cg: i64, var_name: i64, type_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, var_name);
    store_ptr(pair, 1, type_name);
    vec_push(var_types, pair);
    0
}

// Lookup variable type by name (returns type_name or 0 if not found)
fn lookup_var_type(cg: i64, var_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let n: i64 = vec_len(var_types);
    // Search backwards to get most recent binding
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(var_types, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, var_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    0
}

fn cg_is_terminated(cg: i64) -> bool {
    load_i64(cg, 6) != 0
}

fn cg_set_terminated(cg: i64, val: bool) -> i64 {
    if val != false {
        store_i64(cg, 6, 1);
    } else {
        store_i64(cg, 6, 0);
    }
    0
}

// Add a string constant and return its index
fn cg_add_string(cg: i64, value: i64) -> i64 {
    let strings: i64 = cg_strings(cg);
    let idx: i64 = vec_len(strings);
    vec_push(strings, value);
    idx
}

// Emit to output buffer
fn emit(cg: i64, s: i64) -> i64 {
    let out: i64 = cg_output(cg);
    let new_out: i64 = string_concat(out, s);
    store_ptr(cg, 0, new_out);
    0
}

fn emit_line(cg: i64, s: i64) -> i64 {
    emit(cg, s);
    emit(cg, "\n");
    0
}

// Register an enum
fn register_enum(cg: i64, name: i64, variants: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, variants);
    vec_push(enums, entry);
    0
}

// Look up enum variant index
fn lookup_variant(cg: i64, enum_name: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, enum_name) {
            let variants: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(variants);
            let j: i64 = 0;
            while j < m {
                let v: i64 = vec_get(variants, j);
                if string_eq(v, var_name) {
                    return j;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Get structs vector
fn cg_structs(cg: i64) -> i64 {
    load_ptr(cg, 7)
}

// Get loop stack (for break/continue)
fn cg_loop_stack(cg: i64) -> i64 {
    load_ptr(cg, 9)
}

// Get loop depth
fn cg_loop_depth(cg: i64) -> i64 {
    load_i64(cg, 10)
}

// Push loop context onto stack - pair is (continue_label, break_label)
fn push_loop(cg: i64, continue_label: i64, break_label: i64) -> i64 {
    let stack: i64 = cg_loop_stack(cg);
    let depth: i64 = cg_loop_depth(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, continue_label);
    store_ptr(pair, 1, break_label);
    vec_push(stack, pair);
    store_i64(cg, 10, depth + 1);
    0
}

// Pop loop context from stack
fn pop_loop(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth > 0 {
        let new_depth: i64 = depth - 1;
        store_i64(cg, 10, new_depth);
        // When exiting all loops, clear the stack to prevent stale entries
        // from affecting subsequent loops in the same function
        if new_depth == 0 {
            store_ptr(cg, 9, vec_new());
        }
    }
    0
}

// Get current loop continue label (top of stack)
fn current_loop_continue(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 0)
}

// Get current loop break label (top of stack)
fn current_loop_break(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 1)
}

// Register a struct
fn register_struct(cg: i64, name: i64, fields: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, fields);
    vec_push(structs, entry);
    0
}

// Look up struct field index (returns byte offset = index * 8)
fn lookup_struct_field(cg: i64, struct_name: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            let fields: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(fields);
            let j: i64 = 0;
            while j < m {
                let field: i64 = vec_get(fields, j);
                let fname: i64 = load_ptr(field, 0);
                if string_eq(fname, field_name) {
                    return j;  // Return field index
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Get struct fields by name
fn lookup_struct_fields(cg: i64, struct_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Look up field in all registered structs (for field access without type info)
fn lookup_field_in_all_structs(cg: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let fields: i64 = load_ptr(entry, 1);
        let m: i64 = vec_len(fields);
        let j: i64 = 0;
        while j < m {
            let field: i64 = vec_get(fields, j);
            let fname: i64 = load_ptr(field, 0);
            if string_eq(fname, field_name) {
                return j;  // Return field index
            }
            j = j + 1;
        }
        i = i + 1;
    }
    0
}

// Add local: stores (original_name, unique_name) pair
fn add_local(cg: i64, original_name: i64, unique_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, original_name);
    store_ptr(pair, 1, unique_name);
    vec_push(locals, pair);
    0
}

// Lookup local: find most recent unique_name for original_name
fn lookup_local(cg: i64, original_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let n: i64 = vec_len(locals);
    // Search backwards to get most recent
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(locals, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, original_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    // Not found - return original (shouldn't happen for valid code)
    original_name
}

// Generate expression - returns the LLVM value (temp name or literal)
fn gen_expr(cg: i64, expr: i64) -> i64 {
    // Guard against null expressions
    if expr == 0 {
        return string_from("0");
    }
    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == EXPR_INT() {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == EXPR_BOOL() {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("1");
        }
        return string_from("0");
    }

    // String literal - allocate and initialize
    if tag == EXPR_STRING() {
        let value: i64 = load_ptr(expr, 1);
        let str_idx: i64 = cg_add_string(cg, value);  // Track the string constant
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        // Emit call to intrinsic_string_new with the string constant
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
        emit(cg, cg_module_name(cg));
        emit(cg, ".");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");

        // Convert ptr to i64 for consistent type handling
        let t2: i64 = cg_next_temp(cg);
        let temp2: i64 = string_concat("%t", int_to_string(t2));
        emit(cg, "  ");
        emit(cg, temp2);
        emit(cg, " = ptrtoint ptr ");
        emit(cg, temp);
        emit_line(cg, " to i64");

        return temp2;
    }

    // Identifier - load from local
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);
        let unique_name: i64 = lookup_local(cg, name);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = load i64, ptr %local.");
        emit_line(cg, unique_name);

        return temp;
    }

    // Path - enum variant
    if tag == EXPR_PATH() {
        let segments: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(segments);
        if len == 2 {
            let enum_name: i64 = vec_get(segments, 0);
            let var_name: i64 = vec_get(segments, 1);
            let idx: i64 = lookup_variant(cg, enum_name, var_name);
            return int_to_string(idx);
        }
        return string_from("0");
    }

    // Function call
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);

        // Get function name
        let callee_name: i64 = load_ptr(callee, 1);

        // Generate args
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Check for intrinsics - emit with proper type conversions
        // Pattern: convert i64 args to ptr, call intrinsic, convert ptr result to i64

        // string_from: argument is already a string handle from EXPR_STRING
        if string_eq(callee_name, "string_from") {
            return vec_get(arg_values, 0);
        }

        // void intrinsics (return "0")
        if string_eq(callee_name, "println") {
            emit_intrinsic_void_ptr(cg, "intrinsic_println", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_push") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_vec_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "write_file") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_write_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "free") {
            emit_intrinsic_void_ptr(cg, "free", vec_get(arg_values, 0));
            return string_from("0");
        }

        // i64 result intrinsics
        if string_eq(callee_name, "string_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_char_at") {
            return emit_intrinsic_i64_ptr_i64(cg, "intrinsic_string_char_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_to_int") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_to_int", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_vec_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_i64") {
            return emit_intrinsic_i64_ptr_i64(cg, "load_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_eq") {
            return emit_intrinsic_i1_ptr_ptr(cg, "intrinsic_string_eq", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // ptr result intrinsics -> convert to i64
        if string_eq(callee_name, "string_concat") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_concat", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_slice") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "intrinsic_string_slice", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "int_to_string") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_int_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_from_char") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_string_from_char", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_vec_new");
        }
        if string_eq(callee_name, "vec_get") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_vec_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_args") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_args");
        }
        if string_eq(callee_name, "read_file") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_read_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "malloc") {
            return emit_intrinsic_ptr_i64(cg, "malloc", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_ptr") {
            return emit_intrinsic_ptr_ptr_i64(cg, "load_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "store_ptr") {
            return emit_intrinsic_ptr_ptr_i64_ptr(cg, "store_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "store_i64") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "store_i64", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }

        // Default: emit call as user function
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(");

        i = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Binary operation
    if tag == EXPR_BINARY() {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        // Short-circuit evaluation for && and ||
        // Use simple approach: evaluate both and use logical and/or
        // This is simpler than proper phi-based short-circuit
        if op == OP_AND() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // and i1
            let and_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(and_t));
            emit(cg, " = and i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(and_t));
            emit_line(cg, " to i64");

            return result;
        }

        if op == OP_OR() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // or i1
            let or_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(or_t));
            emit(cg, " = or i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(or_t));
            emit_line(cg, " to i64");

            return result;
        }

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = ");

        let is_cmp: bool = false;
        if op == OP_ADD() { emit(cg, "add i64 "); }
        if op == OP_SUB() { emit(cg, "sub i64 "); }
        if op == OP_MUL() { emit(cg, "mul i64 "); }
        if op == OP_DIV() { emit(cg, "sdiv i64 "); }
        if op == OP_MOD() { emit(cg, "srem i64 "); }
        if op == OP_BITAND() { emit(cg, "and i64 "); }
        if op == OP_BITOR() { emit(cg, "or i64 "); }
        if op == OP_BITXOR() { emit(cg, "xor i64 "); }
        if op == OP_SHL() { emit(cg, "shl i64 "); }
        if op == OP_SHR() { emit(cg, "ashr i64 "); }
        if op == OP_EQ() { emit(cg, "icmp eq i64 "); is_cmp = true; }
        if op == OP_NE() { emit(cg, "icmp ne i64 "); is_cmp = true; }
        if op == OP_LT() { emit(cg, "icmp slt i64 "); is_cmp = true; }
        if op == OP_GT() { emit(cg, "icmp sgt i64 "); is_cmp = true; }
        if op == OP_LE() { emit(cg, "icmp sle i64 "); is_cmp = true; }
        if op == OP_GE() { emit(cg, "icmp sge i64 "); is_cmp = true; }

        emit(cg, left_val);
        emit(cg, ", ");
        emit_line(cg, right_val);

        // If comparison, zext from i1 to i64
        if is_cmp {
            let t2: i64 = cg_next_temp(cg);
            let temp2: i64 = string_concat("%t", int_to_string(t2));
            emit(cg, "  ");
            emit(cg, temp2);
            emit(cg, " = zext i1 ");
            emit(cg, temp);
            emit_line(cg, " to i64");
            return temp2;
        }

        return temp;
    }

    // Unary operation
    if tag == EXPR_UNARY() {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        let val: i64 = gen_expr(cg, operand);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);

        if op == OP_NEG() {
            emit(cg, " = sub i64 0, ");
            emit_line(cg, val);
        }
        if op == OP_NOT() {
            emit(cg, " = xor i1 ");
            emit(cg, val);
            emit_line(cg, ", 1");
        }

        return temp;
    }

    // If expression
    if tag == EXPR_IF() {
        return gen_if(cg, expr);
    }

    // While expression
    if tag == EXPR_WHILE() {
        return gen_while(cg, expr);
    }

    // For expression
    if tag == EXPR_FOR() {
        return gen_for(cg, expr);
    }

    // Match expression
    if tag == EXPR_MATCH() {
        return gen_match(cg, expr);
    }

    // Block expression
    if tag == EXPR_BLOCK() {
        return gen_block(cg, expr);
    }

    // Struct literal: Foo { x: 1, y: 2 }
    if tag == EXPR_STRUCT_LIT() {
        let struct_name: i64 = load_ptr(expr, 1);
        let field_inits: i64 = load_ptr(expr, 2);
        let num_fields: i64 = vec_len(field_inits);

        // Allocate struct: malloc(num_fields * 8)
        let alloc_size: i64 = num_fields * 8;
        let t: i64 = cg_next_temp(cg);
        let ptr_temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, ptr_temp);
        emit(cg, " = call ptr @malloc(i64 ");
        emit(cg, int_to_string(alloc_size));
        emit_line(cg, ")");

        // Get the struct field order from definition
        let fields: i64 = lookup_struct_fields(cg, struct_name);

        // Initialize each field
        let i: i64 = 0;
        while i < num_fields {
            let field_init: i64 = vec_get(field_inits, i);
            let field_name: i64 = load_ptr(field_init, 0);
            let field_expr: i64 = load_ptr(field_init, 1);

            // Generate field value
            let field_val: i64 = gen_expr(cg, field_expr);

            // Look up field offset
            let field_idx: i64 = lookup_struct_field(cg, struct_name, field_name);
            let offset: i64 = field_idx * 8;

            // Store field using getelementptr + store
            let gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(gep_t));
            emit(cg, " = getelementptr i8, ptr ");
            emit(cg, ptr_temp);
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(offset));

            emit(cg, "  store i64 ");
            emit(cg, field_val);
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(gep_t));

            i = i + 1;
        }

        // Convert ptr to i64
        return emit_ptr_to_i64(cg, ptr_temp);
    }

    // Field access: expr.field
    if tag == EXPR_FIELD() {
        let object: i64 = load_ptr(expr, 1);
        let field_name: i64 = load_ptr(expr, 2);

        // Generate object value (pointer as i64)
        let obj_val: i64 = gen_expr(cg, object);

        // Convert i64 to ptr
        let ptr_temp: i64 = emit_i64_to_ptr(cg, obj_val);

        // For now, we need to figure out the struct type from context
        // We'll do a simple approach: try all structs and find one with this field
        let field_idx: i64 = lookup_field_in_all_structs(cg, field_name);
        let offset: i64 = field_idx * 8;

        // GEP to field
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr ");
        emit(cg, ptr_temp);
        emit(cg, ", i64 ");
        emit_line(cg, int_to_string(offset));

        // Load field value
        let load_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(load_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(load_t));
    }

    // Method call: expr.method(args)
    if tag == EXPR_METHOD_CALL() {
        let object: i64 = load_ptr(expr, 1);
        let method_name: i64 = load_ptr(expr, 2);
        let args: i64 = load_ptr(expr, 3);

        // Try to get the type of the object
        let type_name: i64 = 0;

        // If object is an identifier, look up its type
        let obj_tag: i64 = load_i64(object, 0);
        if obj_tag == EXPR_IDENT() {
            let obj_name: i64 = load_ptr(object, 1);
            type_name = lookup_var_type(cg, obj_name);
        }

        // Generate object value (this will be the first argument)
        let obj_val: i64 = gen_expr(cg, object);

        // Generate remaining arguments
        let arg_values: i64 = vec_new();
        vec_push(arg_values, obj_val);  // Object is first argument
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Build mangled function name: TypeName_methodName
        let callee_name: i64 = method_name;
        if type_name != 0 {
            callee_name = string_concat(type_name, string_concat(string_from("_"), method_name));
        }

        // Emit call
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(");

        let total_args: i64 = vec_len(arg_values);
        i = 0;
        while i < total_args {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    string_from("0")
}

// Generate if expression
fn gen_if(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let then_block: i64 = load_ptr(expr, 2);
    let else_block: i64 = load_ptr(expr, 3);

    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    let l: i64 = cg_next_label(cg);
    let then_lbl: i64 = string_concat("then", int_to_string(l));
    let then_end_lbl: i64 = string_concat("then", int_to_string(l));
    then_end_lbl = string_concat(then_end_lbl, "_end");
    let else_lbl: i64 = string_concat("else", int_to_string(l));
    let else_end_lbl: i64 = string_concat("else", int_to_string(l));
    else_end_lbl = string_concat(else_end_lbl, "_end");
    let end_lbl: i64 = string_concat("endif", int_to_string(l));

    // Branch
    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, then_lbl);
    emit(cg, ", label %");
    emit_line(cg, else_lbl);

    // Then block
    emit(cg, then_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let then_val: i64 = gen_block(cg, then_block);
    let then_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, then_end_lbl);
    // Then end block
    emit(cg, then_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Else block
    emit(cg, else_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let else_val: i64 = string_from("0");
    if else_block != 0 {
        else_val = gen_expr(cg, else_block);
    }
    let else_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, else_end_lbl);
    // Else end block
    emit(cg, else_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);

    // Phi with proper predecessor blocks
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = phi i64 [ ");
    emit(cg, then_val);
    emit(cg, ", %");
    emit(cg, then_end_lbl);
    emit(cg, " ], [ ");
    emit(cg, else_val);
    emit(cg, ", %");
    emit(cg, else_end_lbl);
    emit_line(cg, " ]");

    temp
}

// Generate while expression
fn gen_while(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let body: i64 = load_ptr(expr, 2);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let body_lbl: i64 = string_concat("body", int_to_string(l));
    let end_lbl: i64 = string_concat("endloop", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, loop_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate for expression: for i in start..end { body }
// Desugars to: let i = start; while i < end { body; i = i + 1; }
fn gen_for(cg: i64, expr: i64) -> i64 {
    let var_name: i64 = load_ptr(expr, 1);
    let start_expr: i64 = load_ptr(expr, 2);
    let end_expr: i64 = load_ptr(expr, 3);
    let body: i64 = load_ptr(expr, 4);

    // Generate start value
    let start_val: i64 = gen_expr(cg, start_expr);

    // Use pre-allocated local for loop variable
    let unique_name: i64 = cg_pop_alloca(cg);
    if unique_name == 0 {
        // Fallback: allocate inline (shouldn't happen with proper pre-pass)
        let local_id: i64 = cg_next_temp(cg);
        unique_name = string_concat(var_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
    }
    // Initialize loop variable
    emit(cg, "  store i64 ");
    emit(cg, start_val);
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);
    add_local(cg, var_name, unique_name);

    // Generate end value (before the loop since it's evaluated once)
    let end_val: i64 = gen_expr(cg, end_expr);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("for", int_to_string(l));
    let body_lbl: i64 = string_concat("forbody", int_to_string(l));
    let inc_lbl: i64 = string_concat("forinc", int_to_string(l));
    let end_lbl: i64 = string_concat("endfor", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition: i < end
    emit(cg, loop_lbl);
    emit_line(cg, ":");

    // Load current loop variable
    let cur_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    // Compare i < end
    let cmp_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, " = icmp slt i64 %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, ", ");
    emit_line(cg, end_val);

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, inc_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, inc_lbl);

    // Increment loop variable: i = i + 1
    emit(cg, inc_lbl);
    emit_line(cg, ":");
    let load_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(load_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    let inc_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, " = add i64 %t");
    emit(cg, int_to_string(load_t));
    emit_line(cg, ", 1");

    emit(cg, "  store i64 %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate match expression
// Lowered to a series of if-else comparisons
fn gen_match(cg: i64, expr: i64) -> i64 {
    let scrutinee: i64 = load_ptr(expr, 1);
    let arms: i64 = load_ptr(expr, 2);
    let num_arms: i64 = vec_len(arms);

    // Evaluate scrutinee once
    let scru_val: i64 = gen_expr(cg, scrutinee);

    let l: i64 = cg_next_label(cg);
    let end_lbl: i64 = string_concat("matchend", int_to_string(l));

    // Collect arm labels and results for phi
    let arm_labels: i64 = vec_new();
    let arm_results: i64 = vec_new();

    // Process each arm
    let i: i64 = 0;
    while i < num_arms {
        let arm: i64 = vec_get(arms, i);
        let pattern: i64 = load_ptr(arm, 0);
        let result: i64 = load_ptr(arm, 1);

        let arm_lbl: i64 = string_concat("arm", int_to_string(l));
        arm_lbl = string_concat(arm_lbl, string_concat("_", int_to_string(i)));
        let arm_end_lbl: i64 = string_concat(arm_lbl, "_end");
        let next_lbl: i64 = string_concat("arm", int_to_string(l));
        next_lbl = string_concat(next_lbl, string_concat("_", int_to_string(i + 1)));

        // Check if this is the last arm or wildcard
        let is_last: i64 = i == num_arms - 1;
        let is_wildcard: i64 = pattern == 0;

        if is_wildcard != 0 {
            // Wildcard - unconditional jump to arm
            emit(cg, "  br label %");
            emit_line(cg, arm_lbl);
        } else {
            // Generate pattern value
            let pat_val: i64 = gen_expr(cg, pattern);

            // Compare scrutinee == pattern
            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 ");
            emit(cg, scru_val);
            emit(cg, ", ");
            emit_line(cg, pat_val);

            // Branch: if match goto arm, else goto next/end
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, arm_lbl);
            emit(cg, ", label %");
            if is_last != 0 {
                // Last arm without wildcard - shouldn't happen in well-formed match
                emit_line(cg, end_lbl);
            } else {
                emit_line(cg, next_lbl);
            }
        }

        // Arm body
        emit(cg, arm_lbl);
        emit_line(cg, ":");
        cg_set_terminated(cg, false);
        let arm_val: i64 = gen_expr(cg, result);
        emit(cg, "  br label %");
        emit_line(cg, arm_end_lbl);

        // Arm end block for phi
        emit(cg, arm_end_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, end_lbl);

        vec_push(arm_labels, arm_end_lbl);
        vec_push(arm_results, arm_val);

        i = i + 1;
    }

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");

    let result_t: i64 = cg_next_temp(cg);
    let result_temp: i64 = string_concat("%t", int_to_string(result_t));
    emit(cg, "  ");
    emit(cg, result_temp);
    emit(cg, " = phi i64 ");

    i = 0;
    while i < num_arms {
        if i > 0 {
            emit(cg, ", ");
        }
        emit(cg, "[ ");
        emit(cg, vec_get(arm_results, i));
        emit(cg, ", %");
        emit(cg, vec_get(arm_labels, i));
        emit(cg, " ]");
        i = i + 1;
    }
    emit_line(cg, "");

    result_temp
}

// Generate block
fn gen_block(cg: i64, block: i64) -> i64 {
    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);

    let n: i64 = vec_len(stmts);
    let i: i64 = 0;
    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        gen_stmt(cg, stmt);
        i = i + 1;
    }

    if result != 0 {
        return gen_expr(cg, result);
    }

    string_from("0")
}

// Generate statement
fn gen_stmt(cg: i64, stmt: i64) -> i64 {
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        let ty: i64 = load_ptr(stmt, 2);
        let init_expr: i64 = load_ptr(stmt, 3);

        // Use pre-allocated local from entry block
        let unique_name: i64 = cg_pop_alloca(cg);
        if unique_name == 0 {
            // Fallback: allocate inline (shouldn't happen with proper pre-pass)
            let local_id: i64 = cg_next_temp(cg);
            unique_name = string_concat(name, string_concat(".", int_to_string(local_id)));
            emit(cg, "  %local.");
            emit(cg, unique_name);
            emit_line(cg, " = alloca i64");
        }
        add_local(cg, name, unique_name);

        // Record type if present (for method call resolution)
        if ty != 0 {
            add_var_type(cg, name, ty);
        }

        // Initialize if there's an init expression
        if init_expr != 0 {
            let val: i64 = gen_expr(cg, init_expr);
            emit(cg, "  store i64 ");
            emit(cg, val);
            emit(cg, ", ptr %local.");
            emit_line(cg, unique_name);
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            gen_expr(cg, expr);
        }
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            let val: i64 = gen_expr(cg, expr);
            emit(cg, "  ret i64 ");
            emit_line(cg, val);
        } else {
            emit_line(cg, "  ret void");
        }
        cg_set_terminated(cg, true);
        return 0;
    }

    // Assignment statement
    if tag == STMT_ASSIGN() {
        let name: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        let val: i64 = gen_expr(cg, value);
        let unique_name: i64 = lookup_local(cg, name);
        emit(cg, "  store i64 ");
        emit(cg, val);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        return 0;
    }

    // Break statement
    if tag == STMT_BREAK() {
        let break_lbl: i64 = current_loop_break(cg);
        if break_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, break_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_break");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    // Continue statement
    if tag == STMT_CONTINUE() {
        let continue_lbl: i64 = current_loop_continue(cg);
        if continue_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, continue_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_continue");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    0
}

// Generate function
fn gen_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let params: i64 = load_ptr(fn_def, 2);
    let ret_ty: i64 = load_ptr(fn_def, 3);
    let body: i64 = load_ptr(fn_def, 4);

    // Rename main to simplex_main
    let emit_name: i64 = name;
    if string_eq(name, "main") {
        emit_name = string_from("simplex_main");
    }

    cg_clear_locals(cg);

    // Function signature
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, emit_name);
    emit(cg, "\"(");

    // Parameters
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate ALL local variables in the entry block to avoid
    // allocas in loops/conditionals which cause stack corruption
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // Copy params to locals
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);  // Params use same name
        i = i + 1;
    }

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Only emit final return if body didn't already terminate
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Generate enum (just register it)
fn gen_enum(cg: i64, enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    register_enum(cg, name, variants);
    0
}

// Generate struct (just register it)
fn gen_struct(cg: i64, struct_def: i64) -> i64 {
    let name: i64 = load_ptr(struct_def, 1);
    let fields: i64 = load_ptr(struct_def, 2);
    register_struct(cg, name, fields);
    0
}

// Generate impl block
// Methods are generated with mangled names: TypeName_methodName
fn gen_impl(cg: i64, impl_def: i64) -> i64 {
    let type_name: i64 = load_ptr(impl_def, 1);
    let methods: i64 = load_ptr(impl_def, 2);
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Get method name and mangle it: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = string_concat(type_name, string_concat(string_from("_"), method_name));
        // Store mangled name back into the method AST
        store_ptr(method, 1, mangled_name);
        // Generate the function
        gen_fn(cg, method);
        i = i + 1;
    }
    0
}

// Generate item
fn gen_item(cg: i64, item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == TAG_FN() {
        return gen_fn(cg, item);
    }
    if tag == TAG_ENUM() {
        return gen_enum(cg, item);
    }
    if tag == TAG_STRUCT() {
        return gen_struct(cg, item);
    }
    if tag == TAG_IMPL() {
        return gen_impl(cg, item);
    }
    0
}

// Generate program header
fn gen_header(cg: i64) -> i64 {
    emit_line(cg, "; ModuleID = 'simplex_program'");
    emit_line(cg, "target triple = \"x86_64-apple-macosx14.0.0\"");
    emit_line(cg, "");
    emit_line(cg, "declare ptr @malloc(i64)");
    emit_line(cg, "declare void @free(ptr)");
    emit_line(cg, "declare void @intrinsic_println(ptr)");
    emit_line(cg, "declare ptr @intrinsic_int_to_string(i64)");
    emit_line(cg, "declare ptr @intrinsic_string_new(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_from_char(i64)");
    emit_line(cg, "declare i64 @intrinsic_string_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_concat(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_slice(ptr, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_string_char_at(ptr, i64)");
    emit_line(cg, "declare i1 @intrinsic_string_eq(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_to_int(ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_new()");
    emit_line(cg, "declare void @intrinsic_vec_push(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_get(ptr, i64)");
    emit_line(cg, "declare i64 @intrinsic_vec_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_args()");
    emit_line(cg, "declare ptr @intrinsic_read_file(ptr)");
    emit_line(cg, "declare void @intrinsic_write_file(ptr, ptr)");
    emit_line(cg, "declare ptr @store_ptr(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @store_i64(ptr, i64, i64)");
    emit_line(cg, "declare ptr @load_ptr(ptr, i64)");
    emit_line(cg, "declare i64 @load_i64(ptr, i64)");
    emit_line(cg, "");
    0
}

// Emit a string constant in LLVM format
fn emit_string_constant(cg: i64, idx: i64, value: i64) -> i64 {
    // For simplicity, just emit the string with basic escaping
    // Format: @.str.MODULE.N = private unnamed_addr constant [LEN x i8] c"STRING\00"
    let len: i64 = string_len(value);

    emit(cg, "@.str.");
    emit(cg, cg_module_name(cg));
    emit(cg, ".");
    emit(cg, int_to_string(idx));
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(len + 1));  // +1 for null terminator
    emit(cg, " x i8] c\"");

    // Emit string with escaping
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(value, i);
        if c == 10 {
            // newline -> \0A
            emit(cg, "\\0A");
        } else {
            if c == 9 {
                // tab -> \09
                emit(cg, "\\09");
            } else {
                if c == 34 {
                    // quote -> \22
                    emit(cg, "\\22");
                } else {
                    if c == 92 {
                        // backslash -> \5C
                        emit(cg, "\\5C");
                    } else {
                        // Regular character
                        emit(cg, string_slice(value, i, i + 1));
                    }
                }
            }
        }
        i = i + 1;
    }

    emit_line(cg, "\\00\"");
    0
}

// Generate entire program with module name for unique string prefixes
fn gen_program_with_module(items: i64, module_name: i64) -> i64 {
    let cg: i64 = codegen_new();
    cg_set_module_name(cg, module_name);
    gen_header(cg);

    // First pass: register enums and structs
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        if tag == TAG_STRUCT() {
            gen_struct(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions and impl blocks
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        if tag == TAG_IMPL() {
            gen_impl(cg, item);
        }
        i = i + 1;
    }

    // Emit string constants
    let strings: i64 = cg_strings(cg);
    let str_count: i64 = vec_len(strings);
    if str_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; String constants");
        i = 0;
        while i < str_count {
            let value: i64 = vec_get(strings, i);
            emit_string_constant(cg, i, value);
            i = i + 1;
        }
    }

    cg_output(cg)
}

// Backward-compatible wrapper using default module name
fn gen_program(items: i64) -> i64 {
    gen_program_with_module(items, string_from("mod"))
}

// Helper functions for intrinsic emission with type conversions
// These handle the i64 <-> ptr conversions needed at boundaries

// Helper: convert i64 to ptr using inttoptr
fn emit_i64_to_ptr(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = inttoptr i64 ");
    emit(cg, val);
    emit_line(cg, " to ptr");
    temp
}

// Helper: convert ptr to i64 using ptrtoint
fn emit_ptr_to_i64(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = ptrtoint ptr ");
    emit(cg, val);
    emit_line(cg, " to i64");
    temp
}

// void intrinsic(ptr)
fn emit_intrinsic_void_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, ptr)
fn emit_intrinsic_void_ptr2(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr)
fn emit_intrinsic_i64_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, i64)
fn emit_intrinsic_i64_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i1 intrinsic(ptr, ptr) -> zext to i64
fn emit_intrinsic_i1_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i1 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    // zext i1 to i64
    let t2: i64 = cg_next_temp(cg);
    let temp2: i64 = string_concat("%t", int_to_string(t2));
    emit(cg, "  ");
    emit(cg, temp2);
    emit(cg, " = zext i1 ");
    emit(cg, temp);
    emit_line(cg, " to i64");
    temp2
}

// ptr intrinsic(ptr, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic() -> ptrtoint to i64
fn emit_intrinsic_ptr_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit_line(cg, "()");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}
