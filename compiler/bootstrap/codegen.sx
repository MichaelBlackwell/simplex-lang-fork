// Simplex Code Generator
// Self-hosted LLVM IR generator supporting:
// - impl blocks, traits, for loops, match expressions
// - generic functions with monomorphization
// - struct literals and field access
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex-lang

// Dependencies: error.sx (E_* error codes, error_msg_*, report_simple_error)
// These functions are provided when compiled together with error.sx

// AST tags - duplicated from parser.sx for standalone compilation
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }
fn TAG_TRAIT() -> i64 { 4 }
fn TAG_IMPL_TRAIT() -> i64 { 5 }
fn TAG_MOD() -> i64 { 6 }
fn TAG_USE() -> i64 { 7 }
fn TAG_ACTOR() -> i64 { 8 }       // actor definition
fn TAG_SPECIALIST() -> i64 { 9 }  // AI specialist
fn TAG_HIVE() -> i64 { 10 }       // cognitive hive
fn TAG_ANIMA() -> i64 { 11 }      // cognitive soul
fn TAG_TYPE_ALIAS() -> i64 { 12 } // type alias

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }
fn EXPR_TRY() -> i64 { 16 }
fn EXPR_AWAIT() -> i64 { 17 }
fn EXPR_FSTRING() -> i64 { 18 }
fn EXPR_YIELD() -> i64 { 19 }
fn EXPR_SPAWN() -> i64 { 20 }
fn EXPR_ARRAY() -> i64 { 21 }
fn EXPR_FLOAT() -> i64 { 22 }
fn EXPR_CLOSURE() -> i64 { 23 }
fn EXPR_INFER() -> i64 { 24 }
fn EXPR_TUPLE() -> i64 { 25 }
fn EXPR_LOOP() -> i64 { 26 }
fn EXPR_INDEX() -> i64 { 27 }
fn EXPR_WHILE_LET() -> i64 { 28 }
fn EXPR_BREAK() -> i64 { 29 }
fn EXPR_STRUCT_PAT() -> i64 { 30 }
fn EXPR_OR_PAT() -> i64 { 31 }
fn EXPR_CAST() -> i64 { 32 }
fn EXPR_METHOD() -> i64 { 33 }
fn EXPR_STRUCT() -> i64 { 34 }

// Belief guard expressions
fn EXPR_CONFIDENCE() -> i64 { 35 }    // confidence(belief_id)
fn EXPR_DERIVATIVE() -> i64 { 36 }    // expr.derivative
fn EXPR_BELIEF_GUARD() -> i64 { 37 }  // belief_expr cmp value
fn EXPR_BELIEF_AND() -> i64 { 38 }    // guard && guard
fn EXPR_BELIEF_OR() -> i64 { 39 }     // guard || guard

// Binary operators - must match parser.sx
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }
fn OP_NEG() -> i64 { 100 }
fn OP_NOT() -> i64 { 101 }

// =============================================================================
// Efficient String Building Helpers
// Use these instead of nested string_concat() for O(n) instead of O(n²)
// =============================================================================

// Join 3 strings efficiently
fn str_join3(a: i64, b: i64, c: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, a);
    sb_append(sb, b);
    sb_append(sb, c);
    sb_build(sb)
}

// Build mangled name: str_mangle("Type", "method") -> "Type_method"
fn str_mangle(type_name: i64, method_name: i64) -> i64 {
    str_join3(type_name, "_", method_name)
}

// Build path: str_path("Type", "Assoc") -> "Type::Assoc"
fn str_path(a: i64, b: i64) -> i64 {
    str_join3(a, "::", b)
}

// Build unique name: str_unique("var", 42) -> "var.42"
fn str_unique(name: i64, id: i64) -> i64 {
    str_join3(name, ".", int_to_string(id))
}

// Build label: str_label("arm", 3) -> "arm_3"
fn str_label(base: i64, suffix: i64) -> i64 {
    str_join3(base, "_", int_to_string(suffix))
}

// =============================================================================
// Platform Detection for Cross-Platform Compilation
// Fixes GitHub issue #56 - target triple was hardcoded to macOS
// =============================================================================

// Detect current operating system
// Returns: "windows", "linux", "macos", or "unknown"
fn get_os_name() -> i64 {
    // Check for Windows-specific environment variable
    let windir: i64 = intrinsic_getenv("WINDIR");
    if windir != 0 {
        if string_len(windir) > 0 {
            return "windows";
        }
    }

    // Check for macOS by looking for Darwin-specific paths
    if intrinsic_file_exists("/System/Library") != 0 {
        return "macos";
    }

    // Check for Linux by looking for /proc (Linux-specific)
    if intrinsic_file_exists("/proc/version") != 0 {
        return "linux";
    }

    // Default to linux for other Unix-like systems
    "linux"
}

// Get LLVM target triple for current platform
fn get_target_triple() -> i64 {
    let os: i64 = get_os_name();

    if string_eq(os, "windows") {
        return "x86_64-pc-windows-msvc";
    }
    if string_eq(os, "macos") {
        return "x86_64-apple-macosx14.0.0";
    }
    // Linux and other Unix-like systems
    "x86_64-unknown-linux-gnu"
}

// Codegen state
fn codegen_new() -> i64 {
    // Allocate codegen: output_sb(0), temp_counter(1), label_counter(2), enums(3), locals(4), strings(5), terminated(6), structs(7), var_types(8), loop_stack(9), loop_depth(10), pre_alloca_queue(11), module_name(12), generic_fns(13), instantiated(14), pending_instantiations(15), assoc_types(16), current_impl_type(17), const_params(18), type_params(19), generic_struct_templates(20), trait_impls(21), is_async_fn(22), async_state_counter(23), async_await_points(24), async_fn_name(25), default_methods(26), trait_defs(27), vtables(28), type_aliases(29), closures(30), closure_counter(31), defined_fns(32), messages(33)
    // Debug info slots: debug_enabled(34), debug_file(35), debug_dir(36), debug_metadata_id(37), debug_subprograms(38), current_subprogram(39), current_line(40)
    // Note: slot 0 is now a StringBuilder for O(n) instead of O(n²) string building
    let cg: i64 = malloc(328);
    store_ptr(cg, 0, sb_new_cap(65536));
    store_i64(cg, 1, 0);
    store_i64(cg, 2, 0);
    store_ptr(cg, 3, vec_new());  // registered enums: vec of (name, variants)
    store_ptr(cg, 4, vec_new());  // local variables in current function
    store_ptr(cg, 5, vec_new());  // string constants: vec of string values
    store_i64(cg, 6, 0);          // terminated flag (set after ret)
    store_ptr(cg, 7, vec_new());  // registered structs: vec of (name, fields)
    store_ptr(cg, 8, vec_new());  // variable types: vec of (name, type_name) pairs
    store_ptr(cg, 9, vec_new());  // loop_stack: vec of (continue_label, break_label) pairs
    store_i64(cg, 10, 0);         // loop_depth: current depth in loop stack
    store_ptr(cg, 11, vec_new()); // pre_alloca_queue: pre-allocated local names in order
    store_ptr(cg, 12, string_from("mod")); // module_name: prefix for string constants
    store_ptr(cg, 13, vec_new()); // generic_fns: vec of (name, fn_def) pairs
    store_ptr(cg, 14, vec_new()); // instantiated: vec of mangled names already generated
    store_ptr(cg, 15, vec_new()); // pending_instantiations: vec of (mangled_name, fn_def, type_args)
    store_ptr(cg, 16, vec_new()); // assoc_types: vec of (impl_type::assoc_name, concrete_type) pairs
    store_ptr(cg, 17, 0);         // current_impl_type: type being implemented (for Self resolution)
    store_ptr(cg, 18, vec_new()); // const_params: vec of (name, value) pairs for current instantiation
    store_ptr(cg, 19, vec_new()); // type_params: vec of (name, concrete_type) pairs for current instantiation
    store_ptr(cg, 20, vec_new()); // generic_struct_templates: vec of (name, type_params, fields)
    store_ptr(cg, 21, vec_new()); // trait_impls: vec of (type_name, trait_name) pairs
    store_i64(cg, 22, 0);         // is_async_fn: flag for async function context
    store_i64(cg, 23, 0);         // async_state_counter: state number for async state machine
    store_ptr(cg, 24, vec_new()); // async_await_points: vec of await point info
    store_ptr(cg, 25, 0);         // async_fn_name: current async function name
    store_ptr(cg, 26, vec_new()); // default_methods: vec of (trait::method, fn_def) pairs
    store_ptr(cg, 27, vec_new()); // trait_defs: vec of (trait_name, method_sigs) for vtable layout
    store_ptr(cg, 28, vec_new()); // vtables: vec of (type_name, trait_name, vtable_global) pairs
    store_ptr(cg, 29, vec_new()); // type_aliases: vec of (alias_name, target_type) pairs
    store_ptr(cg, 30, vec_new()); // closures: vec of (name, params, body, captures) for inline closures
    store_i64(cg, 31, 0);         // closure_counter: for unique closure function names
    store_ptr(cg, 32, vec_new()); // defined_fns: vec of function names defined by user (to avoid redefinition)
    store_ptr(cg, 33, vec_new()); // messages: vec of nullary message constructor names (for actor messages without args)
    // Debug info slots
    store_i64(cg, 34, 0);         // debug_enabled: 1 if -g flag was set
    store_ptr(cg, 35, 0);         // debug_file: source filename for DIFile
    store_ptr(cg, 36, 0);         // debug_dir: source directory for DIFile
    store_i64(cg, 37, 0);         // debug_metadata_id: next metadata node ID
    store_ptr(cg, 38, vec_new()); // debug_subprograms: vec of (fn_name, metadata_id, line) for DISubprogram
    store_i64(cg, 39, 0);         // current_subprogram: metadata ID of current function's DISubprogram
    store_i64(cg, 40, 1);         // current_line: current source line number for debug locations
    cg
}

// User-defined function tracking (to prevent duplicate stdlib declarations)
fn cg_defined_fns(cg: i64) -> i64 {
    load_ptr(cg, 32)
}

fn cg_add_defined_fn(cg: i64, name: i64) -> i64 {
    vec_push(cg_defined_fns(cg), name);
    0
}

// Message constructor registry (for nullary actor messages like Get)
fn cg_messages(cg: i64) -> i64 {
    load_ptr(cg, 33)
}

fn cg_register_message(cg: i64, name: i64) -> i64 {
    vec_push(cg_messages(cg), name);
    0
}

fn cg_is_message(cg: i64, name: i64) -> i64 {
    let msgs: i64 = cg_messages(cg);
    let n: i64 = vec_len(msgs);
    let i: i64 = 0;
    while i < n {
        let msg: i64 = vec_get(msgs, i);
        if string_eq(msg, name) {
            return 1;
        }
        i = i + 1;
    }
    0
}

fn cg_has_defined_fn(cg: i64, name: i64) -> bool {
    let defined: i64 = cg_defined_fns(cg);
    let n: i64 = vec_len(defined);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(defined, i), name) {
            return true;
        }
        i = i + 1;
    }
    false
}

// ========================================
// DWARF Debug Info Generation (0.10.0)
// ========================================

// Debug info accessors
fn cg_debug_enabled(cg: i64) -> i64 { load_i64(cg, 34) }
fn cg_set_debug_enabled(cg: i64, v: i64) -> i64 { store_i64(cg, 34, v); 0 }

fn cg_debug_file(cg: i64) -> i64 { load_ptr(cg, 35) }
fn cg_set_debug_file(cg: i64, f: i64) -> i64 { store_ptr(cg, 35, f); 0 }

fn cg_debug_dir(cg: i64) -> i64 { load_ptr(cg, 36) }
fn cg_set_debug_dir(cg: i64, d: i64) -> i64 { store_ptr(cg, 36, d); 0 }

fn cg_debug_metadata_id(cg: i64) -> i64 { load_i64(cg, 37) }
fn cg_next_debug_metadata_id(cg: i64) -> i64 {
    let id: i64 = load_i64(cg, 37);
    store_i64(cg, 37, id + 1);
    id
}

fn cg_debug_subprograms(cg: i64) -> i64 { load_ptr(cg, 38) }

fn cg_current_subprogram(cg: i64) -> i64 { load_i64(cg, 39) }
fn cg_set_current_subprogram(cg: i64, id: i64) -> i64 { store_i64(cg, 39, id); 0 }

fn cg_current_line(cg: i64) -> i64 { load_i64(cg, 40) }
fn cg_set_current_line(cg: i64, line: i64) -> i64 { store_i64(cg, 40, line); 0 }

// Register a subprogram for debug info
// Returns the metadata ID assigned to this subprogram
fn cg_register_subprogram(cg: i64, fn_name: i64, line: i64) -> i64 {
    let id: i64 = cg_next_debug_metadata_id(cg);
    let subprograms: i64 = cg_debug_subprograms(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, fn_name);
    store_i64(entry, 1, id);
    store_i64(entry, 2, line);
    vec_push(subprograms, entry);
    id
}

// Look up subprogram metadata ID by function name
fn cg_lookup_subprogram(cg: i64, fn_name: i64) -> i64 {
    let subprograms: i64 = cg_debug_subprograms(cg);
    let n: i64 = vec_len(subprograms);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(subprograms, i);
        if string_eq(load_ptr(entry, 0), fn_name) {
            return load_i64(entry, 1);
        }
        i = i + 1;
    }
    0  // Not found
}

// Async state accessors
fn cg_is_async_fn(cg: i64) -> i64 {
    load_i64(cg, 22)
}

fn cg_set_async_fn(cg: i64, is_async: i64) -> i64 {
    store_i64(cg, 22, is_async);
    0
}

fn cg_next_async_state(cg: i64) -> i64 {
    let state: i64 = load_i64(cg, 23);
    store_i64(cg, 23, state + 1);
    state
}

fn cg_reset_async_state(cg: i64) -> i64 {
    store_i64(cg, 23, 0);
    0
}

fn cg_async_await_points(cg: i64) -> i64 {
    load_ptr(cg, 24)
}

fn cg_add_await_point(cg: i64, state: i64, label: i64) -> i64 {
    let points: i64 = cg_async_await_points(cg);
    let point: i64 = malloc(16);
    store_i64(point, 0, state);
    store_ptr(point, 1, label);
    vec_push(points, point);
    0
}

fn cg_clear_await_points(cg: i64) -> i64 {
    store_ptr(cg, 24, vec_new());
    0
}

fn cg_async_fn_name(cg: i64) -> i64 {
    load_ptr(cg, 25)
}

fn cg_set_async_fn_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 25, name);
    0
}

fn cg_module_name(cg: i64) -> i64 {
    load_ptr(cg, 12)
}

fn cg_set_module_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 12, name);
    0
}

fn cg_generic_fns(cg: i64) -> i64 {
    load_ptr(cg, 13)
}

fn cg_instantiated(cg: i64) -> i64 {
    load_ptr(cg, 14)
}

fn cg_pending_instantiations(cg: i64) -> i64 {
    load_ptr(cg, 15)
}

// Register a generic function definition
fn cg_register_generic(cg: i64, name: i64, fn_def: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, fn_def);
    vec_push(generics, pair);
    0
}

// Look up a generic function by name
fn cg_lookup_generic(cg: i64, name: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let n: i64 = vec_len(generics);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(generics, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Check if an instantiation has been generated
fn cg_is_instantiated(cg: i64, mangled_name: i64) -> bool {
    let instantiated: i64 = cg_instantiated(cg);
    let n: i64 = vec_len(instantiated);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(instantiated, i), mangled_name) {
            return true;
        }
        i = i + 1;
    }
    false
}

// Mark an instantiation as generated
fn cg_mark_instantiated(cg: i64, mangled_name: i64) -> i64 {
    vec_push(cg_instantiated(cg), mangled_name);
    0
}

// Queue a pending instantiation
fn cg_queue_instantiation(cg: i64, mangled_name: i64, fn_def: i64, type_args: i64) -> i64 {
    let pending: i64 = cg_pending_instantiations(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, mangled_name);
    store_ptr(entry, 1, fn_def);
    store_ptr(entry, 2, type_args);
    vec_push(pending, entry);
    0
}

// Associated types helpers
fn cg_assoc_types(cg: i64) -> i64 {
    load_ptr(cg, 16)
}

fn cg_current_impl_type(cg: i64) -> i64 {
    load_ptr(cg, 17)
}

fn cg_set_current_impl_type(cg: i64, type_name: i64) -> i64 {
    store_ptr(cg, 17, type_name);
    0
}

// Register an associated type: maps "TypeName::AssocName" to concrete type
fn cg_register_assoc_type(cg: i64, impl_type: i64, assoc_name: i64, concrete_type: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = str_path(impl_type, assoc_name);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, key);
    store_ptr(pair, 1, concrete_type);
    vec_push(assoc_types, pair);
    0
}

// Look up an associated type
fn cg_lookup_assoc_type(cg: i64, impl_type: i64, assoc_name: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = str_path(impl_type, assoc_name);
    let n: i64 = vec_len(assoc_types);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(assoc_types, i);
        if string_eq(load_ptr(pair, 0), key) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Resolve a type: handles Self, Self::Name, and type aliases
fn cg_resolve_type(cg: i64, type_name: i64) -> i64 {
    // Check for Self::Name pattern
    if string_starts_with(type_name, string_from("Self::")) {
        let assoc_name: i64 = string_slice(type_name, 6, string_len(type_name));
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            let resolved: i64 = cg_lookup_assoc_type(cg, impl_type, assoc_name);
            if resolved != 0 {
                return resolved;
            }
        }
        // Not found - return as-is (will be an error at compile time)
        return type_name;
    }
    // Check for plain Self
    if string_eq(type_name, string_from("Self")) {
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            return impl_type;
        }
    }
    // Check for type alias
    let resolved: i64 = cg_resolve_type_alias(cg, type_name);
    if string_eq(resolved, type_name) == false {
        return resolved;
    }
    // Not Self::anything or alias, return as-is
    type_name
}

// Const params helpers for const generics
fn cg_const_params(cg: i64) -> i64 {
    load_ptr(cg, 18)
}

fn cg_clear_const_params(cg: i64) -> i64 {
    store_ptr(cg, 18, vec_new());
    0
}

fn cg_add_const_param(cg: i64, name: i64, value: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, value);
    vec_push(const_params, pair);
    0
}

fn cg_lookup_const_param(cg: i64, name: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let n: i64 = vec_len(const_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(const_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Type Parameter Substitution (Phase 21 completion)
// ========================================

// Slot 19: type_params - maps type param names to concrete types
fn cg_type_params(cg: i64) -> i64 {
    load_ptr(cg, 19)
}

fn cg_clear_type_params(cg: i64) -> i64 {
    store_ptr(cg, 19, vec_new());
    0
}

fn cg_add_type_param(cg: i64, name: i64, concrete_type: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, concrete_type);
    vec_push(type_params, pair);
    0
}

fn cg_lookup_type_param(cg: i64, name: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(type_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Substitute type parameters in a type string
// e.g., "Vec<T>" with T=i64 becomes "Vec<i64>"
fn substitute_type_params(cg: i64, type_str: i64) -> i64 {
    if type_str == 0 {
        return type_str;
    }
    // Check if type_str is a type parameter itself
    let subst: i64 = cg_lookup_type_param(cg, type_str);
    if subst != 0 {
        return subst;
    }
    // Otherwise return unchanged (bootstrap compiler uses i64 for everything)
    type_str
}

// ========================================
// Generic Struct Templates (Phase 21 completion)
// ========================================

// Slot 20: generic_struct_templates - stores generic struct definitions
// Format: vec of (name, type_params, fields) tuples
fn cg_generic_struct_templates(cg: i64) -> i64 {
    load_ptr(cg, 20)
}

fn cg_add_generic_struct_template(cg: i64, name: i64, type_params: i64, fields: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, type_params);
    store_ptr(entry, 2, fields);
    vec_push(templates, entry);
    0
}

fn cg_lookup_generic_struct_template(cg: i64, name: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let n: i64 = vec_len(templates);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(templates, i);
        if string_eq(load_ptr(entry, 0), name) {
            return entry;
        }
        i = i + 1;
    }
    0
}

// Monomorphize a generic struct with concrete type arguments
// Returns the mangled name (e.g., "Pair_i64_i64")
fn monomorphize_struct(cg: i64, struct_name: i64, type_args: i64) -> i64 {
    // Build mangled name
    let mangled_name: i64 = struct_name;
    if type_args != 0 {
        let num_args: i64 = vec_len(type_args);
        if num_args > 0 {
            let i: i64 = 0;
            while i < num_args {
                mangled_name = string_concat(mangled_name, "_");
                mangled_name = string_concat(mangled_name, vec_get(type_args, i));
                i = i + 1;
            }
        }
    }

    // Check if already registered
    let existing: i64 = lookup_struct_fields(cg, mangled_name);
    if existing != 0 {
        return mangled_name;
    }

    // Look up the generic struct template
    let template: i64 = cg_lookup_generic_struct_template(cg, struct_name);
    if template == 0 {
        // Not a generic struct, check if it's already registered
        let plain: i64 = lookup_struct_fields(cg, struct_name);
        if plain != 0 {
            return struct_name;
        }
        return struct_name;  // Fall back to plain name
    }

    // Get template info
    let type_params: i64 = load_ptr(template, 1);
    let fields: i64 = load_ptr(template, 2);

    // Set up type parameter mappings
    cg_clear_type_params(cg);
    if type_params != 0 {
        let num_type_params: i64 = vec_len(type_params);
        let pi: i64 = 0;
        while pi < num_type_params {
            let param_name: i64 = vec_get(type_params, pi);
            if type_args != 0 {
                if pi < vec_len(type_args) {
                    cg_add_type_param(cg, param_name, vec_get(type_args, pi));
                }
            }
            pi = pi + 1;
        }
    }

    // Create monomorphized fields (in bootstrap compiler, all types are i64)
    // Just register with same fields
    register_struct(cg, mangled_name, fields);

    mangled_name
}

// ========================================
// Trait Implementation Tracking (Phase 21 completion)
// ========================================

// Slot 21: trait_impls - stores which types implement which traits
fn cg_trait_impls(cg: i64) -> i64 {
    load_ptr(cg, 21)
}

fn cg_register_trait_impl(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    vec_push(impls, entry);
    0
}

fn cg_type_implements_trait(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let n: i64 = vec_len(impls);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(impls, i);
        let impl_type: i64 = load_ptr(entry, 0);
        let impl_trait: i64 = load_ptr(entry, 1);
        if string_eq(impl_type, type_name) {
            if string_eq(impl_trait, trait_name) {
                return 1;
            }
        }
        i = i + 1;
    }
    0
}

// Default method accessors
fn cg_default_methods(cg: i64) -> i64 {
    load_ptr(cg, 26)
}

fn cg_register_default_method(cg: i64, trait_name: i64, method_name: i64, fn_def: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = str_path(trait_name, method_name);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, key);
    store_ptr(entry, 1, fn_def);
    vec_push(methods, entry);
    0
}

fn cg_get_default_method(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = str_path(trait_name, method_name);
    let n: i64 = vec_len(methods);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(methods, i);
        let entry_key: i64 = load_ptr(entry, 0);
        if string_eq(entry_key, key) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Vtable Support for Dynamic Dispatch (Phase 32)
// ========================================

// Slot 27: trait_defs - stores trait definitions with their method signatures
fn cg_trait_defs(cg: i64) -> i64 {
    load_ptr(cg, 27)
}

// Register a trait definition with its method signatures for vtable layout
// method_sigs is a vec of method signatures from the trait definition
fn cg_register_trait_def(cg: i64, trait_name: i64, method_sigs: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, trait_name);
    store_ptr(entry, 1, method_sigs);
    vec_push(defs, entry);
    0
}

// Get method signatures for a trait (for vtable layout)
fn cg_get_trait_methods(cg: i64, trait_name: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let n: i64 = vec_len(defs);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(defs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, trait_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Slot 28: vtables - stores generated vtables
fn cg_vtables(cg: i64) -> i64 {
    load_ptr(cg, 28)
}

// Register a vtable global for (type, trait) pair
fn cg_register_vtable(cg: i64, type_name: i64, trait_name: i64, vtable_global: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    store_ptr(entry, 2, vtable_global);
    vec_push(vtables, entry);
    0
}

// Get vtable global name for a (type, trait) pair
fn cg_get_vtable(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let n: i64 = vec_len(vtables);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(vtables, i);
        let t: i64 = load_ptr(entry, 0);
        let tr: i64 = load_ptr(entry, 1);
        if string_eq(t, type_name) {
            if string_eq(tr, trait_name) {
                return load_ptr(entry, 2);
            }
        }
        i = i + 1;
    }
    0
}

// Slot 29: type_aliases - stores type alias mappings
fn cg_type_aliases(cg: i64) -> i64 {
    load_ptr(cg, 29)
}

// Register a type alias
fn cg_register_type_alias(cg: i64, alias_name: i64, target_type: i64) -> i64 {
    let aliases: i64 = cg_type_aliases(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, alias_name);
    store_ptr(entry, 1, target_type);
    vec_push(aliases, entry);
    0
}

// Resolve a type alias recursively, returns the final target type
fn cg_resolve_type_alias(cg: i64, type_name: i64) -> i64 {
    let aliases: i64 = cg_type_aliases(cg);
    let n: i64 = vec_len(aliases);
    let current: i64 = type_name;
    let depth: i64 = 0;
    let max_depth: i64 = 100;  // Prevent infinite recursion

    while depth < max_depth {
        let found: i64 = 0;
        let i: i64 = 0;
        while i < n {
            let entry: i64 = vec_get(aliases, i);
            let alias: i64 = load_ptr(entry, 0);
            if string_eq(alias, current) {
                current = load_ptr(entry, 1);
                found = 1;
                break;
            }
            i = i + 1;
        }
        if found == 0 {
            break;  // No more aliases to resolve
        }
        depth = depth + 1;
    }
    current
}

// Resolve type alias with generic parameter substitution
fn cg_resolve_type_with_generics(cg: i64, type_name: i64, type_args: i64) -> i64 {
    let resolved: i64 = cg_resolve_type_alias(cg, type_name);

    // If we have type arguments and the resolved type is generic, substitute
    if type_args != 0 {
        if vec_len(type_args) > 0 {
            // Build monomorphized name: Type_Arg1_Arg2
            let result: i64 = resolved;
            let n: i64 = vec_len(type_args);
            let i: i64 = 0;
            while i < n {
                let arg: i64 = vec_get(type_args, i);
                result = string_concat(result, "_");
                result = string_concat(result, arg);
                i = i + 1;
            }
            return result;
        }
    }
    resolved
}

// Slot 30: closures - stores inline closure definitions
fn cg_closures(cg: i64) -> i64 {
    load_ptr(cg, 30)
}

fn cg_next_closure_id(cg: i64) -> i64 {
    let id: i64 = load_i64(cg, 31);
    store_i64(cg, 31, id + 1);
    id
}

// Register an inline closure with capture analysis
// Entry layout: (name, params, body, captures) - 32 bytes
fn cg_register_closure(cg: i64, var_name: i64, params: i64, body: i64) -> i64 {
    let closures: i64 = cg_closures(cg);
    let entry: i64 = malloc(32);
    store_ptr(entry, 0, var_name);
    store_ptr(entry, 1, params);
    store_ptr(entry, 2, body);
    // Analyze captures - variables referenced in body that aren't parameters
    let captures: i64 = analyze_closure_captures(params, body);
    store_ptr(entry, 3, captures);
    vec_push(closures, entry);
    0
}

// Look up a closure by variable name, returns the entry or 0 if not found
fn cg_lookup_closure(cg: i64, var_name: i64) -> i64 {
    let closures: i64 = cg_closures(cg);
    let n: i64 = vec_len(closures);
    let i: i64 = n - 1;  // Search backwards for most recent
    while i >= 0 {
        let entry: i64 = vec_get(closures, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, var_name) {
            return entry;
        }
        i = i - 1;
    }
    0  // Not found
}

// Get method index in vtable for a trait method
fn cg_get_vtable_method_index(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let method_sigs: i64 = cg_get_trait_methods(cg, trait_name);
    if method_sigs == 0 {
        return 0;  // Unknown trait
    }
    let n: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < n {
        let sig: i64 = vec_get(method_sigs, i);
        let sig_name: i64 = load_ptr(sig, 0);
        if string_eq(sig_name, method_name) {
            return i;
        }
        i = i + 1;
    }
    0  // Default to first slot if not found
}

// Check if a type is a dyn trait type (starts with "dyn:")
fn is_dyn_type(type_name: i64) -> i64 {
    string_starts_with(type_name, string_from("dyn:"))
}

// Extract trait name from dyn type (e.g., "dyn:Display" -> "Display")
fn extract_dyn_trait(type_name: i64) -> i64 {
    if is_dyn_type(type_name) != 0 {
        return string_slice(type_name, 4, string_len(type_name));
    }
    type_name
}

// Extract type param name from bounded type param (e.g., "T:Display" -> "T")
fn extract_type_param_name(type_param: i64) -> i64 {
    // Check for const: prefix
    if string_starts_with(type_param, string_from("const:")) {
        return string_slice(type_param, 6, string_len(type_param));
    }
    // Check for trait bound (contains : but not const:)
    let colon_pos: i64 = string_find(type_param, string_from(":"));
    if colon_pos > 0 {
        return string_slice(type_param, 0, colon_pos);
    }
    type_param
}

// Extract trait bound from bounded type param (e.g., "T:Display" -> "Display")
fn extract_trait_bound(type_param: i64) -> i64 {
    // Check for const: prefix (no trait bound)
    if string_starts_with(type_param, string_from("const:")) {
        return 0;
    }
    // Check for trait bound
    let colon_pos: i64 = string_find(type_param, string_from(":"));
    if colon_pos > 0 {
        return string_slice(type_param, colon_pos + 1, string_len(type_param));
    }
    0
}

// Check if all trait bounds are satisfied for a generic instantiation
// Returns 1 if all bounds satisfied, 0 otherwise
fn check_trait_bounds(cg: i64, type_params: i64, type_args: i64) -> i64 {
    if type_params == 0 {
        return 1;
    }
    if type_args == 0 {
        return 1;
    }
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let type_param: i64 = vec_get(type_params, i);
        let bound: i64 = extract_trait_bound(type_param);
        if bound != 0 {
            // This type param has a trait bound
            if i < vec_len(type_args) {
                let concrete_type: i64 = vec_get(type_args, i);
                // Check if concrete type implements the bound trait
                // Handle multiple bounds separated by +
                let plus_pos: i64 = string_find(bound, string_from("+"));
                if plus_pos > 0 {
                    // Multiple bounds: check each one
                    let remaining: i64 = bound;
                    while string_len(remaining) > 0 {
                        plus_pos = string_find(remaining, string_from("+"));
                        let trait_name: i64 = remaining;
                        if plus_pos > 0 {
                            trait_name = string_slice(remaining, 0, plus_pos);
                            remaining = string_slice(remaining, plus_pos + 1, string_len(remaining));
                        } else {
                            remaining = string_from("");
                        }
                        if cg_type_implements_trait(cg, concrete_type, trait_name) == 0 {
                            let msg: i64 = error_msg_trait_not_impl(concrete_type, trait_name);
                            report_simple_error(E_TRAIT_NOT_IMPLEMENTED(), msg);
                            return 0;
                        }
                    }
                } else {
                    // Single bound
                    if cg_type_implements_trait(cg, concrete_type, bound) == 0 {
                        let msg: i64 = error_msg_trait_not_impl(concrete_type, bound);
                        report_simple_error(E_TRAIT_NOT_IMPLEMENTED(), msg);
                        return 0;
                    }
                }
            }
        }
        i = i + 1;
    }
    1
}

// ========================================
// Improved Type Error Messages (Phase 21 completion)
// Updated for 0.10.0 with Rust/Elm-style error formatting
// ========================================

// Format a type mismatch error with context
fn type_error_mismatch(expected: i64, found: i64, context: i64) -> i64 {
    let sb: i64 = sb_new();
    sb_append(sb, "expected `");
    sb_append(sb, expected);
    sb_append(sb, "`, found `");
    sb_append(sb, found);
    sb_append(sb, "`");
    if context != 0 {
        sb_append(sb, " in ");
        sb_append(sb, context);
    }
    let msg: i64 = sb_build(sb);
    report_simple_error(E_TYPE_MISMATCH(), msg);
    0
}

// Format an argument count mismatch error
fn error_arg_count(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = error_msg_wrong_arg_count(fn_name, expected, found);
    report_simple_error(E_WRONG_ARG_COUNT(), msg);
    0
}

// Format an undefined variable error
fn error_undefined_var(name: i64) -> i64 {
    let msg: i64 = error_msg_undefined_var(name);
    report_simple_error(E_UNDEFINED_VARIABLE(), msg);
    0
}

// Format an undefined function error
fn error_undefined_fn(name: i64) -> i64 {
    let msg: i64 = error_msg_undefined_fn(name);
    report_simple_error(E_UNDEFINED_FUNCTION(), msg);
    0
}

// Format an undefined struct error
fn error_undefined_struct(name: i64) -> i64 {
    let msg: i64 = error_msg_undefined_struct(name);
    report_simple_error(E_UNDEFINED_STRUCT(), msg);
    0
}

// Format an undefined field error
fn error_undefined_field(struct_name: i64, field_name: i64) -> i64 {
    let msg: i64 = error_msg_undefined_field(struct_name, field_name);
    report_simple_error(E_UNDEFINED_FIELD(), msg);
    0
}

// Format a generic instantiation error
fn error_generic_instantiation(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = error_msg_wrong_type_arg_count(fn_name, expected, found);
    report_simple_error(E_WRONG_TYPE_ARG_COUNT(), msg);
    0
}

fn cg_alloca_queue(cg: i64) -> i64 {
    load_ptr(cg, 11)
}

fn cg_clear_alloca_queue(cg: i64) -> i64 {
    store_ptr(cg, 11, vec_new());
    0
}

fn cg_push_alloca(cg: i64, unique_name: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    vec_push(queue, unique_name);
    0
}

fn cg_pop_alloca(cg: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    let len: i64 = vec_len(queue);
    if len == 0 {
        return 0;
    }
    let name: i64 = vec_get(queue, 0);
    // Shift queue (remove first element by building new vec)
    let new_queue: i64 = vec_new();
    let i: i64 = 1;
    while i < len {
        vec_push(new_queue, vec_get(queue, i));
        i = i + 1;
    }
    store_ptr(cg, 11, new_queue);
    name
}

// Collect all local variable names from a block (recursive)
// Returns a vector of variable names in declaration order
fn collect_locals_from_expr(expr: i64, result: i64) -> i64 {
    if expr == 0 {
        return 0;
    }
    let tag: i64 = load_i64(expr, 0);

    // Block - process stmts and result expr
    if tag == EXPR_BLOCK() {
        let stmts: i64 = load_ptr(expr, 1);
        let result_expr: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(stmts);
        let i: i64 = 0;
        while i < n {
            let stmt: i64 = vec_get(stmts, i);
            collect_locals_from_stmt(stmt, result);
            i = i + 1;
        }
        if result_expr != 0 {
            collect_locals_from_expr(result_expr, result);
        }
        return 0;
    }

    // If expression - process then/else blocks
    if tag == EXPR_IF() {
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        collect_locals_from_expr(then_block, result);
        if else_block != 0 {
            collect_locals_from_expr(else_block, result);
        }
        return 0;
    }

    // While expression - process body
    if tag == EXPR_WHILE() {
        let body: i64 = load_ptr(expr, 2);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // For expression - collect loop var and process body
    if tag == EXPR_FOR() {
        let var_name: i64 = load_ptr(expr, 1);
        vec_push(result, var_name);
        let body: i64 = load_ptr(expr, 4);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // Match expression - process arms
    if tag == EXPR_MATCH() {
        let arms: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(arms);
        let i: i64 = 0;
        while i < n {
            let arm: i64 = vec_get(arms, i);
            let body: i64 = load_ptr(arm, 1);
            collect_locals_from_expr(body, result);
            i = i + 1;
        }
        return 0;
    }

    0
}

fn collect_locals_from_stmt(stmt: i64, result: i64) -> i64 {
    if stmt == 0 {
        return 0;
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement - collect the variable name
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        vec_push(result, name);
        // Also check init expression for nested blocks
        let init_expr: i64 = load_ptr(stmt, 3);
        if init_expr != 0 {
            collect_locals_from_expr(init_expr, result);
        }
        return 0;
    }

    // Expression statement - check for blocks
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        collect_locals_from_expr(expr, result);
        return 0;
    }

    // Return statement - check expression
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            collect_locals_from_expr(expr, result);
        }
        return 0;
    }

    0
}

fn collect_locals_from_block(block: i64) -> i64 {
    let result: i64 = vec_new();
    collect_locals_from_expr(block, result);
    result
}

// Collect all identifier references from an expression (for capture analysis)
fn collect_referenced_ids(expr: i64, result: i64) -> i64 {
    if expr == 0 {
        return 0;
    }
    let tag: i64 = load_i64(expr, 0);

    // Identifier - add to result
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);
        // Only add if not already in result
        let n: i64 = vec_len(result);
        let found: i64 = 0;
        let i: i64 = 0;
        while i < n {
            if string_eq(vec_get(result, i), name) {
                found = 1;
                break;
            }
            i = i + 1;
        }
        if found == 0 {
            vec_push(result, name);
        }
        return 0;
    }

    // Binary - recurse on left and right
    if tag == EXPR_BINARY() {
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);
        collect_referenced_ids(left, result);
        collect_referenced_ids(right, result);
        return 0;
    }

    // Unary - recurse on operand
    if tag == EXPR_UNARY() {
        let operand: i64 = load_ptr(expr, 2);
        collect_referenced_ids(operand, result);
        return 0;
    }

    // Call - recurse on callee and args
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);
        collect_referenced_ids(callee, result);
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            collect_referenced_ids(vec_get(args, i), result);
            i = i + 1;
        }
        return 0;
    }

    // Method call - recurse on receiver and args
    if tag == EXPR_METHOD() {
        let receiver: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 3);
        collect_referenced_ids(receiver, result);
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            collect_referenced_ids(vec_get(args, i), result);
            i = i + 1;
        }
        return 0;
    }

    // Field access - recurse on base
    if tag == EXPR_FIELD() {
        let base: i64 = load_ptr(expr, 1);
        collect_referenced_ids(base, result);
        return 0;
    }

    // Index access - recurse on base and index
    if tag == EXPR_INDEX() {
        let base: i64 = load_ptr(expr, 1);
        let index: i64 = load_ptr(expr, 2);
        collect_referenced_ids(base, result);
        collect_referenced_ids(index, result);
        return 0;
    }

    // Block - recurse on statements and result
    if tag == EXPR_BLOCK() {
        let stmts: i64 = load_ptr(expr, 1);
        let result_expr: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(stmts);
        let i: i64 = 0;
        while i < n {
            let stmt: i64 = vec_get(stmts, i);
            collect_referenced_ids_stmt(stmt, result);
            i = i + 1;
        }
        if result_expr != 0 {
            collect_referenced_ids(result_expr, result);
        }
        return 0;
    }

    // If - recurse on condition, then, else
    if tag == EXPR_IF() {
        let cond: i64 = load_ptr(expr, 1);
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        collect_referenced_ids(cond, result);
        collect_referenced_ids(then_block, result);
        if else_block != 0 {
            collect_referenced_ids(else_block, result);
        }
        return 0;
    }

    // While - recurse on condition and body
    if tag == EXPR_WHILE() {
        let cond: i64 = load_ptr(expr, 1);
        let body: i64 = load_ptr(expr, 2);
        collect_referenced_ids(cond, result);
        collect_referenced_ids(body, result);
        return 0;
    }

    // For - recurse on range and body
    if tag == EXPR_FOR() {
        let start: i64 = load_ptr(expr, 2);
        let end: i64 = load_ptr(expr, 3);
        let body: i64 = load_ptr(expr, 4);
        collect_referenced_ids(start, result);
        collect_referenced_ids(end, result);
        collect_referenced_ids(body, result);
        return 0;
    }

    // Match - recurse on scrutinee and arm bodies
    if tag == EXPR_MATCH() {
        let scrutinee: i64 = load_ptr(expr, 1);
        let arms: i64 = load_ptr(expr, 2);
        collect_referenced_ids(scrutinee, result);
        let n: i64 = vec_len(arms);
        let i: i64 = 0;
        while i < n {
            let arm: i64 = vec_get(arms, i);
            let body: i64 = load_ptr(arm, 1);
            collect_referenced_ids(body, result);
            i = i + 1;
        }
        return 0;
    }

    // Array - recurse on elements
    if tag == EXPR_ARRAY() {
        let elems: i64 = load_ptr(expr, 1);
        let n: i64 = vec_len(elems);
        let i: i64 = 0;
        while i < n {
            collect_referenced_ids(vec_get(elems, i), result);
            i = i + 1;
        }
        return 0;
    }

    // Tuple - recurse on elements
    if tag == EXPR_TUPLE() {
        let elems: i64 = load_ptr(expr, 1);
        let n: i64 = vec_len(elems);
        let i: i64 = 0;
        while i < n {
            collect_referenced_ids(vec_get(elems, i), result);
            i = i + 1;
        }
        return 0;
    }

    // Struct literal - recurse on field values
    if tag == EXPR_STRUCT() {
        let fields: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(fields, i);
            let val: i64 = load_ptr(field, 1);
            collect_referenced_ids(val, result);
            i = i + 1;
        }
        return 0;
    }

    // Cast - recurse on expression
    if tag == EXPR_CAST() {
        let inner: i64 = load_ptr(expr, 1);
        collect_referenced_ids(inner, result);
        return 0;
    }

    // Try - recurse on expression
    if tag == EXPR_TRY() {
        let inner: i64 = load_ptr(expr, 1);
        collect_referenced_ids(inner, result);
        return 0;
    }

    // Closure - recurse into body (nested closures can capture from outer)
    if tag == EXPR_CLOSURE() {
        let body: i64 = load_ptr(expr, 2);
        collect_referenced_ids(body, result);
        return 0;
    }

    0
}

// Collect referenced identifiers from a statement
fn collect_referenced_ids_stmt(stmt: i64, result: i64) -> i64 {
    if stmt == 0 {
        return 0;
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement - recurse on init expression
    if tag == STMT_LET() {
        let init_expr: i64 = load_ptr(stmt, 3);
        if init_expr != 0 {
            collect_referenced_ids(init_expr, result);
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        collect_referenced_ids(expr, result);
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            collect_referenced_ids(expr, result);
        }
        return 0;
    }

    // Assign statement
    if tag == STMT_ASSIGN() {
        let target: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        collect_referenced_ids(target, result);
        collect_referenced_ids(value, result);
        return 0;
    }

    0
}

// Analyze captures for a closure: find variables referenced in body that are not params
// Returns a vec of captured variable names
fn analyze_closure_captures(params: i64, body: i64) -> i64 {
    // Collect all referenced identifiers in the body
    let refs: i64 = vec_new();
    collect_referenced_ids(body, refs);

    // Collect parameter names
    let param_names: i64 = vec_new();
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        vec_push(param_names, pname);
        i = i + 1;
    }

    // Filter: captures are references that are not parameters
    let captures: i64 = vec_new();
    n = vec_len(refs);
    i = 0;
    while i < n {
        let ref_name: i64 = vec_get(refs, i);
        // Check if this is a parameter
        let is_param: i64 = 0;
        let j: i64 = 0;
        let np: i64 = vec_len(param_names);
        while j < np {
            if string_eq(vec_get(param_names, j), ref_name) {
                is_param = 1;
                break;
            }
            j = j + 1;
        }
        if is_param == 0 {
            vec_push(captures, ref_name);
        }
        i = i + 1;
    }

    captures
}

fn cg_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_next_temp(cg: i64) -> i64 {
    let t: i64 = load_i64(cg, 1);
    store_i64(cg, 1, t + 1);
    t
}

fn cg_next_label(cg: i64) -> i64 {
    let l: i64 = load_i64(cg, 2);
    store_i64(cg, 2, l + 1);
    l
}

fn cg_enums(cg: i64) -> i64 {
    load_ptr(cg, 3)
}

fn cg_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_clear_locals(cg: i64) -> i64 {
    store_ptr(cg, 4, vec_new());
    store_ptr(cg, 8, vec_new());  // Also clear var_types
    store_ptr(cg, 9, vec_new());  // Also clear loop_stack
    store_i64(cg, 10, 0);         // Reset loop_depth
    0
}

fn cg_strings(cg: i64) -> i64 {
    load_ptr(cg, 5)
}

// Variable type tracking for method calls
fn cg_var_types(cg: i64) -> i64 {
    load_ptr(cg, 8)
}

// Add variable type: stores (var_name, type_name) pair
fn add_var_type(cg: i64, var_name: i64, type_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, var_name);
    store_ptr(pair, 1, type_name);
    vec_push(var_types, pair);
    0
}

// Lookup variable type by name (returns type_name or 0 if not found)
fn lookup_var_type(cg: i64, var_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let n: i64 = vec_len(var_types);
    // Search backwards to get most recent binding
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(var_types, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, var_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    0
}

fn cg_is_terminated(cg: i64) -> bool {
    load_i64(cg, 6) != 0
}

fn cg_set_terminated(cg: i64, val: bool) -> i64 {
    if val != false {
        store_i64(cg, 6, 1);
    } else {
        store_i64(cg, 6, 0);
    }
    0
}

// Add a string constant and return its index
fn cg_add_string(cg: i64, value: i64) -> i64 {
    let strings: i64 = cg_strings(cg);
    let idx: i64 = vec_len(strings);
    vec_push(strings, value);
    idx
}

// Emit to output buffer using StringBuilder for O(n) instead of O(n²)
fn emit(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    0
}

fn emit_line(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    sb_append(sb, "\n");
    0
}

// Emit a line with debug location metadata attached
// Used for instructions that should have source location info
fn emit_line_dbg(cg: i64, s: i64, line: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    // Add !dbg metadata if debug info is enabled and we're in a function
    if cg_debug_enabled(cg) != 0 {
        let sp: i64 = cg_current_subprogram(cg);
        if sp > 0 {
            // Emit inline DILocation: !dbg !DILocation(line: N, scope: !M)
            sb_append(sb, ", !dbg !DILocation(line: ");
            sb_append(sb, int_to_string(line));
            sb_append(sb, ", scope: !");
            sb_append(sb, int_to_string(sp));
            sb_append(sb, ")");
        }
    }
    sb_append(sb, "\n");
    0
}

// Emit debug location suffix for an instruction (without newline)
fn emit_dbg_loc(cg: i64, line: i64) -> i64 {
    if cg_debug_enabled(cg) != 0 {
        let sp: i64 = cg_current_subprogram(cg);
        if sp > 0 {
            emit(cg, ", !dbg !DILocation(line: ");
            emit(cg, int_to_string(line));
            emit(cg, ", scope: !");
            emit(cg, int_to_string(sp));
            emit(cg, ")");
        }
    }
    0
}

// Emit a stdlib function declaration only if not user-defined
// This prevents LLVM redefinition errors when user defines functions with stdlib names
fn emit_stdlib_decl(cg: i64, fn_name: i64, decl: i64) -> i64 {
    if cg_has_defined_fn(cg, fn_name) == false {
        emit_line(cg, decl);
    }
    0
}

// Register an enum
fn register_enum(cg: i64, name: i64, variants: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, variants);
    vec_push(enums, entry);
    0
}

// Look up enum variant index
fn lookup_variant(cg: i64, enum_name: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, enum_name) {
            let variants: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(variants);
            let j: i64 = 0;
            while j < m {
                let v: i64 = vec_get(variants, j);
                if string_eq(v, var_name) {
                    return j;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0 - 1  // Return -1 when not found
}

// Look up enum variant index by variant name only (searches all enums)
fn lookup_variant_any(cg: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let variants: i64 = load_ptr(entry, 1);
        let m: i64 = vec_len(variants);
        let j: i64 = 0;
        while j < m {
            let v: i64 = vec_get(variants, j);
            if string_eq(v, var_name) {
                return j;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    0 - 1  // Return -1 when not found
}

// Register builtin enums (Option, Result) for enum construction without explicit enum definition
fn register_builtin_enums(cg: i64) -> i64 {
    // Option<T>: None=0, Some=1
    let option_variants: i64 = vec_new();
    vec_push(option_variants, string_from("None"));
    vec_push(option_variants, string_from("Some"));
    register_enum(cg, string_from("Option"), option_variants);

    // Result<T,E>: Err=0, Ok=1
    let result_variants: i64 = vec_new();
    vec_push(result_variants, string_from("Err"));
    vec_push(result_variants, string_from("Ok"));
    register_enum(cg, string_from("Result"), result_variants);
    0
}

// Phase 36: Extract base type name from generic type string
// e.g., "Option<i64>" -> "Option", "Result<T, E>" -> "Result"
fn extract_base_type(type_name: i64) -> i64 {
    if type_name == 0 {
        return 0;
    }
    let len: i64 = string_len(type_name);
    let i: i64 = 0;
    while i < len {
        let ch: i64 = string_char_at(type_name, i);
        if ch == 60 {  // '<' character
            return string_slice(type_name, 0, i);
        }
        i = i + 1;
    }
    type_name  // No '<' found, return as-is
}

// Get structs vector
fn cg_structs(cg: i64) -> i64 {
    load_ptr(cg, 7)
}

// Get loop stack (for break/continue)
fn cg_loop_stack(cg: i64) -> i64 {
    load_ptr(cg, 9)
}

// Get loop depth
fn cg_loop_depth(cg: i64) -> i64 {
    load_i64(cg, 10)
}

// Push loop context onto stack - triple is (continue_label, break_label, result_ptr)
fn push_loop(cg: i64, continue_label: i64, break_label: i64) -> i64 {
    let stack: i64 = cg_loop_stack(cg);
    let depth: i64 = cg_loop_depth(cg);
    let ctx: i64 = malloc(24);  // 3 pointers: continue, break, result
    store_ptr(ctx, 0, continue_label);
    store_ptr(ctx, 1, break_label);
    store_ptr(ctx, 2, 0);  // result_ptr initially null
    vec_push(stack, ctx);
    store_i64(cg, 10, depth + 1);
    0
}

// Get current loop context (top of stack)
fn cg_current_loop(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    vec_get(stack, depth - 1)
}

// Pop loop context from stack
fn pop_loop(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth > 0 {
        let new_depth: i64 = depth - 1;
        store_i64(cg, 10, new_depth);
        // When exiting all loops, clear the stack to prevent stale entries
        // from affecting subsequent loops in the same function
        if new_depth == 0 {
            store_ptr(cg, 9, vec_new());
        }
    }
    0
}

// Get current loop continue label (top of stack)
fn current_loop_continue(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 0)
}

// Get current loop break label (top of stack)
fn current_loop_break(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 1)
}

// Register a struct
fn register_struct(cg: i64, name: i64, fields: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, fields);
    vec_push(structs, entry);
    0
}

// Look up struct field index (returns byte offset = index * 8)
fn lookup_struct_field(cg: i64, struct_name: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            let fields: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(fields);
            let j: i64 = 0;
            while j < m {
                let field: i64 = vec_get(fields, j);
                let fname: i64 = load_ptr(field, 0);
                if string_eq(fname, field_name) {
                    return j;  // Return field index
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Get struct fields by name
fn lookup_struct_fields(cg: i64, struct_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Look up struct definition by name (returns the entry or 0 if not found)
fn cg_lookup_struct(cg: i64, struct_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            return entry;
        }
        i = i + 1;
    }
    0
}

// Look up field in all registered structs (for field access without type info)
fn lookup_field_in_all_structs(cg: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let fields: i64 = load_ptr(entry, 1);
        let m: i64 = vec_len(fields);
        let j: i64 = 0;
        while j < m {
            let field: i64 = vec_get(fields, j);
            let fname: i64 = load_ptr(field, 0);
            if string_eq(fname, field_name) {
                return j;  // Return field index
            }
            j = j + 1;
        }
        i = i + 1;
    }
    0
}

// Add local: stores (original_name, unique_name) pair
fn add_local(cg: i64, original_name: i64, unique_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, original_name);
    store_ptr(pair, 1, unique_name);
    vec_push(locals, pair);
    0
}

// Lookup local: find most recent unique_name for original_name
fn lookup_local(cg: i64, original_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let n: i64 = vec_len(locals);
    // Search backwards to get most recent
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(locals, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, original_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    // Not found - report error and return original
    error_undefined_var(original_name);
    original_name
}

// Generate expression - returns the LLVM value (temp name or literal)
fn gen_expr(cg: i64, expr: i64) -> i64 {
    // Guard against null expressions
    if expr == 0 {
        return string_from("0");
    }
    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == EXPR_INT() {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == EXPR_BOOL() {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("1");
        }
        return string_from("0");
    }

    // String literal - allocate and initialize
    if tag == EXPR_STRING() {
        let value: i64 = load_ptr(expr, 1);
        let str_idx: i64 = cg_add_string(cg, value);  // Track the string constant
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        // Emit call to intrinsic_string_new with the string constant
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
        emit(cg, cg_module_name(cg));
        emit(cg, ".");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");

        // Convert ptr to i64 for consistent type handling
        let t2: i64 = cg_next_temp(cg);
        let temp2: i64 = string_concat("%t", int_to_string(t2));
        emit(cg, "  ");
        emit(cg, temp2);
        emit(cg, " = ptrtoint ptr ");
        emit(cg, temp);
        emit_line(cg, " to i64");

        return temp2;
    }

    // FString - interpolated string
    // Layout: tag(0), parts(1), exprs(2)
    if tag == EXPR_FSTRING() {
        let parts: i64 = load_ptr(expr, 1);
        let exprs: i64 = load_ptr(expr, 2);
        let num_parts: i64 = vec_len(parts);
        let num_exprs: i64 = vec_len(exprs);

        // Start with empty string
        let result: i64 = string_from("0");

        // Interleave parts and expressions
        let i: i64 = 0;
        while i < num_parts {
            // Emit the string part
            let part: i64 = vec_get(parts, i);
            if string_len(part) > 0 {
                let part_idx: i64 = cg_add_string(cg, part);
                let t1: i64 = cg_next_temp(cg);
                let temp1: i64 = string_concat("%t", int_to_string(t1));
                emit(cg, "  ");
                emit(cg, temp1);
                emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
                emit(cg, cg_module_name(cg));
                emit(cg, ".");
                emit(cg, int_to_string(part_idx));
                emit_line(cg, ")");

                let t2: i64 = cg_next_temp(cg);
                let temp2: i64 = string_concat("%t", int_to_string(t2));
                emit(cg, "  ");
                emit(cg, temp2);
                emit(cg, " = ptrtoint ptr ");
                emit(cg, temp1);
                emit_line(cg, " to i64");

                // Concat with result
                if string_eq(result, "0") {
                    result = temp2;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, temp2);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            // If there's an expression, evaluate and concat it
            if i < num_exprs {
                let ex: i64 = vec_get(exprs, i);
                let ex_val: i64 = gen_expr(cg, ex);

                // Concat with result (assuming expr returns string handle)
                if string_eq(result, "0") {
                    result = ex_val;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, ex_val);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            i = i + 1;
        }

        return result;
    }

    // Yield expression - for generators
    // Layout: tag(0), inner(1)
    if tag == EXPR_YIELD() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Call generator_yield intrinsic
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @generator_yield(i64 ");
        emit(cg, inner_val);
        emit_line(cg, ")");

        return temp;
    }

    // Closure expression - return placeholder (closures should be handled in let statements)
    if tag == EXPR_CLOSURE() {
        // Closures assigned to variables are handled in let statement processing
        // If we get here, it's a closure used directly (not supported for now)
        let closure_id: i64 = cg_next_closure_id(cg);
        return int_to_string(closure_id);
    }

    // Identifier - load from local
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);

        // Check if this is a const generic parameter
        let const_value: i64 = cg_lookup_const_param(cg, name);
        if const_value != 0 {
            // Return the literal value directly
            return const_value;
        }

        // Phase 36: Check if this is an enum variant without arguments (e.g., None)
        let opt_variant_idx: i64 = lookup_variant(cg, string_from("Option"), name);
        if opt_variant_idx >= 0 {
            // This is None - allocate Option with just the tag
            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " = call ptr @malloc(i64 8)");
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(opt_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check if this is a nullary message constructor (e.g., Get for actor messages)
        // Nullary messages are used with ask(actor, Get) - they need to be called as functions
        if cg_is_message(cg, name) == 1 {
            // Generate a function call to the message constructor
            let t: i64 = cg_next_temp(cg);
            let temp: i64 = string_concat("%t", int_to_string(t));
            emit(cg, "  ");
            emit(cg, temp);
            emit(cg, " = call i64 @\"");
            emit(cg, name);
            emit_line(cg, "\"()");
            return temp;
        }

        let unique_name: i64 = lookup_local(cg, name);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = load i64, ptr %local.");
        emit_line(cg, unique_name);

        return temp;
    }

    // Path - enum variant (no payload)
    // Allocate memory and store tag for consistency with payloaded enums
    if tag == EXPR_PATH() {
        let segments: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(segments);
        if len == 2 {
            let enum_name: i64 = vec_get(segments, 0);
            let var_name: i64 = vec_get(segments, 1);
            let idx: i64 = lookup_variant(cg, enum_name, var_name);
            // Allocate 8 bytes for tag only
            let ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(ptr_t));
            emit_line(cg, " = call ptr @malloc(i64 8)");
            // Store tag at offset 0
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(ptr_t));
            // Convert to i64 for return
            let ret_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(ret_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(ptr_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(ret_t));
        }
        return string_from("0");
    }

    // Function call
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);  // Generic type arguments (or 0)

        // Get function name - handle both identifiers and path expressions
        var callee_name: i64 = 0;
        let callee_tag: i64 = load_i64(callee, 0);
        if callee_tag == EXPR_PATH() {
            // Path expression like Vec::new or std::io::read
            let segments: i64 = load_ptr(callee, 1);
            let seg_len: i64 = vec_len(segments);
            if seg_len == 2 {
                let type_part: i64 = vec_get(segments, 0);
                let method_part: i64 = vec_get(segments, 1);
                // Handle Vec::new() -> vec_new()
                if string_eq(type_part, string_from("Vec")) {
                    if string_eq(method_part, string_from("new")) {
                        callee_name = string_from("vec_new");
                    }
                }
                // Handle Option::Some, Option::None
                if string_eq(type_part, string_from("Option")) {
                    callee_name = method_part;
                }
                // Handle Result::Ok, Result::Err
                if string_eq(type_part, string_from("Result")) {
                    callee_name = method_part;
                }
                // Check if type_part is a user-defined enum
                // Store enum name for later inline construction
                if callee_name == 0 {
                    let enum_variant_idx: i64 = lookup_variant(cg, type_part, method_part);
                    if enum_variant_idx >= 0 {
                        // Mark this as an enum variant call by prefixing with "enum:"
                        callee_name = string_concat("enum:", string_concat(type_part, string_concat(":", method_part)));
                    }
                }
                // Default: join with underscore for static method calls
                if callee_name == 0 {
                    callee_name = string_concat(type_part, string_concat("_", method_part));
                }
            } else {
                if seg_len > 0 {
                    callee_name = vec_get(segments, seg_len - 1);
                }
            }
        } else {
            // Simple identifier
            callee_name = load_ptr(callee, 1);
        }

        // Check if this is a closure call (inline expansion)
        let closure_entry: i64 = cg_lookup_closure(cg, callee_name);
        if closure_entry != 0 {
            // Inline the closure body with argument substitution
            let closure_params: i64 = load_ptr(closure_entry, 1);
            let closure_body: i64 = load_ptr(closure_entry, 2);

            // Generate argument values and bind them to parameter names
            let n: i64 = vec_len(args);
            let i: i64 = 0;
            while i < n {
                let arg: i64 = vec_get(args, i);
                let val: i64 = gen_expr(cg, arg);

                // Get param name and bind it to the argument value
                if i < vec_len(closure_params) {
                    let param: i64 = vec_get(closure_params, i);
                    let param_name: i64 = load_ptr(param, 0);  // param: (name, type)
                    // Create an alloca and store the argument value
                    let param_id: i64 = cg_next_temp(cg);
                    let unique_name: i64 = str_unique(param_name, param_id);
                    emit(cg, "  %local.");
                    emit(cg, unique_name);
                    emit_line(cg, " = alloca i64");
                    emit(cg, "  store i64 ");
                    emit(cg, val);
                    emit(cg, ", ptr %local.");
                    emit_line(cg, unique_name);
                    add_local(cg, param_name, unique_name);
                }
                i = i + 1;
            }

            // Generate the closure body - captures work because we're in same function
            return gen_expr(cg, closure_body);
        }

        // Generate args for regular function call
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // ===== PHASE 36: ENUM VARIANT CONSTRUCTORS =====
        // Handle Some(x), None, Ok(x), Err(e) as enum constructors
        let variant_idx: i64 = lookup_variant(cg, string_from("Option"), callee_name);
        if variant_idx >= 0 {
            // Option variant: Some or None
            // Allocate: 8 bytes tag + 8 bytes payload (if Some)
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads at offset 8, 16, etc.
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for Result variants
        let result_variant_idx: i64 = lookup_variant(cg, string_from("Result"), callee_name);
        if result_variant_idx >= 0 {
            // Result variant: Ok or Err
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(result_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Handle user-defined enum variants (marked as "enum:EnumName:VariantName")
        if string_starts_with(callee_name, string_from("enum:")) {
            // Parse enum:EnumName:VariantName
            let rest: i64 = string_slice(callee_name, 5, string_len(callee_name));
            let colon_pos: i64 = string_find(rest, string_from(":"), 0);
            let enum_name: i64 = string_slice(rest, 0, colon_pos);
            let variant_name: i64 = string_slice(rest, colon_pos + 1, string_len(rest));

            // Look up the variant index
            let user_variant_idx: i64 = lookup_variant(cg, enum_name, variant_name);

            // Generate enum construction inline (same as Option/Result)
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(user_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for intrinsics - emit with proper type conversions
        // Pattern: convert i64 args to ptr, call intrinsic, convert ptr result to i64

        // string_from: argument is already a string handle from EXPR_STRING
        if string_eq(callee_name, "string_from") {
            return vec_get(arg_values, 0);
        }

        // void intrinsics (return "0")
        if string_eq(callee_name, "println") {
            emit_intrinsic_void_ptr(cg, "intrinsic_println", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "print") {
            emit_intrinsic_void_ptr(cg, "intrinsic_print", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "print_i64") {
            emit_intrinsic_void_i64(cg, "print_i64", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_push") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_vec_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "write_file") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_write_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "file_write") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_write_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "remove_path") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_remove_path", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "free") {
            emit_intrinsic_void_ptr(cg, "free", vec_get(arg_values, 0));
            return string_from("0");
        }

        // i64 result intrinsics
        if string_eq(callee_name, "string_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_char_at") {
            return emit_intrinsic_i64_ptr_i64(cg, "intrinsic_string_char_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_to_int") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_to_int", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_vec_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_i64") {
            return emit_intrinsic_i64_ptr_i64(cg, "load_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_eq") {
            return emit_intrinsic_i1_ptr_ptr(cg, "intrinsic_string_eq", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // ptr result intrinsics -> convert to i64
        if string_eq(callee_name, "string_concat") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_concat", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_slice") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "intrinsic_string_slice", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "int_to_string") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_int_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_from_char") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_string_from_char", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_vec_new");
        }
        // Handle mangled name from Vec::new() syntax
        if string_eq(callee_name, "Vec_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_vec_new");
        }
        if string_eq(callee_name, "vec_get") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_vec_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_args") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_args");
        }
        if string_eq(callee_name, "read_file") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_read_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "malloc") {
            return emit_intrinsic_ptr_i64(cg, "malloc", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_ptr") {
            return emit_intrinsic_ptr_ptr_i64(cg, "load_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "store_ptr") {
            return emit_intrinsic_ptr_ptr_i64_ptr(cg, "store_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "store_i64") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "store_i64", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }

        // Timing intrinsics
        if string_eq(callee_name, "get_time_ms") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_ms");
        }
        if string_eq(callee_name, "get_time_us") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_us");
        }

        // File I/O intrinsics
        if string_eq(callee_name, "file_exists") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_exists", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_dir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_directory", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_size") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_size", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_mtime") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_mtime", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "remove_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_remove_path", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "mkdir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_mkdir_p", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "get_cwd") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_cwd");
        }
        if string_eq(callee_name, "set_cwd") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_set_cwd", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "list_dir") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_list_dir", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_join") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_path_join", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "path_dirname") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_dirname", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_basename") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_basename", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_ext") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_extension", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_copy") {
            return emit_intrinsic_i64_ptr_ptr(cg, "file_copy", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "file_rename") {
            return emit_intrinsic_i64_ptr_ptr(cg, "file_rename", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "stderr_write") {
            emit_intrinsic_void_ptr(cg, "stderr_write", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "stderr_writeln") {
            emit_intrinsic_void_ptr(cg, "stderr_writeln", vec_get(arg_values, 0));
            return string_from("0");
        }

        // Arena intrinsics
        if string_eq(callee_name, "arena_create") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_arena_create", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "arena_alloc") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_arena_alloc", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "arena_reset") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_reset", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_used") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_arena_used", vec_get(arg_values, 0));
        }

        // StringBuilder intrinsics
        if string_eq(callee_name, "sb_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_sb_new");
        }
        if string_eq(callee_name, "sb_new_cap") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_sb_new_cap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_append") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_sb_append", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_char") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_char", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_i64") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_to_string") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_sb_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_clear") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_sb_len", vec_get(arg_values, 0));
        }

        // Error handling intrinsics
        if string_eq(callee_name, "panic") {
            emit_intrinsic_void_ptr(cg, "intrinsic_panic", vec_get(arg_values, 0));
            emit_line(cg, "  unreachable");
            return string_from("0");
        }
        if string_eq(callee_name, "print_stack_trace") {
            emit_intrinsic_void_void(cg, "intrinsic_print_stack_trace");
            return string_from("0");
        }

        // Process intrinsics
        if string_eq(callee_name, "process_run") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_process_run", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "process_output") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_process_output", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "exit") {
            emit_intrinsic_void_i64(cg, "intrinsic_exit", vec_get(arg_values, 0));
            return string_from("0");
        }

        // Phase 20: REPL/I/O intrinsics
        if string_eq(callee_name, "read_line") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_read_line");
        }
        if string_eq(callee_name, "is_tty") {
            return emit_intrinsic_i64_void(cg, "intrinsic_is_tty");
        }
        if string_eq(callee_name, "stdin_has_data") {
            return emit_intrinsic_i64_void(cg, "intrinsic_stdin_has_data");
        }
        if string_eq(callee_name, "string_hash") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_hash", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_find") {
            return emit_intrinsic_i64_ptr_ptr_i64(cg, "intrinsic_string_find", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "string_trim") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_trim", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_split") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_split", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_starts_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_starts_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_ends_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_ends_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_contains") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_replace") {
            return emit_intrinsic_ptr_ptr_ptr_ptr(cg, "intrinsic_string_replace", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "copy_file") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_copy_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_home_dir") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_home_dir");
        }

        // Phase 1 Stdlib: HashMap
        if string_eq(callee_name, "hashmap_new") {
            return emit_intrinsic_i64_void(cg, "hashmap_new");
        }
        if string_eq(callee_name, "hashmap_insert") {
            return emit_call_i64_3args(cg, "hashmap_insert", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "hashmap_get") {
            return emit_call_i64_2args(cg, "hashmap_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_remove") {
            return emit_call_i64_2args(cg, "hashmap_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_contains") {
            return emit_call_i64_2args(cg, "hashmap_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_len") {
            return emit_call_i64_1arg(cg, "hashmap_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashmap_clear") {
            emit_call_void_1arg(cg, "hashmap_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "hashmap_keys") {
            return emit_call_i64_1arg(cg, "hashmap_keys", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashmap_values") {
            return emit_call_i64_1arg(cg, "hashmap_values", vec_get(arg_values, 0));
        }

        // Phase 1 Stdlib: HashSet
        if string_eq(callee_name, "hashset_new") {
            return emit_intrinsic_i64_void(cg, "hashset_new");
        }
        if string_eq(callee_name, "hashset_insert") {
            return emit_call_i64_2args(cg, "hashset_insert", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_remove") {
            return emit_call_i64_2args(cg, "hashset_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_contains") {
            return emit_call_i64_2args(cg, "hashset_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_len") {
            return emit_call_i64_1arg(cg, "hashset_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashset_clear") {
            emit_call_void_1arg(cg, "hashset_clear", vec_get(arg_values, 0));
            return string_from("0");
        }

        // Phase 1 Stdlib: Option
        if string_eq(callee_name, "option_some") {
            return emit_call_i64_1arg(cg, "option_some", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_none") {
            return emit_intrinsic_i64_void(cg, "option_none");
        }
        if string_eq(callee_name, "option_is_some") {
            return emit_call_i64_1arg(cg, "option_is_some", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_is_none") {
            return emit_call_i64_1arg(cg, "option_is_none", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_unwrap") {
            return emit_call_i64_1arg(cg, "option_unwrap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_expect") {
            return emit_call_i64_2args(cg, "option_expect", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "option_unwrap_or") {
            return emit_call_i64_2args(cg, "option_unwrap_or", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: Result
        if string_eq(callee_name, "result_ok") {
            return emit_call_i64_1arg(cg, "result_ok", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_err") {
            return emit_call_i64_1arg(cg, "result_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_is_ok") {
            return emit_call_i64_1arg(cg, "result_is_ok", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_is_err") {
            return emit_call_i64_1arg(cg, "result_is_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap") {
            return emit_call_i64_1arg(cg, "result_unwrap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap_err") {
            return emit_call_i64_1arg(cg, "result_unwrap_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap_or") {
            return emit_call_i64_2args(cg, "result_unwrap_or", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: Vec extensions
        if string_eq(callee_name, "vec_sum") {
            return emit_call_i64_1arg(cg, "vec_sum", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_find") {
            return emit_call_i64_2args(cg, "vec_find", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "vec_contains") {
            return emit_call_i64_2args(cg, "vec_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "vec_reverse") {
            return emit_call_i64_1arg(cg, "vec_reverse", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_clone") {
            return emit_call_i64_1arg(cg, "vec_clone", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_first") {
            return emit_call_i64_1arg(cg, "vec_first", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_last") {
            return emit_call_i64_1arg(cg, "vec_last", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_pop") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_vec_pop", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_set") {
            emit_intrinsic_void_ptr_i64_ptr(cg, "intrinsic_vec_set", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_clear") {
            emit_intrinsic_void_ptr(cg, "intrinsic_vec_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_remove") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_vec_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }

        // Phase 1 Stdlib: String extensions (map to intrinsics)
        if string_eq(callee_name, "string_to_lower") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_to_lowercase", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_to_upper") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_to_uppercase", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_compare") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_compare", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_lines") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_lines", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_join") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_join", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: JSON
        if string_eq(callee_name, "json_parse") {
            return emit_call_i64_1arg(cg, "json_parse_simple", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_stringify") {
            return emit_call_i64_1arg(cg, "json_stringify", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_get") {
            return emit_call_i64_2args(cg, "json_get_sx", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "json_keys") {
            return emit_call_i64_1arg(cg, "json_keys", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_string") {
            return emit_call_i64_1arg(cg, "json_is_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_object") {
            return emit_call_i64_1arg(cg, "json_is_object", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_array") {
            return emit_call_i64_1arg(cg, "json_is_array", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_as_string") {
            return emit_call_i64_1arg(cg, "json_as_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_as_array") {
            return emit_call_i64_1arg(cg, "json_as_array", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_object_new") {
            return emit_intrinsic_i64_void(cg, "json_object_new");
        }
        if string_eq(callee_name, "json_array_new") {
            return emit_intrinsic_i64_void(cg, "json_array_new");
        }
        if string_eq(callee_name, "json_object_set") {
            emit_call_void_3args(cg, "json_object_set", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
            return string_from("0");
        }
        if string_eq(callee_name, "json_array_push") {
            emit_call_void_2args(cg, "json_array_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "json_string") {
            return emit_call_i64_1arg(cg, "json_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_string_sx") {
            return emit_call_i64_1arg(cg, "json_string_sx", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_array_len") {
            return emit_call_i64_1arg(cg, "json_array_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_object_len") {
            return emit_call_i64_1arg(cg, "json_object_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_as_i64") {
            return emit_call_i64_1arg(cg, "json_as_i64", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_get_index") {
            return emit_call_i64_2args(cg, "json_get_index", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "json_is_null") {
            return emit_call_i64_1arg(cg, "json_is_null", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_object") {
            return emit_intrinsic_i64_void(cg, "json_object_new");
        }
        if string_eq(callee_name, "json_object_key_at") {
            return emit_call_i64_2args(cg, "json_object_key_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "json_object_value_at") {
            return emit_call_i64_2args(cg, "json_object_value_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "json_object_set_sx") {
            emit_call_void_3args(cg, "json_object_set_sx", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
            return string_from("0");
        }

        // ===== USER-DEFINED ENUM VARIANT CONSTRUCTORS =====
        // Check if callee_name is an enum variant for any registered enum
        let any_variant_idx: i64 = lookup_variant_any(cg, callee_name);
        if any_variant_idx >= 0 {
            // Found an enum variant - generate construction inline
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(any_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads at offset 8, 16, etc.
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check if this is a generic function call
        let emit_callee: i64 = callee_name;
        if type_args != 0 {
            if vec_len(type_args) > 0 {
                // This is a generic call - mangle the name
                let mangled: i64 = mangle_generic_name(callee_name, type_args);
                emit_callee = mangled;

                // Queue instantiation if not already done
                if cg_is_instantiated(cg, mangled) == false {
                    let fn_def: i64 = cg_lookup_generic(cg, callee_name);
                    if fn_def != 0 {
                        cg_queue_instantiation(cg, mangled, fn_def, type_args);
                        cg_mark_instantiated(cg, mangled);
                    }
                }
            }
        }

        // Default: emit call as user function
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, emit_callee);
        emit(cg, "\"(");

        i = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Binary operation
    if tag == EXPR_BINARY() {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        // Short-circuit evaluation for && and ||
        // Use simple approach: evaluate both and use logical and/or
        // This is simpler than proper phi-based short-circuit
        if op == OP_AND() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // and i1
            let and_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(and_t));
            emit(cg, " = and i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(and_t));
            emit_line(cg, " to i64");

            return result;
        }

        if op == OP_OR() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // or i1
            let or_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(or_t));
            emit(cg, " = or i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(or_t));
            emit_line(cg, " to i64");

            return result;
        }

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = ");

        let is_cmp: bool = false;
        if op == OP_ADD() { emit(cg, "add i64 "); }
        if op == OP_SUB() { emit(cg, "sub i64 "); }
        if op == OP_MUL() { emit(cg, "mul i64 "); }
        if op == OP_DIV() { emit(cg, "sdiv i64 "); }
        if op == OP_MOD() { emit(cg, "srem i64 "); }
        if op == OP_BITAND() { emit(cg, "and i64 "); }
        if op == OP_BITOR() { emit(cg, "or i64 "); }
        if op == OP_BITXOR() { emit(cg, "xor i64 "); }
        if op == OP_SHL() { emit(cg, "shl i64 "); }
        if op == OP_SHR() { emit(cg, "ashr i64 "); }
        if op == OP_EQ() { emit(cg, "icmp eq i64 "); is_cmp = true; }
        if op == OP_NE() { emit(cg, "icmp ne i64 "); is_cmp = true; }
        if op == OP_LT() { emit(cg, "icmp slt i64 "); is_cmp = true; }
        if op == OP_GT() { emit(cg, "icmp sgt i64 "); is_cmp = true; }
        if op == OP_LE() { emit(cg, "icmp sle i64 "); is_cmp = true; }
        if op == OP_GE() { emit(cg, "icmp sge i64 "); is_cmp = true; }

        emit(cg, left_val);
        emit(cg, ", ");
        emit_line(cg, right_val);

        // If comparison, zext from i1 to i64
        if is_cmp {
            let t2: i64 = cg_next_temp(cg);
            let temp2: i64 = string_concat("%t", int_to_string(t2));
            emit(cg, "  ");
            emit(cg, temp2);
            emit(cg, " = zext i1 ");
            emit(cg, temp);
            emit_line(cg, " to i64");
            return temp2;
        }

        return temp;
    }

    // Unary operation
    if tag == EXPR_UNARY() {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        let val: i64 = gen_expr(cg, operand);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);

        if op == OP_NEG() {
            emit(cg, " = sub i64 0, ");
            emit_line(cg, val);
        }
        if op == OP_NOT() {
            // Bool is represented as i64, so use i64 for xor
            emit(cg, " = xor i64 ");
            emit(cg, val);
            emit_line(cg, ", 1");
        }

        return temp;
    }

    // If expression
    if tag == EXPR_IF() {
        return gen_if(cg, expr);
    }

    // While expression
    if tag == EXPR_WHILE() {
        return gen_while(cg, expr);
    }

    // While-let expression
    if tag == EXPR_WHILE_LET() {
        return gen_while_let(cg, expr);
    }

    // Loop expression
    if tag == EXPR_LOOP() {
        return gen_loop(cg, expr);
    }

    // Break expression with value
    if tag == EXPR_BREAK() {
        return gen_break_value(cg, expr);
    }

    // For expression
    if tag == EXPR_FOR() {
        return gen_for(cg, expr);
    }

    // Match expression
    if tag == EXPR_MATCH() {
        return gen_match(cg, expr);
    }

    // Block expression
    if tag == EXPR_BLOCK() {
        return gen_block(cg, expr);
    }

    // Struct literal: Foo { x: 1, y: 2 } or Foo::<T> { x: 1, y: 2 }
    if tag == EXPR_STRUCT_LIT() {
        let struct_name: i64 = load_ptr(expr, 1);
        let field_inits: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);
        let num_fields: i64 = vec_len(field_inits);

        // Monomorphize if type args provided (e.g., Pair::<i64, i64>)
        let effective_name: i64 = monomorphize_struct(cg, struct_name, type_args);

        // Allocate struct: malloc(num_fields * 8)
        let alloc_size: i64 = num_fields * 8;
        let t: i64 = cg_next_temp(cg);
        let ptr_temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, ptr_temp);
        emit(cg, " = call ptr @malloc(i64 ");
        emit(cg, int_to_string(alloc_size));
        emit_line(cg, ")");

        // Get the struct field order from definition
        let fields: i64 = lookup_struct_fields(cg, effective_name);
        if fields == 0 {
            error_undefined_struct(effective_name);
        }

        // Initialize each field
        let i: i64 = 0;
        while i < num_fields {
            let field_init: i64 = vec_get(field_inits, i);
            let field_name: i64 = load_ptr(field_init, 0);
            let field_expr: i64 = load_ptr(field_init, 1);

            // Generate field value
            let field_val: i64 = gen_expr(cg, field_expr);

            // Look up field offset
            let field_idx: i64 = lookup_struct_field(cg, effective_name, field_name);
            let offset: i64 = field_idx * 8;

            // Store field using getelementptr + store
            let gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(gep_t));
            emit(cg, " = getelementptr i8, ptr ");
            emit(cg, ptr_temp);
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(offset));

            emit(cg, "  store i64 ");
            emit(cg, field_val);
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(gep_t));

            i = i + 1;
        }

        // Convert ptr to i64
        return emit_ptr_to_i64(cg, ptr_temp);
    }

    // Field access: expr.field
    if tag == EXPR_FIELD() {
        let object: i64 = load_ptr(expr, 1);
        let field_name: i64 = load_ptr(expr, 2);

        // Generate object value (pointer as i64)
        let obj_val: i64 = gen_expr(cg, object);

        // Convert i64 to ptr
        let ptr_temp: i64 = emit_i64_to_ptr(cg, obj_val);

        // For now, we need to figure out the struct type from context
        // We'll do a simple approach: try all structs and find one with this field
        let field_idx: i64 = lookup_field_in_all_structs(cg, field_name);
        let offset: i64 = field_idx * 8;

        // GEP to field
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr ");
        emit(cg, ptr_temp);
        emit(cg, ", i64 ");
        emit_line(cg, int_to_string(offset));

        // Load field value
        let load_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(load_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(load_t));
    }

    // Method call: expr.method(args)
    if tag == EXPR_METHOD_CALL() {
        let object: i64 = load_ptr(expr, 1);
        let method_name: i64 = load_ptr(expr, 2);
        let args: i64 = load_ptr(expr, 3);

        // Try to get the type of the object
        let type_name: i64 = 0;

        // If object is an identifier, look up its type
        let obj_tag: i64 = load_i64(object, 0);
        if obj_tag == EXPR_IDENT() {
            let obj_name: i64 = load_ptr(object, 1);
            type_name = lookup_var_type(cg, obj_name);
        }

        // Generate object value (this will be the first argument)
        let obj_val: i64 = gen_expr(cg, object);

        // Generate remaining arguments
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Check if this is a dyn trait object (Phase 32 dynamic dispatch)
        if is_dyn_type(type_name) != 0 {
            // Dynamic dispatch through vtable
            // dyn object layout: data_ptr(0), vtable_ptr(8)
            let trait_name: i64 = extract_dyn_trait(type_name);
            let method_idx: i64 = cg_get_vtable_method_index(cg, trait_name, method_name);

            // obj_val is a fat pointer (16 bytes): data_ptr + vtable_ptr
            // Convert to ptr to access fields
            let fat_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            // Load data pointer (offset 0)
            let data_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(data_ptr_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(fat_ptr_t));

            // Load vtable pointer (offset 8)
            let vtable_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_gep_t));
            emit(cg, " = getelementptr i8, ptr %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit_line(cg, ", i64 8");

            let vtable_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(vtable_gep_t));

            // Index into vtable to get function pointer
            let fn_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_gep_t));
            emit(cg, " = getelementptr ptr, ptr %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(method_idx));

            let fn_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(fn_gep_t));

            // Call through function pointer
            let t: i64 = cg_next_temp(cg);
            let temp: i64 = string_concat("%t", int_to_string(t));

            emit(cg, "  ");
            emit(cg, temp);
            emit(cg, " = call i64 %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, "(i64 %t");
            emit(cg, int_to_string(data_ptr_t));

            // Additional arguments
            let total_args: i64 = vec_len(arg_values);
            i = 0;
            while i < total_args {
                emit(cg, ", i64 ");
                emit(cg, vec_get(arg_values, i));
                i = i + 1;
            }
            emit_line(cg, ")");

            return temp;
        }

        // ===== PHASE 36: INLINE OPTION METHODS =====
        // Handle Option<T> methods inline (is_some, is_none, unwrap, unwrap_or)
        let base_type: i64 = extract_base_type(type_name);
        if string_eq(base_type, string_from("Option")) {
            // Option layout: tag at offset 0 (0=None, 1=Some), value at offset 8
            let opt_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(opt_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(opt_ptr_t));

            if string_eq(method_name, string_from("is_some")) {
                // tag == 1 means Some
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_none")) {
                // tag == 0 means None
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Some, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_some_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let some_lbl: i64 = string_concat("unwrap_or_some", int_to_string(lbl));
                let none_lbl: i64 = string_concat("unwrap_or_none", int_to_string(lbl));
                let done_lbl: i64 = string_concat("unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, ", label %");
                emit(cg, some_lbl);
                emit(cg, ", label %");
                emit_line(cg, none_lbl);

                emit(cg, some_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let some_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, none_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, ", %");
                emit(cg, some_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, none_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // ===== PHASE 36: INLINE RESULT METHODS =====
        // Handle Result<T,E> methods inline (is_ok, is_err, unwrap, unwrap_err, unwrap_or)
        if string_eq(base_type, string_from("Result")) {
            // Result layout: tag at offset 0 (0=Err, 1=Ok), value at offset 8
            let res_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(res_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(res_ptr_t));

            if string_eq(method_name, string_from("is_ok")) {
                // tag == 1 means Ok
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_err")) {
                // tag == 0 means Err
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_err")) {
                // Return error at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Ok, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_ok_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let ok_lbl: i64 = string_concat("result_unwrap_or_ok", int_to_string(lbl));
                let err_lbl: i64 = string_concat("result_unwrap_or_err", int_to_string(lbl));
                let done_lbl: i64 = string_concat("result_unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, ", label %");
                emit(cg, ok_lbl);
                emit(cg, ", label %");
                emit_line(cg, err_lbl);

                emit(cg, ok_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let ok_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, err_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, ", %");
                emit(cg, ok_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, err_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // ===== INLINE VEC METHODS =====
        // Handle Vec<T> methods by mapping to intrinsic functions
        if string_eq(base_type, string_from("Vec")) {
            if string_eq(method_name, string_from("len")) {
                // vec.len() -> intrinsic_vec_len(vec)
                return emit_intrinsic_i64_ptr(cg, "intrinsic_vec_len", obj_val);
            }

            if string_eq(method_name, string_from("push")) {
                // vec.push(item) -> intrinsic_vec_push(vec, item)
                let item_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    item_val = vec_get(arg_values, 0);
                }
                emit_intrinsic_void_ptr2(cg, "intrinsic_vec_push", obj_val, item_val);
                return string_from("0");
            }

            if string_eq(method_name, string_from("get")) {
                // vec.get(idx) -> intrinsic_vec_get(vec, idx)
                let idx_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    idx_val = vec_get(arg_values, 0);
                }
                return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_vec_get", obj_val, idx_val);
            }

            if string_eq(method_name, string_from("pop")) {
                // vec.pop() -> intrinsic_vec_pop(vec)
                return emit_intrinsic_ptr_ptr(cg, "intrinsic_vec_pop", obj_val);
            }

            if string_eq(method_name, string_from("clear")) {
                // vec.clear() -> intrinsic_vec_clear(vec)
                emit_intrinsic_void_ptr(cg, "intrinsic_vec_clear", obj_val);
                return string_from("0");
            }

            if string_eq(method_name, string_from("is_empty")) {
                // vec.is_empty() -> intrinsic_vec_len(vec) == 0
                let len_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(len_t));
                emit(cg, " = call i64 @intrinsic_vec_len(i64 ");
                emit(cg, obj_val);
                emit_line(cg, ")");
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(len_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // Static dispatch - build mangled function name: TypeName_methodName
        let callee_name: i64 = method_name;
        if type_name != 0 {
            callee_name = str_mangle(type_name, method_name);
        }

        // Emit call - object is first argument
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(i64 ");
        emit(cg, obj_val);

        let total_args: i64 = vec_len(arg_values);
        i = 0;
        while i < total_args {
            emit(cg, ", i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Try operator: expr? - check Result tag and early return on Err
    // Result layout: tag(0=Err, 1=Ok) at offset 0, value at offset 8
    if tag == EXPR_TRY() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Convert i64 to ptr
        let ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ptr_t));
        emit(cg, " = inttoptr i64 ");
        emit(cg, inner_val);
        emit_line(cg, " to ptr");

        // Load the tag (field 0)
        let tag_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tag_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(ptr_t));

        // Check if tag == 0 (Err)
        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp eq i64 %t");
        emit(cg, int_to_string(tag_t));
        emit_line(cg, ", 0");

        // Labels for conditional
        let label: i64 = cg_next_label(cg);
        let err_label: i64 = string_concat("try_err", int_to_string(label));
        let ok_label: i64 = string_concat("try_ok", int_to_string(label));

        // Branch: if Err goto err_label, else goto ok_label
        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, err_label);
        emit(cg, ", label %");
        emit_line(cg, ok_label);

        // Error path: early return the Result
        emit(cg, err_label);
        emit_line(cg, ":");
        emit(cg, "  ret i64 ");
        emit_line(cg, inner_val);

        // Ok path: unwrap the value (field 1, offset 8)
        emit(cg, ok_label);
        emit_line(cg, ":");
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr %t");
        emit(cg, int_to_string(ptr_t));
        emit_line(cg, ", i64 8");
        let val_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(val_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(val_t));
    }

    // EXPR_AWAIT - await a future
    if tag == EXPR_AWAIT() {
        let inner: i64 = load_ptr(expr, 1);
        let future_val: i64 = gen_expr(cg, inner);

        // For async context, we generate a state transition
        // For sync context, we poll in a loop until ready

        if cg_is_async_fn(cg) != 0 {
            // Inside async function - generate state machine transition
            let state_num: i64 = cg_next_async_state(cg);
            let resume_label: i64 = string_concat("await_resume_", int_to_string(state_num));

            // Save current state number
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(state_num));
            emit_line(cg, ", ptr %async_state");

            // Store the future we're awaiting
            emit(cg, "  store i64 ");
            emit(cg, future_val);
            emit_line(cg, ", ptr %async_inner_future");

            // Record this await point for the dispatch switch
            cg_add_await_point(cg, state_num, resume_label);

            // Poll the inner future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check poll result: 0 = Pending, 1 = Ready(value)
            let is_ready: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, " = and i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, ", 0");

            let pending_label: i64 = string_concat("await_pending_", int_to_string(state_num));
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, pending_label);
            emit(cg, ", label %");
            emit_line(cg, resume_label);

            // Pending path - return Pending from poll
            emit(cg, pending_label);
            emit_line(cg, ":");
            emit_line(cg, "  ret i64 0");  // Return Pending

            // Ready path - continue execution
            emit(cg, resume_label);
            emit_line(cg, ":");

            // Extract the value (shift right to remove tag bit)
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        } else {
            // Synchronous context - poll in a loop until ready
            let loop_label: i64 = string_concat("await_loop_", int_to_string(cg_next_label(cg)));
            let done_label: i64 = string_concat("await_done_", int_to_string(cg_next_label(cg)));

            emit(cg, "  br label %");
            emit_line(cg, loop_label);

            emit(cg, loop_label);
            emit_line(cg, ":");

            // Poll the future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check if ready
            let is_pending: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 0");

            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, ", label %");
            emit(cg, loop_label);
            emit(cg, ", label %");
            emit_line(cg, done_label);

            emit(cg, done_label);
            emit_line(cg, ":");

            // Extract the value
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        }
    }

    // EXPR_SPAWN - spawn an actor/specialist
    if tag == EXPR_SPAWN() {
        let type_name: i64 = load_ptr(expr, 1);
        // Generate call to TypeName_new() constructor
        let ctor_name: i64 = string_concat(type_name, "_new");
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @\"");
        emit(cg, ctor_name);
        emit_line(cg, "\"()");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_INFER - AI model inference
    if tag == EXPR_INFER() {
        let prompt: i64 = load_ptr(expr, 1);
        // Generate the prompt expression
        let prompt_val: i64 = gen_expr(cg, prompt);
        // Call the runtime inference function
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @model_infer(i64 ");
        emit(cg, prompt_val);
        emit_line(cg, ")");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_FLOAT - floating point literal
    if tag == EXPR_FLOAT() {
        let text: i64 = load_ptr(expr, 1);
        // Convert float string to f64 bits, store in i64
        // Use f64_parse intrinsic to convert string to f64 bits
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @f64_parse(ptr ");
        // Add string constant
        let str_idx: i64 = cg_add_string(cg, text);
        emit(cg, "@.str.mod.");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_TUPLE - tuple literal (a, b, c)
    // Layout: Allocate struct with each element at 8-byte offsets
    if tag == EXPR_TUPLE() {
        let elements: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(elements);
        let size: i64 = len * 8;
        if size == 0 {
            size = 8;  // At least 8 bytes for empty tuple
        }

        // Allocate memory for tuple
        let ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ptr_t));
        emit(cg, " = call ptr @malloc(i64 ");
        emit(cg, int_to_string(size));
        emit_line(cg, ")");

        // Store each element at offset i * 8
        let i: i64 = 0;
        while i < len {
            let elem: i64 = vec_get(elements, i);
            let elem_val: i64 = gen_expr(cg, elem);
            let offset: i64 = i * 8;

            let gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(gep_t));
            emit(cg, " = getelementptr i8, ptr %t");
            emit(cg, int_to_string(ptr_t));
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(offset));

            emit(cg, "  store i64 ");
            emit(cg, elem_val);
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(gep_t));

            i = i + 1;
        }

        // Return tuple pointer as i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = ptrtoint ptr %t");
        emit(cg, int_to_string(ptr_t));
        emit_line(cg, " to i64");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_INDEX - array/tuple indexing expr[index]
    if tag == EXPR_INDEX() {
        let base: i64 = load_ptr(expr, 1);
        let index: i64 = load_ptr(expr, 2);

        let base_val: i64 = gen_expr(cg, base);
        let index_val: i64 = gen_expr(cg, index);

        // Convert base to ptr
        let base_ptr: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(base_ptr));
        emit(cg, " = inttoptr i64 ");
        emit(cg, base_val);
        emit_line(cg, " to ptr");

        // Calculate offset = index * 8
        let offset_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(offset_t));
        emit(cg, " = mul i64 ");
        emit(cg, index_val);
        emit_line(cg, ", 8");

        // GEP to get element pointer
        let elem_ptr: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(elem_ptr));
        emit(cg, " = getelementptr i8, ptr %t");
        emit(cg, int_to_string(base_ptr));
        emit(cg, ", i64 %t");
        emit_line(cg, int_to_string(offset_t));

        // Load the value
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(elem_ptr));

        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_ARRAY - array literal [a, b, c]
    if tag == EXPR_ARRAY() {
        let elements: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(elements);
        // Create a new vector and push all elements
        let vec_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " = call ptr @intrinsic_vec_new()");
        // Push each element
        let i: i64 = 0;
        while i < len {
            let elem: i64 = vec_get(elements, i);
            let elem_val: i64 = gen_expr(cg, elem);
            // Convert i64 to ptr for vec_push
            let ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, elem_val);
            emit_line(cg, " to ptr");
            emit(cg, "  call void @intrinsic_vec_push(ptr %t");
            emit(cg, int_to_string(vec_t));
            emit(cg, ", ptr %t");
            emit(cg, int_to_string(ptr_t));
            emit_line(cg, ")");
            i = i + 1;
        }
        // Return the vector as i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = ptrtoint ptr %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " to i64");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_CONFIDENCE - confidence(belief_id)
    // Layout: tag(0), belief_id(1)
    // Returns confidence value of specified belief (dual.val) as i64 bit pattern
    if tag == EXPR_CONFIDENCE() {
        let belief_id: i64 = load_ptr(expr, 1);
        let id_val: i64 = gen_expr(cg, belief_id);

        // Call runtime to get belief confidence value
        // Returns f64 bit pattern in i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @belief_guard_get_confidence(i64 ");
        emit(cg, id_val);
        emit_line(cg, ")");

        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_DERIVATIVE - expr.derivative
    // Layout: tag(0), inner_expr(1)
    // Returns derivative of confidence (dual.der) as i64 bit pattern
    if tag == EXPR_DERIVATIVE() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Call runtime to get belief derivative value
        // The inner expression is a confidence() expression - extract derivative
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @belief_guard_get_derivative(i64 ");
        emit(cg, inner_val);
        emit_line(cg, ")");

        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_BELIEF_GUARD - belief_expr cmp value
    // Layout: tag(0), left(1), op(2), right(3)
    // Returns 1 if guard condition is satisfied, 0 otherwise
    if tag == EXPR_BELIEF_GUARD() {
        let left: i64 = load_ptr(expr, 1);
        let op: i64 = load_i64(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        // Compare as f64 bit patterns - use fcmp for floating point comparison
        // First bitcast i64 to double
        let left_f: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(left_f));
        emit(cg, " = bitcast i64 ");
        emit(cg, left_val);
        emit_line(cg, " to double");

        let right_f: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(right_f));
        emit(cg, " = bitcast i64 ");
        emit(cg, right_val);
        emit_line(cg, " to double");

        // Determine comparison type based on operator
        let cmp_op: i64 = string_from("olt");  // default: less than
        if op == OP_LT() {
            cmp_op = string_from("olt");
        }
        if op == OP_LE() {
            cmp_op = string_from("ole");
        }
        if op == OP_GT() {
            cmp_op = string_from("ogt");
        }
        if op == OP_GE() {
            cmp_op = string_from("oge");
        }
        if op == OP_EQ() {
            cmp_op = string_from("oeq");
        }
        if op == OP_NE() {
            cmp_op = string_from("one");
        }

        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = fcmp ");
        emit(cg, cmp_op);
        emit(cg, " double %t");
        emit(cg, int_to_string(left_f));
        emit(cg, ", %t");
        emit_line(cg, int_to_string(right_f));

        // Extend i1 to i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = zext i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit_line(cg, " to i64");

        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_BELIEF_AND - guard && guard
    // Layout: tag(0), left(1), right(2)
    // Short-circuit evaluation: returns 1 if both guards are true
    if tag == EXPR_BELIEF_AND() {
        let left: i64 = load_ptr(expr, 1);
        let right: i64 = load_ptr(expr, 2);

        let left_val: i64 = gen_expr(cg, left);

        // Short-circuit: if left is false (0), result is 0
        let lbl: i64 = cg_next_label(cg);
        let entry_lbl: i64 = string_concat("belief_and_entry", int_to_string(lbl));
        let eval_right: i64 = string_concat("belief_and_right", int_to_string(lbl));
        let short_lbl: i64 = string_concat("belief_and_short", int_to_string(lbl));
        let done_lbl: i64 = string_concat("belief_and_done", int_to_string(lbl));

        // Create entry label block for phi
        emit(cg, "  br label %");
        emit_line(cg, entry_lbl);
        emit(cg, entry_lbl);
        emit_line(cg, ":");

        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp ne i64 ");
        emit(cg, left_val);
        emit_line(cg, ", 0");

        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, eval_right);
        emit(cg, ", label %");
        emit_line(cg, short_lbl);

        // Short-circuit path - left was false, return 0
        emit(cg, short_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, done_lbl);

        // Evaluate right side
        emit(cg, eval_right);
        emit_line(cg, ":");
        let right_val: i64 = gen_expr(cg, right);
        emit(cg, "  br label %");
        emit_line(cg, done_lbl);

        // Merge
        emit(cg, done_lbl);
        emit_line(cg, ":");
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = phi i64 [ 0, %");
        emit(cg, short_lbl);
        emit(cg, " ], [ ");
        emit(cg, right_val);
        emit(cg, ", %");
        emit(cg, eval_right);
        emit_line(cg, " ]");

        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_BELIEF_OR - guard || guard
    // Layout: tag(0), left(1), right(2)
    // Short-circuit evaluation: returns 1 if either guard is true
    if tag == EXPR_BELIEF_OR() {
        let left: i64 = load_ptr(expr, 1);
        let right: i64 = load_ptr(expr, 2);

        let left_val: i64 = gen_expr(cg, left);

        // Short-circuit: if left is true (non-0), result is 1
        let lbl: i64 = cg_next_label(cg);
        let entry_lbl: i64 = string_concat("belief_or_entry", int_to_string(lbl));
        let eval_right: i64 = string_concat("belief_or_right", int_to_string(lbl));
        let short_lbl: i64 = string_concat("belief_or_short", int_to_string(lbl));
        let done_lbl: i64 = string_concat("belief_or_done", int_to_string(lbl));

        // Create entry label block for phi
        emit(cg, "  br label %");
        emit_line(cg, entry_lbl);
        emit(cg, entry_lbl);
        emit_line(cg, ":");

        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp eq i64 ");
        emit(cg, left_val);
        emit_line(cg, ", 0");

        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, eval_right);
        emit(cg, ", label %");
        emit_line(cg, short_lbl);

        // Short-circuit path - left was true, return 1
        emit(cg, short_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, done_lbl);

        // Evaluate right side
        emit(cg, eval_right);
        emit_line(cg, ":");
        let right_val: i64 = gen_expr(cg, right);
        emit(cg, "  br label %");
        emit_line(cg, done_lbl);

        // Merge
        emit(cg, done_lbl);
        emit_line(cg, ":");
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = phi i64 [ 1, %");
        emit(cg, short_lbl);
        emit(cg, " ], [ ");
        emit(cg, right_val);
        emit(cg, ", %");
        emit(cg, eval_right);
        emit_line(cg, " ]");

        return string_concat("%t", int_to_string(result_t));
    }

    string_from("0")
}

// Generate if expression
fn gen_if(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let then_block: i64 = load_ptr(expr, 2);
    let else_block: i64 = load_ptr(expr, 3);

    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    let l: i64 = cg_next_label(cg);
    let then_lbl: i64 = string_concat("then", int_to_string(l));
    let then_end_lbl: i64 = string_concat("then", int_to_string(l));
    then_end_lbl = string_concat(then_end_lbl, "_end");
    let else_lbl: i64 = string_concat("else", int_to_string(l));
    let else_end_lbl: i64 = string_concat("else", int_to_string(l));
    else_end_lbl = string_concat(else_end_lbl, "_end");
    let end_lbl: i64 = string_concat("endif", int_to_string(l));

    // Branch
    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, then_lbl);
    emit(cg, ", label %");
    emit_line(cg, else_lbl);

    // Then block
    emit(cg, then_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let then_val: i64 = gen_block(cg, then_block);
    let then_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, then_end_lbl);
    // Then end block
    emit(cg, then_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Else block
    emit(cg, else_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let else_val: i64 = string_from("0");
    if else_block != 0 {
        else_val = gen_expr(cg, else_block);
    }
    let else_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, else_end_lbl);
    // Else end block
    emit(cg, else_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);

    // Phi with proper predecessor blocks
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = phi i64 [ ");
    emit(cg, then_val);
    emit(cg, ", %");
    emit(cg, then_end_lbl);
    emit(cg, " ], [ ");
    emit(cg, else_val);
    emit(cg, ", %");
    emit(cg, else_end_lbl);
    emit_line(cg, " ]");

    temp
}

// Generate while expression
fn gen_while(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let body: i64 = load_ptr(expr, 2);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let body_lbl: i64 = string_concat("body", int_to_string(l));
    let end_lbl: i64 = string_concat("endloop", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, loop_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate for expression: for i in start..end { body }
// Desugars to: let i = start; while i < end { body; i = i + 1; }
fn gen_for(cg: i64, expr: i64) -> i64 {
    let var_name: i64 = load_ptr(expr, 1);
    let start_expr: i64 = load_ptr(expr, 2);
    let end_expr: i64 = load_ptr(expr, 3);
    let body: i64 = load_ptr(expr, 4);

    // Generate start value
    let start_val: i64 = gen_expr(cg, start_expr);

    // Use pre-allocated local for loop variable
    let unique_name: i64 = cg_pop_alloca(cg);
    if unique_name == 0 {
        // Fallback: allocate inline (shouldn't happen with proper pre-pass)
        let local_id: i64 = cg_next_temp(cg);
        unique_name = str_unique(var_name, local_id);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
    }
    // Initialize loop variable
    emit(cg, "  store i64 ");
    emit(cg, start_val);
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);
    add_local(cg, var_name, unique_name);

    // Generate end value (before the loop since it's evaluated once)
    let end_val: i64 = gen_expr(cg, end_expr);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("for", int_to_string(l));
    let body_lbl: i64 = string_concat("forbody", int_to_string(l));
    let inc_lbl: i64 = string_concat("forinc", int_to_string(l));
    let end_lbl: i64 = string_concat("endfor", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition: i < end
    emit(cg, loop_lbl);
    emit_line(cg, ":");

    // Load current loop variable
    let cur_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    // Compare i < end
    let cmp_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, " = icmp slt i64 %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, ", ");
    emit_line(cg, end_val);

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, inc_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, inc_lbl);

    // Increment loop variable: i = i + 1
    emit(cg, inc_lbl);
    emit_line(cg, ":");
    let load_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(load_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    let inc_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, " = add i64 %t");
    emit(cg, int_to_string(load_t));
    emit_line(cg, ", 1");

    emit(cg, "  store i64 %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate while-let expression: while let Pattern = scrutinee { body }
// Continues looping as long as the pattern matches
fn gen_while_let(cg: i64, expr: i64) -> i64 {
    let pattern: i64 = load_ptr(expr, 1);
    let scrutinee: i64 = load_ptr(expr, 2);
    let body: i64 = load_ptr(expr, 3);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("whilelet", int_to_string(l));
    let match_lbl: i64 = string_concat("whileletmatch", int_to_string(l));
    let body_lbl: i64 = string_concat("whileletbody", int_to_string(l));
    let end_lbl: i64 = string_concat("whileletend", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - evaluate scrutinee
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let scru_val: i64 = gen_expr(cg, scrutinee);

    // Check if pattern matches - similar to if-let
    // For enum patterns like Some(x), check the tag
    let pat_tag: i64 = 0;
    if pattern != 0 {
        pat_tag = load_i64(pattern, 0);
    }

    // Handle enum variant patterns: Some(x)
    if pat_tag == EXPR_CALL() {
        // Pattern is EnumName(binding) - check tag
        let variant_name: i64 = load_ptr(pattern, 1);
        let args: i64 = load_ptr(pattern, 2);

        // Load discriminant from scrutinee (at offset 0)
        let ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ptr_t));
        emit(cg, " = inttoptr i64 ");
        emit(cg, scru_val);
        emit_line(cg, " to ptr");

        let tag_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tag_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(ptr_t));

        // Get expected tag for this variant
        let expected_tag: i64 = 1;  // Default: Some = 1, None = 0
        if string_eq(variant_name, "None") {
            expected_tag = 0;
        }

        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp eq i64 %t");
        emit(cg, int_to_string(tag_t));
        emit(cg, ", ");
        emit_line(cg, int_to_string(expected_tag));

        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, match_lbl);
        emit(cg, ", label %");
        emit_line(cg, end_lbl);

        // Match succeeded - extract binding and execute body
        emit(cg, match_lbl);
        emit_line(cg, ":");

        // Extract binding if present
        if vec_len(args) > 0 {
            let binding: i64 = vec_get(args, 0);
            let bind_tag: i64 = load_i64(binding, 0);
            if bind_tag == EXPR_IDENT() {
                let bind_name: i64 = load_ptr(binding, 1);

                // Load value from offset 8 (after tag)
                let val_gep: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(val_gep));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(ptr_t));
                emit_line(cg, ", i64 8");

                let val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(val_gep));

                // Create local binding
                let local_id: i64 = cg_next_temp(cg);
                let unique_name: i64 = str_unique(bind_name, local_id);
                emit(cg, "  %local.");
                emit(cg, unique_name);
                emit_line(cg, " = alloca i64");
                emit(cg, "  store i64 %t");
                emit(cg, int_to_string(val_t));
                emit(cg, ", ptr %local.");
                emit_line(cg, unique_name);
                add_local(cg, bind_name, unique_name);
            }
        }

        emit(cg, "  br label %");
        emit_line(cg, body_lbl);
    } else {
        // For other patterns, assume always matches (like identifier pattern)
        emit(cg, "  br label %");
        emit_line(cg, body_lbl);
    }

    // Loop body
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, loop_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate loop expression: loop { body }
// Infinite loop that can be exited with break value
fn gen_loop(cg: i64, expr: i64) -> i64 {
    let body: i64 = load_ptr(expr, 1);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let end_lbl: i64 = string_concat("loopend", int_to_string(l));

    // Allocate result slot for break value
    let result_t: i64 = cg_next_temp(cg);
    emit(cg, "  %loopresult");
    emit(cg, int_to_string(l));
    emit_line(cg, " = alloca i64");
    emit(cg, "  store i64 0, ptr %loopresult");
    emit_line(cg, int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header
    emit(cg, loop_lbl);
    emit_line(cg, ":");

    // Push loop context with result slot
    push_loop(cg, loop_lbl, end_lbl);
    // Store result slot name for break to use
    let loop_ctx: i64 = cg_current_loop(cg);
    if loop_ctx != 0 {
        let result_name: i64 = string_concat("%loopresult", int_to_string(l));
        store_ptr(loop_ctx, 2, result_name);  // Store result ptr at offset 2
    }

    gen_block(cg, body);
    pop_loop(cg);

    // Loop back unconditionally
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End - load result
    emit(cg, end_lbl);
    emit_line(cg, ":");
    let final_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(final_t));
    emit(cg, " = load i64, ptr %loopresult");
    emit_line(cg, int_to_string(l));

    return string_concat("%t", int_to_string(final_t));
}

// Generate break with value expression
fn gen_break_value(cg: i64, expr: i64) -> i64 {
    let value: i64 = load_ptr(expr, 1);

    // Get current loop context
    let loop_ctx: i64 = cg_current_loop(cg);
    if loop_ctx == 0 {
        // No loop context - error (but emit something to avoid crash)
        emit_line(cg, "  ; ERROR: break outside loop");
        return string_from("0");
    }

    let end_lbl: i64 = load_ptr(loop_ctx, 1);
    let result_ptr: i64 = load_ptr(loop_ctx, 2);

    // Store break value if present
    if value != 0 {
        let val: i64 = gen_expr(cg, value);
        if result_ptr != 0 {
            emit(cg, "  store i64 ");
            emit(cg, val);
            emit(cg, ", ptr ");
            emit_line(cg, result_ptr);
        }
    }

    // Branch to end
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Need a dummy block for code after break (unreachable)
    let l: i64 = cg_next_label(cg);
    emit(cg, "afterbreak");
    emit(cg, int_to_string(l));
    emit_line(cg, ":");

    string_from("0")
}

// Generate match expression
// Lowered to a series of if-else comparisons
fn gen_match(cg: i64, expr: i64) -> i64 {
    let scrutinee: i64 = load_ptr(expr, 1);
    let arms: i64 = load_ptr(expr, 2);
    let num_arms: i64 = vec_len(arms);

    // Evaluate scrutinee once
    let scru_val: i64 = gen_expr(cg, scrutinee);

    let l: i64 = cg_next_label(cg);
    let end_lbl: i64 = string_concat("matchend", int_to_string(l));
    let fail_lbl: i64 = string_concat("matchfail", int_to_string(l));

    // Collect arm labels and results for phi
    let arm_labels: i64 = vec_new();
    let arm_results: i64 = vec_new();

    // Process each arm
    let i: i64 = 0;
    while i < num_arms {
        let arm: i64 = vec_get(arms, i);
        let pattern: i64 = load_ptr(arm, 0);
        let guard: i64 = load_ptr(arm, 1);
        let result: i64 = load_ptr(arm, 2);

        let base_lbl: i64 = str_label("arm", l);
        let arm_lbl: i64 = str_label(base_lbl, i);
        let guard_lbl: i64 = string_concat(arm_lbl, "_guard");
        let arm_end_lbl: i64 = string_concat(arm_lbl, "_end");
        let check_lbl: i64 = str_label(str_label("check", l), i);
        let next_check_lbl: i64 = str_label(str_label("check", l), i + 1);

        // Emit check block label (except for first arm which follows entry)
        if i > 0 {
            emit(cg, check_lbl);
            emit_line(cg, ":");
            cg_set_terminated(cg, false);
        }

        // Check if this is the last arm or wildcard
        let is_last: i64 = i == num_arms - 1;
        let is_wildcard: i64 = pattern == 0;
        let has_guard: i64 = guard != 0;

        // Check if pattern is a simple identifier (binding pattern)
        // EXPR_IDENT = 3, and binding patterns bind the scrutinee to a variable
        let is_binding: i64 = 0;
        let binding_name: i64 = 0;
        let is_enum_pattern: i64 = 0;
        let enum_variant_name: i64 = 0;
        let enum_bindings: i64 = 0;
        let expected_tag: i64 = 0;
        if pattern != 0 {
            let pat_tag: i64 = load_i64(pattern, 0);
            if pat_tag == EXPR_IDENT() {
                // Check if it's an enum variant (None, etc.) or a binding
                let ident_name: i64 = load_ptr(pattern, 1);
                let variant_tag: i64 = lookup_variant_any(cg, ident_name);
                if variant_tag >= 0 {
                    // It's an enum variant without payload (like None)
                    is_enum_pattern = 1;
                    enum_variant_name = ident_name;
                    expected_tag = variant_tag;
                    enum_bindings = vec_new();
                } else {
                    // Regular binding pattern
                    is_binding = 1;
                    binding_name = ident_name;
                }
            } else {
                if pat_tag == EXPR_CALL() {
                    // Enum variant with payload: Some(x), Ok(val), etc.
                    is_enum_pattern = 1;
                    let callee: i64 = load_ptr(pattern, 1);
                    let callee_tag: i64 = load_i64(callee, 0);
                    if callee_tag == EXPR_IDENT() {
                        enum_variant_name = load_ptr(callee, 1);
                    } else {
                        if callee_tag == EXPR_PATH() {
                            // EnumName::Variant - get the variant name from segments
                            let segments: i64 = load_ptr(callee, 1);
                            let num_segs: i64 = vec_len(segments);
                            if num_segs == 2 {
                                // Use specific enum lookup for qualified path like Status::Ok
                                let enum_name: i64 = vec_get(segments, 0);
                                enum_variant_name = vec_get(segments, 1);
                                enum_bindings = load_ptr(pattern, 2);
                                expected_tag = lookup_variant(cg, enum_name, enum_variant_name);
                                if expected_tag < 0 {
                                    expected_tag = 0;
                                }
                            } else {
                                if num_segs > 0 {
                                    enum_variant_name = vec_get(segments, num_segs - 1);
                                }
                                enum_bindings = load_ptr(pattern, 2);
                                expected_tag = lookup_variant_any(cg, enum_variant_name);
                                if expected_tag < 0 {
                                    expected_tag = 0;
                                }
                            }
                        }
                    }
                    // Only set bindings and tag if not already set by EXPR_PATH branch
                    if callee_tag == EXPR_IDENT() {
                        enum_bindings = load_ptr(pattern, 2);
                        expected_tag = lookup_variant_any(cg, enum_variant_name);
                        if expected_tag < 0 {
                            expected_tag = 0;
                        }
                    }
                } else {
                    if pat_tag == EXPR_PATH() {
                        // EnumName::Variant without payload
                        // EXPR_PATH layout: tag(0), segments(1)
                        // segments is a vector like ["Color", "Red"]
                        is_enum_pattern = 1;
                        let segments: i64 = load_ptr(pattern, 1);
                        let num_segs: i64 = vec_len(segments);
                        if num_segs == 2 {
                            // Use specific enum lookup for qualified path
                            let enum_name: i64 = vec_get(segments, 0);
                            enum_variant_name = vec_get(segments, 1);
                            expected_tag = lookup_variant(cg, enum_name, enum_variant_name);
                        } else {
                            if num_segs > 0 {
                                enum_variant_name = vec_get(segments, num_segs - 1);
                            }
                            expected_tag = lookup_variant_any(cg, enum_variant_name);
                        }
                        if expected_tag < 0 {
                            expected_tag = 0;
                        }
                        enum_bindings = vec_new();
                    }
                }
            }
        }

        // Check for tuple pattern - EXPR_TUPLE
        let is_tuple_pattern: i64 = 0;
        let tuple_elements: i64 = 0;
        if pattern != 0 {
            let pat_tag: i64 = load_i64(pattern, 0);
            if pat_tag == EXPR_TUPLE() {
                is_tuple_pattern = 1;
                tuple_elements = load_ptr(pattern, 1);
            }
        }

        // Check for struct pattern - EXPR_STRUCT_PAT
        let is_struct_pattern: i64 = 0;
        let struct_type_name: i64 = 0;
        let struct_fields: i64 = 0;
        let struct_has_rest: i64 = 0;
        if pattern != 0 {
            let pat_tag: i64 = load_i64(pattern, 0);
            if pat_tag == EXPR_STRUCT_PAT() {
                is_struct_pattern = 1;
                struct_type_name = load_ptr(pattern, 1);
                struct_fields = load_ptr(pattern, 2);
                struct_has_rest = load_i64(pattern, 3);
            }
        }

        // Check for or-pattern - EXPR_OR_PAT
        let is_or_pattern: i64 = 0;
        let or_alternatives: i64 = 0;
        if pattern != 0 {
            let pat_tag: i64 = load_i64(pattern, 0);
            if pat_tag == EXPR_OR_PAT() {
                is_or_pattern = 1;
                or_alternatives = load_ptr(pattern, 1);
            }
        }

        if is_wildcard != 0 {
            if has_guard != 0 {
                // Wildcard with guard - check guard only
                emit(cg, "  br label %");
                emit_line(cg, guard_lbl);
            } else {
                // Wildcard without guard - unconditional jump to arm
                emit(cg, "  br label %");
                emit_line(cg, arm_lbl);
            }
        } else {
            if is_binding != 0 {
                // Binding pattern - always matches, go to guard or arm
                if has_guard != 0 {
                    emit(cg, "  br label %");
                    emit_line(cg, guard_lbl);
                } else {
                    emit(cg, "  br label %");
                    emit_line(cg, arm_lbl);
                }
            } else {
                if is_tuple_pattern != 0 {
                    // Tuple pattern - always matches, extract elements as bindings
                    // Go to guard or arm
                    if has_guard != 0 {
                        emit(cg, "  br label %");
                        emit_line(cg, guard_lbl);
                    } else {
                        emit(cg, "  br label %");
                        emit_line(cg, arm_lbl);
                    }
                } else {
                if is_struct_pattern != 0 {
                    // Struct pattern - always matches, extract field bindings
                    // Go to guard or arm
                    if has_guard != 0 {
                        emit(cg, "  br label %");
                        emit_line(cg, guard_lbl);
                    } else {
                        emit(cg, "  br label %");
                        emit_line(cg, arm_lbl);
                    }
                } else {
                if is_or_pattern != 0 {
                    // Or-pattern - check each alternative with short-circuit
                    // For now, treat first alternative as if it always matches (simplification)
                    // More complete: generate check for each alternative
                    if has_guard != 0 {
                        emit(cg, "  br label %");
                        emit_line(cg, guard_lbl);
                    } else {
                        emit(cg, "  br label %");
                        emit_line(cg, arm_lbl);
                    }
                } else {
                if is_enum_pattern != 0 {
                    // Enum pattern - compare tag at offset 0
                    // Convert scrutinee to ptr
                    let ptr_t: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(ptr_t));
                    emit(cg, " = inttoptr i64 ");
                    emit(cg, scru_val);
                    emit_line(cg, " to ptr");

                    // Load tag from offset 0
                    let tag_t: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(tag_t));
                    emit(cg, " = load i64, ptr %t");
                    emit_line(cg, int_to_string(ptr_t));

                    // Compare tag with expected
                    let cmp_t: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(cmp_t));
                    emit(cg, " = icmp eq i64 %t");
                    emit(cg, int_to_string(tag_t));
                    emit(cg, ", ");
                    emit_line(cg, int_to_string(expected_tag));

                    // Branch on tag match
                    emit(cg, "  br i1 %t");
                    emit(cg, int_to_string(cmp_t));
                    emit(cg, ", label %");
                    if has_guard != 0 {
                        emit(cg, guard_lbl);
                    } else {
                        emit(cg, arm_lbl);
                    }
                    emit(cg, ", label %");
                    if is_last != 0 {
                        emit_line(cg, fail_lbl);
                    } else {
                        emit_line(cg, next_check_lbl);
                    }
                } else {
                    // Value pattern - compare scrutinee to pattern
                    let pat_val: i64 = gen_expr(cg, pattern);

                    // Compare scrutinee == pattern
                    let cmp_t: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(cmp_t));
                    emit(cg, " = icmp eq i64 ");
                    emit(cg, scru_val);
                    emit(cg, ", ");
                    emit_line(cg, pat_val);

                    // Branch: if match goto guard_check or arm, else goto next/end
                    emit(cg, "  br i1 %t");
                    emit(cg, int_to_string(cmp_t));
                    emit(cg, ", label %");
                    if has_guard != 0 {
                        emit(cg, guard_lbl);
                    } else {
                        emit(cg, arm_lbl);
                    }
                    emit(cg, ", label %");
                    if is_last != 0 {
                        emit_line(cg, fail_lbl);
                    } else {
                        emit_line(cg, next_check_lbl);
                    }
                }
                }
                }
                }
            }
        }

        // Guard check block (if has guard)
        if has_guard != 0 {
            emit(cg, guard_lbl);
            emit_line(cg, ":");
            cg_set_terminated(cg, false);

            // If binding pattern, create an alloca and store the scrutinee value
            if is_binding != 0 {
                let bind_id: i64 = cg_next_temp(cg);
                let unique_name: i64 = str_unique(binding_name, bind_id);
                emit(cg, "  %local.");
                emit(cg, unique_name);
                emit_line(cg, " = alloca i64");
                emit(cg, "  store i64 ");
                emit(cg, scru_val);
                emit(cg, ", ptr %local.");
                emit_line(cg, unique_name);
                add_local(cg, binding_name, unique_name);
            }

            let guard_val: i64 = gen_expr(cg, guard);
            // Guard should be i1, but our bools are i64, so compare != 0
            let guard_cmp: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(guard_cmp));
            emit(cg, " = icmp ne i64 ");
            emit(cg, guard_val);
            emit_line(cg, ", 0");
            // Branch: if guard true goto arm, else goto next/end
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(guard_cmp));
            emit(cg, ", label %");
            emit(cg, arm_lbl);
            emit(cg, ", label %");
            if is_last != 0 {
                emit_line(cg, end_lbl);
            } else {
                emit_line(cg, next_check_lbl);
            }
        }

        // Arm body
        emit(cg, arm_lbl);
        emit_line(cg, ":");
        cg_set_terminated(cg, false);

        // If binding pattern and no guard, create alloca and add binding now
        if is_binding != 0 {
            if has_guard == 0 {
                let bind_id: i64 = cg_next_temp(cg);
                let unique_name: i64 = str_unique(binding_name, bind_id);
                emit(cg, "  %local.");
                emit(cg, unique_name);
                emit_line(cg, " = alloca i64");
                emit(cg, "  store i64 ");
                emit(cg, scru_val);
                emit(cg, ", ptr %local.");
                emit_line(cg, unique_name);
                add_local(cg, binding_name, unique_name);
            }
        }

        // If tuple pattern, extract elements and create bindings
        if is_tuple_pattern != 0 {
            if tuple_elements != 0 {
                let num_elems: i64 = vec_len(tuple_elements);
                if num_elems > 0 {
                    // Convert scrutinee to ptr for element extraction
                    let tup_ptr: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(tup_ptr));
                    emit(cg, " = inttoptr i64 ");
                    emit(cg, scru_val);
                    emit_line(cg, " to ptr");

                    let ti: i64 = 0;
                    while ti < num_elems {
                        let elem_pat: i64 = vec_get(tuple_elements, ti);
                        // Check if element is an identifier pattern (binding)
                        if elem_pat != 0 {
                            let elem_tag: i64 = load_i64(elem_pat, 0);
                            if elem_tag == EXPR_IDENT() {
                                let elem_name: i64 = load_ptr(elem_pat, 1);

                                // Element at offset ti * 8
                                let offset: i64 = ti * 8;
                                let gep_t: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(gep_t));
                                emit(cg, " = getelementptr i8, ptr %t");
                                emit(cg, int_to_string(tup_ptr));
                                emit(cg, ", i64 ");
                                emit_line(cg, int_to_string(offset));

                                // Load element value
                                let val_t: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(val_t));
                                emit(cg, " = load i64, ptr %t");
                                emit_line(cg, int_to_string(gep_t));

                                // Create local binding
                                let bind_id: i64 = cg_next_temp(cg);
                                let unique_name: i64 = str_unique(elem_name, bind_id);
                                emit(cg, "  %local.");
                                emit(cg, unique_name);
                                emit_line(cg, " = alloca i64");
                                emit(cg, "  store i64 %t");
                                emit(cg, int_to_string(val_t));
                                emit(cg, ", ptr %local.");
                                emit_line(cg, unique_name);
                                add_local(cg, elem_name, unique_name);
                            }
                        }
                        ti = ti + 1;
                    }
                }
            }
        }

        // If struct pattern, extract field values and create bindings
        if is_struct_pattern != 0 {
            if struct_fields != 0 {
                let num_fields: i64 = vec_len(struct_fields);
                if num_fields > 0 {
                    // Convert scrutinee to ptr for field extraction
                    let struct_ptr: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(struct_ptr));
                    emit(cg, " = inttoptr i64 ");
                    emit(cg, scru_val);
                    emit_line(cg, " to ptr");

                    // Get struct definition to know field offsets
                    let struct_def: i64 = cg_lookup_struct(cg, struct_type_name);
                    let fi: i64 = 0;
                    while fi < num_fields {
                        let field_entry: i64 = vec_get(struct_fields, fi);
                        let field_name: i64 = load_ptr(field_entry, 0);
                        let binding: i64 = load_ptr(field_entry, 1);

                        // Find field offset in struct definition
                        let field_offset: i64 = 0;
                        if struct_def != 0 {
                            let fields: i64 = load_ptr(struct_def, 1);
                            let nf: i64 = vec_len(fields);
                            let fj: i64 = 0;
                            while fj < nf {
                                let f: i64 = vec_get(fields, fj);
                                let fname: i64 = load_ptr(f, 0);
                                if string_eq(fname, field_name) {
                                    field_offset = fj * 8;
                                    break;
                                }
                                fj = fj + 1;
                            }
                        } else {
                            // Fallback: sequential offsets
                            field_offset = fi * 8;
                        }

                        // Load field value
                        let gep_t: i64 = cg_next_temp(cg);
                        emit(cg, "  %t");
                        emit(cg, int_to_string(gep_t));
                        emit(cg, " = getelementptr i8, ptr %t");
                        emit(cg, int_to_string(struct_ptr));
                        emit(cg, ", i64 ");
                        emit_line(cg, int_to_string(field_offset));

                        let val_t: i64 = cg_next_temp(cg);
                        emit(cg, "  %t");
                        emit(cg, int_to_string(val_t));
                        emit(cg, " = load i64, ptr %t");
                        emit_line(cg, int_to_string(gep_t));

                        // Check if binding is an identifier (shorthand: field_name is binding name)
                        // or a nested pattern
                        let bind_name: i64 = 0;
                        if binding != 0 {
                            let b_tag: i64 = load_i64(binding, 0);
                            if b_tag == EXPR_IDENT() {
                                bind_name = load_ptr(binding, 1);
                            }
                        }
                        // If binding was a string (shorthand syntax), use field_name
                        if bind_name == 0 {
                            bind_name = field_name;
                        }

                        // Create local binding
                        let bind_id: i64 = cg_next_temp(cg);
                        let unique_name: i64 = str_unique(bind_name, bind_id);
                        emit(cg, "  %local.");
                        emit(cg, unique_name);
                        emit_line(cg, " = alloca i64");
                        emit(cg, "  store i64 %t");
                        emit(cg, int_to_string(val_t));
                        emit(cg, ", ptr %local.");
                        emit_line(cg, unique_name);
                        add_local(cg, bind_name, unique_name);

                        fi = fi + 1;
                    }
                }
            }
        }

        // If enum pattern with bindings, extract payload values and create bindings
        if is_enum_pattern != 0 {
            if enum_bindings != 0 {
                let num_bindings: i64 = vec_len(enum_bindings);
                if num_bindings > 0 {
                    // Convert scrutinee to ptr for payload extraction
                    let base_ptr: i64 = cg_next_temp(cg);
                    emit(cg, "  %t");
                    emit(cg, int_to_string(base_ptr));
                    emit(cg, " = inttoptr i64 ");
                    emit(cg, scru_val);
                    emit_line(cg, " to ptr");

                    let bi: i64 = 0;
                    while bi < num_bindings {
                        let binding: i64 = vec_get(enum_bindings, bi);
                        // Check if binding is an identifier pattern
                        if binding != 0 {
                            let b_tag: i64 = load_i64(binding, 0);
                            if b_tag == EXPR_IDENT() {
                                let b_name: i64 = load_ptr(binding, 1);

                                // Payload at offset (1 + bi) * 8 from base
                                let offset: i64 = (1 + bi) * 8;
                                let gep_t: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(gep_t));
                                emit(cg, " = getelementptr i8, ptr %t");
                                emit(cg, int_to_string(base_ptr));
                                emit(cg, ", i64 ");
                                emit_line(cg, int_to_string(offset));

                                // Load payload value
                                let val_t: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(val_t));
                                emit(cg, " = load i64, ptr %t");
                                emit_line(cg, int_to_string(gep_t));

                                // Create local binding
                                let bind_id: i64 = cg_next_temp(cg);
                                let unique_name: i64 = str_unique(b_name, bind_id);
                                emit(cg, "  %local.");
                                emit(cg, unique_name);
                                emit_line(cg, " = alloca i64");
                                emit(cg, "  store i64 %t");
                                emit(cg, int_to_string(val_t));
                                emit(cg, ", ptr %local.");
                                emit_line(cg, unique_name);
                                add_local(cg, b_name, unique_name);
                            }
                            // Handle nested pattern (e.g., Some(Some(y)))
                            if b_tag == EXPR_CALL() {
                                // Load the nested enum value at current offset
                                let offset: i64 = (1 + bi) * 8;
                                let gep_t: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(gep_t));
                                emit(cg, " = getelementptr i8, ptr %t");
                                emit(cg, int_to_string(base_ptr));
                                emit(cg, ", i64 ");
                                emit_line(cg, int_to_string(offset));

                                let nested_val: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(nested_val));
                                emit(cg, " = load i64, ptr %t");
                                emit_line(cg, int_to_string(gep_t));

                                // Convert to ptr for nested payload access
                                let nested_ptr: i64 = cg_next_temp(cg);
                                emit(cg, "  %t");
                                emit(cg, int_to_string(nested_ptr));
                                emit(cg, " = inttoptr i64 %t");
                                emit(cg, int_to_string(nested_val));
                                emit_line(cg, " to ptr");

                                // Get nested pattern's bindings
                                let nested_args: i64 = load_ptr(binding, 2);
                                let num_nested: i64 = vec_len(nested_args);
                                let ni: i64 = 0;
                                while ni < num_nested {
                                    let nested_binding: i64 = vec_get(nested_args, ni);
                                    if nested_binding != 0 {
                                        let nb_tag: i64 = load_i64(nested_binding, 0);
                                        if nb_tag == EXPR_IDENT() {
                                            let nb_name: i64 = load_ptr(nested_binding, 1);

                                            // Payload at offset (1 + ni) * 8 from nested base
                                            let nested_offset: i64 = (1 + ni) * 8;
                                            let ngep_t: i64 = cg_next_temp(cg);
                                            emit(cg, "  %t");
                                            emit(cg, int_to_string(ngep_t));
                                            emit(cg, " = getelementptr i8, ptr %t");
                                            emit(cg, int_to_string(nested_ptr));
                                            emit(cg, ", i64 ");
                                            emit_line(cg, int_to_string(nested_offset));

                                            let nval_t: i64 = cg_next_temp(cg);
                                            emit(cg, "  %t");
                                            emit(cg, int_to_string(nval_t));
                                            emit(cg, " = load i64, ptr %t");
                                            emit_line(cg, int_to_string(ngep_t));

                                            // Create local binding for nested value
                                            let nbind_id: i64 = cg_next_temp(cg);
                                            let nunique_name: i64 = str_unique(nb_name, nbind_id);
                                            emit(cg, "  %local.");
                                            emit(cg, nunique_name);
                                            emit_line(cg, " = alloca i64");
                                            emit(cg, "  store i64 %t");
                                            emit(cg, int_to_string(nval_t));
                                            emit(cg, ", ptr %local.");
                                            emit_line(cg, nunique_name);
                                            add_local(cg, nb_name, nunique_name);
                                        }
                                        // Handle third level of nesting (e.g., Some(Some(Some(x))))
                                        if nb_tag == EXPR_CALL() {
                                            // Load the deeply nested enum value
                                            let nested_offset: i64 = (1 + ni) * 8;
                                            let ngep_t: i64 = cg_next_temp(cg);
                                            emit(cg, "  %t");
                                            emit(cg, int_to_string(ngep_t));
                                            emit(cg, " = getelementptr i8, ptr %t");
                                            emit(cg, int_to_string(nested_ptr));
                                            emit(cg, ", i64 ");
                                            emit_line(cg, int_to_string(nested_offset));

                                            let deep_val: i64 = cg_next_temp(cg);
                                            emit(cg, "  %t");
                                            emit(cg, int_to_string(deep_val));
                                            emit(cg, " = load i64, ptr %t");
                                            emit_line(cg, int_to_string(ngep_t));

                                            // Convert to ptr for deeply nested access
                                            let deep_ptr: i64 = cg_next_temp(cg);
                                            emit(cg, "  %t");
                                            emit(cg, int_to_string(deep_ptr));
                                            emit(cg, " = inttoptr i64 %t");
                                            emit(cg, int_to_string(deep_val));
                                            emit_line(cg, " to ptr");

                                            // Get deeply nested pattern's bindings
                                            let deep_args: i64 = load_ptr(nested_binding, 2);
                                            let num_deep: i64 = vec_len(deep_args);
                                            let di: i64 = 0;
                                            while di < num_deep {
                                                let deep_binding: i64 = vec_get(deep_args, di);
                                                if deep_binding != 0 {
                                                    let db_tag: i64 = load_i64(deep_binding, 0);
                                                    if db_tag == EXPR_IDENT() {
                                                        let db_name: i64 = load_ptr(deep_binding, 1);
                                                        let deep_offset: i64 = (1 + di) * 8;
                                                        let dgep_t: i64 = cg_next_temp(cg);
                                                        emit(cg, "  %t");
                                                        emit(cg, int_to_string(dgep_t));
                                                        emit(cg, " = getelementptr i8, ptr %t");
                                                        emit(cg, int_to_string(deep_ptr));
                                                        emit(cg, ", i64 ");
                                                        emit_line(cg, int_to_string(deep_offset));

                                                        let dval_t: i64 = cg_next_temp(cg);
                                                        emit(cg, "  %t");
                                                        emit(cg, int_to_string(dval_t));
                                                        emit(cg, " = load i64, ptr %t");
                                                        emit_line(cg, int_to_string(dgep_t));

                                                        let dbind_id: i64 = cg_next_temp(cg);
                                                        let dunique_name: i64 = str_unique(db_name, dbind_id);
                                                        emit(cg, "  %local.");
                                                        emit(cg, dunique_name);
                                                        emit_line(cg, " = alloca i64");
                                                        emit(cg, "  store i64 %t");
                                                        emit(cg, int_to_string(dval_t));
                                                        emit(cg, ", ptr %local.");
                                                        emit_line(cg, dunique_name);
                                                        add_local(cg, db_name, dunique_name);
                                                    }
                                                }
                                                di = di + 1;
                                            }
                                        }
                                    }
                                    ni = ni + 1;
                                }
                            }
                        }
                        bi = bi + 1;
                    }
                }
            }
        }

        let arm_val: i64 = gen_expr(cg, result);
        emit(cg, "  br label %");
        emit_line(cg, arm_end_lbl);

        // Arm end block for phi
        emit(cg, arm_end_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, end_lbl);

        vec_push(arm_labels, arm_end_lbl);
        vec_push(arm_results, arm_val);

        i = i + 1;
    }

    // Match failure block (for exhaustive match that shouldn't happen)
    emit(cg, fail_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");

    let result_t: i64 = cg_next_temp(cg);
    let result_temp: i64 = string_concat("%t", int_to_string(result_t));
    emit(cg, "  ");
    emit(cg, result_temp);
    emit(cg, " = phi i64 ");

    i = 0;
    while i < num_arms {
        if i > 0 {
            emit(cg, ", ");
        }
        emit(cg, "[ ");
        emit(cg, vec_get(arm_results, i));
        emit(cg, ", %");
        emit(cg, vec_get(arm_labels, i));
        emit(cg, " ]");
        i = i + 1;
    }
    // Add fail case with default value of 0
    emit(cg, ", [ 0, %");
    emit(cg, fail_lbl);
    emit_line(cg, " ]");

    result_temp
}

// Generate block
fn gen_block(cg: i64, block: i64) -> i64 {
    // Guard against null block to prevent segfault
    if block == 0 {
        return string_from("0");
    }
    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);

    let n: i64 = vec_len(stmts);
    let i: i64 = 0;
    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        gen_stmt(cg, stmt);
        i = i + 1;
    }

    if result != 0 {
        return gen_expr(cg, result);
    }

    string_from("0")
}

// Generate statement
fn gen_stmt(cg: i64, stmt: i64) -> i64 {
    // Guard against null statement to prevent segfault
    if stmt == 0 {
        return string_from("0");
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        let ty: i64 = load_ptr(stmt, 2);
        let init_expr: i64 = load_ptr(stmt, 3);

        // Use pre-allocated local from entry block
        let unique_name: i64 = cg_pop_alloca(cg);
        if unique_name == 0 {
            // Fallback: allocate inline (shouldn't happen with proper pre-pass)
            let local_id: i64 = cg_next_temp(cg);
            unique_name = str_unique(name, local_id);
            emit(cg, "  %local.");
            emit(cg, unique_name);
            emit_line(cg, " = alloca i64");
        }
        add_local(cg, name, unique_name);

        // Record type if present (for method call resolution)
        if ty != 0 {
            add_var_type(cg, name, ty);
        }

        // Initialize if there's an init expression
        if init_expr != 0 {
            // Check if init is a closure - register it for inline expansion
            let init_tag: i64 = load_i64(init_expr, 0);
            if init_tag == EXPR_CLOSURE() {
                let params: i64 = load_ptr(init_expr, 1);
                let body: i64 = load_ptr(init_expr, 2);
                cg_register_closure(cg, name, params, body);
                // Store a placeholder value (closure ID)
                let closure_id: i64 = cg_next_closure_id(cg);
                emit(cg, "  store i64 ");
                emit(cg, int_to_string(closure_id));
                emit(cg, ", ptr %local.");
                emit_line(cg, unique_name);
            } else {
                let val: i64 = gen_expr(cg, init_expr);
                emit(cg, "  store i64 ");
                emit(cg, val);
                emit(cg, ", ptr %local.");
                emit_line(cg, unique_name);
            }
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            gen_expr(cg, expr);
        }
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            let val: i64 = gen_expr(cg, expr);
            emit(cg, "  ret i64 ");
            emit_line(cg, val);
        } else {
            emit_line(cg, "  ret void");
        }
        cg_set_terminated(cg, true);
        return 0;
    }

    // Assignment statement
    if tag == STMT_ASSIGN() {
        let name: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        let val: i64 = gen_expr(cg, value);
        let unique_name: i64 = lookup_local(cg, name);
        emit(cg, "  store i64 ");
        emit(cg, val);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        return 0;
    }

    // Break statement
    if tag == STMT_BREAK() {
        let break_lbl: i64 = current_loop_break(cg);
        if break_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, break_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_break");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    // Continue statement
    if tag == STMT_CONTINUE() {
        let continue_lbl: i64 = current_loop_continue(cg);
        if continue_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, continue_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_continue");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    0
}

// Generate async function as a Future with poll method
fn gen_async_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Future struct: poll_fn(0), state(8), inner_future(16), result(24), params(32+), locals...
    let future_name: i64 = string_concat(name, "_Future");

    // Set async context
    cg_set_async_fn(cg, 1);
    cg_set_async_fn_name(cg, name);
    cg_reset_async_state(cg);
    cg_clear_await_points(cg);
    cg_clear_locals(cg);

    // Generate the constructor function that creates the future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit(cg, "\"(");

    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Allocate future struct: poll_fn + state + inner_future + result + params + locals
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let struct_size: i64 = 32 + n * 8 + num_locals * 8;  // 4 fields + params + locals

    emit(cg, "  %future = call ptr @malloc(i64 ");
    emit(cg, int_to_string(struct_size));
    emit_line(cg, ")");

    // Store poll function pointer at offset 0
    emit(cg, "  %poll_fn_ptr = ptrtoint ptr @\"");
    emit(cg, name);
    emit_line(cg, "_poll\" to i64");
    emit_line(cg, "  store i64 %poll_fn_ptr, ptr %future");

    // Initialize state to 0 at offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  store i64 0, ptr %state_ptr");

    // Store parameters in future struct (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %param_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %param_ptr_");
        emit_line(cg, int_to_string(i));
        i = i + 1;
    }

    // Return the future pointer as i64
    emit_line(cg, "  %result = ptrtoint ptr %future to i64");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate the poll function for this future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_poll\"(i64 %future_ptr) {");
    emit_line(cg, "entry:");

    // Convert future_ptr to actual pointer
    emit_line(cg, "  %future = inttoptr i64 %future_ptr to ptr");

    // Allocate async state tracking
    emit_line(cg, "  %async_state = alloca i64");
    emit_line(cg, "  %async_inner_future = alloca i64");

    // Load current state from offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  %state = load i64, ptr %state_ptr");
    emit_line(cg, "  store i64 %state, ptr %async_state");

    // Load parameters from future struct into locals (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  %param_load_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, " = load i64, ptr %param_load_ptr_");
        emit_line(cg, int_to_string(i));
        emit(cg, "  store i64 %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);
        i = i + 1;
    }

    // Pre-allocate locals
    cg_clear_alloca_queue(cg);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // Generate body to a temporary buffer first so we can collect await points
    // before emitting the state dispatch switch
    let saved_output: i64 = load_ptr(cg, 0);
    let body_buffer: i64 = sb_new();
    store_ptr(cg, 0, body_buffer);

    // State 0 - start of function (emitted to body buffer)
    emit_line(cg, "state_0:");

    // Generate body (emits to body_buffer, collects await points)
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Return Ready with value (tagged: value << 1 | 1)
    if cg_is_terminated(cg) == false {
        let ret_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ret_t));
        emit(cg, " = shl i64 ");
        emit(cg, result);
        emit_line(cg, ", 1");
        let tagged_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tagged_t));
        emit(cg, " = or i64 %t");
        emit(cg, int_to_string(ret_t));
        emit_line(cg, ", 1");
        emit(cg, "  ret i64 %t");
        emit_line(cg, int_to_string(tagged_t));
    }

    emit_line(cg, "}");
    emit_line(cg, "");

    // Now body generation is complete - restore original output and emit proper switch
    let body_code: i64 = sb_to_string(body_buffer);
    store_ptr(cg, 0, saved_output);

    // State dispatch switch - now includes all await points
    let await_points: i64 = cg_async_await_points(cg);
    let num_points: i64 = vec_len(await_points);

    emit_line(cg, "  switch i64 %state, label %state_0 [");
    emit_line(cg, "    i64 0, label %state_0");

    // Add cases for each await resume point
    let k: i64 = 0;
    while k < num_points {
        let point: i64 = vec_get(await_points, k);
        let state_num: i64 = load_i64(point, 0);
        let label: i64 = load_ptr(point, 1);
        emit(cg, "    i64 ");
        emit(cg, int_to_string(state_num));
        emit(cg, ", label %");
        emit_line(cg, label);
        k = k + 1;
    }

    emit_line(cg, "  ]");

    // Now emit the body code we generated earlier
    emit(cg, body_code);

    // Reset async context
    cg_set_async_fn(cg, 0);

    0
}

// Generate function
fn gen_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let type_params: i64 = load_ptr(fn_def, 2);  // Generic type params (or 0)
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);
    let is_async: i64 = load_i64(fn_def, 6);

    // If this is a generic function, register it but don't generate code yet
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            cg_register_generic(cg, name, fn_def);
            return 0;
        }
    }

    // Handle async functions
    if is_async != 0 {
        return gen_async_fn(cg, fn_def);
    }

    // Handle extern function declarations (no body)
    // Emit LLVM 'declare' statement instead of 'define' with body
    if body == 0 {
        emit(cg, "declare ");
        if ret_ty != 0 {
            emit(cg, "i64");
        } else {
            emit(cg, "void");
        }
        emit(cg, " @\"");
        emit(cg, name);
        emit(cg, "\"(");
        // Parameters - emit types only for declarations
        let n: i64 = vec_len(params);
        let i: i64 = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64");
            i = i + 1;
        }
        emit_line(cg, ")");
        return 0;
    }

    // Rename main to simplex_main
    let emit_name: i64 = name;
    if string_eq(name, "main") {
        emit_name = string_from("simplex_main");
    }

    cg_clear_locals(cg);

    // Function signature
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, emit_name);
    emit(cg, "\"(");

    // Parameters
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit(cg, ")");

    // Add !dbg metadata reference if debug info is enabled
    if cg_debug_enabled(cg) != 0 {
        let sp_id: i64 = cg_lookup_subprogram(cg, name);
        if sp_id > 0 {
            // Calculate actual metadata ID (11 + index in subprograms list)
            let subprograms: i64 = cg_debug_subprograms(cg);
            let sp_idx: i64 = 0;
            let found: i64 = 0;
            while sp_idx < vec_len(subprograms) {
                let entry: i64 = vec_get(subprograms, sp_idx);
                if string_eq(load_ptr(entry, 0), name) {
                    found = 1;
                    break;
                }
                sp_idx = sp_idx + 1;
            }
            if found == 1 {
                emit(cg, " !dbg !");
                emit(cg, int_to_string(11 + sp_idx));
                cg_set_current_subprogram(cg, 11 + sp_idx);
            }
        }
    }
    emit_line(cg, " {");
    emit_line(cg, "entry:");

    // Pre-allocate ALL local variables in the entry block to avoid
    // allocas in loops/conditionals which cause stack corruption
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // Copy params to locals
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);  // Params use same name
        i = i + 1;
    }

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Only emit final return if body didn't already terminate
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Generate a monomorphized instantiation of a generic function
fn gen_fn_instantiation(cg: i64, fn_def: i64, mangled_name: i64, type_args: i64) -> i64 {
    let type_params: i64 = load_ptr(fn_def, 2);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Check trait bounds before proceeding
    if check_trait_bounds(cg, type_params, type_args) == 0 {
        println(string_concat("  in instantiation of: ", mangled_name));
        // Continue anyway for now - error was already printed
    }

    cg_clear_locals(cg);
    cg_clear_const_params(cg);
    cg_clear_type_params(cg);

    // Set up type params and const params from type_params and type_args
    // type_params has names like "T", "T:Trait" (bounded), or "const:N"
    // type_args has corresponding values like "i64" or "10"
    if type_params != 0 {
        if type_args != 0 {
            let num_type_params: i64 = vec_len(type_params);
            let tp_idx: i64 = 0;
            while tp_idx < num_type_params {
                let type_param: i64 = vec_get(type_params, tp_idx);
                // Check if this is a const param (has "const:" prefix)
                if string_starts_with(type_param, string_from("const:")) {
                    // Extract the name after "const:"
                    let const_name: i64 = string_slice(type_param, 6, string_len(type_param));
                    // Get the corresponding value from type_args
                    if tp_idx < vec_len(type_args) {
                        let const_value: i64 = vec_get(type_args, tp_idx);
                        cg_add_const_param(cg, const_name, const_value);
                    }
                } else {
                    // Regular type parameter (e.g., "T" or "T:Trait")
                    // Extract just the param name (before any : for bound)
                    let param_name: i64 = extract_type_param_name(type_param);
                    // Get the corresponding concrete type from type_args
                    if tp_idx < vec_len(type_args) {
                        let concrete_type: i64 = vec_get(type_args, tp_idx);
                        cg_add_type_param(cg, param_name, concrete_type);
                    }
                }
                tp_idx = tp_idx + 1;
            }
        }
    }

    // Function signature with mangled name
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, mangled_name);
    emit(cg, "\"(");

    // Parameters (all i64 in bootstrap compiler)
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate local variables
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        add_local(cg, local_name, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        j = j + 1;
    }

    // Copy parameters to local variables
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(pname, string_concat(".", int_to_string(local_id)));
        add_local(cg, pname, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        i = i + 1;
    }

    cg_set_terminated(cg, false);

    // Generate body
    let result: i64 = gen_block(cg, body);

    // Return
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Mangle a generic function name with type arguments
fn mangle_generic_name(name: i64, type_args: i64) -> i64 {
    let result: i64 = name;
    let n: i64 = vec_len(type_args);
    let i: i64 = 0;
    while i < n {
        result = string_concat(result, string_from("_"));
        result = string_concat(result, vec_get(type_args, i));
        i = i + 1;
    }
    result
}

// Generate enum (just register it)
fn gen_enum(cg: i64, enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    register_enum(cg, name, variants);
    0
}

// Generate struct (register it or store as template if generic)
fn gen_struct(cg: i64, struct_def: i64) -> i64 {
    let name: i64 = load_ptr(struct_def, 1);
    let type_params: i64 = load_ptr(struct_def, 2);
    let fields: i64 = load_ptr(struct_def, 3);

    // Check if this is a generic struct
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            // Store as template for later monomorphization
            cg_add_generic_struct_template(cg, name, type_params, fields);
            return 0;
        }
    }

    // Non-generic struct: register immediately
    register_struct(cg, name, fields);
    0
}

// Generate impl block
// Methods are generated with mangled names: TypeName_methodName
fn gen_impl(cg: i64, impl_def: i64) -> i64 {
    let type_name: i64 = load_ptr(impl_def, 1);
    let methods: i64 = load_ptr(impl_def, 2);
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Get method name and mangle it: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = str_mangle(type_name, method_name);
        // Store mangled name back into the method AST
        store_ptr(method, 1, mangled_name);
        // Generate the function
        gen_fn(cg, method);
        i = i + 1;
    }

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate trait (just a declaration, no code)
fn gen_trait(cg: i64, trait_def: i64) -> i64 {
    // Register trait and its default methods for later use
    let name: i64 = load_ptr(trait_def, 1);
    let method_sigs: i64 = load_ptr(trait_def, 2);

    // Register trait definition for vtable layout (Phase 32)
    cg_register_trait_def(cg, name, method_sigs);

    // Store default method implementations in codegen context
    let num_methods: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < num_methods {
        let method_sig: i64 = vec_get(method_sigs, i);
        // Default methods have fn_def at offset 3
        let fn_def: i64 = load_ptr(method_sig, 3);
        if fn_def != 0 {
            // This is a default method - register it
            let method_name: i64 = load_ptr(method_sig, 0);
            cg_register_default_method(cg, name, method_name, fn_def);
        }
        i = i + 1;
    }
    0
}

// Generate impl Trait for Type block
// Methods are named: TypeName_methodName (same as regular impl, for simplicity)
fn gen_impl_trait(cg: i64, impl_def: i64) -> i64 {
    let trait_name: i64 = load_ptr(impl_def, 1);
    let type_name: i64 = load_ptr(impl_def, 2);
    let methods: i64 = load_ptr(impl_def, 3);
    let assoc_types: i64 = load_ptr(impl_def, 4);

    // Register this trait implementation for bounds checking
    cg_register_trait_impl(cg, type_name, trait_name);

    // Register associated types for this impl
    if assoc_types != 0 {
        let num_assoc: i64 = vec_len(assoc_types);
        let j: i64 = 0;
        while j < num_assoc {
            let assoc: i64 = vec_get(assoc_types, j);
            let assoc_name: i64 = load_ptr(assoc, 0);
            let assoc_ty: i64 = load_ptr(assoc, 1);
            cg_register_assoc_type(cg, type_name, assoc_name, assoc_ty);
            j = j + 1;
        }
    }

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    // Build list of mangled method names for vtable generation
    let mangled_methods: i64 = vec_new();
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Mangle method name: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = str_mangle(type_name, method_name);
        store_ptr(method, 1, mangled_name);
        vec_push(mangled_methods, mangled_name);
        gen_fn(cg, method);
        i = i + 1;
    }

    // Generate vtable for this (type, trait) pair (Phase 32)
    gen_vtable(cg, type_name, trait_name, mangled_methods);

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate a vtable global for dynamic dispatch (Phase 32)
// Layout: array of function pointers matching trait method order
fn gen_vtable(cg: i64, type_name: i64, trait_name: i64, impl_methods: i64) -> i64 {
    // Get trait method signatures for vtable ordering
    let trait_methods: i64 = cg_get_trait_methods(cg, trait_name);
    if trait_methods == 0 {
        // Trait not yet seen - will generate vtable later
        return 0;
    }

    let num_trait_methods: i64 = vec_len(trait_methods);
    if num_trait_methods == 0 {
        return 0;
    }

    // Vtable global name: @vtable_TypeName_TraitName
    let vtable_name: i64 = string_concat(string_from("@vtable_"), type_name);
    vtable_name = string_concat(vtable_name, string_from("_"));
    vtable_name = string_concat(vtable_name, trait_name);

    // Register vtable
    cg_register_vtable(cg, type_name, trait_name, vtable_name);

    // Generate vtable global: @vtable_Type_Trait = global [N x ptr] [ptr @Type_method1, ptr @Type_method2, ...]
    emit(cg, vtable_name);
    emit(cg, " = global [");
    emit(cg, int_to_string(num_trait_methods));
    emit(cg, " x ptr] [");

    // Match trait methods to impl methods and emit function pointers
    let i: i64 = 0;
    while i < num_trait_methods {
        if i > 0 {
            emit(cg, ", ");
        }
        let trait_sig: i64 = vec_get(trait_methods, i);
        let trait_method_name: i64 = load_ptr(trait_sig, 0);

        // Find corresponding impl method (TypeName_methodName)
        let mangled: i64 = str_mangle(type_name, trait_method_name);
        emit(cg, "ptr @\"");
        emit(cg, mangled);
        emit(cg, "\"");
        i = i + 1;
    }

    emit_line(cg, "]");
    0
}

// Generate actor definition (Phase 33)
// Actors become struct + message handlers + mailbox functions
fn gen_actor(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let state_fields: i64 = load_ptr(item, 2);
    let handlers: i64 = load_ptr(item, 3);
    let init_fn: i64 = load_ptr(item, 4);

    emit(cg, "; Actor: ");
    emit_line(cg, name);

    // Register actor state as a struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate actor_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %actor = call ptr @malloc(i64 64)");
    emit_line(cg, "  %ret = ptrtoint ptr %actor to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate message handler functions
    // Issue 1 fix: Wire up handler body execution
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);
            let params: i64 = load_ptr(handler, 1);
            let body: i64 = load_ptr(handler, 2);

            // Generate handler function: ActorName_handle_MsgName
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit(cg, "\"(i64 %self");

            // Add message parameters
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    emit(cg, ", i64 %");
                    emit(cg, pname);
                    pi = pi + 1;
                }
            }
            emit_line(cg, ") {");
            emit_line(cg, "entry:");

            // Set up local for self
            cg_clear_locals(cg);
            add_local(cg, string_from("self"), string_from("self_param"));
            emit_line(cg, "  %local.self_param = alloca i64");
            emit_line(cg, "  store i64 %self, ptr %local.self_param");

            // Set up locals for parameters
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    add_local(cg, pname, pname);
                    emit(cg, "  %local.");
                    emit(cg, pname);
                    emit_line(cg, " = alloca i64");
                    emit(cg, "  store i64 %");
                    emit(cg, pname);
                    emit(cg, ", ptr %local.");
                    emit_line(cg, pname);
                    pi = pi + 1;
                }
            }

            // Pre-allocate locals from body
            if body != 0 {
                cg_clear_alloca_queue(cg);
                let all_locals: i64 = collect_locals_from_block(body);
                let num_locals: i64 = vec_len(all_locals);
                let j: i64 = 0;
                while j < num_locals {
                    let local_name: i64 = vec_get(all_locals, j);
                    let local_id: i64 = cg_next_temp(cg);
                    let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
                    emit(cg, "  %local.");
                    emit(cg, unique_name);
                    emit_line(cg, " = alloca i64");
                    cg_push_alloca(cg, unique_name);
                    j = j + 1;
                }

                // Generate handler body
                cg_set_terminated(cg, false);
                let result: i64 = gen_block(cg, body);

                // Return result if not already terminated
                if cg_is_terminated(cg) == false {
                    emit(cg, "  ret i64 ");
                    emit_line(cg, result);
                }
            } else {
                emit_line(cg, "  ret i64 0");
            }

            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    // Generate message constructor functions for send/ask calls
    // Each message type (Add, Get, etc.) needs a constructor function
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);
            let params: i64 = load_ptr(handler, 1);

            // Register nullary messages (no params) so gen_expr can generate calls for them
            // instead of treating them as variable references
            let is_nullary: i64 = 1;
            if params != 0 {
                if vec_len(params) > 0 {
                    is_nullary = 0;
                }
            }
            if is_nullary == 1 {
                cg_register_message(cg, msg_name);
            }

            // Generate message constructor: MsgName(params...) -> i64
            // Returns a pointer to message struct: [tag, param0, param1, ...]
            emit(cg, "define i64 @\"");
            emit(cg, msg_name);
            emit(cg, "\"(");

            // Add parameters to function signature
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    if pi > 0 {
                        emit(cg, ", ");
                    }
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    emit(cg, "i64 %");
                    emit(cg, pname);
                    pi = pi + 1;
                }
            }
            emit_line(cg, ") {");
            emit_line(cg, "entry:");

            // Calculate message struct size: 8 bytes for tag + 8 bytes per param
            let param_count: i64 = 0;
            if params != 0 {
                param_count = vec_len(params);
            }
            let msg_size: i64 = 8 + (param_count * 8);

            // Allocate message struct
            emit(cg, "  %msg = call ptr @malloc(i64 ");
            emit(cg, int_to_string(msg_size));
            emit_line(cg, ")");

            // Store message tag (index of this handler)
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(i));
            emit_line(cg, ", ptr %msg");

            // Store each parameter at offset 8 + (pi * 8)
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    let offset: i64 = 8 + (pi * 8);
                    emit(cg, "  %slot");
                    emit(cg, int_to_string(pi));
                    emit(cg, " = getelementptr i8, ptr %msg, i64 ");
                    emit_line(cg, int_to_string(offset));
                    emit(cg, "  store i64 %");
                    emit(cg, pname);
                    emit(cg, ", ptr %slot");
                    emit_line(cg, int_to_string(pi));
                    pi = pi + 1;
                }
            }

            // Return message pointer as i64
            emit_line(cg, "  %ret = ptrtoint ptr %msg to i64");
            emit_line(cg, "  ret i64 %ret");
            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate specialist definition (Phase 33)
// Specialists are AI agents with capabilities and knowledge
fn gen_specialist(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let config: i64 = load_ptr(item, 2);
    let state_fields: i64 = load_ptr(item, 3);
    let handlers: i64 = load_ptr(item, 4);

    emit(cg, "; Specialist: ");
    emit_line(cg, name);

    // Issue 15 fix: Extract config values for use in specialist
    // Config layout: capabilities(0), model(1), context_window(2)
    let model_name: i64 = 0;
    let context_window: i64 = 4096;  // default
    if config != 0 {
        model_name = load_ptr(config, 1);
        context_window = load_i64(config, 2);
        if context_window == 0 {
            context_window = 4096;
        }
    }

    // Register state fields as struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate specialist_new function
    // Issue 15 fix: Initialize specialist with config
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    // Allocate: model_ptr(0), context(8), context_window(16), state fields(24+)
    emit_line(cg, "  %spec = call ptr @malloc(i64 128)");
    // Store context window size
    emit_line(cg, "  %ctx_ptr = getelementptr i8, ptr %spec, i64 16");
    emit(cg, "  store i64 ");
    emit(cg, int_to_string(context_window));
    emit_line(cg, ", ptr %ctx_ptr");
    // Initialize context vector
    emit_line(cg, "  %ctx = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %ctx_slot = getelementptr i8, ptr %spec, i64 8");
    emit_line(cg, "  store ptr %ctx, ptr %ctx_slot");
    emit_line(cg, "  %ret = ptrtoint ptr %spec to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Issue 3 fix: Generate actual infer function using specialist_query runtime
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_infer\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    // Get context from specialist
    emit_line(cg, "  %spec = inttoptr i64 %self to ptr");
    emit_line(cg, "  %ctx_slot = getelementptr i8, ptr %spec, i64 8");
    emit_line(cg, "  %ctx = load ptr, ptr %ctx_slot");
    // Add query to context
    emit_line(cg, "  %query_ptr = inttoptr i64 %query to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %ctx, ptr %query_ptr)");
    // Call specialist_query runtime for inference
    emit_line(cg, "  %result = call i64 @specialist_query(i64 %self, i64 %query)");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate set_context function for specialists
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_set_context\"(i64 %self, i64 %context) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  call void @specialist_set_context(i64 %self, i64 %context)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Issue 2 fix: Generate message handlers with body execution
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);
            let params: i64 = load_ptr(handler, 1);
            let body: i64 = load_ptr(handler, 2);

            // Generate handler function
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit(cg, "\"(i64 %self");

            // Add handler parameters
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    emit(cg, ", i64 %");
                    emit(cg, pname);
                    pi = pi + 1;
                }
            }
            emit_line(cg, ") {");
            emit_line(cg, "entry:");

            // Set up local for self
            cg_clear_locals(cg);
            add_local(cg, string_from("self"), string_from("self_param"));
            emit_line(cg, "  %local.self_param = alloca i64");
            emit_line(cg, "  store i64 %self, ptr %local.self_param");

            // Set up locals for parameters
            if params != 0 {
                let pn: i64 = vec_len(params);
                let pi: i64 = 0;
                while pi < pn {
                    let param: i64 = vec_get(params, pi);
                    let pname: i64 = load_ptr(param, 0);
                    add_local(cg, pname, pname);
                    emit(cg, "  %local.");
                    emit(cg, pname);
                    emit_line(cg, " = alloca i64");
                    emit(cg, "  store i64 %");
                    emit(cg, pname);
                    emit(cg, ", ptr %local.");
                    emit_line(cg, pname);
                    pi = pi + 1;
                }
            }

            // Generate handler body if present
            if body != 0 {
                cg_clear_alloca_queue(cg);
                let all_locals: i64 = collect_locals_from_block(body);
                let num_locals: i64 = vec_len(all_locals);
                let j: i64 = 0;
                while j < num_locals {
                    let local_name: i64 = vec_get(all_locals, j);
                    let local_id: i64 = cg_next_temp(cg);
                    let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
                    emit(cg, "  %local.");
                    emit(cg, unique_name);
                    emit_line(cg, " = alloca i64");
                    cg_push_alloca(cg, unique_name);
                    j = j + 1;
                }

                cg_set_terminated(cg, false);
                let result: i64 = gen_block(cg, body);

                if cg_is_terminated(cg) == false {
                    emit(cg, "  ret i64 ");
                    emit_line(cg, result);
                }
            } else {
                emit_line(cg, "  ret i64 0");
            }

            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate hive definition (Phase 33)
// Hives orchestrate multiple specialists
fn gen_hive(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let specialists: i64 = load_ptr(item, 2);
    let routing: i64 = load_ptr(item, 3);

    emit(cg, "; Hive: ");
    emit_line(cg, name);

    // Issue 5 fix: Count specialists for allocation
    let num_specialists: i64 = 0;
    if specialists != 0 {
        num_specialists = vec_len(specialists);
    }

    // Generate hive_new function
    // Issue 5 fix: Initialize hive with specialists
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    // Allocate: specialist_vec(0), routing_table(8), count(16)
    emit_line(cg, "  %hive = call ptr @malloc(i64 128)");
    // Initialize specialist vector
    emit_line(cg, "  %spec_vec = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  store ptr %spec_vec, ptr %hive");

    // Issue 5 fix: Create and add each specialist
    if specialists != 0 {
        let i: i64 = 0;
        while i < num_specialists {
            let spec_name: i64 = vec_get(specialists, i);
            // Generate call to create specialist
            emit(cg, "  %spec_");
            emit(cg, int_to_string(i));
            emit(cg, " = call i64 @\"");
            emit(cg, spec_name);
            emit_line(cg, "_new\"()");
            // Add to hive
            emit(cg, "  %spec_ptr_");
            emit(cg, int_to_string(i));
            emit(cg, " = inttoptr i64 %spec_");
            emit(cg, int_to_string(i));
            emit_line(cg, " to ptr");
            emit(cg, "  call void @intrinsic_vec_push(ptr %spec_vec, ptr %spec_ptr_");
            emit(cg, int_to_string(i));
            emit_line(cg, ")");
            // Also call hive_add_specialist runtime
            emit(cg, "  %hive_i64_");
            emit(cg, int_to_string(i));
            emit_line(cg, " = ptrtoint ptr %hive to i64");
            emit(cg, "  call void @hive_add_specialist(i64 %hive_i64_");
            emit(cg, int_to_string(i));
            emit(cg, ", i64 %spec_");
            emit(cg, int_to_string(i));
            emit_line(cg, ")");
            i = i + 1;
        }
    }

    // Issue 11 fix: Store routing configuration
    if routing != 0 {
        emit_line(cg, "  %route_ptr = getelementptr i8, ptr %hive, i64 8");
        emit_line(cg, "  %route_vec = call ptr @intrinsic_vec_new()");
        emit_line(cg, "  store ptr %route_vec, ptr %route_ptr");
    }

    emit_line(cg, "  %ret = ptrtoint ptr %hive to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Issue 4 fix: Generate dispatch function with actual routing
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_dispatch\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    // Use hive_route runtime to find appropriate specialist
    emit_line(cg, "  %specialist = call i64 @hive_route(i64 %self, i64 %query)");
    // Check if we got a valid specialist
    emit_line(cg, "  %has_spec = icmp ne i64 %specialist, 0");
    emit_line(cg, "  br i1 %has_spec, label %do_query, label %no_spec");
    emit_line(cg, "do_query:");
    // Call specialist_query on the routed specialist
    emit_line(cg, "  %result = call i64 @specialist_query(i64 %specialist, i64 %query)");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "no_spec:");
    // No specialist found - try consensus if multiple specialists
    if num_specialists > 1 {
        emit_line(cg, "  %consensus = call i64 @hive_consensus(i64 %self, i64 %query)");
        emit_line(cg, "  ret i64 %consensus");
    } else {
        emit_line(cg, "  ret i64 0");
    }
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate add_specialist function
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_add_specialist\"(i64 %self, i64 %specialist) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  call void @hive_add_specialist(i64 %self, i64 %specialist)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate anima (cognitive soul)
// Layout: episodic(0), semantic(1), procedural(2), working(3), beliefs(4), identity(5), slm(6), persistence(7)
fn gen_anima(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let identity: i64 = load_ptr(item, 2);
    let memory: i64 = load_ptr(item, 3);
    let beliefs: i64 = load_ptr(item, 4);
    let slm: i64 = load_ptr(item, 5);
    let persistence: i64 = load_ptr(item, 6);

    emit(cg, "; Anima: ");
    emit_line(cg, name);

    // Issue 14 fix: Extract identity string for storage
    let identity_str: i64 = name;  // default to name
    if identity != 0 {
        identity_str = identity;
    }

    // Issue 12, 13 fix: Extract SLM and persistence config
    let slm_model: i64 = 0;
    let persistence_path: i64 = 0;
    if slm != 0 {
        slm_model = slm;  // SLM model name/path
    }
    if persistence != 0 {
        persistence_path = persistence;  // persistence file path
    }

    // Generate anima_new function - creates a new anima instance
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    // Allocate anima struct: memory stores + identity + slm + persistence
    emit_line(cg, "  %anima = call ptr @malloc(i64 256)");
    // Initialize memory stores
    emit_line(cg, "  %episodic = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %semantic = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %procedural = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %working = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %beliefs_store = call ptr @intrinsic_vec_new()");
    // Store memory stores in anima struct
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  store ptr %episodic, ptr %ep_ptr");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  store ptr %semantic, ptr %sem_ptr");
    emit_line(cg, "  %proc_ptr = getelementptr ptr, ptr %anima, i64 2");
    emit_line(cg, "  store ptr %procedural, ptr %proc_ptr");
    emit_line(cg, "  %work_ptr = getelementptr ptr, ptr %anima, i64 3");
    emit_line(cg, "  store ptr %working, ptr %work_ptr");
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  store ptr %beliefs_store, ptr %bel_ptr");

    // Issue 14 fix: Store identity string
    emit(cg, "  %identity_str = call i64 @intrinsic_string_new(ptr @.str.anima.id.");
    emit(cg, name);
    emit_line(cg, ")");
    emit_line(cg, "  %id_ptr = getelementptr ptr, ptr %anima, i64 5");
    emit_line(cg, "  %id_as_ptr = inttoptr i64 %identity_str to ptr");
    emit_line(cg, "  store ptr %id_as_ptr, ptr %id_ptr");

    // Issue 12 fix: Initialize SLM integration if configured
    if slm_model != 0 {
        emit(cg, "  %slm_name = call i64 @intrinsic_string_new(ptr @.str.anima.slm.");
        emit(cg, name);
        emit_line(cg, ")");
        emit_line(cg, "  %slm_handle = call i64 @model_load(i64 %slm_name)");
        emit_line(cg, "  %slm_ptr = getelementptr ptr, ptr %anima, i64 6");
        emit_line(cg, "  %slm_as_ptr = inttoptr i64 %slm_handle to ptr");
        emit_line(cg, "  store ptr %slm_as_ptr, ptr %slm_ptr");
    }

    // Issue 13 fix: Store persistence path if configured
    if persistence_path != 0 {
        emit(cg, "  %persist_str = call i64 @intrinsic_string_new(ptr @.str.anima.persist.");
        emit(cg, name);
        emit_line(cg, ")");
        emit_line(cg, "  %persist_ptr = getelementptr ptr, ptr %anima, i64 7");
        emit_line(cg, "  %persist_as_ptr = inttoptr i64 %persist_str to ptr");
        emit_line(cg, "  store ptr %persist_as_ptr, ptr %persist_ptr");
    }

    emit_line(cg, "  %ret = ptrtoint ptr %anima to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Emit string constants for identity, slm, persistence
    emit(cg, "@.str.anima.id.");
    emit(cg, name);
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(string_len(identity_str) + 1));
    emit(cg, " x i8] c\"");
    emit(cg, identity_str);
    emit_line(cg, "\\00\"");

    if slm_model != 0 {
        emit(cg, "@.str.anima.slm.");
        emit(cg, name);
        emit(cg, " = private unnamed_addr constant [");
        emit(cg, int_to_string(string_len(slm_model) + 1));
        emit(cg, " x i8] c\"");
        emit(cg, slm_model);
        emit_line(cg, "\\00\"");
    }

    if persistence_path != 0 {
        emit(cg, "@.str.anima.persist.");
        emit(cg, name);
        emit(cg, " = private unnamed_addr constant [");
        emit(cg, int_to_string(string_len(persistence_path) + 1));
        emit(cg, " x i8] c\"");
        emit(cg, persistence_path);
        emit_line(cg, "\\00\"");
    }

    // Generate remember function - stores experience in episodic memory
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_remember\"(i64 %self, i64 %experience) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  %episodic = load ptr, ptr %ep_ptr");
    emit_line(cg, "  %exp = inttoptr i64 %experience to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %episodic, ptr %exp)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate learn function - stores fact in semantic memory
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_learn\"(i64 %self, i64 %fact) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  %semantic = load ptr, ptr %sem_ptr");
    emit_line(cg, "  %f = inttoptr i64 %fact to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %semantic, ptr %f)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate believe function - stores belief with confidence
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_believe\"(i64 %self, i64 %belief, i64 %confidence) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  %beliefs = load ptr, ptr %bel_ptr");
    emit_line(cg, "  %b = inttoptr i64 %belief to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %beliefs, ptr %b)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Issue 6 fix: Generate recall_for function with goal-directed recall
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_recall_for\"(i64 %self, i64 %goal, i64 %context) {");
    emit_line(cg, "entry:");
    // Create results vector
    emit_line(cg, "  %results = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");

    // Search episodic memory for goal-relevant memories
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  %episodic = load ptr, ptr %ep_ptr");
    emit_line(cg, "  %ep_len = call i64 @intrinsic_vec_len(ptr %episodic)");
    emit_line(cg, "  br label %ep_search");
    emit_line(cg, "ep_search:");
    emit_line(cg, "  %ep_i = phi i64 [ 0, %entry ], [ %ep_next, %ep_check ]");
    emit_line(cg, "  %ep_done = icmp sge i64 %ep_i, %ep_len");
    emit_line(cg, "  br i1 %ep_done, label %search_semantic, label %ep_check");
    emit_line(cg, "ep_check:");
    emit_line(cg, "  %ep_item = call ptr @intrinsic_vec_get(ptr %episodic, i64 %ep_i)");
    emit_line(cg, "  %ep_val = ptrtoint ptr %ep_item to i64");
    // Check if memory contains goal (simple string contains check)
    emit_line(cg, "  %goal_ptr = inttoptr i64 %goal to ptr");
    emit_line(cg, "  %ep_contains = call i64 @intrinsic_string_contains(ptr %ep_item, ptr %goal_ptr)");
    emit_line(cg, "  %ep_relevant = icmp ne i64 %ep_contains, 0");
    emit_line(cg, "  br i1 %ep_relevant, label %ep_add, label %ep_skip");
    emit_line(cg, "ep_add:");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %results, ptr %ep_item)");
    emit_line(cg, "  br label %ep_skip");
    emit_line(cg, "ep_skip:");
    emit_line(cg, "  %ep_next = add i64 %ep_i, 1");
    emit_line(cg, "  br label %ep_search");

    // Search semantic memory
    emit_line(cg, "search_semantic:");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  %semantic = load ptr, ptr %sem_ptr");
    emit_line(cg, "  %sem_len = call i64 @intrinsic_vec_len(ptr %semantic)");
    emit_line(cg, "  br label %sem_search");
    emit_line(cg, "sem_search:");
    emit_line(cg, "  %sem_i = phi i64 [ 0, %search_semantic ], [ %sem_next, %sem_check ]");
    emit_line(cg, "  %sem_done = icmp sge i64 %sem_i, %sem_len");
    emit_line(cg, "  br i1 %sem_done, label %recall_done, label %sem_check");
    emit_line(cg, "sem_check:");
    emit_line(cg, "  %sem_item = call ptr @intrinsic_vec_get(ptr %semantic, i64 %sem_i)");
    emit_line(cg, "  %sem_contains = call i64 @intrinsic_string_contains(ptr %sem_item, ptr %goal_ptr)");
    emit_line(cg, "  %sem_relevant = icmp ne i64 %sem_contains, 0");
    emit_line(cg, "  br i1 %sem_relevant, label %sem_add, label %sem_skip");
    emit_line(cg, "sem_add:");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %results, ptr %sem_item)");
    emit_line(cg, "  br label %sem_skip");
    emit_line(cg, "sem_skip:");
    emit_line(cg, "  %sem_next = add i64 %sem_i, 1");
    emit_line(cg, "  br label %sem_search");

    emit_line(cg, "recall_done:");
    emit_line(cg, "  %ret = ptrtoint ptr %results to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Issue 12 fix: Generate think function with actual SLM integration
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_think\"(i64 %self, i64 %question) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    // Get SLM handle from slot 6
    emit_line(cg, "  %slm_ptr = getelementptr ptr, ptr %anima, i64 6");
    emit_line(cg, "  %slm_handle_ptr = load ptr, ptr %slm_ptr");
    emit_line(cg, "  %slm_handle = ptrtoint ptr %slm_handle_ptr to i64");
    // Check if SLM is loaded
    emit_line(cg, "  %has_slm = icmp ne i64 %slm_handle, 0");
    emit_line(cg, "  br i1 %has_slm, label %do_infer, label %no_slm");
    emit_line(cg, "do_infer:");
    // Call model_infer with the question
    emit_line(cg, "  %result = call i64 @model_infer(i64 %question)");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "no_slm:");
    // No SLM loaded - return the question as-is
    emit_line(cg, "  ret i64 %question");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate save function - persist anima to file
    // Bug 30 fix: Implement actual JSON serialization
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_save\"(i64 %self, i64 %path) {");
    emit_line(cg, "entry:");
    // Create JSON object for anima state
    emit_line(cg, "  %json = call i64 @\"json_object_new\"()");

    // Store anima name/identity as string
    emit(cg, "  %name_str = call i64 @intrinsic_string_new(ptr @.str.anima.");
    emit(cg, name);
    emit_line(cg, ")");
    emit_line(cg, "  %name_json = call i64 @\"json_string_sx\"(i64 %name_str)");
    emit_line(cg, "  %key_identity = call i64 @intrinsic_string_new(ptr @.str.identity)");
    emit_line(cg, "  call void @\"json_object_set_sx\"(i64 %json, i64 %key_identity, i64 %name_json)");

    // Get anima struct pointer
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");

    // Serialize episodic memory (slot 0)
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  %episodic = load ptr, ptr %ep_ptr");
    emit_line(cg, "  %ep_len = call i64 @intrinsic_vec_len(ptr %episodic)");
    emit_line(cg, "  %ep_arr = call i64 @\"json_array_new\"()");
    emit_line(cg, "  br label %ep_loop");
    emit_line(cg, "ep_loop:");
    emit_line(cg, "  %ep_i = phi i64 [ 0, %entry ], [ %ep_next, %ep_body ]");
    emit_line(cg, "  %ep_done = icmp sge i64 %ep_i, %ep_len");
    emit_line(cg, "  br i1 %ep_done, label %ep_end, label %ep_body");
    emit_line(cg, "ep_body:");
    emit_line(cg, "  %ep_item = call ptr @intrinsic_vec_get(ptr %episodic, i64 %ep_i)");
    emit_line(cg, "  %ep_val = ptrtoint ptr %ep_item to i64");
    emit_line(cg, "  %ep_json_item = call i64 @\"json_string_sx\"(i64 %ep_val)");
    emit_line(cg, "  call void @\"json_array_push\"(i64 %ep_arr, i64 %ep_json_item)");
    emit_line(cg, "  %ep_next = add i64 %ep_i, 1");
    emit_line(cg, "  br label %ep_loop");
    emit_line(cg, "ep_end:");
    emit_line(cg, "  %key_episodic = call i64 @intrinsic_string_new(ptr @.str.episodic)");
    emit_line(cg, "  call void @\"json_object_set_sx\"(i64 %json, i64 %key_episodic, i64 %ep_arr)");

    // Serialize semantic memory (slot 1)
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  %semantic = load ptr, ptr %sem_ptr");
    emit_line(cg, "  %sem_len = call i64 @intrinsic_vec_len(ptr %semantic)");
    emit_line(cg, "  %sem_arr = call i64 @\"json_array_new\"()");
    emit_line(cg, "  br label %sem_loop");
    emit_line(cg, "sem_loop:");
    emit_line(cg, "  %sem_i = phi i64 [ 0, %ep_end ], [ %sem_next, %sem_body ]");
    emit_line(cg, "  %sem_done = icmp sge i64 %sem_i, %sem_len");
    emit_line(cg, "  br i1 %sem_done, label %sem_end, label %sem_body");
    emit_line(cg, "sem_body:");
    emit_line(cg, "  %sem_item = call ptr @intrinsic_vec_get(ptr %semantic, i64 %sem_i)");
    emit_line(cg, "  %sem_val = ptrtoint ptr %sem_item to i64");
    emit_line(cg, "  %sem_json_item = call i64 @\"json_string_sx\"(i64 %sem_val)");
    emit_line(cg, "  call void @\"json_array_push\"(i64 %sem_arr, i64 %sem_json_item)");
    emit_line(cg, "  %sem_next = add i64 %sem_i, 1");
    emit_line(cg, "  br label %sem_loop");
    emit_line(cg, "sem_end:");
    emit_line(cg, "  %key_semantic = call i64 @intrinsic_string_new(ptr @.str.semantic)");
    emit_line(cg, "  call void @\"json_object_set_sx\"(i64 %json, i64 %key_semantic, i64 %sem_arr)");

    // Serialize beliefs (slot 4)
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  %beliefs = load ptr, ptr %bel_ptr");
    emit_line(cg, "  %bel_len = call i64 @intrinsic_vec_len(ptr %beliefs)");
    emit_line(cg, "  %bel_arr = call i64 @\"json_array_new\"()");
    emit_line(cg, "  br label %bel_loop");
    emit_line(cg, "bel_loop:");
    emit_line(cg, "  %bel_i = phi i64 [ 0, %sem_end ], [ %bel_next, %bel_body ]");
    emit_line(cg, "  %bel_done = icmp sge i64 %bel_i, %bel_len");
    emit_line(cg, "  br i1 %bel_done, label %bel_end, label %bel_body");
    emit_line(cg, "bel_body:");
    emit_line(cg, "  %bel_item = call ptr @intrinsic_vec_get(ptr %beliefs, i64 %bel_i)");
    emit_line(cg, "  %bel_val = ptrtoint ptr %bel_item to i64");
    emit_line(cg, "  %bel_json_item = call i64 @\"json_string_sx\"(i64 %bel_val)");
    emit_line(cg, "  call void @\"json_array_push\"(i64 %bel_arr, i64 %bel_json_item)");
    emit_line(cg, "  %bel_next = add i64 %bel_i, 1");
    emit_line(cg, "  br label %bel_loop");
    emit_line(cg, "bel_end:");
    emit_line(cg, "  %key_beliefs = call i64 @intrinsic_string_new(ptr @.str.beliefs)");
    emit_line(cg, "  call void @\"json_object_set_sx\"(i64 %json, i64 %key_beliefs, i64 %bel_arr)");

    // Stringify and write to file
    emit_line(cg, "  %json_str = call i64 @\"json_stringify\"(i64 %json)");
    emit_line(cg, "  %path_ptr = inttoptr i64 %path to ptr");
    emit_line(cg, "  %json_ptr = inttoptr i64 %json_str to ptr");
    emit_line(cg, "  call void @intrinsic_write_file(ptr %path_ptr, ptr %json_ptr)");
    emit_line(cg, "  ret i64 1");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Emit string constants for JSON keys
    emit(cg, "@.str.anima.");
    emit(cg, name);
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(string_len(name) + 1));
    emit(cg, " x i8] c\"");
    emit(cg, name);
    emit_line(cg, "\\00\"");
    emit_line(cg, "@.str.identity = private unnamed_addr constant [9 x i8] c\"identity\\00\"");
    emit_line(cg, "@.str.episodic = private unnamed_addr constant [9 x i8] c\"episodic\\00\"");
    emit_line(cg, "@.str.semantic = private unnamed_addr constant [9 x i8] c\"semantic\\00\"");
    emit_line(cg, "@.str.beliefs = private unnamed_addr constant [8 x i8] c\"beliefs\\00\"");

    // Generate load function - load anima from file
    // Bug 30 fix: Implement actual JSON deserialization
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_load\"(i64 %path) {");
    emit_line(cg, "entry:");

    // Create new anima instance first
    emit(cg, "  %anima_i64 = call i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"()");
    emit_line(cg, "  %anima = inttoptr i64 %anima_i64 to ptr");

    // Read file content
    emit_line(cg, "  %path_ptr = inttoptr i64 %path to ptr");
    emit_line(cg, "  %content = call ptr @intrinsic_read_file(ptr %path_ptr)");
    emit_line(cg, "  %content_i64 = ptrtoint ptr %content to i64");

    // Parse JSON
    emit_line(cg, "  %json = call i64 @\"json_parse_simple\"(i64 %content_i64)");
    emit_line(cg, "  %is_null = call i8 @\"json_is_null\"(i64 %json)");
    emit_line(cg, "  %is_null_i1 = trunc i8 %is_null to i1");
    emit_line(cg, "  br i1 %is_null_i1, label %parse_fail, label %parse_ok");
    emit_line(cg, "parse_fail:");
    emit_line(cg, "  ret i64 %anima_i64");
    emit_line(cg, "parse_ok:");

    // Load episodic memory
    emit_line(cg, "  %key_ep = call i64 @intrinsic_string_new(ptr @.str.episodic)");
    emit_line(cg, "  %ep_json = call i64 @\"json_get_sx\"(i64 %json, i64 %key_ep)");
    emit_line(cg, "  %ep_is_arr = call i8 @\"json_is_array\"(i64 %ep_json)");
    emit_line(cg, "  %ep_is_arr_i1 = trunc i8 %ep_is_arr to i1");
    emit_line(cg, "  br i1 %ep_is_arr_i1, label %load_ep, label %skip_ep");
    emit_line(cg, "load_ep:");
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  %episodic = load ptr, ptr %ep_ptr");
    emit_line(cg, "  %ep_len = call i64 @\"json_array_len\"(i64 %ep_json)");
    emit_line(cg, "  br label %ep_load_loop");
    emit_line(cg, "ep_load_loop:");
    emit_line(cg, "  %ep_li = phi i64 [ 0, %load_ep ], [ %ep_lnext, %ep_load_body ]");
    emit_line(cg, "  %ep_ldone = icmp sge i64 %ep_li, %ep_len");
    emit_line(cg, "  br i1 %ep_ldone, label %skip_ep, label %ep_load_body");
    emit_line(cg, "ep_load_body:");
    emit_line(cg, "  %ep_item_json = call i64 @\"json_get_index\"(i64 %ep_json, i64 %ep_li)");
    emit_line(cg, "  %ep_item_str = call i64 @\"json_as_string\"(i64 %ep_item_json)");
    emit_line(cg, "  %ep_item_ptr = inttoptr i64 %ep_item_str to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %episodic, ptr %ep_item_ptr)");
    emit_line(cg, "  %ep_lnext = add i64 %ep_li, 1");
    emit_line(cg, "  br label %ep_load_loop");
    emit_line(cg, "skip_ep:");

    // Load semantic memory
    emit_line(cg, "  %key_sem = call i64 @intrinsic_string_new(ptr @.str.semantic)");
    emit_line(cg, "  %sem_json = call i64 @\"json_get_sx\"(i64 %json, i64 %key_sem)");
    emit_line(cg, "  %sem_is_arr = call i8 @\"json_is_array\"(i64 %sem_json)");
    emit_line(cg, "  %sem_is_arr_i1 = trunc i8 %sem_is_arr to i1");
    emit_line(cg, "  br i1 %sem_is_arr_i1, label %load_sem, label %skip_sem");
    emit_line(cg, "load_sem:");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  %semantic = load ptr, ptr %sem_ptr");
    emit_line(cg, "  %sem_len = call i64 @\"json_array_len\"(i64 %sem_json)");
    emit_line(cg, "  br label %sem_load_loop");
    emit_line(cg, "sem_load_loop:");
    emit_line(cg, "  %sem_li = phi i64 [ 0, %load_sem ], [ %sem_lnext, %sem_load_body ]");
    emit_line(cg, "  %sem_ldone = icmp sge i64 %sem_li, %sem_len");
    emit_line(cg, "  br i1 %sem_ldone, label %skip_sem, label %sem_load_body");
    emit_line(cg, "sem_load_body:");
    emit_line(cg, "  %sem_item_json = call i64 @\"json_get_index\"(i64 %sem_json, i64 %sem_li)");
    emit_line(cg, "  %sem_item_str = call i64 @\"json_as_string\"(i64 %sem_item_json)");
    emit_line(cg, "  %sem_item_ptr = inttoptr i64 %sem_item_str to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %semantic, ptr %sem_item_ptr)");
    emit_line(cg, "  %sem_lnext = add i64 %sem_li, 1");
    emit_line(cg, "  br label %sem_load_loop");
    emit_line(cg, "skip_sem:");

    // Load beliefs
    emit_line(cg, "  %key_bel = call i64 @intrinsic_string_new(ptr @.str.beliefs)");
    emit_line(cg, "  %bel_json = call i64 @\"json_get_sx\"(i64 %json, i64 %key_bel)");
    emit_line(cg, "  %bel_is_arr = call i8 @\"json_is_array\"(i64 %bel_json)");
    emit_line(cg, "  %bel_is_arr_i1 = trunc i8 %bel_is_arr to i1");
    emit_line(cg, "  br i1 %bel_is_arr_i1, label %load_bel, label %load_done");
    emit_line(cg, "load_bel:");
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  %beliefs = load ptr, ptr %bel_ptr");
    emit_line(cg, "  %bel_len = call i64 @\"json_array_len\"(i64 %bel_json)");
    emit_line(cg, "  br label %bel_load_loop");
    emit_line(cg, "bel_load_loop:");
    emit_line(cg, "  %bel_li = phi i64 [ 0, %load_bel ], [ %bel_lnext, %bel_load_body ]");
    emit_line(cg, "  %bel_ldone = icmp sge i64 %bel_li, %bel_len");
    emit_line(cg, "  br i1 %bel_ldone, label %load_done, label %bel_load_body");
    emit_line(cg, "bel_load_body:");
    emit_line(cg, "  %bel_item_json = call i64 @\"json_get_index\"(i64 %bel_json, i64 %bel_li)");
    emit_line(cg, "  %bel_item_str = call i64 @\"json_as_string\"(i64 %bel_item_json)");
    emit_line(cg, "  %bel_item_ptr = inttoptr i64 %bel_item_str to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %beliefs, ptr %bel_item_ptr)");
    emit_line(cg, "  %bel_lnext = add i64 %bel_li, 1");
    emit_line(cg, "  br label %bel_load_loop");
    emit_line(cg, "load_done:");

    emit_line(cg, "  ret i64 %anima_i64");
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate item
fn gen_item(cg: i64, item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == TAG_FN() {
        return gen_fn(cg, item);
    }
    if tag == TAG_ENUM() {
        return gen_enum(cg, item);
    }
    if tag == TAG_STRUCT() {
        return gen_struct(cg, item);
    }
    if tag == TAG_IMPL() {
        return gen_impl(cg, item);
    }
    if tag == TAG_TRAIT() {
        return gen_trait(cg, item);
    }
    if tag == TAG_IMPL_TRAIT() {
        return gen_impl_trait(cg, item);
    }
    // TAG_MOD and TAG_USE don't generate code - they're for the build system
    if tag == TAG_MOD() {
        return 0;
    }
    if tag == TAG_USE() {
        return 0;
    }
    // Type alias - register the alias for type resolution
    if tag == TAG_TYPE_ALIAS() {
        let alias_name: i64 = load_ptr(item, 1);
        let target_type: i64 = load_ptr(item, 2);
        cg_register_type_alias(cg, alias_name, target_type);
        return 0;  // No code generated for type aliases
    }
    // Actor, Specialist, Hive - call dedicated generators
    if tag == TAG_ACTOR() {
        return gen_actor(cg, item);
    }
    if tag == TAG_SPECIALIST() {
        return gen_specialist(cg, item);
    }
    if tag == TAG_HIVE() {
        return gen_hive(cg, item);
    }
    if tag == TAG_ANIMA() {
        return gen_anima(cg, item);
    }
    0
}

// Generate program header
fn gen_header(cg: i64) -> i64 {
    emit_line(cg, "; ModuleID = 'simplex_program'");
    // Dynamic target triple based on current platform (fixes GitHub issue #56)
    let triple_line: i64 = str_join3("target triple = \"", get_target_triple(), "\"");
    emit_line(cg, triple_line);
    emit_line(cg, "");
    emit_line(cg, "declare ptr @malloc(i64)");
    emit_line(cg, "declare void @free(ptr)");
    emit_line(cg, "declare void @intrinsic_println(ptr)");
    emit_line(cg, "declare void @intrinsic_print(ptr)");
    emit_line(cg, "declare void @\"print_i64\"(i64)");
    emit_line(cg, "declare ptr @intrinsic_int_to_string(i64)");
    emit_line(cg, "declare ptr @intrinsic_string_new(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_from_char(i64)");
    emit_line(cg, "declare i64 @intrinsic_string_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_concat(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_slice(ptr, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_string_char_at(ptr, i64)");
    emit_line(cg, "declare i1 @intrinsic_string_eq(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_to_int(ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_new()");
    emit_line(cg, "declare void @intrinsic_vec_push(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_get(ptr, i64)");
    emit_line(cg, "declare i64 @intrinsic_vec_len(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_set(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_pop(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_clear(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_remove(ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_get_args()");
    emit_line(cg, "declare ptr @intrinsic_read_file(ptr)");
    emit_line(cg, "declare void @intrinsic_write_file(ptr, ptr)");
    emit_line(cg, "declare ptr @store_ptr(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @store_i64(ptr, i64, i64)");
    emit_line(cg, "declare ptr @load_ptr(ptr, i64)");
    emit_line(cg, "declare i64 @load_i64(ptr, i64)");
    emit_line(cg, "; Timing intrinsics");
    emit_line(cg, "declare i64 @intrinsic_get_time_ms()");
    emit_line(cg, "declare i64 @intrinsic_get_time_us()");
    emit_line(cg, "; Arena allocator intrinsics");
    emit_line(cg, "declare ptr @intrinsic_arena_create(i64)");
    emit_line(cg, "declare ptr @intrinsic_arena_alloc(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_arena_reset(ptr)");
    emit_line(cg, "declare void @intrinsic_arena_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_arena_used(ptr)");
    emit_line(cg, "; StringBuilder intrinsics");
    emit_line(cg, "declare ptr @intrinsic_sb_new()");
    emit_line(cg, "declare ptr @intrinsic_sb_new_cap(i64)");
    emit_line(cg, "declare void @intrinsic_sb_append(ptr, ptr)");
    emit_line(cg, "declare void @intrinsic_sb_append_char(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_sb_append_i64(ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_sb_to_string(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_clear(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_sb_len(ptr)");
    emit_line(cg, "; File I/O intrinsics");
    emit_line(cg, "declare ptr @intrinsic_getenv(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_exists(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_file(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_directory(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_size(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_mtime(ptr)");
    emit_line(cg, "declare i64 @intrinsic_remove_path(ptr)");
    emit_line(cg, "declare i64 @intrinsic_mkdir_p(ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_cwd()");
    emit_line(cg, "declare i64 @intrinsic_set_cwd(ptr)");
    emit_line(cg, "declare ptr @intrinsic_list_dir(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_join(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_dirname(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_basename(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_extension(ptr)");
    emit_line(cg, "declare i64 @file_copy(ptr, ptr)");
    emit_line(cg, "declare i64 @file_rename(ptr, ptr)");
    emit_line(cg, "declare void @stderr_write(ptr)");
    emit_line(cg, "declare void @stderr_writeln(ptr)");
    emit_line(cg, "; Error handling intrinsics");
    emit_line(cg, "declare void @intrinsic_panic(ptr)");
    emit_line(cg, "declare void @intrinsic_print_stack_trace()");
    emit_line(cg, "; Process intrinsics");
    emit_line(cg, "declare i64 @intrinsic_process_run(ptr)");
    emit_line(cg, "declare ptr @intrinsic_process_output(ptr)");
    emit_line(cg, "; Phase 20: REPL/I/O intrinsics");
    emit_line(cg, "declare ptr @intrinsic_read_line()");
    emit_line(cg, "declare i64 @intrinsic_is_tty()");
    emit_line(cg, "declare i64 @intrinsic_stdin_has_data()");
    emit_line(cg, "declare i64 @intrinsic_string_hash(ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_find(ptr, ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_string_trim(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_split(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_starts_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_ends_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_contains(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_replace(ptr, ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_lines(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_join(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_to_lowercase(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_to_uppercase(ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_compare(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_copy_file(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_home_dir()");
    // CLI/Environment intrinsics
    emit_line(cg, "declare i64 @cli_getenv(i64)");
    emit_line(cg, "declare i64 @file_read(i64)");
    emit_line(cg, "declare void @file_write(i64, i64)");
    emit_line(cg, "declare i64 @remove_path(i64)");
    // Float parsing
    emit_line(cg, "declare i64 @f64_parse(ptr)");

    // Issue 7 fix: Generator intrinsics
    emit_line(cg, "; Generator intrinsics");
    emit_line(cg, "declare i64 @generator_yield(i64)");
    emit_line(cg, "declare i64 @generator_new(i64)");
    emit_line(cg, "declare i64 @generator_next(i64)");
    emit_line(cg, "declare i64 @generator_done(i64)");

    // Issue 8, 9 fix: Belief guard intrinsics
    emit_line(cg, "; Belief guard intrinsics");
    emit_line(cg, "declare i64 @belief_guard_get_confidence(i64)");
    emit_line(cg, "declare i64 @belief_guard_get_derivative(i64)");
    emit_line(cg, "declare i64 @belief_register(i64, double)");
    emit_line(cg, "declare void @belief_update(i64, double)");
    emit_line(cg, "declare double @belief_get_value(i64)");

    // Async runtime
    emit_line(cg, "declare i64 @future_poll(i64)");
    emit_line(cg, "declare i64 @future_ready(i64)");
    emit_line(cg, "declare i64 @future_pending()");
    emit_line(cg, "declare void @executor_run(i64)");
    emit_line(cg, "declare i64 @executor_spawn(i64)");

    // Async combinators
    emit_line(cg, "declare i64 @async_join(i64, i64)");
    emit_line(cg, "declare i64 @join_result1(i64)");
    emit_line(cg, "declare i64 @join_result2(i64)");
    emit_line(cg, "declare i64 @async_select(i64, i64)");
    emit_line(cg, "declare i64 @select_result(i64)");
    emit_line(cg, "declare i64 @select_which(i64)");
    emit_line(cg, "declare i64 @async_timeout(i64, i64)");
    emit_line(cg, "declare i64 @timeout_result(i64)");
    emit_line(cg, "declare i64 @timeout_expired(i64)");
    emit_line(cg, "declare i64 @time_now_ms()");

    // Pin<T>
    emit_line(cg, "declare i64 @pin_new(i64, i64)");
    emit_line(cg, "declare i64 @pin_new_uninit(i64)");
    emit_line(cg, "declare i64 @pin_get(i64)");
    emit_line(cg, "declare i64 @pin_get_mut(i64)");
    emit_line(cg, "declare i64 @pin_is_pinned(i64)");
    emit_line(cg, "declare void @pin_ref(i64)");
    emit_line(cg, "declare void @pin_unref(i64)");
    emit_line(cg, "declare void @pin_set_self_ref(i64, i64)");
    emit_line(cg, "declare i64 @pin_check_self_ref(i64, i64)");

    // Function pointer calls
    emit_line(cg, "declare i64 @intrinsic_call0(i64)");
    emit_line(cg, "declare i64 @intrinsic_call1(i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call2(i64, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call3(i64, i64, i64, i64)");

    // Structured concurrency
    emit_line(cg, "declare i64 @scope_new()");
    emit_line(cg, "declare i64 @scope_spawn(i64, i64)");
    emit_line(cg, "declare i64 @scope_poll(i64)");
    emit_line(cg, "declare i64 @scope_join(i64)");
    emit_line(cg, "declare i64 @scope_get_result(i64, i64)");
    emit_line(cg, "declare void @scope_cancel(i64)");
    emit_line(cg, "declare i64 @scope_count(i64)");
    emit_line(cg, "declare i64 @scope_completed(i64)");
    emit_line(cg, "declare void @scope_free(i64)");
    emit_line(cg, "declare i64 @nursery_run(i64, i64)");

    // Phase 23.4: Actor Error Handling
    emit_line(cg, "declare i64 @actor_get_status(i64)");
    emit_line(cg, "declare i64 @actor_get_exit_reason(i64)");
    emit_line(cg, "declare i64 @actor_get_error_code(i64)");
    emit_line(cg, "declare void @actor_set_error(i64, i64, i64)");
    emit_line(cg, "declare void @actor_stop(i64)");
    emit_line(cg, "declare void @actor_kill(i64)");
    emit_line(cg, "declare void @actor_crash(i64, i64, i64)");
    emit_line(cg, "declare void @actor_set_on_error(i64, i64)");
    emit_line(cg, "declare void @actor_set_on_exit(i64, i64)");
    emit_line(cg, "declare void @actor_set_supervisor(i64, i64)");
    emit_line(cg, "declare i64 @actor_get_supervisor(i64)");
    emit_line(cg, "declare i64 @actor_get_restart_count(i64)");
    emit_line(cg, "declare void @actor_increment_restart(i64)");
    emit_line(cg, "declare i64 @actor_is_alive(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @circuit_breaker_allow(i64)");
    emit_line(cg, "declare void @circuit_breaker_success(i64)");
    emit_line(cg, "declare void @circuit_breaker_failure(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_state(i64)");
    emit_line(cg, "declare void @circuit_breaker_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_new(i64, i64, i64, i64)");
    emit_line(cg, "declare void @retry_policy_set_jitter(i64, i64)");
    emit_line(cg, "declare i64 @retry_policy_should_retry(i64)");
    emit_line(cg, "declare i64 @retry_policy_next_delay(i64)");
    emit_line(cg, "declare void @retry_policy_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_count(i64)");

    // Phase 23.5: Actor Linking and Monitoring
    emit_line(cg, "declare i64 @actor_link(i64, i64)");
    emit_line(cg, "declare void @actor_unlink(i64, i64)");
    emit_line(cg, "declare i64 @actor_monitor(i64, i64)");
    emit_line(cg, "declare void @actor_demonitor(i64)");
    emit_line(cg, "declare void @actor_propagate_exit(i64, i64)");
    emit_line(cg, "declare i64 @actor_is_linked(i64, i64)");
    emit_line(cg, "declare i64 @actor_spawn_link(i64, i64, i64)");
    emit_line(cg, "declare i64 @actor_get_links_count(i64)");
    emit_line(cg, "declare i64 @actor_send_down(i64, i64, i64)");

    // Phase 23.1: Supervision Trees
    emit_line(cg, "; Phase 23.1: Supervision Trees");
    emit_line(cg, "declare i64 @supervisor_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_add_child(i64, i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_start(i64)");
    emit_line(cg, "declare void @supervisor_stop(i64)");
    emit_line(cg, "declare i64 @supervisor_handle_exit(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_count(i64)");
    emit_line(cg, "declare i64 @supervisor_child_status(i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_handle(i64, i64)");
    emit_line(cg, "declare void @supervisor_free(i64)");
    emit_line(cg, "declare i64 @strategy_one_for_one()");
    emit_line(cg, "declare i64 @strategy_one_for_all()");
    emit_line(cg, "declare i64 @strategy_rest_for_one()");
    emit_line(cg, "declare i64 @child_permanent()");
    emit_line(cg, "declare i64 @child_temporary()");
    emit_line(cg, "declare i64 @child_transient()");

    // Phase 23.2: Work-Stealing Scheduler
    emit_line(cg, "; Phase 23.2: Work-Stealing Scheduler");
    emit_line(cg, "declare i64 @scheduler_new(i64)");
    emit_line(cg, "declare i64 @scheduler_start(i64)");
    emit_line(cg, "declare i64 @scheduler_submit(i64, i64, i64)");
    emit_line(cg, "declare i64 @scheduler_submit_local(i64, i64, i64, i64)");
    emit_line(cg, "declare void @scheduler_stop(i64)");
    emit_line(cg, "declare void @scheduler_free(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_count(i64)");
    emit_line(cg, "declare i64 @scheduler_queue_size(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_idle(i64, i64)");

    // Phase 23.3: Lock-Free Mailbox
    emit_line(cg, "; Phase 23.3: Lock-Free Mailbox");
    emit_line(cg, "declare i64 @mailbox_new(i64)");
    emit_line(cg, "declare i64 @mailbox_send(i64, i64)");
    emit_line(cg, "declare i64 @mailbox_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_try_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_size(i64)");
    emit_line(cg, "declare i64 @mailbox_empty(i64)");
    emit_line(cg, "declare i64 @mailbox_full(i64)");
    emit_line(cg, "declare void @mailbox_close(i64)");
    emit_line(cg, "declare i64 @mailbox_is_closed(i64)");
    emit_line(cg, "declare void @mailbox_free(i64)");

    // Phase 23.6: Actor Discovery and Registry
    emit_line(cg, "; Phase 23.6: Actor Discovery and Registry");
    emit_line(cg, "declare i64 @registry_register(i64, i64)");
    emit_line(cg, "declare void @registry_unregister(i64)");
    emit_line(cg, "declare i64 @registry_lookup(i64)");
    emit_line(cg, "declare i64 @registry_count()");
    emit_line(cg, "declare i64 @registry_set_metadata(i64, i64)");
    emit_line(cg, "declare i64 @registry_get_metadata(i64)");

    // Phase 23.7: Backpressure and Flow Control
    emit_line(cg, "; Phase 23.7: Backpressure and Flow Control");
    emit_line(cg, "declare i64 @flow_controller_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @flow_check(i64)");
    emit_line(cg, "declare i64 @flow_acquire(i64)");
    emit_line(cg, "declare void @flow_release(i64)");
    emit_line(cg, "declare i64 @flow_is_signaling(i64)");
    emit_line(cg, "declare i64 @flow_current(i64)");
    emit_line(cg, "declare i64 @flow_high_watermark(i64)");
    emit_line(cg, "declare i64 @flow_low_watermark(i64)");
    emit_line(cg, "declare void @flow_reset(i64)");
    emit_line(cg, "declare void @flow_free(i64)");
    emit_line(cg, "declare i64 @flow_mode_drop()");
    emit_line(cg, "declare i64 @flow_mode_block()");
    emit_line(cg, "declare i64 @flow_mode_signal()");
    emit_line(cg, "declare void @intrinsic_exit(i64)");

    // Phase 1 Stdlib: Option<T>
    emit_line(cg, "; Phase 1 Stdlib: Option");
    emit_line(cg, "declare ptr @\"option_some\"(i64)");
    emit_line(cg, "declare ptr @\"option_none\"()");
    emit_line(cg, "declare i8 @\"option_is_some\"(i64)");
    emit_line(cg, "declare i8 @\"option_is_none\"(i64)");
    emit_line(cg, "declare i64 @\"option_unwrap\"(i64)");
    emit_line(cg, "declare i64 @\"option_expect\"(i64, i64)");
    emit_line(cg, "declare i64 @\"option_unwrap_or\"(i64, i64)");
    emit_line(cg, "declare i64 @\"option_map\"(i64, i64)");

    // Phase 1 Stdlib: Result<T, E>
    emit_line(cg, "; Phase 1 Stdlib: Result");
    emit_line(cg, "declare ptr @\"result_ok\"(i64)");
    emit_line(cg, "declare ptr @\"result_err\"(i64)");
    emit_line(cg, "declare i8 @\"result_is_ok\"(i64)");
    emit_line(cg, "declare i8 @\"result_is_err\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap_err\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap_or\"(i64, i64)");
    emit_line(cg, "declare i64 @\"result_ok_or\"(i64, i64)");

    // Phase 1 Stdlib: Vec extensions
    // Use emit_stdlib_decl to skip declarations for user-defined functions (fixes vec_set redefinition bug)
    emit_line(cg, "; Phase 1 Stdlib: Vec extensions");
    emit_stdlib_decl(cg, "vec_sum", "declare i64 @\"vec_sum\"(i64)");
    emit_stdlib_decl(cg, "vec_find", "declare i64 @\"vec_find\"(i64, i64)");
    emit_stdlib_decl(cg, "vec_contains", "declare i8 @\"vec_contains\"(i64, i64)");
    emit_stdlib_decl(cg, "vec_reverse", "declare i64 @\"vec_reverse\"(i64)");
    emit_stdlib_decl(cg, "vec_clone", "declare i64 @\"vec_clone\"(i64)");
    emit_stdlib_decl(cg, "vec_first", "declare i64 @\"vec_first\"(i64)");
    emit_stdlib_decl(cg, "vec_last", "declare i64 @\"vec_last\"(i64)");
    emit_stdlib_decl(cg, "vec_pop", "declare i64 @\"vec_pop\"(i64)");
    emit_stdlib_decl(cg, "vec_set", "declare void @\"vec_set\"(i64, i64, i64)");
    emit_stdlib_decl(cg, "vec_clear", "declare void @\"vec_clear\"(i64)");
    emit_stdlib_decl(cg, "vec_remove", "declare void @\"vec_remove\"(i64, i64)");

    // Phase 1 Stdlib: HashMap (string keys)
    emit_line(cg, "; Phase 1 Stdlib: HashMap");
    emit_line(cg, "declare i64 @\"hashmap_new\"()");
    emit_line(cg, "declare i64 @\"hashmap_insert\"(i64, i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_get\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_remove\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashmap_contains\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_len\"(i64)");
    emit_line(cg, "declare void @\"hashmap_clear\"(i64)");
    emit_line(cg, "declare i64 @\"hashmap_keys\"(i64)");
    emit_line(cg, "declare i64 @\"hashmap_values\"(i64)");

    // Phase 1 Stdlib: HashSet (string values)
    emit_line(cg, "; Phase 1 Stdlib: HashSet");
    emit_line(cg, "declare i64 @\"hashset_new\"()");
    emit_line(cg, "declare i8 @\"hashset_insert\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashset_remove\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashset_contains\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashset_len\"(i64)");
    emit_line(cg, "declare void @\"hashset_clear\"(i64)");

    // Phase 1 Stdlib: JSON
    emit_line(cg, "; Phase 1 Stdlib: JSON");
    emit_line(cg, "declare i64 @\"json_parse_simple\"(i64)");
    emit_line(cg, "declare i64 @\"json_stringify\"(i64)");
    emit_line(cg, "declare i64 @\"json_get_sx\"(i64, i64)");
    emit_line(cg, "declare i64 @\"json_keys\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_string\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_object\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_array\"(i64)");
    emit_line(cg, "declare i64 @\"json_as_string\"(i64)");
    emit_line(cg, "declare i64 @\"json_as_array\"(i64)");
    emit_line(cg, "declare i64 @\"json_object_new\"()");
    emit_line(cg, "declare i64 @\"json_array_new\"()");
    emit_line(cg, "declare void @\"json_object_set\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"json_array_push\"(i64, i64)");
    emit_line(cg, "declare i64 @\"json_string\"(i64)");
    emit_line(cg, "declare i64 @\"json_string_sx\"(i64)");
    emit_line(cg, "declare i64 @\"json_array_len\"(i64)");
    emit_line(cg, "declare i64 @\"json_object_len\"(i64)");
    emit_line(cg, "declare i64 @\"json_as_i64\"(i64)");
    emit_line(cg, "declare i64 @\"json_get_index\"(i64, i64)");
    emit_line(cg, "declare i8 @\"json_is_null\"(i64)");
    emit_line(cg, "declare i64 @\"json_object_key_at\"(i64, i64)");
    emit_line(cg, "declare i64 @\"json_object_value_at\"(i64, i64)");
    emit_line(cg, "declare void @\"json_object_set_sx\"(i64, i64, i64)");

    // Phase 3: HTTP Client/Server API
    emit_line(cg, "; Phase 3: HTTP Client/Server");
    emit_line(cg, "declare i64 @\"http_request_new\"(i64, i64)");
    emit_line(cg, "declare void @\"http_request_header\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"http_request_body\"(i64, i64)");
    emit_line(cg, "declare i64 @\"http_request_send\"(i64)");
    emit_line(cg, "declare void @\"http_request_free\"(i64)");
    emit_line(cg, "declare i64 @\"http_response_status\"(i64)");
    emit_line(cg, "declare i64 @\"http_response_body\"(i64)");
    emit_line(cg, "declare i64 @\"http_response_header\"(i64, i64)");
    emit_line(cg, "declare void @\"http_response_free\"(i64)");
    emit_line(cg, "declare i64 @\"http_server_new\"(i64)");
    emit_line(cg, "declare void @\"http_server_route\"(i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @\"http_server_start\"(i64)");
    emit_line(cg, "declare void @\"http_server_stop\"(i64)");
    emit_line(cg, "declare void @\"http_server_free\"(i64)");

    // Phase 3: SQL Database API
    emit_line(cg, "; Phase 3: SQL Database");
    emit_line(cg, "declare i64 @\"sql_open\"(i64)");
    emit_line(cg, "declare void @\"sql_close\"(i64)");
    emit_line(cg, "declare i64 @\"sql_exec\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_query\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_prepare\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_bind_int\"(i64, i64, i64)");
    emit_line(cg, "declare i64 @\"sql_bind_text\"(i64, i64, i64)");
    emit_line(cg, "declare i64 @\"sql_bind_float\"(i64, i64, double)");
    emit_line(cg, "declare i64 @\"sql_bind_null\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_bind_blob\"(i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @\"sql_step\"(i64)");
    emit_line(cg, "declare i64 @\"sql_column_int\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_column_text\"(i64, i64)");
    emit_line(cg, "declare double @\"sql_column_float\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_column_blob\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_column_blob_len\"(i64, i64)");
    emit_line(cg, "declare i64 @\"sql_column_is_null\"(i64, i64)");
    emit_line(cg, "declare void @\"sql_finalize\"(i64)");
    emit_line(cg, "declare i64 @\"sql_begin\"(i64)");
    emit_line(cg, "declare i64 @\"sql_commit\"(i64)");
    emit_line(cg, "declare i64 @\"sql_rollback\"(i64)");
    emit_line(cg, "declare i64 @\"sql_last_insert_id\"(i64)");

    // Phase 3: UUID API
    emit_line(cg, "; Phase 3: UUID");
    emit_line(cg, "declare i64 @\"uuid_v4\"()");
    emit_line(cg, "declare i64 @\"uuid_nil\"()");
    emit_line(cg, "declare i64 @\"uuid_is_nil\"(i64)");
    emit_line(cg, "declare i64 @\"uuid_is_valid\"(i64)");

    // Phase 3: TOML API
    emit_line(cg, "; Phase 3: TOML");
    emit_line(cg, "declare i64 @\"toml_parse\"(i64)");
    emit_line(cg, "declare i64 @\"toml_get\"(i64, i64)");
    emit_line(cg, "declare i64 @\"toml_get_string\"(i64, i64)");
    emit_line(cg, "declare i64 @\"toml_get_int\"(i64, i64)");
    emit_line(cg, "declare double @\"toml_get_float\"(i64, i64)");
    emit_line(cg, "declare i64 @\"toml_get_bool\"(i64, i64)");
    emit_line(cg, "declare i64 @\"toml_get_array\"(i64, i64)");
    emit_line(cg, "declare i64 @\"toml_get_table\"(i64, i64)");
    emit_line(cg, "declare void @\"toml_set_string\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"toml_set_int\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"toml_set_float\"(i64, i64, double)");
    emit_line(cg, "declare void @\"toml_set_bool\"(i64, i64, i64)");
    emit_line(cg, "declare i64 @\"toml_stringify\"(i64)");
    emit_line(cg, "declare i64 @\"toml_table_new\"()");
    emit_line(cg, "declare void @\"toml_free\"(i64)");

    // Phase G: AI Features
    emit_line(cg, "; Phase G: AI Features");
    emit_line(cg, "declare i64 @model_infer(i64)");
    emit_line(cg, "declare i64 @model_load(i64)");
    emit_line(cg, "declare i64 @model_embed(i64, i64)");
    emit_line(cg, "declare i64 @model_classify(i64, i64)");
    emit_line(cg, "declare void @model_unload(i64)");

    // Vector operations for AI
    emit_line(cg, "; AI Vector Operations");
    emit_line(cg, "declare i64 @vector_new(i64, i64)");
    emit_line(cg, "declare i64 @vector_len(i64)");
    emit_line(cg, "declare double @vector_get(i64, i64)");
    emit_line(cg, "declare void @vector_set(i64, i64, double)");
    emit_line(cg, "declare double @vector_dot(i64, i64)");
    emit_line(cg, "declare i64 @vector_add(i64, i64)");
    emit_line(cg, "declare i64 @vector_sub(i64, i64)");
    emit_line(cg, "declare i64 @vector_scale(i64, double)");
    emit_line(cg, "declare double @vector_norm(i64)");
    emit_line(cg, "declare i64 @vector_normalize(i64)");
    emit_line(cg, "declare double @vector_cosine_similarity(i64, i64)");

    // Tensor operations for AI
    emit_line(cg, "; AI Tensor Operations");
    emit_line(cg, "declare i64 @tensor_new(i64, i64)");
    emit_line(cg, "declare i64 @tensor_shape(i64)");
    emit_line(cg, "declare i64 @tensor_rank(i64)");
    emit_line(cg, "declare double @tensor_get(i64, i64)");
    emit_line(cg, "declare void @tensor_set(i64, i64, double)");
    emit_line(cg, "declare i64 @tensor_matmul(i64, i64)");
    emit_line(cg, "declare i64 @tensor_add(i64, i64)");
    emit_line(cg, "declare i64 @tensor_transpose(i64)");
    emit_line(cg, "declare i64 @tensor_reshape(i64, i64)");

    // Specialist operations
    emit_line(cg, "; Specialist Operations");
    emit_line(cg, "declare i64 @specialist_query(i64, i64)");
    emit_line(cg, "declare i64 @specialist_stream(i64, i64)");
    emit_line(cg, "declare void @specialist_set_context(i64, i64)");
    emit_line(cg, "declare i64 @specialist_get_context(i64)");

    // Hive operations
    emit_line(cg, "; Hive Operations");
    emit_line(cg, "declare i64 @hive_route(i64, i64)");
    emit_line(cg, "declare void @hive_add_specialist(i64, i64)");
    emit_line(cg, "declare void @hive_remove_specialist(i64, i64)");
    emit_line(cg, "declare i64 @hive_consensus(i64, i64)");

    emit_line(cg, "");
    0
}

// Emit a string constant in LLVM format
fn emit_string_constant(cg: i64, idx: i64, value: i64) -> i64 {
    // For simplicity, just emit the string with basic escaping
    // Format: @.str.MODULE.N = private unnamed_addr constant [LEN x i8] c"STRING\00"
    let len: i64 = string_len(value);

    emit(cg, "@.str.");
    emit(cg, cg_module_name(cg));
    emit(cg, ".");
    emit(cg, int_to_string(idx));
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(len + 1));  // +1 for null terminator
    emit(cg, " x i8] c\"");

    // Emit string with escaping
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(value, i);
        if c == 10 {
            // newline -> \0A
            emit(cg, "\\0A");
        } else {
            if c == 9 {
                // tab -> \09
                emit(cg, "\\09");
            } else {
                if c == 34 {
                    // quote -> \22
                    emit(cg, "\\22");
                } else {
                    if c == 92 {
                        // backslash -> \5C
                        emit(cg, "\\5C");
                    } else {
                        // Regular character
                        emit(cg, string_slice(value, i, i + 1));
                    }
                }
            }
        }
        i = i + 1;
    }

    emit_line(cg, "\\00\"");
    0
}

// Generate entire program with module name for unique string prefixes
fn gen_program_with_module(items: i64, module_name: i64) -> i64 {
    let cg: i64 = codegen_new();
    cg_set_module_name(cg, module_name);
    register_builtin_enums(cg);  // Phase 36: Pre-register Option and Result

    // Pre-pass: collect all user-defined function names to prevent stdlib declaration conflicts
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            let fn_name: i64 = load_ptr(item, 1);
            cg_add_defined_fn(cg, fn_name);
        }
        i = i + 1;
    }

    gen_header(cg);

    // First pass: register enums and structs
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        if tag == TAG_STRUCT() {
            gen_struct(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions, impl blocks, and trait impls
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        if tag == TAG_IMPL() {
            gen_impl(cg, item);
        }
        if tag == TAG_IMPL_TRAIT() {
            gen_impl_trait(cg, item);
        }
        // Note: TAG_TRAIT() doesn't generate code (trait definitions are just declarations)
        i = i + 1;
    }

    // Third pass: generate pending generic instantiations
    // Loop until no more pending (instantiation might queue more)
    let pending: i64 = cg_pending_instantiations(cg);
    let processed: i64 = 0;
    while processed < vec_len(pending) {
        let entry: i64 = vec_get(pending, processed);
        let mangled_name: i64 = load_ptr(entry, 0);
        let fn_def: i64 = load_ptr(entry, 1);
        let type_args: i64 = load_ptr(entry, 2);
        gen_fn_instantiation(cg, fn_def, mangled_name, type_args);
        processed = processed + 1;
    }

    // Emit string constants
    let strings: i64 = cg_strings(cg);
    let str_count: i64 = vec_len(strings);
    if str_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; String constants");
        i = 0;
        while i < str_count {
            let value: i64 = vec_get(strings, i);
            emit_string_constant(cg, i, value);
            i = i + 1;
        }
    }

    // Convert StringBuilder to String for final output
    sb_to_string(cg_output(cg))
}

// Backward-compatible wrapper using default module name
fn gen_program(items: i64) -> i64 {
    gen_program_with_module(items, string_from("mod"))
}

// Generate program with DWARF debug info
// filename: source file name (e.g., "main.sx")
// directory: source directory (e.g., "/path/to")
fn gen_program_with_debug(items: i64, module_name: i64, filename: i64, directory: i64) -> i64 {
    let cg: i64 = codegen_new();
    cg_set_module_name(cg, module_name);
    cg_set_debug_enabled(cg, 1);
    cg_set_debug_file(cg, filename);
    cg_set_debug_dir(cg, directory);
    register_builtin_enums(cg);

    // Pre-pass: collect all user-defined function names
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            let fn_name: i64 = load_ptr(item, 1);
            cg_add_defined_fn(cg, fn_name);
            // Register subprogram for debug info (line 1 as placeholder)
            cg_register_subprogram(cg, fn_name, 1);
        }
        i = i + 1;
    }

    gen_header(cg);

    // First pass: register enums and structs
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        if tag == TAG_STRUCT() {
            gen_struct(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions with debug info
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        if tag == TAG_IMPL() {
            gen_impl(cg, item);
        }
        if tag == TAG_IMPL_TRAIT() {
            gen_impl_trait(cg, item);
        }
        i = i + 1;
    }

    // Third pass: generate pending generic instantiations
    let pending: i64 = cg_pending_instantiations(cg);
    let processed: i64 = 0;
    while processed < vec_len(pending) {
        let entry: i64 = vec_get(pending, processed);
        let mangled_name: i64 = load_ptr(entry, 0);
        let fn_def: i64 = load_ptr(entry, 1);
        let type_args: i64 = load_ptr(entry, 2);
        gen_fn_instantiation(cg, fn_def, mangled_name, type_args);
        processed = processed + 1;
    }

    // Emit string constants
    let strings: i64 = cg_strings(cg);
    let str_count: i64 = vec_len(strings);
    if str_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; String constants");
        i = 0;
        while i < str_count {
            let value: i64 = vec_get(strings, i);
            emit_string_constant(cg, i, value);
            i = i + 1;
        }
    }

    // Emit debug info metadata footer
    gen_debug_info_footer(cg);

    // Convert StringBuilder to String for final output
    sb_to_string(cg_output(cg))
}

// Generate DWARF debug info metadata footer
fn gen_debug_info_footer(cg: i64) -> i64 {
    if cg_debug_enabled(cg) == 0 {
        return 0;
    }

    emit_line(cg, "");
    emit_line(cg, "; DWARF Debug Info");
    emit_line(cg, "!llvm.dbg.cu = !{!0}");
    emit_line(cg, "!llvm.module.flags = !{!1, !2}");
    emit_line(cg, "!llvm.ident = !{!3}");
    emit_line(cg, "");

    // !0 = DICompileUnit
    emit(cg, "!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !4, producer: \"sxc ");
    emit(cg, "0.10.0");
    emit_line(cg, "\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !5)");

    // !1 = Module flag for DWARF Version
    emit_line(cg, "!1 = !{i32 7, !\"Dwarf Version\", i32 4}");

    // !2 = Module flag for Debug Info Version
    emit_line(cg, "!2 = !{i32 2, !\"Debug Info Version\", i32 3}");

    // !3 = llvm.ident
    emit_line(cg, "!3 = !{!\"Simplex Compiler 0.10.0\"}");

    // !4 = DIFile
    emit(cg, "!4 = !DIFile(filename: \"");
    emit(cg, cg_debug_file(cg));
    emit(cg, "\", directory: \"");
    emit(cg, cg_debug_dir(cg));
    emit_line(cg, "\")");

    // !5 = Empty tuple for enums
    emit_line(cg, "!5 = !{}");

    // !6 = DIBasicType for i64 (used for all types in bootstrap compiler)
    emit_line(cg, "!6 = !DIBasicType(name: \"i64\", size: 64, encoding: DW_ATE_signed)");

    // !7 = DISubroutineType (void function type)
    emit_line(cg, "!7 = !DISubroutineType(types: !8)");
    emit_line(cg, "!8 = !{null}");

    // !9 = DISubroutineType (function returning i64)
    emit_line(cg, "!9 = !DISubroutineType(types: !10)");
    emit_line(cg, "!10 = !{!6}");

    // Generate DISubprogram entries for each function
    let subprograms: i64 = cg_debug_subprograms(cg);
    let n: i64 = vec_len(subprograms);
    let i: i64 = 0;
    let metadata_base: i64 = 11;  // Start DISubprogram metadata at !11

    while i < n {
        let entry: i64 = vec_get(subprograms, i);
        let fn_name: i64 = load_ptr(entry, 0);
        let line: i64 = load_i64(entry, 2);

        emit(cg, "!");
        emit(cg, int_to_string(metadata_base + i));
        emit(cg, " = distinct !DISubprogram(name: \"");
        emit(cg, fn_name);
        emit(cg, "\", scope: !4, file: !4, line: ");
        emit(cg, int_to_string(line));
        emit(cg, ", type: !9, isLocal: false, isDefinition: true, scopeLine: ");
        emit(cg, int_to_string(line));
        emit_line(cg, ", isOptimized: false, unit: !0, retainedNodes: !5)");

        i = i + 1;
    }

    0
}

// Helper functions for intrinsic emission with type conversions
// These handle the i64 <-> ptr conversions needed at boundaries

// Helper: convert i64 to ptr using inttoptr
fn emit_i64_to_ptr(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = inttoptr i64 ");
    emit(cg, val);
    emit_line(cg, " to ptr");
    temp
}

// Helper: convert ptr to i64 using ptrtoint
fn emit_ptr_to_i64(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = ptrtoint ptr ");
    emit(cg, val);
    emit_line(cg, " to i64");
    temp
}

// void intrinsic(ptr)
fn emit_intrinsic_void_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, ptr)
fn emit_intrinsic_void_ptr2(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr)
fn emit_intrinsic_i64_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, i64)
fn emit_intrinsic_i64_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i1 intrinsic(ptr, ptr) -> zext to i64
fn emit_intrinsic_i1_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i1 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    // zext i1 to i64
    let t2: i64 = cg_next_temp(cg);
    let temp2: i64 = string_concat("%t", int_to_string(t2));
    emit(cg, "  ");
    emit(cg, temp2);
    emit(cg, " = zext i1 ");
    emit(cg, temp);
    emit_line(cg, " to i64");
    temp2
}

// ptr intrinsic(ptr, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic() -> ptrtoint to i64
fn emit_intrinsic_ptr_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit_line(cg, "()");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// i64 intrinsic() - no args, returns i64
fn emit_intrinsic_i64_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit_line(cg, "()");
    temp
}

// void intrinsic() - no args, no return
fn emit_intrinsic_void_void(cg: i64, name: i64) -> i64 {
    emit(cg, "  call void @");
    emit(cg, name);
    emit_line(cg, "()");
    0
}

// void intrinsic(i64) - i64 arg, no return
fn emit_intrinsic_void_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, i64) - ptr arg and i64 arg, no return
fn emit_intrinsic_void_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr, ptr) - two ptr args, returns i64
fn emit_intrinsic_i64_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, ptr, i64) - two ptr args and one i64, returns i64
fn emit_intrinsic_i64_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    temp
}

// ptr intrinsic(ptr, ptr, ptr) - three ptr args, returns ptr
fn emit_intrinsic_ptr_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ============================================================================
// Phase 1 Stdlib call helpers - emit calls with i64 args directly
// ============================================================================

// i64 call(i64) - one i64 arg, returns i64
fn emit_call_i64_1arg(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    temp
}

// i64 call(i64, i64) - two i64 args, returns i64
fn emit_call_i64_2args(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i64 call(i64, i64, i64) - three i64 args, returns i64
fn emit_call_i64_3args(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    temp
}

// void call(i64) - one i64 arg, no return
fn emit_call_void_1arg(cg: i64, name: i64, arg1: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    0
}

// void call(i64, i64) - two i64 args, no return
fn emit_call_void_2args(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    0
}

// void call(i64, i64, i64) - three i64 args, no return
fn emit_call_void_3args(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, i64, ptr) - for vec_set(vec, index, item)
fn emit_intrinsic_void_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    0
}
