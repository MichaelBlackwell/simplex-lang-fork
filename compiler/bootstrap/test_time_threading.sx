// Test Time and Threading Intrinsics

// ============ TIME FUNCTIONS ============

// Test get_time_ms returns a reasonable value
fn test_get_time_ms() -> i64 {
    let t = get_time_ms();
    // Time should be positive (milliseconds since epoch)
    if t > 0 {
        1
    } else {
        0
    }
}

// Test get_time_us returns a reasonable value
fn test_get_time_us() -> i64 {
    let t = get_time_us();
    // Time should be positive (microseconds since epoch)
    if t > 0 {
        1
    } else {
        0
    }
}

// Test that microseconds > milliseconds * 1000 (approximately)
fn test_time_relation() -> i64 {
    let ms = get_time_ms();
    let us = get_time_us();
    // us should be roughly ms * 1000 (within some tolerance)
    let expected_us = ms * 1000;
    let diff = us - expected_us;
    // Allow 1 second tolerance (1000000 us)
    if diff > -1000000 && diff < 1000000 {
        1
    } else {
        0
    }
}

// Test sleep_ms actually delays
fn test_sleep_ms() -> i64 {
    let before = get_time_ms();
    sleep_ms(50);  // Sleep 50ms
    let after = get_time_ms();
    let elapsed = after - before;
    // Should have elapsed at least 40ms (allowing some tolerance)
    if elapsed >= 40 {
        1
    } else {
        0
    }
}

// Test multiple sleeps accumulate
fn test_multiple_sleeps() -> i64 {
    let before = get_time_ms();
    sleep_ms(20);
    sleep_ms(20);
    sleep_ms(20);
    let after = get_time_ms();
    let elapsed = after - before;
    // Should have elapsed at least 50ms
    if elapsed >= 50 {
        1
    } else {
        0
    }
}

// ============ MUTEX FUNCTIONS ============

// Test mutex_new creates a valid mutex
fn test_mutex_new() -> i64 {
    let m = mutex_new();
    if m != 0 {
        mutex_free(m);
        1
    } else {
        0
    }
}

// Test mutex lock and unlock
fn test_mutex_lock_unlock() -> i64 {
    let m = mutex_new();
    mutex_lock(m);
    // If we get here, lock succeeded
    mutex_unlock(m);
    mutex_free(m);
    1
}

// Test mutex can be locked multiple times (by same thread after unlock)
fn test_mutex_relock() -> i64 {
    let m = mutex_new();
    mutex_lock(m);
    mutex_unlock(m);
    mutex_lock(m);
    mutex_unlock(m);
    mutex_free(m);
    1
}

// Test multiple mutexes
fn test_multiple_mutexes() -> i64 {
    let m1 = mutex_new();
    let m2 = mutex_new();

    mutex_lock(m1);
    mutex_lock(m2);

    // Both locked, now unlock
    mutex_unlock(m2);
    mutex_unlock(m1);

    mutex_free(m1);
    mutex_free(m2);

    if m1 != m2 {
        1
    } else {
        0
    }
}

// ============ ATOMIC FUNCTIONS ============
// Note: Atomic functions require heap-allocated memory (pointers)

// Test atomic_store and atomic_load
fn test_atomic_store_load() -> i64 {
    let ptr = malloc(8);  // Allocate 8 bytes for i64
    atomic_store(ptr, 42);
    let loaded = atomic_load(ptr);
    if loaded == 42 {
        1
    } else {
        0
    }
}

// Test atomic_add
fn test_atomic_add() -> i64 {
    let ptr = malloc(8);
    atomic_store(ptr, 10);
    let old = atomic_add(ptr, 5);
    let new_val = atomic_load(ptr);
    // old should be 10, new should be 15
    if old == 10 && new_val == 15 {
        1
    } else {
        0
    }
}

// Test atomic_sub
fn test_atomic_sub() -> i64 {
    let ptr = malloc(8);
    atomic_store(ptr, 20);
    let old = atomic_sub(ptr, 7);
    let new_val = atomic_load(ptr);
    // old should be 20, new should be 13
    if old == 20 && new_val == 13 {
        1
    } else {
        0
    }
}

// Test atomic_add multiple times
fn test_atomic_add_multiple() -> i64 {
    let ptr = malloc(8);
    atomic_store(ptr, 0);
    atomic_add(ptr, 10);
    atomic_add(ptr, 20);
    atomic_add(ptr, 30);
    let result = atomic_load(ptr);
    if result == 60 {
        1
    } else {
        0
    }
}

// Test atomic_cas (compare and swap) - success case
fn test_atomic_cas_success() -> i64 {
    let ptr = malloc(8);
    atomic_store(ptr, 100);
    // CAS: if value == 100, set to 200
    let success = atomic_cas(ptr, 100, 200);
    let result = atomic_load(ptr);
    if success == 1 && result == 200 {
        1
    } else {
        0
    }
}

// Test atomic_cas - failure case
fn test_atomic_cas_fail() -> i64 {
    let ptr = malloc(8);
    atomic_store(ptr, 100);
    // CAS: if value == 50, set to 200 (should fail since value is 100)
    let success = atomic_cas(ptr, 50, 200);
    let result = atomic_load(ptr);
    // Should fail, value unchanged
    if success == 0 && result == 100 {
        1
    } else {
        0
    }
}

// ============ THREAD FUNCTIONS ============

// Test thread_id returns a value
fn test_thread_id() -> i64 {
    let id = thread_id();
    // Thread ID should be non-negative
    if id >= 0 {
        1
    } else {
        0
    }
}

// Test thread_yield doesn't crash
fn test_thread_yield() -> i64 {
    thread_yield();
    thread_yield();
    thread_yield();
    // If we get here, yield worked
    1
}

fn main() -> i64 {
    var passed = 0;
    var total = 17;

    print("=== Time and Threading Tests ===\n\n");

    // Time tests
    print("Testing get_time_ms...\n");
    if test_get_time_ms() == 1 {
        print("get_time_ms: PASS\n");
        passed = passed + 1;
    } else {
        print("get_time_ms: FAIL\n");
    }

    print("\nTesting get_time_us...\n");
    if test_get_time_us() == 1 {
        print("get_time_us: PASS\n");
        passed = passed + 1;
    } else {
        print("get_time_us: FAIL\n");
    }

    print("\nTesting time_relation...\n");
    if test_time_relation() == 1 {
        print("time_relation: PASS\n");
        passed = passed + 1;
    } else {
        print("time_relation: FAIL\n");
    }

    print("\nTesting sleep_ms...\n");
    if test_sleep_ms() == 1 {
        print("sleep_ms: PASS\n");
        passed = passed + 1;
    } else {
        print("sleep_ms: FAIL\n");
    }

    print("\nTesting multiple_sleeps...\n");
    if test_multiple_sleeps() == 1 {
        print("multiple_sleeps: PASS\n");
        passed = passed + 1;
    } else {
        print("multiple_sleeps: FAIL\n");
    }

    // Mutex tests
    print("\nTesting mutex_new...\n");
    if test_mutex_new() == 1 {
        print("mutex_new: PASS\n");
        passed = passed + 1;
    } else {
        print("mutex_new: FAIL\n");
    }

    print("\nTesting mutex_lock_unlock...\n");
    if test_mutex_lock_unlock() == 1 {
        print("mutex_lock_unlock: PASS\n");
        passed = passed + 1;
    } else {
        print("mutex_lock_unlock: FAIL\n");
    }

    print("\nTesting mutex_relock...\n");
    if test_mutex_relock() == 1 {
        print("mutex_relock: PASS\n");
        passed = passed + 1;
    } else {
        print("mutex_relock: FAIL\n");
    }

    print("\nTesting multiple_mutexes...\n");
    if test_multiple_mutexes() == 1 {
        print("multiple_mutexes: PASS\n");
        passed = passed + 1;
    } else {
        print("multiple_mutexes: FAIL\n");
    }

    // Atomic tests
    print("\nTesting atomic_store_load...\n");
    if test_atomic_store_load() == 1 {
        print("atomic_store_load: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_store_load: FAIL\n");
    }

    print("\nTesting atomic_add...\n");
    if test_atomic_add() == 1 {
        print("atomic_add: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_add: FAIL\n");
    }

    print("\nTesting atomic_sub...\n");
    if test_atomic_sub() == 1 {
        print("atomic_sub: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_sub: FAIL\n");
    }

    print("\nTesting atomic_add_multiple...\n");
    if test_atomic_add_multiple() == 1 {
        print("atomic_add_multiple: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_add_multiple: FAIL\n");
    }

    print("\nTesting atomic_cas_success...\n");
    if test_atomic_cas_success() == 1 {
        print("atomic_cas_success: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_cas_success: FAIL\n");
    }

    print("\nTesting atomic_cas_fail...\n");
    if test_atomic_cas_fail() == 1 {
        print("atomic_cas_fail: PASS\n");
        passed = passed + 1;
    } else {
        print("atomic_cas_fail: FAIL\n");
    }

    // Thread tests
    print("\nTesting thread_id...\n");
    if test_thread_id() == 1 {
        print("thread_id: PASS\n");
        passed = passed + 1;
    } else {
        print("thread_id: FAIL\n");
    }

    print("\nTesting thread_yield...\n");
    if test_thread_yield() == 1 {
        print("thread_yield: PASS\n");
        passed = passed + 1;
    } else {
        print("thread_yield: FAIL\n");
    }

    print("\n=== Summary ===\n");
    print("Passed: ");
    print_i64(passed);
    print(" / ");
    print_i64(total);
    print("\n");

    passed
}
