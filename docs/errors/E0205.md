error[E0205]: cannot infer type

This error occurs when the compiler cannot determine the type of an
expression from context and needs an explicit type annotation.

Example of erroneous code:
    fn main() {
        let x = Vec::new();  // error: cannot infer type for `T` in `Vec<T>`
        let none = None;     // error: cannot infer type for `T` in `Option<T>`
    }

    fn default<T: Default>() -> T {
        T::default()
    }

    fn test() {
        let x = default();  // error: cannot infer return type
    }

Common causes:
- Creating empty collections without type context
- Using None without type context
- Generic functions where return type can't be inferred
- Complex generic expressions

To fix this, provide type annotations:

Correct examples:
    fn main() {
        // Annotate the variable type
        let x: Vec<i64> = Vec::new();  // ok
        let none: Option<i64> = None;  // ok

        // Or use turbofish syntax on the function
        let y = Vec::<str>::new();  // ok
        let some = Option::<i64>::None;  // ok
    }

    fn default<T: Default>() -> T {
        T::default()
    }

    fn test() {
        let x: i64 = default();  // ok: type annotation helps inference
        let y = default::<str>(); // ok: turbofish specifies T
    }

Type inference works when there's enough context:
    fn main() {
        let mut v = Vec::new();
        v.push(42);  // Now compiler knows v: Vec<i64>

        let x = if true { 1 } else { 2 };  // x inferred as i64
    }

See also:
- E0200: mismatched types
- E0202: wrong number of type arguments
