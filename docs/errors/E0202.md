error[E0202]: wrong number of type arguments

This error occurs when a generic type or function is instantiated with
the wrong number of type parameters.

Example of erroneous code:
    struct Pair<A, B> {
        first: A,
        second: B,
    }

    fn main() {
        let p: Pair<i64> = ...;        // error: takes 2 type arguments but 1 was supplied
        let q: Pair<i64, str, bool> = ...;  // error: takes 2 but 3 were supplied
    }

    fn identity<T>(x: T) -> T { x }

    fn test() {
        identity::<i64, str>(42);  // error: takes 1 type argument but 2 were supplied
    }

Common causes:
- Forgetting type arguments for generic types
- Providing extra type arguments
- Confusing the number of generics a type has
- Copy-paste errors with generic types

To fix this, match the number of type arguments:

Correct examples:
    struct Pair<A, B> {
        first: A,
        second: B,
    }

    fn main() {
        let p: Pair<i64, str> = Pair { first: 42, second: "hello" };  // ok
    }

    fn identity<T>(x: T) -> T { x }

    fn test() {
        let n = identity::<i64>(42);  // ok: 1 type argument
        // Or let type inference handle it:
        let n = identity(42);  // ok: T inferred as i64
    }

Common generic types and their parameters:
- Option<T>      - 1 type parameter
- Result<T, E>   - 2 type parameters
- Vec<T>         - 1 type parameter
- Map<K, V>      - 2 type parameters

See also:
- E0201: wrong number of arguments
- E0205: cannot infer type
