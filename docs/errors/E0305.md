error[E0305]: self outside of impl block

This error occurs when you use `self` outside of a method in an `impl` block.
The `self` keyword refers to the instance a method is called on.

Example of erroneous code:
    fn standalone() {
        println(self.x);  // error: `self` outside of impl block
    }

    struct Point {
        x: i64,
        y: i64,
    }

    fn move_point(dx: i64) {
        self.x = self.x + dx;  // error: not in an impl block
    }

Common causes:
- Using self in a free function instead of a method
- Forgetting to put the function inside an impl block
- Copying method code outside of its impl block

To fix this, put the function inside an impl block:

Correct examples:
    struct Point {
        x: i64,
        y: i64,
    }

    impl Point {
        fn move_by(self, dx: i64, dy: i64) -> Point {
            Point {
                x: self.x + dx,  // ok: self refers to the Point instance
                y: self.y + dy,
            }
        }

        fn distance(self) -> f64 {
            sqrt((self.x * self.x + self.y * self.y) as f64)
        }
    }

    fn main() {
        let p = Point { x: 3, y: 4 };
        let d = p.distance();  // calls method with p as self
    }

If you need a standalone function that operates on a type,
pass the instance as a parameter:
    fn move_point(p: Point, dx: i64, dy: i64) -> Point {
        Point {
            x: p.x + dx,  // ok: using parameter p, not self
            y: p.y + dy,
        }
    }

Types of self in methods:
- `self` - takes ownership of the instance
- `&self` - borrows the instance immutably
- `&mut self` - borrows the instance mutably

See also:
- E0100: cannot find value in this scope
- E0107: no method found
