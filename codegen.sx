// Simplex Code Generator
// Self-hosted LLVM IR generator supporting:
// - impl blocks, traits, for loops, match expressions
// - generic functions with monomorphization
// - struct literals and field access
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under MIT License - see LICENSE file
// https://github.com/senuamedia/simplex-lang

// AST tags - duplicated from parser.sx for standalone compilation
// Item tags
fn TAG_FN() -> i64 { 0 }
fn TAG_ENUM() -> i64 { 1 }
fn TAG_STRUCT() -> i64 { 2 }
fn TAG_IMPL() -> i64 { 3 }
fn TAG_TRAIT() -> i64 { 4 }
fn TAG_IMPL_TRAIT() -> i64 { 5 }
fn TAG_MOD() -> i64 { 6 }
fn TAG_USE() -> i64 { 7 }
fn TAG_ACTOR() -> i64 { 8 }       // actor definition
fn TAG_SPECIALIST() -> i64 { 9 }  // AI specialist
fn TAG_HIVE() -> i64 { 10 }       // cognitive hive
fn TAG_ANIMA() -> i64 { 11 }         // cognitive soul
fn TAG_TYPE_ALIAS() -> i64 { 12 }    // type alias
fn TAG_NEURAL_GATE() -> i64 { 13 }   // neural gate with differentiable control flow

// Stmt tags
fn STMT_LET() -> i64 { 0 }
fn STMT_EXPR() -> i64 { 1 }
fn STMT_RETURN() -> i64 { 2 }
fn STMT_ASSIGN() -> i64 { 3 }
fn STMT_BREAK() -> i64 { 4 }
fn STMT_CONTINUE() -> i64 { 5 }

// Expr tags
fn EXPR_INT() -> i64 { 0 }
fn EXPR_BOOL() -> i64 { 1 }
fn EXPR_STRING() -> i64 { 2 }
fn EXPR_IDENT() -> i64 { 3 }
fn EXPR_PATH() -> i64 { 4 }
fn EXPR_CALL() -> i64 { 5 }
fn EXPR_BINARY() -> i64 { 6 }
fn EXPR_UNARY() -> i64 { 7 }
fn EXPR_IF() -> i64 { 8 }
fn EXPR_WHILE() -> i64 { 9 }
fn EXPR_BLOCK() -> i64 { 10 }
fn EXPR_STRUCT_LIT() -> i64 { 11 }
fn EXPR_FIELD() -> i64 { 12 }
fn EXPR_FOR() -> i64 { 13 }
fn EXPR_MATCH() -> i64 { 14 }
fn EXPR_METHOD_CALL() -> i64 { 15 }
fn EXPR_TRY() -> i64 { 16 }
fn EXPR_AWAIT() -> i64 { 17 }
fn EXPR_FSTRING() -> i64 { 18 }
fn EXPR_YIELD() -> i64 { 19 }
fn EXPR_SPAWN() -> i64 { 20 }
fn EXPR_ARRAY() -> i64 { 21 }
fn EXPR_FLOAT() -> i64 { 22 }

// Binary operators - must match parser.sx
fn OP_ADD() -> i64 { 0 }
fn OP_SUB() -> i64 { 1 }
fn OP_MUL() -> i64 { 2 }
fn OP_DIV() -> i64 { 3 }
fn OP_EQ() -> i64 { 4 }
fn OP_NE() -> i64 { 5 }
fn OP_LT() -> i64 { 6 }
fn OP_GT() -> i64 { 7 }
fn OP_LE() -> i64 { 8 }
fn OP_GE() -> i64 { 9 }
fn OP_AND() -> i64 { 10 }
fn OP_OR() -> i64 { 11 }
fn OP_MOD() -> i64 { 12 }
fn OP_BITAND() -> i64 { 13 }
fn OP_BITOR() -> i64 { 14 }
fn OP_BITXOR() -> i64 { 15 }
fn OP_SHL() -> i64 { 16 }
fn OP_SHR() -> i64 { 17 }
fn OP_NEG() -> i64 { 100 }
fn OP_NOT() -> i64 { 101 }

// Codegen state
fn codegen_new() -> i64 {
    // Allocate codegen: output_sb(0), temp_counter(1), label_counter(2), enums(3), locals(4), strings(5), terminated(6), structs(7), var_types(8), loop_stack(9), loop_depth(10), pre_alloca_queue(11), module_name(12), generic_fns(13), instantiated(14), pending_instantiations(15), assoc_types(16), current_impl_type(17), const_params(18), type_params(19), generic_struct_templates(20), trait_impls(21), is_async_fn(22), async_state_counter(23), async_await_points(24), async_fn_name(25), default_methods(26), trait_defs(27), vtables(28), type_aliases(29), training_mode(30), neural_gates(31), gate_temperature(32), gate_counter(33)
    // Note: slot 0 is now a StringBuilder for O(n) instead of O(n²) string building
    let cg: i64 = malloc(272);  // Extended for neural gate support
    store_ptr(cg, 0, sb_new_cap(65536));
    store_i64(cg, 1, 0);
    store_i64(cg, 2, 0);
    store_ptr(cg, 3, vec_new());  // registered enums: vec of (name, variants)
    store_ptr(cg, 4, vec_new());  // local variables in current function
    store_ptr(cg, 5, vec_new());  // string constants: vec of string values
    store_i64(cg, 6, 0);          // terminated flag (set after ret)
    store_ptr(cg, 7, vec_new());  // registered structs: vec of (name, fields)
    store_ptr(cg, 8, vec_new());  // variable types: vec of (name, type_name) pairs
    store_ptr(cg, 9, vec_new());  // loop_stack: vec of (continue_label, break_label) pairs
    store_i64(cg, 10, 0);         // loop_depth: current depth in loop stack
    store_ptr(cg, 11, vec_new()); // pre_alloca_queue: pre-allocated local names in order
    store_ptr(cg, 12, string_from("mod")); // module_name: prefix for string constants
    store_ptr(cg, 13, vec_new()); // generic_fns: vec of (name, fn_def) pairs
    store_ptr(cg, 14, vec_new()); // instantiated: vec of mangled names already generated
    store_ptr(cg, 15, vec_new()); // pending_instantiations: vec of (mangled_name, fn_def, type_args)
    store_ptr(cg, 16, vec_new()); // assoc_types: vec of (impl_type::assoc_name, concrete_type) pairs
    store_ptr(cg, 17, 0);         // current_impl_type: type being implemented (for Self resolution)
    store_ptr(cg, 18, vec_new()); // const_params: vec of (name, value) pairs for current instantiation
    store_ptr(cg, 19, vec_new()); // type_params: vec of (name, concrete_type) pairs for current instantiation
    store_ptr(cg, 20, vec_new()); // generic_struct_templates: vec of (name, type_params, fields)
    store_ptr(cg, 21, vec_new()); // trait_impls: vec of (type_name, trait_name) pairs
    store_i64(cg, 22, 0);         // is_async_fn: flag for async function context
    store_i64(cg, 23, 0);         // async_state_counter: state number for async state machine
    store_ptr(cg, 24, vec_new()); // async_await_points: vec of await point info
    store_ptr(cg, 25, 0);         // async_fn_name: current async function name
    store_ptr(cg, 26, vec_new()); // default_methods: vec of (trait::method, fn_def) pairs
    store_ptr(cg, 27, vec_new()); // trait_defs: vec of (trait_name, method_sigs) for vtable layout
    store_ptr(cg, 28, vec_new()); // vtables: vec of (type_name, trait_name, vtable_global) pairs
    store_ptr(cg, 29, vec_new()); // type_aliases: vec of (alias_name, target_type) pairs
    // Neural IR / Neural Gate support
    store_i64(cg, 30, 0);         // training_mode: 0 = inference, 1 = training (differentiable)
    store_ptr(cg, 31, vec_new()); // neural_gates: vec of (name, gate_id, threshold) tuples
    store_f64(cg, 32, 1.0);       // gate_temperature: Gumbel-softmax temperature (anneals during training)
    store_i64(cg, 33, 0);         // gate_counter: unique ID counter for gates
    cg
}

// Neural IR mode accessors
fn cg_is_training_mode(cg: i64) -> i64 {
    load_i64(cg, 30)
}

fn cg_set_training_mode(cg: i64, training: i64) -> i64 {
    store_i64(cg, 30, training);
    0
}

fn cg_neural_gates(cg: i64) -> i64 {
    load_ptr(cg, 31)
}

fn cg_gate_temperature(cg: i64) -> f64 {
    load_f64(cg, 32)
}

fn cg_set_gate_temperature(cg: i64, temp: f64) -> i64 {
    store_f64(cg, 32, temp);
    0
}

fn cg_next_gate_id(cg: i64) -> i64 {
    let id: i64 = load_i64(cg, 33);
    store_i64(cg, 33, id + 1);
    id
}

// Register a neural gate
fn cg_register_neural_gate(cg: i64, name: i64, threshold: f64) -> i64 {
    let gates: i64 = cg_neural_gates(cg);
    let gate_id: i64 = cg_next_gate_id(cg);
    let gate: i64 = malloc(24);
    store_ptr(gate, 0, name);
    store_i64(gate, 1, gate_id);
    store_f64(gate, 2, threshold);
    vec_push(gates, gate);
    gate_id
}

// Lookup neural gate by name
fn cg_lookup_neural_gate(cg: i64, name: i64) -> i64 {
    let gates: i64 = cg_neural_gates(cg);
    let n: i64 = vec_len(gates);
    let i: i64 = 0;
    while i < n {
        let gate: i64 = vec_get(gates, i);
        let gate_name: i64 = load_ptr(gate, 0);
        if string_eq(gate_name, name) {
            return gate;
        }
        i = i + 1;
    }
    0
}

// Async state accessors
fn cg_is_async_fn(cg: i64) -> i64 {
    load_i64(cg, 22)
}

fn cg_set_async_fn(cg: i64, is_async: i64) -> i64 {
    store_i64(cg, 22, is_async);
    0
}

fn cg_next_async_state(cg: i64) -> i64 {
    let state: i64 = load_i64(cg, 23);
    store_i64(cg, 23, state + 1);
    state
}

fn cg_reset_async_state(cg: i64) -> i64 {
    store_i64(cg, 23, 0);
    0
}

fn cg_async_await_points(cg: i64) -> i64 {
    load_ptr(cg, 24)
}

fn cg_add_await_point(cg: i64, state: i64, label: i64) -> i64 {
    let points: i64 = cg_async_await_points(cg);
    let point: i64 = malloc(16);
    store_i64(point, 0, state);
    store_ptr(point, 1, label);
    vec_push(points, point);
    0
}

fn cg_clear_await_points(cg: i64) -> i64 {
    store_ptr(cg, 24, vec_new());
    0
}

fn cg_async_fn_name(cg: i64) -> i64 {
    load_ptr(cg, 25)
}

fn cg_set_async_fn_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 25, name);
    0
}

fn cg_module_name(cg: i64) -> i64 {
    load_ptr(cg, 12)
}

fn cg_set_module_name(cg: i64, name: i64) -> i64 {
    store_ptr(cg, 12, name);
    0
}

fn cg_generic_fns(cg: i64) -> i64 {
    load_ptr(cg, 13)
}

fn cg_instantiated(cg: i64) -> i64 {
    load_ptr(cg, 14)
}

fn cg_pending_instantiations(cg: i64) -> i64 {
    load_ptr(cg, 15)
}

// Register a generic function definition
fn cg_register_generic(cg: i64, name: i64, fn_def: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, fn_def);
    vec_push(generics, pair);
    0
}

// Look up a generic function by name
fn cg_lookup_generic(cg: i64, name: i64) -> i64 {
    let generics: i64 = cg_generic_fns(cg);
    let n: i64 = vec_len(generics);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(generics, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Check if an instantiation has been generated
fn cg_is_instantiated(cg: i64, mangled_name: i64) -> bool {
    let instantiated: i64 = cg_instantiated(cg);
    let n: i64 = vec_len(instantiated);
    let i: i64 = 0;
    while i < n {
        if string_eq(vec_get(instantiated, i), mangled_name) {
            return true;
        }
        i = i + 1;
    }
    false
}

// Mark an instantiation as generated
fn cg_mark_instantiated(cg: i64, mangled_name: i64) -> i64 {
    vec_push(cg_instantiated(cg), mangled_name);
    0
}

// Queue a pending instantiation
fn cg_queue_instantiation(cg: i64, mangled_name: i64, fn_def: i64, type_args: i64) -> i64 {
    let pending: i64 = cg_pending_instantiations(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, mangled_name);
    store_ptr(entry, 1, fn_def);
    store_ptr(entry, 2, type_args);
    vec_push(pending, entry);
    0
}

// Associated types helpers
fn cg_assoc_types(cg: i64) -> i64 {
    load_ptr(cg, 16)
}

fn cg_current_impl_type(cg: i64) -> i64 {
    load_ptr(cg, 17)
}

fn cg_set_current_impl_type(cg: i64, type_name: i64) -> i64 {
    store_ptr(cg, 17, type_name);
    0
}

// Register an associated type: maps "TypeName::AssocName" to concrete type
fn cg_register_assoc_type(cg: i64, impl_type: i64, assoc_name: i64, concrete_type: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = string_concat(impl_type, string_concat(string_from("::"), assoc_name));
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, key);
    store_ptr(pair, 1, concrete_type);
    vec_push(assoc_types, pair);
    0
}

// Look up an associated type
fn cg_lookup_assoc_type(cg: i64, impl_type: i64, assoc_name: i64) -> i64 {
    let assoc_types: i64 = cg_assoc_types(cg);
    let key: i64 = string_concat(impl_type, string_concat(string_from("::"), assoc_name));
    let n: i64 = vec_len(assoc_types);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(assoc_types, i);
        if string_eq(load_ptr(pair, 0), key) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Resolve a type: handles Self, Self::Name, and type aliases
fn cg_resolve_type(cg: i64, type_name: i64) -> i64 {
    // Check for Self::Name pattern
    if string_starts_with(type_name, string_from("Self::")) {
        let assoc_name: i64 = string_slice(type_name, 6, string_len(type_name));
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            let resolved: i64 = cg_lookup_assoc_type(cg, impl_type, assoc_name);
            if resolved != 0 {
                return resolved;
            }
        }
        // Not found - return as-is (will be an error at compile time)
        return type_name;
    }
    // Check for plain Self
    if string_eq(type_name, string_from("Self")) {
        let impl_type: i64 = cg_current_impl_type(cg);
        if impl_type != 0 {
            return impl_type;
        }
    }
    // Check for type alias
    let resolved: i64 = cg_resolve_type_alias(cg, type_name);
    if string_eq(resolved, type_name) == false {
        return resolved;
    }
    // Not Self::anything or alias, return as-is
    type_name
}

// Const params helpers for const generics
fn cg_const_params(cg: i64) -> i64 {
    load_ptr(cg, 18)
}

fn cg_clear_const_params(cg: i64) -> i64 {
    store_ptr(cg, 18, vec_new());
    0
}

fn cg_add_const_param(cg: i64, name: i64, value: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, value);
    vec_push(const_params, pair);
    0
}

fn cg_lookup_const_param(cg: i64, name: i64) -> i64 {
    let const_params: i64 = cg_const_params(cg);
    let n: i64 = vec_len(const_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(const_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Type Parameter Substitution (Phase 21 completion)
// ========================================

// Slot 19: type_params - maps type param names to concrete types
fn cg_type_params(cg: i64) -> i64 {
    load_ptr(cg, 19)
}

fn cg_clear_type_params(cg: i64) -> i64 {
    store_ptr(cg, 19, vec_new());
    0
}

fn cg_add_type_param(cg: i64, name: i64, concrete_type: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, name);
    store_ptr(pair, 1, concrete_type);
    vec_push(type_params, pair);
    0
}

fn cg_lookup_type_param(cg: i64, name: i64) -> i64 {
    let type_params: i64 = cg_type_params(cg);
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let pair: i64 = vec_get(type_params, i);
        if string_eq(load_ptr(pair, 0), name) {
            return load_ptr(pair, 1);
        }
        i = i + 1;
    }
    0
}

// Substitute type parameters in a type string
// e.g., "Vec<T>" with T=i64 becomes "Vec<i64>"
fn substitute_type_params(cg: i64, type_str: i64) -> i64 {
    if type_str == 0 {
        return type_str;
    }
    // Check if type_str is a type parameter itself
    let subst: i64 = cg_lookup_type_param(cg, type_str);
    if subst != 0 {
        return subst;
    }
    // Otherwise return unchanged (bootstrap compiler uses i64 for everything)
    type_str
}

// ========================================
// Generic Struct Templates (Phase 21 completion)
// ========================================

// Slot 20: generic_struct_templates - stores generic struct definitions
// Format: vec of (name, type_params, fields) tuples
fn cg_generic_struct_templates(cg: i64) -> i64 {
    load_ptr(cg, 20)
}

fn cg_add_generic_struct_template(cg: i64, name: i64, type_params: i64, fields: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, type_params);
    store_ptr(entry, 2, fields);
    vec_push(templates, entry);
    0
}

fn cg_lookup_generic_struct_template(cg: i64, name: i64) -> i64 {
    let templates: i64 = cg_generic_struct_templates(cg);
    let n: i64 = vec_len(templates);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(templates, i);
        if string_eq(load_ptr(entry, 0), name) {
            return entry;
        }
        i = i + 1;
    }
    0
}

// Monomorphize a generic struct with concrete type arguments
// Returns the mangled name (e.g., "Pair_i64_i64")
fn monomorphize_struct(cg: i64, struct_name: i64, type_args: i64) -> i64 {
    // Build mangled name
    let mangled_name: i64 = struct_name;
    if type_args != 0 {
        let num_args: i64 = vec_len(type_args);
        if num_args > 0 {
            let i: i64 = 0;
            while i < num_args {
                mangled_name = string_concat(mangled_name, "_");
                mangled_name = string_concat(mangled_name, vec_get(type_args, i));
                i = i + 1;
            }
        }
    }

    // Check if already registered
    let existing: i64 = lookup_struct_fields(cg, mangled_name);
    if existing != 0 {
        return mangled_name;
    }

    // Look up the generic struct template
    let template: i64 = cg_lookup_generic_struct_template(cg, struct_name);
    if template == 0 {
        // Not a generic struct, check if it's already registered
        let plain: i64 = lookup_struct_fields(cg, struct_name);
        if plain != 0 {
            return struct_name;
        }
        return struct_name;  // Fall back to plain name
    }

    // Get template info
    let type_params: i64 = load_ptr(template, 1);
    let fields: i64 = load_ptr(template, 2);

    // Set up type parameter mappings
    cg_clear_type_params(cg);
    if type_params != 0 {
        let num_type_params: i64 = vec_len(type_params);
        let pi: i64 = 0;
        while pi < num_type_params {
            let param_name: i64 = vec_get(type_params, pi);
            if type_args != 0 {
                if pi < vec_len(type_args) {
                    cg_add_type_param(cg, param_name, vec_get(type_args, pi));
                }
            }
            pi = pi + 1;
        }
    }

    // Create monomorphized fields (in bootstrap compiler, all types are i64)
    // Just register with same fields
    register_struct(cg, mangled_name, fields);

    mangled_name
}

// ========================================
// Trait Implementation Tracking (Phase 21 completion)
// ========================================

// Slot 21: trait_impls - stores which types implement which traits
fn cg_trait_impls(cg: i64) -> i64 {
    load_ptr(cg, 21)
}

fn cg_register_trait_impl(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    vec_push(impls, entry);
    0
}

fn cg_type_implements_trait(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let impls: i64 = cg_trait_impls(cg);
    let n: i64 = vec_len(impls);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(impls, i);
        let impl_type: i64 = load_ptr(entry, 0);
        let impl_trait: i64 = load_ptr(entry, 1);
        if string_eq(impl_type, type_name) {
            if string_eq(impl_trait, trait_name) {
                return 1;
            }
        }
        i = i + 1;
    }
    0
}

// Default method accessors
fn cg_default_methods(cg: i64) -> i64 {
    load_ptr(cg, 26)
}

fn cg_register_default_method(cg: i64, trait_name: i64, method_name: i64, fn_def: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = string_concat(trait_name, string_concat(string_from("::"), method_name));
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, key);
    store_ptr(entry, 1, fn_def);
    vec_push(methods, entry);
    0
}

fn cg_get_default_method(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let methods: i64 = cg_default_methods(cg);
    let key: i64 = string_concat(trait_name, string_concat(string_from("::"), method_name));
    let n: i64 = vec_len(methods);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(methods, i);
        let entry_key: i64 = load_ptr(entry, 0);
        if string_eq(entry_key, key) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// ========================================
// Vtable Support for Dynamic Dispatch (Phase 32)
// ========================================

// Slot 27: trait_defs - stores trait definitions with their method signatures
fn cg_trait_defs(cg: i64) -> i64 {
    load_ptr(cg, 27)
}

// Register a trait definition with its method signatures for vtable layout
// method_sigs is a vec of method signatures from the trait definition
fn cg_register_trait_def(cg: i64, trait_name: i64, method_sigs: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, trait_name);
    store_ptr(entry, 1, method_sigs);
    vec_push(defs, entry);
    0
}

// Get method signatures for a trait (for vtable layout)
fn cg_get_trait_methods(cg: i64, trait_name: i64) -> i64 {
    let defs: i64 = cg_trait_defs(cg);
    let n: i64 = vec_len(defs);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(defs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, trait_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Slot 28: vtables - stores generated vtables
fn cg_vtables(cg: i64) -> i64 {
    load_ptr(cg, 28)
}

// Register a vtable global for (type, trait) pair
fn cg_register_vtable(cg: i64, type_name: i64, trait_name: i64, vtable_global: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let entry: i64 = malloc(24);
    store_ptr(entry, 0, type_name);
    store_ptr(entry, 1, trait_name);
    store_ptr(entry, 2, vtable_global);
    vec_push(vtables, entry);
    0
}

// Get vtable global name for a (type, trait) pair
fn cg_get_vtable(cg: i64, type_name: i64, trait_name: i64) -> i64 {
    let vtables: i64 = cg_vtables(cg);
    let n: i64 = vec_len(vtables);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(vtables, i);
        let t: i64 = load_ptr(entry, 0);
        let tr: i64 = load_ptr(entry, 1);
        if string_eq(t, type_name) {
            if string_eq(tr, trait_name) {
                return load_ptr(entry, 2);
            }
        }
        i = i + 1;
    }
    0
}

// Slot 29: type_aliases - stores type alias mappings
fn cg_type_aliases(cg: i64) -> i64 {
    load_ptr(cg, 29)
}

// Register a type alias
fn cg_register_type_alias(cg: i64, alias_name: i64, target_type: i64) -> i64 {
    let aliases: i64 = cg_type_aliases(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, alias_name);
    store_ptr(entry, 1, target_type);
    vec_push(aliases, entry);
    0
}

// Resolve a type alias, returns the target type or the original if not an alias
fn cg_resolve_type_alias(cg: i64, type_name: i64) -> i64 {
    let aliases: i64 = cg_type_aliases(cg);
    let n: i64 = vec_len(aliases);
    let i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(aliases, i);
        let alias: i64 = load_ptr(entry, 0);
        if string_eq(alias, type_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    type_name  // Not an alias, return as-is
}

// Get method index in vtable for a trait method
fn cg_get_vtable_method_index(cg: i64, trait_name: i64, method_name: i64) -> i64 {
    let method_sigs: i64 = cg_get_trait_methods(cg, trait_name);
    if method_sigs == 0 {
        return 0;  // Unknown trait
    }
    let n: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < n {
        let sig: i64 = vec_get(method_sigs, i);
        let sig_name: i64 = load_ptr(sig, 0);
        if string_eq(sig_name, method_name) {
            return i;
        }
        i = i + 1;
    }
    0  // Default to first slot if not found
}

// Check if a type is a dyn trait type (starts with "dyn:")
fn is_dyn_type(type_name: i64) -> i64 {
    string_starts_with(type_name, string_from("dyn:"))
}

// Extract trait name from dyn type (e.g., "dyn:Display" -> "Display")
fn extract_dyn_trait(type_name: i64) -> i64 {
    if is_dyn_type(type_name) != 0 {
        return string_slice(type_name, 4, string_len(type_name));
    }
    type_name
}

// Extract type param name from bounded type param (e.g., "T:Display" -> "T")
fn extract_type_param_name(type_param: i64) -> i64 {
    // Check for const: prefix
    if string_starts_with(type_param, string_from("const:")) {
        return string_slice(type_param, 6, string_len(type_param));
    }
    // Check for trait bound (contains : but not const:)
    let colon_pos: i64 = string_find(type_param, string_from(":"));
    if colon_pos > 0 {
        return string_slice(type_param, 0, colon_pos);
    }
    type_param
}

// Extract trait bound from bounded type param (e.g., "T:Display" -> "Display")
fn extract_trait_bound(type_param: i64) -> i64 {
    // Check for const: prefix (no trait bound)
    if string_starts_with(type_param, string_from("const:")) {
        return 0;
    }
    // Check for trait bound
    let colon_pos: i64 = string_find(type_param, string_from(":"));
    if colon_pos > 0 {
        return string_slice(type_param, colon_pos + 1, string_len(type_param));
    }
    0
}

// Check if all trait bounds are satisfied for a generic instantiation
// Returns 1 if all bounds satisfied, 0 otherwise
fn check_trait_bounds(cg: i64, type_params: i64, type_args: i64) -> i64 {
    if type_params == 0 {
        return 1;
    }
    if type_args == 0 {
        return 1;
    }
    let n: i64 = vec_len(type_params);
    let i: i64 = 0;
    while i < n {
        let type_param: i64 = vec_get(type_params, i);
        let bound: i64 = extract_trait_bound(type_param);
        if bound != 0 {
            // This type param has a trait bound
            if i < vec_len(type_args) {
                let concrete_type: i64 = vec_get(type_args, i);
                // Check if concrete type implements the bound trait
                // Handle multiple bounds separated by +
                let plus_pos: i64 = string_find(bound, string_from("+"));
                if plus_pos > 0 {
                    // Multiple bounds: check each one
                    let remaining: i64 = bound;
                    while string_len(remaining) > 0 {
                        plus_pos = string_find(remaining, string_from("+"));
                        let trait_name: i64 = remaining;
                        if plus_pos > 0 {
                            trait_name = string_slice(remaining, 0, plus_pos);
                            remaining = string_slice(remaining, plus_pos + 1, string_len(remaining));
                        } else {
                            remaining = string_from("");
                        }
                        if cg_type_implements_trait(cg, concrete_type, trait_name) == 0 {
                            println(string_concat("Error: type '", string_concat(concrete_type,
                                string_concat("' does not implement trait '", string_concat(trait_name, "'")))));
                            return 0;
                        }
                    }
                } else {
                    // Single bound
                    if cg_type_implements_trait(cg, concrete_type, bound) == 0 {
                        println(string_concat("Error: type '", string_concat(concrete_type,
                            string_concat("' does not implement trait '", string_concat(bound, "'")))));
                        return 0;
                    }
                }
            }
        }
        i = i + 1;
    }
    1
}

// ========================================
// Improved Type Error Messages (Phase 21 completion)
// ========================================

// Format a type mismatch error with context
fn type_error_mismatch(expected: i64, found: i64, context: i64) -> i64 {
    let msg: i64 = string_from("Type error: expected '");
    msg = string_concat(msg, expected);
    msg = string_concat(msg, "', found '");
    msg = string_concat(msg, found);
    msg = string_concat(msg, "'");
    if context != 0 {
        msg = string_concat(msg, " in ");
        msg = string_concat(msg, context);
    }
    println(msg);
    0
}

// Format an argument count mismatch error
fn error_arg_count(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = string_from("Error: function '");
    msg = string_concat(msg, fn_name);
    msg = string_concat(msg, "' expects ");
    msg = string_concat(msg, int_to_string(expected));
    msg = string_concat(msg, " argument(s), found ");
    msg = string_concat(msg, int_to_string(found));
    println(msg);
    0
}

// Format an undefined variable error
fn error_undefined_var(name: i64) -> i64 {
    println(string_concat("Error: undefined variable '", string_concat(name, "'")));
    0
}

// Format an undefined function error
fn error_undefined_fn(name: i64) -> i64 {
    println(string_concat("Error: undefined function '", string_concat(name, "'")));
    0
}

// Format an undefined struct error
fn error_undefined_struct(name: i64) -> i64 {
    println(string_concat("Error: undefined struct '", string_concat(name, "'")));
    0
}

// Format an undefined field error
fn error_undefined_field(struct_name: i64, field_name: i64) -> i64 {
    let msg: i64 = string_from("Error: struct '");
    msg = string_concat(msg, struct_name);
    msg = string_concat(msg, "' has no field '");
    msg = string_concat(msg, field_name);
    msg = string_concat(msg, "'");
    println(msg);
    0
}

// Format a generic instantiation error
fn error_generic_instantiation(fn_name: i64, expected: i64, found: i64) -> i64 {
    let msg: i64 = string_from("Error: generic function '");
    msg = string_concat(msg, fn_name);
    msg = string_concat(msg, "' expects ");
    msg = string_concat(msg, int_to_string(expected));
    msg = string_concat(msg, " type argument(s), found ");
    msg = string_concat(msg, int_to_string(found));
    println(msg);
    0
}

fn cg_alloca_queue(cg: i64) -> i64 {
    load_ptr(cg, 11)
}

fn cg_clear_alloca_queue(cg: i64) -> i64 {
    store_ptr(cg, 11, vec_new());
    0
}

fn cg_push_alloca(cg: i64, unique_name: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    vec_push(queue, unique_name);
    0
}

fn cg_pop_alloca(cg: i64) -> i64 {
    let queue: i64 = cg_alloca_queue(cg);
    let len: i64 = vec_len(queue);
    if len == 0 {
        return 0;
    }
    let name: i64 = vec_get(queue, 0);
    // Shift queue (remove first element by building new vec)
    let new_queue: i64 = vec_new();
    let i: i64 = 1;
    while i < len {
        vec_push(new_queue, vec_get(queue, i));
        i = i + 1;
    }
    store_ptr(cg, 11, new_queue);
    name
}

// Collect all local variable names from a block (recursive)
// Returns a vector of variable names in declaration order
fn collect_locals_from_expr(expr: i64, result: i64) -> i64 {
    if expr == 0 {
        return 0;
    }
    let tag: i64 = load_i64(expr, 0);

    // Block - process stmts and result expr
    if tag == EXPR_BLOCK() {
        let stmts: i64 = load_ptr(expr, 1);
        let result_expr: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(stmts);
        let i: i64 = 0;
        while i < n {
            let stmt: i64 = vec_get(stmts, i);
            collect_locals_from_stmt(stmt, result);
            i = i + 1;
        }
        if result_expr != 0 {
            collect_locals_from_expr(result_expr, result);
        }
        return 0;
    }

    // If expression - process then/else blocks
    if tag == EXPR_IF() {
        let then_block: i64 = load_ptr(expr, 2);
        let else_block: i64 = load_ptr(expr, 3);
        collect_locals_from_expr(then_block, result);
        if else_block != 0 {
            collect_locals_from_expr(else_block, result);
        }
        return 0;
    }

    // While expression - process body
    if tag == EXPR_WHILE() {
        let body: i64 = load_ptr(expr, 2);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // For expression - collect loop var and process body
    if tag == EXPR_FOR() {
        let var_name: i64 = load_ptr(expr, 1);
        vec_push(result, var_name);
        let body: i64 = load_ptr(expr, 4);
        collect_locals_from_expr(body, result);
        return 0;
    }

    // Match expression - process arms
    if tag == EXPR_MATCH() {
        let arms: i64 = load_ptr(expr, 2);
        let n: i64 = vec_len(arms);
        let i: i64 = 0;
        while i < n {
            let arm: i64 = vec_get(arms, i);
            let body: i64 = load_ptr(arm, 1);
            collect_locals_from_expr(body, result);
            i = i + 1;
        }
        return 0;
    }

    0
}

fn collect_locals_from_stmt(stmt: i64, result: i64) -> i64 {
    if stmt == 0 {
        return 0;
    }
    let tag: i64 = load_i64(stmt, 0);

    // Let statement - collect the variable name
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        vec_push(result, name);
        // Also check init expression for nested blocks
        let init_expr: i64 = load_ptr(stmt, 3);
        if init_expr != 0 {
            collect_locals_from_expr(init_expr, result);
        }
        return 0;
    }

    // Expression statement - check for blocks
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        collect_locals_from_expr(expr, result);
        return 0;
    }

    // Return statement - check expression
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            collect_locals_from_expr(expr, result);
        }
        return 0;
    }

    0
}

fn collect_locals_from_block(block: i64) -> i64 {
    let result: i64 = vec_new();
    collect_locals_from_expr(block, result);
    result
}

fn cg_output(cg: i64) -> i64 {
    load_ptr(cg, 0)
}

fn cg_next_temp(cg: i64) -> i64 {
    let t: i64 = load_i64(cg, 1);
    store_i64(cg, 1, t + 1);
    t
}

fn cg_next_label(cg: i64) -> i64 {
    let l: i64 = load_i64(cg, 2);
    store_i64(cg, 2, l + 1);
    l
}

fn cg_enums(cg: i64) -> i64 {
    load_ptr(cg, 3)
}

fn cg_locals(cg: i64) -> i64 {
    load_ptr(cg, 4)
}

fn cg_clear_locals(cg: i64) -> i64 {
    store_ptr(cg, 4, vec_new());
    store_ptr(cg, 8, vec_new());  // Also clear var_types
    store_ptr(cg, 9, vec_new());  // Also clear loop_stack
    store_i64(cg, 10, 0);         // Reset loop_depth
    0
}

fn cg_strings(cg: i64) -> i64 {
    load_ptr(cg, 5)
}

// Variable type tracking for method calls
fn cg_var_types(cg: i64) -> i64 {
    load_ptr(cg, 8)
}

// Add variable type: stores (var_name, type_name) pair
fn add_var_type(cg: i64, var_name: i64, type_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, var_name);
    store_ptr(pair, 1, type_name);
    vec_push(var_types, pair);
    0
}

// Lookup variable type by name (returns type_name or 0 if not found)
fn lookup_var_type(cg: i64, var_name: i64) -> i64 {
    let var_types: i64 = cg_var_types(cg);
    let n: i64 = vec_len(var_types);
    // Search backwards to get most recent binding
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(var_types, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, var_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    0
}

fn cg_is_terminated(cg: i64) -> bool {
    load_i64(cg, 6) != 0
}

fn cg_set_terminated(cg: i64, val: bool) -> i64 {
    if val != false {
        store_i64(cg, 6, 1);
    } else {
        store_i64(cg, 6, 0);
    }
    0
}

// Add a string constant and return its index
fn cg_add_string(cg: i64, value: i64) -> i64 {
    let strings: i64 = cg_strings(cg);
    let idx: i64 = vec_len(strings);
    vec_push(strings, value);
    idx
}

// Emit to output buffer using StringBuilder for O(n) instead of O(n²)
fn emit(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    0
}

fn emit_line(cg: i64, s: i64) -> i64 {
    let sb: i64 = cg_output(cg);
    sb_append(sb, s);
    sb_append(sb, "\n");
    0
}

// Register an enum
fn register_enum(cg: i64, name: i64, variants: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, variants);
    vec_push(enums, entry);
    0
}

// Look up enum variant index
fn lookup_variant(cg: i64, enum_name: i64, var_name: i64) -> i64 {
    let enums: i64 = cg_enums(cg);
    let n: i64 = vec_len(enums);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(enums, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, enum_name) {
            let variants: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(variants);
            let j: i64 = 0;
            while j < m {
                let v: i64 = vec_get(variants, j);
                if string_eq(v, var_name) {
                    return j;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0 - 1  // Return -1 when not found
}

// Register builtin enums (Option, Result) for enum construction without explicit enum definition
fn register_builtin_enums(cg: i64) -> i64 {
    // Option<T>: None=0, Some=1
    let option_variants: i64 = vec_new();
    vec_push(option_variants, string_from("None"));
    vec_push(option_variants, string_from("Some"));
    register_enum(cg, string_from("Option"), option_variants);

    // Result<T,E>: Err=0, Ok=1
    let result_variants: i64 = vec_new();
    vec_push(result_variants, string_from("Err"));
    vec_push(result_variants, string_from("Ok"));
    register_enum(cg, string_from("Result"), result_variants);
    0
}

// Phase 36: Extract base type name from generic type string
// e.g., "Option<i64>" -> "Option", "Result<T, E>" -> "Result"
fn extract_base_type(type_name: i64) -> i64 {
    if type_name == 0 {
        return 0;
    }
    let len: i64 = string_len(type_name);
    let i: i64 = 0;
    while i < len {
        let ch: i64 = string_char_at(type_name, i);
        if ch == 60 {  // '<' character
            return string_slice(type_name, 0, i);
        }
        i = i + 1;
    }
    type_name  // No '<' found, return as-is
}

// Get structs vector
fn cg_structs(cg: i64) -> i64 {
    load_ptr(cg, 7)
}

// Get loop stack (for break/continue)
fn cg_loop_stack(cg: i64) -> i64 {
    load_ptr(cg, 9)
}

// Get loop depth
fn cg_loop_depth(cg: i64) -> i64 {
    load_i64(cg, 10)
}

// Push loop context onto stack - pair is (continue_label, break_label)
fn push_loop(cg: i64, continue_label: i64, break_label: i64) -> i64 {
    let stack: i64 = cg_loop_stack(cg);
    let depth: i64 = cg_loop_depth(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, continue_label);
    store_ptr(pair, 1, break_label);
    vec_push(stack, pair);
    store_i64(cg, 10, depth + 1);
    0
}

// Pop loop context from stack
fn pop_loop(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth > 0 {
        let new_depth: i64 = depth - 1;
        store_i64(cg, 10, new_depth);
        // When exiting all loops, clear the stack to prevent stale entries
        // from affecting subsequent loops in the same function
        if new_depth == 0 {
            store_ptr(cg, 9, vec_new());
        }
    }
    0
}

// Get current loop continue label (top of stack)
fn current_loop_continue(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 0)
}

// Get current loop break label (top of stack)
fn current_loop_break(cg: i64) -> i64 {
    let depth: i64 = cg_loop_depth(cg);
    if depth == 0 {
        return 0;
    }
    let stack: i64 = cg_loop_stack(cg);
    let pair: i64 = vec_get(stack, depth - 1);
    load_ptr(pair, 1)
}

// Register a struct
fn register_struct(cg: i64, name: i64, fields: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let entry: i64 = malloc(16);
    store_ptr(entry, 0, name);
    store_ptr(entry, 1, fields);
    vec_push(structs, entry);
    0
}

// Look up struct field index (returns byte offset = index * 8)
fn lookup_struct_field(cg: i64, struct_name: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            let fields: i64 = load_ptr(entry, 1);
            let m: i64 = vec_len(fields);
            let j: i64 = 0;
            while j < m {
                let field: i64 = vec_get(fields, j);
                let fname: i64 = load_ptr(field, 0);
                if string_eq(fname, field_name) {
                    return j;  // Return field index
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    0
}

// Get struct fields by name
fn lookup_struct_fields(cg: i64, struct_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let name: i64 = load_ptr(entry, 0);
        if string_eq(name, struct_name) {
            return load_ptr(entry, 1);
        }
        i = i + 1;
    }
    0
}

// Look up field in all registered structs (for field access without type info)
fn lookup_field_in_all_structs(cg: i64, field_name: i64) -> i64 {
    let structs: i64 = cg_structs(cg);
    let n: i64 = vec_len(structs);
    let i: i64 = 0;

    while i < n {
        let entry: i64 = vec_get(structs, i);
        let fields: i64 = load_ptr(entry, 1);
        let m: i64 = vec_len(fields);
        let j: i64 = 0;
        while j < m {
            let field: i64 = vec_get(fields, j);
            let fname: i64 = load_ptr(field, 0);
            if string_eq(fname, field_name) {
                return j;  // Return field index
            }
            j = j + 1;
        }
        i = i + 1;
    }
    0
}

// Add local: stores (original_name, unique_name) pair
fn add_local(cg: i64, original_name: i64, unique_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let pair: i64 = malloc(16);
    store_ptr(pair, 0, original_name);
    store_ptr(pair, 1, unique_name);
    vec_push(locals, pair);
    0
}

// Lookup local: find most recent unique_name for original_name
fn lookup_local(cg: i64, original_name: i64) -> i64 {
    let locals: i64 = cg_locals(cg);
    let n: i64 = vec_len(locals);
    // Search backwards to get most recent
    let i: i64 = n - 1;
    while i >= 0 {
        let pair: i64 = vec_get(locals, i);
        let stored_name: i64 = load_ptr(pair, 0);
        if string_eq(stored_name, original_name) {
            return load_ptr(pair, 1);
        }
        i = i - 1;
    }
    // Not found - report error and return original
    error_undefined_var(original_name);
    original_name
}

// Generate expression - returns the LLVM value (temp name or literal)
fn gen_expr(cg: i64, expr: i64) -> i64 {
    // Guard against null expressions
    if expr == 0 {
        return string_from("0");
    }
    let tag: i64 = load_i64(expr, 0);

    // Int literal
    if tag == EXPR_INT() {
        let value: i64 = load_i64(expr, 1);
        return int_to_string(value);
    }

    // Bool literal
    if tag == EXPR_BOOL() {
        let value: i64 = load_i64(expr, 1);
        if value != 0 {
            return string_from("1");
        }
        return string_from("0");
    }

    // String literal - allocate and initialize
    if tag == EXPR_STRING() {
        let value: i64 = load_ptr(expr, 1);
        let str_idx: i64 = cg_add_string(cg, value);  // Track the string constant
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        // Emit call to intrinsic_string_new with the string constant
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
        emit(cg, cg_module_name(cg));
        emit(cg, ".");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");

        // Convert ptr to i64 for consistent type handling
        let t2: i64 = cg_next_temp(cg);
        let temp2: i64 = string_concat("%t", int_to_string(t2));
        emit(cg, "  ");
        emit(cg, temp2);
        emit(cg, " = ptrtoint ptr ");
        emit(cg, temp);
        emit_line(cg, " to i64");

        return temp2;
    }

    // FString - interpolated string
    // Layout: tag(0), parts(1), exprs(2)
    if tag == EXPR_FSTRING() {
        let parts: i64 = load_ptr(expr, 1);
        let exprs: i64 = load_ptr(expr, 2);
        let num_parts: i64 = vec_len(parts);
        let num_exprs: i64 = vec_len(exprs);

        // Start with empty string
        let result: i64 = string_from("0");

        // Interleave parts and expressions
        let i: i64 = 0;
        while i < num_parts {
            // Emit the string part
            let part: i64 = vec_get(parts, i);
            if string_len(part) > 0 {
                let part_idx: i64 = cg_add_string(cg, part);
                let t1: i64 = cg_next_temp(cg);
                let temp1: i64 = string_concat("%t", int_to_string(t1));
                emit(cg, "  ");
                emit(cg, temp1);
                emit(cg, " = call ptr @intrinsic_string_new(ptr @.str.");
                emit(cg, cg_module_name(cg));
                emit(cg, ".");
                emit(cg, int_to_string(part_idx));
                emit_line(cg, ")");

                let t2: i64 = cg_next_temp(cg);
                let temp2: i64 = string_concat("%t", int_to_string(t2));
                emit(cg, "  ");
                emit(cg, temp2);
                emit(cg, " = ptrtoint ptr ");
                emit(cg, temp1);
                emit_line(cg, " to i64");

                // Concat with result
                if string_eq(result, "0") {
                    result = temp2;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, temp2);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            // If there's an expression, evaluate and concat it
            if i < num_exprs {
                let ex: i64 = vec_get(exprs, i);
                let ex_val: i64 = gen_expr(cg, ex);

                // Concat with result (assuming expr returns string handle)
                if string_eq(result, "0") {
                    result = ex_val;
                } else {
                    let tc: i64 = cg_next_temp(cg);
                    let tempc: i64 = string_concat("%t", int_to_string(tc));
                    emit(cg, "  ");
                    emit(cg, tempc);
                    emit(cg, " = call i64 @intrinsic_string_concat(i64 ");
                    emit(cg, result);
                    emit(cg, ", i64 ");
                    emit(cg, ex_val);
                    emit_line(cg, ")");
                    result = tempc;
                }
            }

            i = i + 1;
        }

        return result;
    }

    // Yield expression - for generators
    // Layout: tag(0), inner(1)
    if tag == EXPR_YIELD() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Call generator_yield intrinsic
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @generator_yield(i64 ");
        emit(cg, inner_val);
        emit_line(cg, ")");

        return temp;
    }

    // Identifier - load from local
    if tag == EXPR_IDENT() {
        let name: i64 = load_ptr(expr, 1);

        // Check if this is a const generic parameter
        let const_value: i64 = cg_lookup_const_param(cg, name);
        if const_value != 0 {
            // Return the literal value directly
            return const_value;
        }

        // Phase 36: Check if this is an enum variant without arguments (e.g., None)
        let opt_variant_idx: i64 = lookup_variant(cg, string_from("Option"), name);
        if opt_variant_idx >= 0 {
            // This is None - allocate Option with just the tag
            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " = call ptr @malloc(i64 8)");
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(opt_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        let unique_name: i64 = lookup_local(cg, name);
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = load i64, ptr %local.");
        emit_line(cg, unique_name);

        return temp;
    }

    // Path - enum variant
    if tag == EXPR_PATH() {
        let segments: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(segments);
        if len == 2 {
            let enum_name: i64 = vec_get(segments, 0);
            let var_name: i64 = vec_get(segments, 1);
            let idx: i64 = lookup_variant(cg, enum_name, var_name);
            return int_to_string(idx);
        }
        return string_from("0");
    }

    // Function call
    if tag == EXPR_CALL() {
        let callee: i64 = load_ptr(expr, 1);
        let args: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);  // Generic type arguments (or 0)

        // Get function name
        let callee_name: i64 = load_ptr(callee, 1);

        // Generate args
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // ===== PHASE 36: ENUM VARIANT CONSTRUCTORS =====
        // Handle Some(x), None, Ok(x), Err(e) as enum constructors
        let variant_idx: i64 = lookup_variant(cg, string_from("Option"), callee_name);
        if variant_idx >= 0 {
            // Option variant: Some or None
            // Allocate: 8 bytes tag + 8 bytes payload (if Some)
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads at offset 8, 16, etc.
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for Result variants
        let result_variant_idx: i64 = lookup_variant(cg, string_from("Result"), callee_name);
        if result_variant_idx >= 0 {
            // Result variant: Ok or Err
            let num_payloads: i64 = vec_len(arg_values);
            let size: i64 = 8 + num_payloads * 8;

            let malloc_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(malloc_t));
            emit(cg, " = call ptr @malloc(i64 ");
            emit(cg, int_to_string(size));
            emit_line(cg, ")");

            // Store tag
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(result_variant_idx));
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(malloc_t));

            // Store payloads
            let pi: i64 = 0;
            while pi < num_payloads {
                let offset: i64 = 8 + pi * 8;
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(malloc_t));
                emit(cg, ", i64 ");
                emit_line(cg, int_to_string(offset));
                emit(cg, "  store i64 ");
                emit(cg, vec_get(arg_values, pi));
                emit(cg, ", ptr %t");
                emit_line(cg, int_to_string(gep_t));
                pi = pi + 1;
            }

            // Return ptr as i64
            let result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(result_t));
            emit(cg, " = ptrtoint ptr %t");
            emit(cg, int_to_string(malloc_t));
            emit_line(cg, " to i64");
            return string_concat("%t", int_to_string(result_t));
        }

        // Check for intrinsics - emit with proper type conversions
        // Pattern: convert i64 args to ptr, call intrinsic, convert ptr result to i64

        // string_from: argument is already a string handle from EXPR_STRING
        if string_eq(callee_name, "string_from") {
            return vec_get(arg_values, 0);
        }

        // void intrinsics (return "0")
        if string_eq(callee_name, "println") {
            emit_intrinsic_void_ptr(cg, "intrinsic_println", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "print") {
            emit_intrinsic_void_ptr(cg, "intrinsic_print", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_push") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_vec_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "write_file") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_write_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "free") {
            emit_intrinsic_void_ptr(cg, "free", vec_get(arg_values, 0));
            return string_from("0");
        }

        // i64 result intrinsics
        if string_eq(callee_name, "string_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_char_at") {
            return emit_intrinsic_i64_ptr_i64(cg, "intrinsic_string_char_at", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_to_int") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_to_int", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_vec_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_i64") {
            return emit_intrinsic_i64_ptr_i64(cg, "load_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_eq") {
            return emit_intrinsic_i1_ptr_ptr(cg, "intrinsic_string_eq", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // ptr result intrinsics -> convert to i64
        if string_eq(callee_name, "string_concat") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_concat", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_slice") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "intrinsic_string_slice", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "int_to_string") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_int_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_from_char") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_string_from_char", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_vec_new");
        }
        if string_eq(callee_name, "vec_get") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_vec_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_args") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_args");
        }
        if string_eq(callee_name, "read_file") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_read_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "malloc") {
            return emit_intrinsic_ptr_i64(cg, "malloc", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "load_ptr") {
            return emit_intrinsic_ptr_ptr_i64(cg, "load_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "store_ptr") {
            return emit_intrinsic_ptr_ptr_i64_ptr(cg, "store_ptr", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "store_i64") {
            return emit_intrinsic_ptr_ptr_i64_i64(cg, "store_i64", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }

        // Timing intrinsics
        if string_eq(callee_name, "get_time_ms") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_ms");
        }
        if string_eq(callee_name, "get_time_us") {
            return emit_intrinsic_i64_void(cg, "intrinsic_get_time_us");
        }

        // File I/O intrinsics
        if string_eq(callee_name, "file_exists") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_exists", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_file", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "is_dir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_is_directory", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_size") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_size", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "file_mtime") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_file_mtime", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "remove_file") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_remove_path", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "mkdir") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_mkdir_p", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "get_cwd") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_cwd");
        }
        if string_eq(callee_name, "set_cwd") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_set_cwd", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "list_dir") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_list_dir", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_join") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_path_join", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "path_dirname") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_dirname", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_basename") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_basename", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "path_ext") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_path_extension", vec_get(arg_values, 0));
        }

        // Arena intrinsics
        if string_eq(callee_name, "arena_create") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_arena_create", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "arena_alloc") {
            return emit_intrinsic_ptr_ptr_i64(cg, "intrinsic_arena_alloc", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "arena_reset") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_reset", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_arena_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "arena_used") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_arena_used", vec_get(arg_values, 0));
        }

        // StringBuilder intrinsics
        if string_eq(callee_name, "sb_new") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_sb_new");
        }
        if string_eq(callee_name, "sb_new_cap") {
            return emit_intrinsic_ptr_i64(cg, "intrinsic_sb_new_cap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_append") {
            emit_intrinsic_void_ptr2(cg, "intrinsic_sb_append", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_char") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_char", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_append_i64") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_sb_append_i64", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_to_string") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_sb_to_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "sb_clear") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_free") {
            emit_intrinsic_void_ptr(cg, "intrinsic_sb_free", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "sb_len") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_sb_len", vec_get(arg_values, 0));
        }

        // Error handling intrinsics
        if string_eq(callee_name, "panic") {
            emit_intrinsic_void_ptr(cg, "intrinsic_panic", vec_get(arg_values, 0));
            emit_line(cg, "  unreachable");
            return string_from("0");
        }
        if string_eq(callee_name, "print_stack_trace") {
            emit_intrinsic_void_void(cg, "intrinsic_print_stack_trace");
            return string_from("0");
        }

        // Process intrinsics
        if string_eq(callee_name, "process_run") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_process_run", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "process_output") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_process_output", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "exit") {
            emit_intrinsic_void_i64(cg, "intrinsic_exit", vec_get(arg_values, 0));
            return string_from("0");
        }

        // Phase 20: REPL/I/O intrinsics
        if string_eq(callee_name, "read_line") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_read_line");
        }
        if string_eq(callee_name, "is_tty") {
            return emit_intrinsic_i64_void(cg, "intrinsic_is_tty");
        }
        if string_eq(callee_name, "stdin_has_data") {
            return emit_intrinsic_i64_void(cg, "intrinsic_stdin_has_data");
        }
        if string_eq(callee_name, "string_hash") {
            return emit_intrinsic_i64_ptr(cg, "intrinsic_string_hash", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_find") {
            return emit_intrinsic_i64_ptr_ptr_i64(cg, "intrinsic_string_find", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "string_trim") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_trim", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_split") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_split", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_starts_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_starts_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_ends_with") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_ends_with", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_contains") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_replace") {
            return emit_intrinsic_ptr_ptr_ptr_ptr(cg, "intrinsic_string_replace", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "copy_file") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_copy_file", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "get_home_dir") {
            return emit_intrinsic_ptr_void(cg, "intrinsic_get_home_dir");
        }

        // Phase 1 Stdlib: HashMap
        if string_eq(callee_name, "hashmap_new") {
            return emit_intrinsic_i64_void(cg, "hashmap_new");
        }
        if string_eq(callee_name, "hashmap_insert") {
            return emit_call_i64_3args(cg, "hashmap_insert", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
        }
        if string_eq(callee_name, "hashmap_get") {
            return emit_call_i64_2args(cg, "hashmap_get", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_remove") {
            return emit_call_i64_2args(cg, "hashmap_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_contains") {
            return emit_call_i64_2args(cg, "hashmap_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashmap_len") {
            return emit_call_i64_1arg(cg, "hashmap_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashmap_clear") {
            emit_call_void_1arg(cg, "hashmap_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "hashmap_keys") {
            return emit_call_i64_1arg(cg, "hashmap_keys", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashmap_values") {
            return emit_call_i64_1arg(cg, "hashmap_values", vec_get(arg_values, 0));
        }

        // Phase 1 Stdlib: HashSet
        if string_eq(callee_name, "hashset_new") {
            return emit_intrinsic_i64_void(cg, "hashset_new");
        }
        if string_eq(callee_name, "hashset_insert") {
            return emit_call_i64_2args(cg, "hashset_insert", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_remove") {
            return emit_call_i64_2args(cg, "hashset_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_contains") {
            return emit_call_i64_2args(cg, "hashset_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "hashset_len") {
            return emit_call_i64_1arg(cg, "hashset_len", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "hashset_clear") {
            emit_call_void_1arg(cg, "hashset_clear", vec_get(arg_values, 0));
            return string_from("0");
        }

        // Phase 1 Stdlib: Option
        if string_eq(callee_name, "option_some") {
            return emit_call_i64_1arg(cg, "option_some", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_none") {
            return emit_intrinsic_i64_void(cg, "option_none");
        }
        if string_eq(callee_name, "option_is_some") {
            return emit_call_i64_1arg(cg, "option_is_some", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_is_none") {
            return emit_call_i64_1arg(cg, "option_is_none", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_unwrap") {
            return emit_call_i64_1arg(cg, "option_unwrap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "option_expect") {
            return emit_call_i64_2args(cg, "option_expect", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "option_unwrap_or") {
            return emit_call_i64_2args(cg, "option_unwrap_or", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: Result
        if string_eq(callee_name, "result_ok") {
            return emit_call_i64_1arg(cg, "result_ok", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_err") {
            return emit_call_i64_1arg(cg, "result_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_is_ok") {
            return emit_call_i64_1arg(cg, "result_is_ok", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_is_err") {
            return emit_call_i64_1arg(cg, "result_is_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap") {
            return emit_call_i64_1arg(cg, "result_unwrap", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap_err") {
            return emit_call_i64_1arg(cg, "result_unwrap_err", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "result_unwrap_or") {
            return emit_call_i64_2args(cg, "result_unwrap_or", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: Vec extensions
        if string_eq(callee_name, "vec_sum") {
            return emit_call_i64_1arg(cg, "vec_sum", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_find") {
            return emit_call_i64_2args(cg, "vec_find", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "vec_contains") {
            return emit_call_i64_2args(cg, "vec_contains", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "vec_reverse") {
            return emit_call_i64_1arg(cg, "vec_reverse", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_clone") {
            return emit_call_i64_1arg(cg, "vec_clone", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_first") {
            return emit_call_i64_1arg(cg, "vec_first", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_last") {
            return emit_call_i64_1arg(cg, "vec_last", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_pop") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_vec_pop", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "vec_set") {
            emit_intrinsic_void_ptr_i64_ptr(cg, "intrinsic_vec_set", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_clear") {
            emit_intrinsic_void_ptr(cg, "intrinsic_vec_clear", vec_get(arg_values, 0));
            return string_from("0");
        }
        if string_eq(callee_name, "vec_remove") {
            emit_intrinsic_void_ptr_i64(cg, "intrinsic_vec_remove", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }

        // Phase 1 Stdlib: String extensions (map to intrinsics)
        if string_eq(callee_name, "string_to_lower") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_to_lowercase", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_to_upper") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_to_uppercase", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_compare") {
            return emit_intrinsic_i64_ptr_ptr(cg, "intrinsic_string_compare", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "string_lines") {
            return emit_intrinsic_ptr_ptr(cg, "intrinsic_string_lines", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "string_join") {
            return emit_intrinsic_ptr_ptr_ptr(cg, "intrinsic_string_join", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }

        // Phase 1 Stdlib: JSON
        if string_eq(callee_name, "json_parse") {
            return emit_call_i64_1arg(cg, "json_parse_simple", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_stringify") {
            return emit_call_i64_1arg(cg, "json_stringify", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_get") {
            return emit_call_i64_2args(cg, "json_get_sx", vec_get(arg_values, 0), vec_get(arg_values, 1));
        }
        if string_eq(callee_name, "json_keys") {
            return emit_call_i64_1arg(cg, "json_keys", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_string") {
            return emit_call_i64_1arg(cg, "json_is_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_object") {
            return emit_call_i64_1arg(cg, "json_is_object", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_is_array") {
            return emit_call_i64_1arg(cg, "json_is_array", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_as_string") {
            return emit_call_i64_1arg(cg, "json_as_string", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_as_array") {
            return emit_call_i64_1arg(cg, "json_as_array", vec_get(arg_values, 0));
        }
        if string_eq(callee_name, "json_object_new") {
            return emit_intrinsic_i64_void(cg, "json_object_new");
        }
        if string_eq(callee_name, "json_array_new") {
            return emit_intrinsic_i64_void(cg, "json_array_new");
        }
        if string_eq(callee_name, "json_object_set") {
            emit_call_void_3args(cg, "json_object_set", vec_get(arg_values, 0), vec_get(arg_values, 1), vec_get(arg_values, 2));
            return string_from("0");
        }
        if string_eq(callee_name, "json_array_push") {
            emit_call_void_2args(cg, "json_array_push", vec_get(arg_values, 0), vec_get(arg_values, 1));
            return string_from("0");
        }
        if string_eq(callee_name, "json_string") {
            return emit_call_i64_1arg(cg, "json_string", vec_get(arg_values, 0));
        }

        // Check if this is a generic function call
        let emit_callee: i64 = callee_name;
        if type_args != 0 {
            if vec_len(type_args) > 0 {
                // This is a generic call - mangle the name
                let mangled: i64 = mangle_generic_name(callee_name, type_args);
                emit_callee = mangled;

                // Queue instantiation if not already done
                if cg_is_instantiated(cg, mangled) == false {
                    let fn_def: i64 = cg_lookup_generic(cg, callee_name);
                    if fn_def != 0 {
                        cg_queue_instantiation(cg, mangled, fn_def, type_args);
                        cg_mark_instantiated(cg, mangled);
                    }
                }
            }
        }

        // Check if this is a neural gate (uses double types instead of i64)
        let gate_info: i64 = cg_lookup_neural_gate(cg, emit_callee);
        if gate_info != 0 {
            // Neural gate: bitcast args i64->double, call, bitcast result double->i64
            // Bitcast each argument from i64 to double
            let double_args: i64 = vec_new();
            i = 0;
            while i < n {
                let arg_val: i64 = vec_get(arg_values, i);
                let bc_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(bc_t));
                emit(cg, " = bitcast i64 ");
                emit(cg, arg_val);
                emit_line(cg, " to double");
                vec_push(double_args, string_concat("%t", int_to_string(bc_t)));
                i = i + 1;
            }

            // Call the neural gate with double types
            let dbl_result_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(dbl_result_t));
            emit(cg, " = call double @\"");
            emit(cg, emit_callee);
            emit(cg, "\"(");
            i = 0;
            while i < n {
                if i > 0 { emit(cg, ", "); }
                emit(cg, "double ");
                emit(cg, vec_get(double_args, i));
                i = i + 1;
            }
            emit_line(cg, ")");

            // Bitcast result from double back to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = bitcast double %t");
            emit(cg, int_to_string(dbl_result_t));
            emit_line(cg, " to i64");

            return result;
        }

        // Default: emit call as user function
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, emit_callee);
        emit(cg, "\"(");

        i = 0;
        while i < n {
            if i > 0 { emit(cg, ", "); }
            emit(cg, "i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Binary operation
    if tag == EXPR_BINARY() {
        let op: i64 = load_i64(expr, 1);
        let left: i64 = load_ptr(expr, 2);
        let right: i64 = load_ptr(expr, 3);

        // Short-circuit evaluation for && and ||
        // Use simple approach: evaluate both and use logical and/or
        // This is simpler than proper phi-based short-circuit
        if op == OP_AND() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // and i1
            let and_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(and_t));
            emit(cg, " = and i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(and_t));
            emit_line(cg, " to i64");

            return result;
        }

        if op == OP_OR() {
            let left_val: i64 = gen_expr(cg, left);
            let right_val: i64 = gen_expr(cg, right);

            // Convert both to i1
            let l1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, left_val);
            emit_line(cg, ", 0");

            let r1_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(r1_t));
            emit(cg, " = icmp ne i64 ");
            emit(cg, right_val);
            emit_line(cg, ", 0");

            // or i1
            let or_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(or_t));
            emit(cg, " = or i1 %t");
            emit(cg, int_to_string(l1_t));
            emit(cg, ", %t");
            emit_line(cg, int_to_string(r1_t));

            // zext to i64
            let result_t: i64 = cg_next_temp(cg);
            let result: i64 = string_concat("%t", int_to_string(result_t));
            emit(cg, "  ");
            emit(cg, result);
            emit(cg, " = zext i1 %t");
            emit(cg, int_to_string(or_t));
            emit_line(cg, " to i64");

            return result;
        }

        let left_val: i64 = gen_expr(cg, left);
        let right_val: i64 = gen_expr(cg, right);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = ");

        let is_cmp: bool = false;
        if op == OP_ADD() { emit(cg, "add i64 "); }
        if op == OP_SUB() { emit(cg, "sub i64 "); }
        if op == OP_MUL() { emit(cg, "mul i64 "); }
        if op == OP_DIV() { emit(cg, "sdiv i64 "); }
        if op == OP_MOD() { emit(cg, "srem i64 "); }
        if op == OP_BITAND() { emit(cg, "and i64 "); }
        if op == OP_BITOR() { emit(cg, "or i64 "); }
        if op == OP_BITXOR() { emit(cg, "xor i64 "); }
        if op == OP_SHL() { emit(cg, "shl i64 "); }
        if op == OP_SHR() { emit(cg, "ashr i64 "); }
        if op == OP_EQ() { emit(cg, "icmp eq i64 "); is_cmp = true; }
        if op == OP_NE() { emit(cg, "icmp ne i64 "); is_cmp = true; }
        if op == OP_LT() { emit(cg, "icmp slt i64 "); is_cmp = true; }
        if op == OP_GT() { emit(cg, "icmp sgt i64 "); is_cmp = true; }
        if op == OP_LE() { emit(cg, "icmp sle i64 "); is_cmp = true; }
        if op == OP_GE() { emit(cg, "icmp sge i64 "); is_cmp = true; }

        emit(cg, left_val);
        emit(cg, ", ");
        emit_line(cg, right_val);

        // If comparison, zext from i1 to i64
        if is_cmp {
            let t2: i64 = cg_next_temp(cg);
            let temp2: i64 = string_concat("%t", int_to_string(t2));
            emit(cg, "  ");
            emit(cg, temp2);
            emit(cg, " = zext i1 ");
            emit(cg, temp);
            emit_line(cg, " to i64");
            return temp2;
        }

        return temp;
    }

    // Unary operation
    if tag == EXPR_UNARY() {
        let op: i64 = load_i64(expr, 1);
        let operand: i64 = load_ptr(expr, 2);
        let val: i64 = gen_expr(cg, operand);

        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);

        if op == OP_NEG() {
            emit(cg, " = sub i64 0, ");
            emit_line(cg, val);
        }
        if op == OP_NOT() {
            emit(cg, " = xor i1 ");
            emit(cg, val);
            emit_line(cg, ", 1");
        }

        return temp;
    }

    // If expression
    if tag == EXPR_IF() {
        return gen_if(cg, expr);
    }

    // While expression
    if tag == EXPR_WHILE() {
        return gen_while(cg, expr);
    }

    // For expression
    if tag == EXPR_FOR() {
        return gen_for(cg, expr);
    }

    // Match expression
    if tag == EXPR_MATCH() {
        return gen_match(cg, expr);
    }

    // Block expression
    if tag == EXPR_BLOCK() {
        return gen_block(cg, expr);
    }

    // Struct literal: Foo { x: 1, y: 2 } or Foo::<T> { x: 1, y: 2 }
    if tag == EXPR_STRUCT_LIT() {
        let struct_name: i64 = load_ptr(expr, 1);
        let field_inits: i64 = load_ptr(expr, 2);
        let type_args: i64 = load_ptr(expr, 3);
        let num_fields: i64 = vec_len(field_inits);

        // Monomorphize if type args provided (e.g., Pair::<i64, i64>)
        let effective_name: i64 = monomorphize_struct(cg, struct_name, type_args);

        // Allocate struct: malloc(num_fields * 8)
        let alloc_size: i64 = num_fields * 8;
        let t: i64 = cg_next_temp(cg);
        let ptr_temp: i64 = string_concat("%t", int_to_string(t));
        emit(cg, "  ");
        emit(cg, ptr_temp);
        emit(cg, " = call ptr @malloc(i64 ");
        emit(cg, int_to_string(alloc_size));
        emit_line(cg, ")");

        // Get the struct field order from definition
        let fields: i64 = lookup_struct_fields(cg, effective_name);
        if fields == 0 {
            error_undefined_struct(effective_name);
        }

        // Initialize each field
        let i: i64 = 0;
        while i < num_fields {
            let field_init: i64 = vec_get(field_inits, i);
            let field_name: i64 = load_ptr(field_init, 0);
            let field_expr: i64 = load_ptr(field_init, 1);

            // Generate field value
            let field_val: i64 = gen_expr(cg, field_expr);

            // Look up field offset
            let field_idx: i64 = lookup_struct_field(cg, effective_name, field_name);
            let offset: i64 = field_idx * 8;

            // Store field using getelementptr + store
            let gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(gep_t));
            emit(cg, " = getelementptr i8, ptr ");
            emit(cg, ptr_temp);
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(offset));

            emit(cg, "  store i64 ");
            emit(cg, field_val);
            emit(cg, ", ptr %t");
            emit_line(cg, int_to_string(gep_t));

            i = i + 1;
        }

        // Convert ptr to i64
        return emit_ptr_to_i64(cg, ptr_temp);
    }

    // Field access: expr.field
    if tag == EXPR_FIELD() {
        let object: i64 = load_ptr(expr, 1);
        let field_name: i64 = load_ptr(expr, 2);

        // Generate object value (pointer as i64)
        let obj_val: i64 = gen_expr(cg, object);

        // Convert i64 to ptr
        let ptr_temp: i64 = emit_i64_to_ptr(cg, obj_val);

        // For now, we need to figure out the struct type from context
        // We'll do a simple approach: try all structs and find one with this field
        let field_idx: i64 = lookup_field_in_all_structs(cg, field_name);
        let offset: i64 = field_idx * 8;

        // GEP to field
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr ");
        emit(cg, ptr_temp);
        emit(cg, ", i64 ");
        emit_line(cg, int_to_string(offset));

        // Load field value
        let load_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(load_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(load_t));
    }

    // Method call: expr.method(args)
    if tag == EXPR_METHOD_CALL() {
        let object: i64 = load_ptr(expr, 1);
        let method_name: i64 = load_ptr(expr, 2);
        let args: i64 = load_ptr(expr, 3);

        // Try to get the type of the object
        let type_name: i64 = 0;

        // If object is an identifier, look up its type
        let obj_tag: i64 = load_i64(object, 0);
        if obj_tag == EXPR_IDENT() {
            let obj_name: i64 = load_ptr(object, 1);
            type_name = lookup_var_type(cg, obj_name);
        }

        // Generate object value (this will be the first argument)
        let obj_val: i64 = gen_expr(cg, object);

        // Generate remaining arguments
        let arg_values: i64 = vec_new();
        let n: i64 = vec_len(args);
        let i: i64 = 0;
        while i < n {
            let arg: i64 = vec_get(args, i);
            let val: i64 = gen_expr(cg, arg);
            vec_push(arg_values, val);
            i = i + 1;
        }

        // Check if this is a dyn trait object (Phase 32 dynamic dispatch)
        if is_dyn_type(type_name) != 0 {
            // Dynamic dispatch through vtable
            // dyn object layout: data_ptr(0), vtable_ptr(8)
            let trait_name: i64 = extract_dyn_trait(type_name);
            let method_idx: i64 = cg_get_vtable_method_index(cg, trait_name, method_name);

            // obj_val is a fat pointer (16 bytes): data_ptr + vtable_ptr
            // Convert to ptr to access fields
            let fat_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            // Load data pointer (offset 0)
            let data_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(data_ptr_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(fat_ptr_t));

            // Load vtable pointer (offset 8)
            let vtable_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_gep_t));
            emit(cg, " = getelementptr i8, ptr %t");
            emit(cg, int_to_string(fat_ptr_t));
            emit_line(cg, ", i64 8");

            let vtable_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(vtable_gep_t));

            // Index into vtable to get function pointer
            let fn_gep_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_gep_t));
            emit(cg, " = getelementptr ptr, ptr %t");
            emit(cg, int_to_string(vtable_ptr_t));
            emit(cg, ", i64 ");
            emit_line(cg, int_to_string(method_idx));

            let fn_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, " = load ptr, ptr %t");
            emit_line(cg, int_to_string(fn_gep_t));

            // Call through function pointer
            let t: i64 = cg_next_temp(cg);
            let temp: i64 = string_concat("%t", int_to_string(t));

            emit(cg, "  ");
            emit(cg, temp);
            emit(cg, " = call i64 %t");
            emit(cg, int_to_string(fn_ptr_t));
            emit(cg, "(i64 %t");
            emit(cg, int_to_string(data_ptr_t));

            // Additional arguments
            let total_args: i64 = vec_len(arg_values);
            i = 0;
            while i < total_args {
                emit(cg, ", i64 ");
                emit(cg, vec_get(arg_values, i));
                i = i + 1;
            }
            emit_line(cg, ")");

            return temp;
        }

        // ===== PHASE 36: INLINE OPTION METHODS =====
        // Handle Option<T> methods inline (is_some, is_none, unwrap, unwrap_or)
        let base_type: i64 = extract_base_type(type_name);
        if string_eq(base_type, string_from("Option")) {
            // Option layout: tag at offset 0 (0=None, 1=Some), value at offset 8
            let opt_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(opt_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(opt_ptr_t));

            if string_eq(method_name, string_from("is_some")) {
                // tag == 1 means Some
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_none")) {
                // tag == 0 means None
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Some, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_some_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let some_lbl: i64 = string_concat("unwrap_or_some", int_to_string(lbl));
                let none_lbl: i64 = string_concat("unwrap_or_none", int_to_string(lbl));
                let done_lbl: i64 = string_concat("unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_some_t));
                emit(cg, ", label %");
                emit(cg, some_lbl);
                emit(cg, ", label %");
                emit_line(cg, none_lbl);

                emit(cg, some_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(opt_ptr_t));
                emit_line(cg, ", i64 8");
                let some_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, none_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(some_val_t));
                emit(cg, ", %");
                emit(cg, some_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, none_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // ===== PHASE 36: INLINE RESULT METHODS =====
        // Handle Result<T,E> methods inline (is_ok, is_err, unwrap, unwrap_err, unwrap_or)
        if string_eq(base_type, string_from("Result")) {
            // Result layout: tag at offset 0 (0=Err, 1=Ok), value at offset 8
            let res_ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(res_ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, obj_val);
            emit_line(cg, " to ptr");

            let tag_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(tag_t));
            emit(cg, " = load i64, ptr %t");
            emit_line(cg, int_to_string(res_ptr_t));

            if string_eq(method_name, string_from("is_ok")) {
                // tag == 1 means Ok
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("is_err")) {
                // tag == 0 means Err
                let cmp_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(cmp_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 0");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = zext i1 %t");
                emit(cg, int_to_string(cmp_t));
                emit_line(cg, " to i64");
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap")) {
                // Return value at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_err")) {
                // Return error at offset 8
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                return string_concat("%t", int_to_string(result_t));
            }

            if string_eq(method_name, string_from("unwrap_or")) {
                // Return value if Ok, else default
                let default_val: i64 = string_from("0");
                if vec_len(arg_values) > 0 {
                    default_val = vec_get(arg_values, 0);
                }
                let is_ok_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, " = icmp eq i64 %t");
                emit(cg, int_to_string(tag_t));
                emit_line(cg, ", 1");

                let lbl: i64 = cg_next_label(cg);
                let ok_lbl: i64 = string_concat("result_unwrap_or_ok", int_to_string(lbl));
                let err_lbl: i64 = string_concat("result_unwrap_or_err", int_to_string(lbl));
                let done_lbl: i64 = string_concat("result_unwrap_or_done", int_to_string(lbl));

                emit(cg, "  br i1 %t");
                emit(cg, int_to_string(is_ok_t));
                emit(cg, ", label %");
                emit(cg, ok_lbl);
                emit(cg, ", label %");
                emit_line(cg, err_lbl);

                emit(cg, ok_lbl);
                emit_line(cg, ":");
                let gep_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(gep_t));
                emit(cg, " = getelementptr i8, ptr %t");
                emit(cg, int_to_string(res_ptr_t));
                emit_line(cg, ", i64 8");
                let ok_val_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, " = load i64, ptr %t");
                emit_line(cg, int_to_string(gep_t));
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, err_lbl);
                emit_line(cg, ":");
                emit(cg, "  br label %");
                emit_line(cg, done_lbl);

                emit(cg, done_lbl);
                emit_line(cg, ":");
                let result_t: i64 = cg_next_temp(cg);
                emit(cg, "  %t");
                emit(cg, int_to_string(result_t));
                emit(cg, " = phi i64 [ %t");
                emit(cg, int_to_string(ok_val_t));
                emit(cg, ", %");
                emit(cg, ok_lbl);
                emit(cg, " ], [ ");
                emit(cg, default_val);
                emit(cg, ", %");
                emit(cg, err_lbl);
                emit_line(cg, " ]");
                return string_concat("%t", int_to_string(result_t));
            }
        }

        // Static dispatch - build mangled function name: TypeName_methodName
        let callee_name: i64 = method_name;
        if type_name != 0 {
            callee_name = string_concat(type_name, string_concat(string_from("_"), method_name));
        }

        // Emit call - object is first argument
        let t: i64 = cg_next_temp(cg);
        let temp: i64 = string_concat("%t", int_to_string(t));

        emit(cg, "  ");
        emit(cg, temp);
        emit(cg, " = call i64 @\"");
        emit(cg, callee_name);
        emit(cg, "\"(i64 ");
        emit(cg, obj_val);

        let total_args: i64 = vec_len(arg_values);
        i = 0;
        while i < total_args {
            emit(cg, ", i64 ");
            emit(cg, vec_get(arg_values, i));
            i = i + 1;
        }
        emit_line(cg, ")");

        return temp;
    }

    // Try operator: expr? - check Result tag and early return on Err
    // Result layout: tag(0=Err, 1=Ok) at offset 0, value at offset 8
    if tag == EXPR_TRY() {
        let inner: i64 = load_ptr(expr, 1);
        let inner_val: i64 = gen_expr(cg, inner);

        // Convert i64 to ptr
        let ptr_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ptr_t));
        emit(cg, " = inttoptr i64 ");
        emit(cg, inner_val);
        emit_line(cg, " to ptr");

        // Load the tag (field 0)
        let tag_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tag_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(ptr_t));

        // Check if tag == 0 (Err)
        let cmp_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, " = icmp eq i64 %t");
        emit(cg, int_to_string(tag_t));
        emit_line(cg, ", 0");

        // Labels for conditional
        let label: i64 = cg_next_label(cg);
        let err_label: i64 = string_concat("try_err", int_to_string(label));
        let ok_label: i64 = string_concat("try_ok", int_to_string(label));

        // Branch: if Err goto err_label, else goto ok_label
        emit(cg, "  br i1 %t");
        emit(cg, int_to_string(cmp_t));
        emit(cg, ", label %");
        emit(cg, err_label);
        emit(cg, ", label %");
        emit_line(cg, ok_label);

        // Error path: early return the Result
        emit(cg, err_label);
        emit_line(cg, ":");
        emit(cg, "  ret i64 ");
        emit_line(cg, inner_val);

        // Ok path: unwrap the value (field 1, offset 8)
        emit(cg, ok_label);
        emit_line(cg, ":");
        let gep_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(gep_t));
        emit(cg, " = getelementptr i8, ptr %t");
        emit(cg, int_to_string(ptr_t));
        emit_line(cg, ", i64 8");
        let val_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(val_t));
        emit(cg, " = load i64, ptr %t");
        emit_line(cg, int_to_string(gep_t));

        return string_concat("%t", int_to_string(val_t));
    }

    // EXPR_AWAIT - await a future
    if tag == EXPR_AWAIT() {
        let inner: i64 = load_ptr(expr, 1);
        let future_val: i64 = gen_expr(cg, inner);

        // For async context, we generate a state transition
        // For sync context, we poll in a loop until ready

        if cg_is_async_fn(cg) != 0 {
            // Inside async function - generate state machine transition
            let state_num: i64 = cg_next_async_state(cg);
            let resume_label: i64 = string_concat("await_resume_", int_to_string(state_num));

            // Save current state number
            emit(cg, "  store i64 ");
            emit(cg, int_to_string(state_num));
            emit_line(cg, ", ptr %async_state");

            // Store the future we're awaiting
            emit(cg, "  store i64 ");
            emit(cg, future_val);
            emit_line(cg, ", ptr %async_inner_future");

            // Record this await point for the dispatch switch
            cg_add_await_point(cg, state_num, resume_label);

            // Poll the inner future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check poll result: 0 = Pending, 1 = Ready(value)
            let is_ready: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, " = and i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(is_ready));
            emit_line(cg, ", 0");

            let pending_label: i64 = string_concat("await_pending_", int_to_string(state_num));
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, pending_label);
            emit(cg, ", label %");
            emit_line(cg, resume_label);

            // Pending path - return Pending from poll
            emit(cg, pending_label);
            emit_line(cg, ":");
            emit_line(cg, "  ret i64 0");  // Return Pending

            // Ready path - continue execution
            emit(cg, resume_label);
            emit_line(cg, ":");

            // Extract the value (shift right to remove tag bit)
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        } else {
            // Synchronous context - poll in a loop until ready
            let loop_label: i64 = string_concat("await_loop_", int_to_string(cg_next_label(cg)));
            let done_label: i64 = string_concat("await_done_", int_to_string(cg_next_label(cg)));

            emit(cg, "  br label %");
            emit_line(cg, loop_label);

            emit(cg, loop_label);
            emit_line(cg, ":");

            // Poll the future
            let poll_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(poll_t));
            emit(cg, " = call i64 @future_poll(i64 ");
            emit(cg, future_val);
            emit_line(cg, ")");

            // Check if ready
            let is_pending: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, " = icmp eq i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 0");

            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(is_pending));
            emit(cg, ", label %");
            emit(cg, loop_label);
            emit(cg, ", label %");
            emit_line(cg, done_label);

            emit(cg, done_label);
            emit_line(cg, ":");

            // Extract the value
            let val_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(val_t));
            emit(cg, " = lshr i64 %t");
            emit(cg, int_to_string(poll_t));
            emit_line(cg, ", 1");

            return string_concat("%t", int_to_string(val_t));
        }
    }

    // EXPR_SPAWN - spawn an actor/specialist
    if tag == EXPR_SPAWN() {
        let type_name: i64 = load_ptr(expr, 1);
        // Generate call to TypeName_new() constructor
        let ctor_name: i64 = string_concat(type_name, "_new");
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @\"");
        emit(cg, ctor_name);
        emit_line(cg, "\"()");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_FLOAT - floating point literal
    if tag == EXPR_FLOAT() {
        let text: i64 = load_ptr(expr, 1);
        // Convert float string to f64 bits, store in i64
        // Use f64_parse intrinsic to convert string to f64 bits
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = call i64 @f64_parse(ptr ");
        // Add string constant
        let str_idx: i64 = cg_add_string(cg, text);
        emit(cg, "@.str.mod.");
        emit(cg, int_to_string(str_idx));
        emit_line(cg, ")");
        return string_concat("%t", int_to_string(result_t));
    }

    // EXPR_ARRAY - array literal [a, b, c]
    if tag == EXPR_ARRAY() {
        let elements: i64 = load_ptr(expr, 1);
        let len: i64 = vec_len(elements);
        // Create a new vector and push all elements
        let vec_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " = call ptr @intrinsic_vec_new()");
        // Push each element
        let i: i64 = 0;
        while i < len {
            let elem: i64 = vec_get(elements, i);
            let elem_val: i64 = gen_expr(cg, elem);
            // Convert i64 to ptr for vec_push
            let ptr_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(ptr_t));
            emit(cg, " = inttoptr i64 ");
            emit(cg, elem_val);
            emit_line(cg, " to ptr");
            emit(cg, "  call void @intrinsic_vec_push(ptr %t");
            emit(cg, int_to_string(vec_t));
            emit(cg, ", ptr %t");
            emit(cg, int_to_string(ptr_t));
            emit_line(cg, ")");
            i = i + 1;
        }
        // Return the vector as i64
        let result_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(result_t));
        emit(cg, " = ptrtoint ptr %t");
        emit(cg, int_to_string(vec_t));
        emit_line(cg, " to i64");
        return string_concat("%t", int_to_string(result_t));
    }

    string_from("0")
}

// Generate if expression
fn gen_if(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let then_block: i64 = load_ptr(expr, 2);
    let else_block: i64 = load_ptr(expr, 3);

    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    let l: i64 = cg_next_label(cg);
    let then_lbl: i64 = string_concat("then", int_to_string(l));
    let then_end_lbl: i64 = string_concat("then", int_to_string(l));
    then_end_lbl = string_concat(then_end_lbl, "_end");
    let else_lbl: i64 = string_concat("else", int_to_string(l));
    let else_end_lbl: i64 = string_concat("else", int_to_string(l));
    else_end_lbl = string_concat(else_end_lbl, "_end");
    let end_lbl: i64 = string_concat("endif", int_to_string(l));

    // Branch
    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, then_lbl);
    emit(cg, ", label %");
    emit_line(cg, else_lbl);

    // Then block
    emit(cg, then_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let then_val: i64 = gen_block(cg, then_block);
    let then_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, then_end_lbl);
    // Then end block
    emit(cg, then_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // Else block
    emit(cg, else_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);
    let else_val: i64 = string_from("0");
    if else_block != 0 {
        else_val = gen_expr(cg, else_block);
    }
    let else_terminated: bool = cg_is_terminated(cg);
    // Even if terminated, emit dead branch for phi predecessor consistency
    emit(cg, "  br label %");
    emit_line(cg, else_end_lbl);
    // Else end block
    emit(cg, else_end_lbl);
    emit_line(cg, ":");
    emit(cg, "  br label %");
    emit_line(cg, end_lbl);

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");
    cg_set_terminated(cg, false);

    // Phi with proper predecessor blocks
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = phi i64 [ ");
    emit(cg, then_val);
    emit(cg, ", %");
    emit(cg, then_end_lbl);
    emit(cg, " ], [ ");
    emit(cg, else_val);
    emit(cg, ", %");
    emit(cg, else_end_lbl);
    emit_line(cg, " ]");

    temp
}

// Generate while expression
fn gen_while(cg: i64, expr: i64) -> i64 {
    let cond: i64 = load_ptr(expr, 1);
    let body: i64 = load_ptr(expr, 2);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("loop", int_to_string(l));
    let body_lbl: i64 = string_concat("body", int_to_string(l));
    let end_lbl: i64 = string_concat("endloop", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition
    emit(cg, loop_lbl);
    emit_line(cg, ":");
    let cond_val: i64 = gen_expr(cg, cond);

    // Convert i64 to i1 for branch
    let cond_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, " = icmp ne i64 ");
    emit(cg, cond_val);
    emit_line(cg, ", 0");

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cond_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, loop_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate for expression: for i in start..end { body }
// Desugars to: let i = start; while i < end { body; i = i + 1; }
fn gen_for(cg: i64, expr: i64) -> i64 {
    let var_name: i64 = load_ptr(expr, 1);
    let start_expr: i64 = load_ptr(expr, 2);
    let end_expr: i64 = load_ptr(expr, 3);
    let body: i64 = load_ptr(expr, 4);

    // Generate start value
    let start_val: i64 = gen_expr(cg, start_expr);

    // Use pre-allocated local for loop variable
    let unique_name: i64 = cg_pop_alloca(cg);
    if unique_name == 0 {
        // Fallback: allocate inline (shouldn't happen with proper pre-pass)
        let local_id: i64 = cg_next_temp(cg);
        unique_name = string_concat(var_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
    }
    // Initialize loop variable
    emit(cg, "  store i64 ");
    emit(cg, start_val);
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);
    add_local(cg, var_name, unique_name);

    // Generate end value (before the loop since it's evaluated once)
    let end_val: i64 = gen_expr(cg, end_expr);

    let l: i64 = cg_next_label(cg);
    let loop_lbl: i64 = string_concat("for", int_to_string(l));
    let body_lbl: i64 = string_concat("forbody", int_to_string(l));
    let inc_lbl: i64 = string_concat("forinc", int_to_string(l));
    let end_lbl: i64 = string_concat("endfor", int_to_string(l));

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // Loop header - condition: i < end
    emit(cg, loop_lbl);
    emit_line(cg, ":");

    // Load current loop variable
    let cur_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    // Compare i < end
    let cmp_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, " = icmp slt i64 %t");
    emit(cg, int_to_string(cur_t));
    emit(cg, ", ");
    emit_line(cg, end_val);

    emit(cg, "  br i1 %t");
    emit(cg, int_to_string(cmp_t));
    emit(cg, ", label %");
    emit(cg, body_lbl);
    emit(cg, ", label %");
    emit_line(cg, end_lbl);

    // Loop body - push loop context for break/continue
    emit(cg, body_lbl);
    emit_line(cg, ":");
    push_loop(cg, inc_lbl, end_lbl);
    gen_block(cg, body);
    pop_loop(cg);
    emit(cg, "  br label %");
    emit_line(cg, inc_lbl);

    // Increment loop variable: i = i + 1
    emit(cg, inc_lbl);
    emit_line(cg, ":");
    let load_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(load_t));
    emit(cg, " = load i64, ptr %local.");
    emit_line(cg, unique_name);

    let inc_t: i64 = cg_next_temp(cg);
    emit(cg, "  %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, " = add i64 %t");
    emit(cg, int_to_string(load_t));
    emit_line(cg, ", 1");

    emit(cg, "  store i64 %t");
    emit(cg, int_to_string(inc_t));
    emit(cg, ", ptr %local.");
    emit_line(cg, unique_name);

    emit(cg, "  br label %");
    emit_line(cg, loop_lbl);

    // End
    emit(cg, end_lbl);
    emit_line(cg, ":");

    string_from("0")
}

// Generate match expression
// Lowered to a series of if-else comparisons
fn gen_match(cg: i64, expr: i64) -> i64 {
    let scrutinee: i64 = load_ptr(expr, 1);
    let arms: i64 = load_ptr(expr, 2);
    let num_arms: i64 = vec_len(arms);

    // Evaluate scrutinee once
    let scru_val: i64 = gen_expr(cg, scrutinee);

    let l: i64 = cg_next_label(cg);
    let end_lbl: i64 = string_concat("matchend", int_to_string(l));

    // Collect arm labels and results for phi
    let arm_labels: i64 = vec_new();
    let arm_results: i64 = vec_new();

    // Process each arm
    let i: i64 = 0;
    while i < num_arms {
        let arm: i64 = vec_get(arms, i);
        let pattern: i64 = load_ptr(arm, 0);
        let result: i64 = load_ptr(arm, 1);

        let arm_lbl: i64 = string_concat("arm", int_to_string(l));
        arm_lbl = string_concat(arm_lbl, string_concat("_", int_to_string(i)));
        let arm_end_lbl: i64 = string_concat(arm_lbl, "_end");
        let next_lbl: i64 = string_concat("arm", int_to_string(l));
        next_lbl = string_concat(next_lbl, string_concat("_", int_to_string(i + 1)));

        // Check if this is the last arm or wildcard
        let is_last: i64 = i == num_arms - 1;
        let is_wildcard: i64 = pattern == 0;

        if is_wildcard != 0 {
            // Wildcard - unconditional jump to arm
            emit(cg, "  br label %");
            emit_line(cg, arm_lbl);
        } else {
            // Generate pattern value
            let pat_val: i64 = gen_expr(cg, pattern);

            // Compare scrutinee == pattern
            let cmp_t: i64 = cg_next_temp(cg);
            emit(cg, "  %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, " = icmp eq i64 ");
            emit(cg, scru_val);
            emit(cg, ", ");
            emit_line(cg, pat_val);

            // Branch: if match goto arm, else goto next/end
            emit(cg, "  br i1 %t");
            emit(cg, int_to_string(cmp_t));
            emit(cg, ", label %");
            emit(cg, arm_lbl);
            emit(cg, ", label %");
            if is_last != 0 {
                // Last arm without wildcard - shouldn't happen in well-formed match
                emit_line(cg, end_lbl);
            } else {
                emit_line(cg, next_lbl);
            }
        }

        // Arm body
        emit(cg, arm_lbl);
        emit_line(cg, ":");
        cg_set_terminated(cg, false);
        let arm_val: i64 = gen_expr(cg, result);
        emit(cg, "  br label %");
        emit_line(cg, arm_end_lbl);

        // Arm end block for phi
        emit(cg, arm_end_lbl);
        emit_line(cg, ":");
        emit(cg, "  br label %");
        emit_line(cg, end_lbl);

        vec_push(arm_labels, arm_end_lbl);
        vec_push(arm_results, arm_val);

        i = i + 1;
    }

    // End block with phi
    emit(cg, end_lbl);
    emit_line(cg, ":");

    let result_t: i64 = cg_next_temp(cg);
    let result_temp: i64 = string_concat("%t", int_to_string(result_t));
    emit(cg, "  ");
    emit(cg, result_temp);
    emit(cg, " = phi i64 ");

    i = 0;
    while i < num_arms {
        if i > 0 {
            emit(cg, ", ");
        }
        emit(cg, "[ ");
        emit(cg, vec_get(arm_results, i));
        emit(cg, ", %");
        emit(cg, vec_get(arm_labels, i));
        emit(cg, " ]");
        i = i + 1;
    }
    emit_line(cg, "");

    result_temp
}

// Generate block
fn gen_block(cg: i64, block: i64) -> i64 {
    let stmts: i64 = load_ptr(block, 1);
    let result: i64 = load_ptr(block, 2);

    let n: i64 = vec_len(stmts);
    let i: i64 = 0;
    while i < n {
        let stmt: i64 = vec_get(stmts, i);
        gen_stmt(cg, stmt);
        i = i + 1;
    }

    if result != 0 {
        return gen_expr(cg, result);
    }

    string_from("0")
}

// Generate statement
fn gen_stmt(cg: i64, stmt: i64) -> i64 {
    let tag: i64 = load_i64(stmt, 0);

    // Let statement
    if tag == STMT_LET() {
        let name: i64 = load_ptr(stmt, 1);
        let ty: i64 = load_ptr(stmt, 2);
        let init_expr: i64 = load_ptr(stmt, 3);

        // Use pre-allocated local from entry block
        let unique_name: i64 = cg_pop_alloca(cg);
        if unique_name == 0 {
            // Fallback: allocate inline (shouldn't happen with proper pre-pass)
            let local_id: i64 = cg_next_temp(cg);
            unique_name = string_concat(name, string_concat(".", int_to_string(local_id)));
            emit(cg, "  %local.");
            emit(cg, unique_name);
            emit_line(cg, " = alloca i64");
        }
        add_local(cg, name, unique_name);

        // Record type if present (for method call resolution)
        if ty != 0 {
            add_var_type(cg, name, ty);
        }

        // Initialize if there's an init expression
        if init_expr != 0 {
            let val: i64 = gen_expr(cg, init_expr);
            emit(cg, "  store i64 ");
            emit(cg, val);
            emit(cg, ", ptr %local.");
            emit_line(cg, unique_name);
        }
        return 0;
    }

    // Expression statement
    if tag == STMT_EXPR() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            gen_expr(cg, expr);
        }
        return 0;
    }

    // Return statement
    if tag == STMT_RETURN() {
        let expr: i64 = load_ptr(stmt, 1);
        if expr != 0 {
            let val: i64 = gen_expr(cg, expr);
            emit(cg, "  ret i64 ");
            emit_line(cg, val);
        } else {
            emit_line(cg, "  ret void");
        }
        cg_set_terminated(cg, true);
        return 0;
    }

    // Assignment statement
    if tag == STMT_ASSIGN() {
        let name: i64 = load_ptr(stmt, 1);
        let value: i64 = load_ptr(stmt, 2);
        let val: i64 = gen_expr(cg, value);
        let unique_name: i64 = lookup_local(cg, name);
        emit(cg, "  store i64 ");
        emit(cg, val);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        return 0;
    }

    // Break statement
    if tag == STMT_BREAK() {
        let break_lbl: i64 = current_loop_break(cg);
        if break_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, break_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_break");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    // Continue statement
    if tag == STMT_CONTINUE() {
        let continue_lbl: i64 = current_loop_continue(cg);
        if continue_lbl != 0 {
            emit(cg, "  br label %");
            emit_line(cg, continue_lbl);
            // Create unreachable block to avoid LLVM errors
            let l: i64 = cg_next_label(cg);
            emit(cg, "after_continue");
            emit(cg, int_to_string(l));
            emit_line(cg, ":");
        }
        return 0;
    }

    0
}

// Generate async function as a Future with poll method
fn gen_async_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Future struct: poll_fn(0), state(8), inner_future(16), result(24), params(32+), locals...
    let future_name: i64 = string_concat(name, "_Future");

    // Set async context
    cg_set_async_fn(cg, 1);
    cg_set_async_fn_name(cg, name);
    cg_reset_async_state(cg);
    cg_clear_await_points(cg);
    cg_clear_locals(cg);

    // Generate the constructor function that creates the future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit(cg, "\"(");

    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Allocate future struct: poll_fn + state + inner_future + result + params + locals
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let struct_size: i64 = 32 + n * 8 + num_locals * 8;  // 4 fields + params + locals

    emit(cg, "  %future = call ptr @malloc(i64 ");
    emit(cg, int_to_string(struct_size));
    emit_line(cg, ")");

    // Store poll function pointer at offset 0
    emit(cg, "  %poll_fn_ptr = ptrtoint ptr @\"");
    emit(cg, name);
    emit_line(cg, "_poll\" to i64");
    emit_line(cg, "  store i64 %poll_fn_ptr, ptr %future");

    // Initialize state to 0 at offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  store i64 0, ptr %state_ptr");

    // Store parameters in future struct (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %param_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %param_ptr_");
        emit_line(cg, int_to_string(i));
        i = i + 1;
    }

    // Return the future pointer as i64
    emit_line(cg, "  %result = ptrtoint ptr %future to i64");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate the poll function for this future
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_poll\"(i64 %future_ptr) {");
    emit_line(cg, "entry:");

    // Convert future_ptr to actual pointer
    emit_line(cg, "  %future = inttoptr i64 %future_ptr to ptr");

    // Allocate async state tracking
    emit_line(cg, "  %async_state = alloca i64");
    emit_line(cg, "  %async_inner_future = alloca i64");

    // Load current state from offset 8
    emit_line(cg, "  %state_ptr = getelementptr i8, ptr %future, i64 8");
    emit_line(cg, "  %state = load i64, ptr %state_ptr");
    emit_line(cg, "  store i64 %state, ptr %async_state");

    // Load parameters from future struct into locals (starting at offset 32)
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let offset: i64 = 32 + i * 8;
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  %param_load_ptr_");
        emit(cg, int_to_string(i));
        emit(cg, " = getelementptr i8, ptr %future, i64 ");
        emit_line(cg, int_to_string(offset));
        emit(cg, "  %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, " = load i64, ptr %param_load_ptr_");
        emit_line(cg, int_to_string(i));
        emit(cg, "  store i64 %param_val_");
        emit(cg, int_to_string(i));
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);
        i = i + 1;
    }

    // Pre-allocate locals
    cg_clear_alloca_queue(cg);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // State dispatch switch
    emit_line(cg, "  switch i64 %state, label %state_0 [");
    emit_line(cg, "    i64 0, label %state_0");
    emit_line(cg, "  ]");

    // State 0 - start of function
    emit_line(cg, "state_0:");

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Return Ready with value (tagged: value << 1 | 1)
    if cg_is_terminated(cg) == false {
        let ret_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(ret_t));
        emit(cg, " = shl i64 ");
        emit(cg, result);
        emit_line(cg, ", 1");
        let tagged_t: i64 = cg_next_temp(cg);
        emit(cg, "  %t");
        emit(cg, int_to_string(tagged_t));
        emit(cg, " = or i64 %t");
        emit(cg, int_to_string(ret_t));
        emit_line(cg, ", 1");
        emit(cg, "  ret i64 %t");
        emit_line(cg, int_to_string(tagged_t));
    }

    emit_line(cg, "}");
    emit_line(cg, "");

    // Reset async context
    cg_set_async_fn(cg, 0);

    0
}

// Generate function
fn gen_fn(cg: i64, fn_def: i64) -> i64 {
    let name: i64 = load_ptr(fn_def, 1);
    let type_params: i64 = load_ptr(fn_def, 2);  // Generic type params (or 0)
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);
    let is_async: i64 = load_i64(fn_def, 6);

    // If this is a generic function, register it but don't generate code yet
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            cg_register_generic(cg, name, fn_def);
            return 0;
        }
    }

    // Handle async functions
    if is_async != 0 {
        return gen_async_fn(cg, fn_def);
    }

    // Rename main to simplex_main
    let emit_name: i64 = name;
    if string_eq(name, "main") {
        emit_name = string_from("simplex_main");
    }

    cg_clear_locals(cg);

    // Function signature
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, emit_name);
    emit(cg, "\"(");

    // Parameters
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate ALL local variables in the entry block to avoid
    // allocas in loops/conditionals which cause stack corruption
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        cg_push_alloca(cg, unique_name);
        j = j + 1;
    }

    // Copy params to locals
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "  %local.");
        emit(cg, pname);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, pname);
        add_local(cg, pname, pname);  // Params use same name
        i = i + 1;
    }

    // Generate body
    cg_set_terminated(cg, false);
    let result: i64 = gen_block(cg, body);

    // Only emit final return if body didn't already terminate
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Generate a monomorphized instantiation of a generic function
fn gen_fn_instantiation(cg: i64, fn_def: i64, mangled_name: i64, type_args: i64) -> i64 {
    let type_params: i64 = load_ptr(fn_def, 2);
    let params: i64 = load_ptr(fn_def, 3);
    let ret_ty: i64 = load_ptr(fn_def, 4);
    let body: i64 = load_ptr(fn_def, 5);

    // Check trait bounds before proceeding
    if check_trait_bounds(cg, type_params, type_args) == 0 {
        println(string_concat("  in instantiation of: ", mangled_name));
        // Continue anyway for now - error was already printed
    }

    cg_clear_locals(cg);
    cg_clear_const_params(cg);
    cg_clear_type_params(cg);

    // Set up type params and const params from type_params and type_args
    // type_params has names like "T", "T:Trait" (bounded), or "const:N"
    // type_args has corresponding values like "i64" or "10"
    if type_params != 0 {
        if type_args != 0 {
            let num_type_params: i64 = vec_len(type_params);
            let tp_idx: i64 = 0;
            while tp_idx < num_type_params {
                let type_param: i64 = vec_get(type_params, tp_idx);
                // Check if this is a const param (has "const:" prefix)
                if string_starts_with(type_param, string_from("const:")) {
                    // Extract the name after "const:"
                    let const_name: i64 = string_slice(type_param, 6, string_len(type_param));
                    // Get the corresponding value from type_args
                    if tp_idx < vec_len(type_args) {
                        let const_value: i64 = vec_get(type_args, tp_idx);
                        cg_add_const_param(cg, const_name, const_value);
                    }
                } else {
                    // Regular type parameter (e.g., "T" or "T:Trait")
                    // Extract just the param name (before any : for bound)
                    let param_name: i64 = extract_type_param_name(type_param);
                    // Get the corresponding concrete type from type_args
                    if tp_idx < vec_len(type_args) {
                        let concrete_type: i64 = vec_get(type_args, tp_idx);
                        cg_add_type_param(cg, param_name, concrete_type);
                    }
                }
                tp_idx = tp_idx + 1;
            }
        }
    }

    // Function signature with mangled name
    emit(cg, "define ");
    if ret_ty != 0 {
        emit(cg, "i64");
    } else {
        emit(cg, "void");
    }
    emit(cg, " @\"");
    emit(cg, mangled_name);
    emit(cg, "\"(");

    // Parameters (all i64 in bootstrap compiler)
    let n: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n {
        if i > 0 { emit(cg, ", "); }
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        emit(cg, "i64 %");
        emit(cg, pname);
        i = i + 1;
    }
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Pre-allocate local variables
    cg_clear_alloca_queue(cg);
    let all_locals: i64 = collect_locals_from_block(body);
    let num_locals: i64 = vec_len(all_locals);
    let j: i64 = 0;
    while j < num_locals {
        let local_name: i64 = vec_get(all_locals, j);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(local_name, string_concat(".", int_to_string(local_id)));
        add_local(cg, local_name, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        j = j + 1;
    }

    // Copy parameters to local variables
    i = 0;
    while i < n {
        let param: i64 = vec_get(params, i);
        let pname: i64 = load_ptr(param, 0);
        let local_id: i64 = cg_next_temp(cg);
        let unique_name: i64 = string_concat(pname, string_concat(".", int_to_string(local_id)));
        add_local(cg, pname, unique_name);
        cg_push_alloca(cg, unique_name);
        emit(cg, "  %local.");
        emit(cg, unique_name);
        emit_line(cg, " = alloca i64");
        emit(cg, "  store i64 %");
        emit(cg, pname);
        emit(cg, ", ptr %local.");
        emit_line(cg, unique_name);
        i = i + 1;
    }

    cg_set_terminated(cg, false);

    // Generate body
    let result: i64 = gen_block(cg, body);

    // Return
    if cg_is_terminated(cg) == false {
        if ret_ty != 0 {
            emit(cg, "  ret i64 ");
            emit_line(cg, result);
        } else {
            emit_line(cg, "  ret void");
        }
    }

    emit_line(cg, "}");
    emit_line(cg, "");
    0
}

// Mangle a generic function name with type arguments
fn mangle_generic_name(name: i64, type_args: i64) -> i64 {
    let result: i64 = name;
    let n: i64 = vec_len(type_args);
    let i: i64 = 0;
    while i < n {
        result = string_concat(result, string_from("_"));
        result = string_concat(result, vec_get(type_args, i));
        i = i + 1;
    }
    result
}

// Generate enum (just register it)
fn gen_enum(cg: i64, enum_def: i64) -> i64 {
    let name: i64 = load_ptr(enum_def, 1);
    let variants: i64 = load_ptr(enum_def, 2);
    register_enum(cg, name, variants);
    0
}

// Generate struct (register it or store as template if generic)
fn gen_struct(cg: i64, struct_def: i64) -> i64 {
    let name: i64 = load_ptr(struct_def, 1);
    let type_params: i64 = load_ptr(struct_def, 2);
    let fields: i64 = load_ptr(struct_def, 3);

    // Check if this is a generic struct
    if type_params != 0 {
        if vec_len(type_params) > 0 {
            // Store as template for later monomorphization
            cg_add_generic_struct_template(cg, name, type_params, fields);
            return 0;
        }
    }

    // Non-generic struct: register immediately
    register_struct(cg, name, fields);
    0
}

// Generate impl block
// Methods are generated with mangled names: TypeName_methodName
fn gen_impl(cg: i64, impl_def: i64) -> i64 {
    let type_name: i64 = load_ptr(impl_def, 1);
    let methods: i64 = load_ptr(impl_def, 2);
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Get method name and mangle it: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = string_concat(type_name, string_concat(string_from("_"), method_name));
        // Store mangled name back into the method AST
        store_ptr(method, 1, mangled_name);
        // Generate the function
        gen_fn(cg, method);
        i = i + 1;
    }

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate trait (just a declaration, no code)
fn gen_trait(cg: i64, trait_def: i64) -> i64 {
    // Register trait and its default methods for later use
    let name: i64 = load_ptr(trait_def, 1);
    let method_sigs: i64 = load_ptr(trait_def, 2);

    // Register trait definition for vtable layout (Phase 32)
    cg_register_trait_def(cg, name, method_sigs);

    // Store default method implementations in codegen context
    let num_methods: i64 = vec_len(method_sigs);
    let i: i64 = 0;
    while i < num_methods {
        let method_sig: i64 = vec_get(method_sigs, i);
        // Default methods have fn_def at offset 3
        let fn_def: i64 = load_ptr(method_sig, 3);
        if fn_def != 0 {
            // This is a default method - register it
            let method_name: i64 = load_ptr(method_sig, 0);
            cg_register_default_method(cg, name, method_name, fn_def);
        }
        i = i + 1;
    }
    0
}

// Generate impl Trait for Type block
// Methods are named: TypeName_methodName (same as regular impl, for simplicity)
fn gen_impl_trait(cg: i64, impl_def: i64) -> i64 {
    let trait_name: i64 = load_ptr(impl_def, 1);
    let type_name: i64 = load_ptr(impl_def, 2);
    let methods: i64 = load_ptr(impl_def, 3);
    let assoc_types: i64 = load_ptr(impl_def, 4);

    // Register this trait implementation for bounds checking
    cg_register_trait_impl(cg, type_name, trait_name);

    // Register associated types for this impl
    if assoc_types != 0 {
        let num_assoc: i64 = vec_len(assoc_types);
        let j: i64 = 0;
        while j < num_assoc {
            let assoc: i64 = vec_get(assoc_types, j);
            let assoc_name: i64 = load_ptr(assoc, 0);
            let assoc_ty: i64 = load_ptr(assoc, 1);
            cg_register_assoc_type(cg, type_name, assoc_name, assoc_ty);
            j = j + 1;
        }
    }

    // Set current impl type for Self resolution in methods
    cg_set_current_impl_type(cg, type_name);

    // Build list of mangled method names for vtable generation
    let mangled_methods: i64 = vec_new();
    let num_methods: i64 = vec_len(methods);
    let i: i64 = 0;

    while i < num_methods {
        let method: i64 = vec_get(methods, i);
        // Mangle method name: TypeName_methodName
        let method_name: i64 = load_ptr(method, 1);
        let mangled_name: i64 = string_concat(type_name, string_concat(string_from("_"), method_name));
        store_ptr(method, 1, mangled_name);
        vec_push(mangled_methods, mangled_name);
        gen_fn(cg, method);
        i = i + 1;
    }

    // Generate vtable for this (type, trait) pair (Phase 32)
    gen_vtable(cg, type_name, trait_name, mangled_methods);

    // Clear current impl type
    cg_set_current_impl_type(cg, 0);
    0
}

// Generate a vtable global for dynamic dispatch (Phase 32)
// Layout: array of function pointers matching trait method order
fn gen_vtable(cg: i64, type_name: i64, trait_name: i64, impl_methods: i64) -> i64 {
    // Get trait method signatures for vtable ordering
    let trait_methods: i64 = cg_get_trait_methods(cg, trait_name);
    if trait_methods == 0 {
        // Trait not yet seen - will generate vtable later
        return 0;
    }

    let num_trait_methods: i64 = vec_len(trait_methods);
    if num_trait_methods == 0 {
        return 0;
    }

    // Vtable global name: @vtable_TypeName_TraitName
    let vtable_name: i64 = string_concat(string_from("@vtable_"), type_name);
    vtable_name = string_concat(vtable_name, string_from("_"));
    vtable_name = string_concat(vtable_name, trait_name);

    // Register vtable
    cg_register_vtable(cg, type_name, trait_name, vtable_name);

    // Generate vtable global: @vtable_Type_Trait = global [N x ptr] [ptr @Type_method1, ptr @Type_method2, ...]
    emit(cg, vtable_name);
    emit(cg, " = global [");
    emit(cg, int_to_string(num_trait_methods));
    emit(cg, " x ptr] [");

    // Match trait methods to impl methods and emit function pointers
    let i: i64 = 0;
    while i < num_trait_methods {
        if i > 0 {
            emit(cg, ", ");
        }
        let trait_sig: i64 = vec_get(trait_methods, i);
        let trait_method_name: i64 = load_ptr(trait_sig, 0);

        // Find corresponding impl method (TypeName_methodName)
        let mangled: i64 = string_concat(type_name, string_concat(string_from("_"), trait_method_name));
        emit(cg, "ptr @\"");
        emit(cg, mangled);
        emit(cg, "\"");
        i = i + 1;
    }

    emit_line(cg, "]");
    0
}

// Generate actor definition (Phase 33)
// Actors become struct + message handlers + mailbox functions
fn gen_actor(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let state_fields: i64 = load_ptr(item, 2);
    let handlers: i64 = load_ptr(item, 3);
    let init_fn: i64 = load_ptr(item, 4);

    emit(cg, "; Actor: ");
    emit_line(cg, name);

    // Register actor state as a struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate actor_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %actor = call ptr @malloc(i64 64)");
    emit_line(cg, "  %ret = ptrtoint ptr %actor to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate message handler functions
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);
            let params: i64 = load_ptr(handler, 1);
            let body: i64 = load_ptr(handler, 2);

            // Generate handler function: ActorName_handle_MsgName
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit_line(cg, "\"(i64 %self) {");
            emit_line(cg, "entry:");
            emit_line(cg, "  ret i64 0");
            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate specialist definition (Phase 33)
// Specialists are AI agents with capabilities and knowledge
fn gen_specialist(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let config: i64 = load_ptr(item, 2);
    let state_fields: i64 = load_ptr(item, 3);
    let handlers: i64 = load_ptr(item, 4);

    emit(cg, "; Specialist: ");
    emit_line(cg, name);

    // Register state fields as struct
    if state_fields != 0 {
        let n: i64 = vec_len(state_fields);
        let i: i64 = 0;
        while i < n {
            let field: i64 = vec_get(state_fields, i);
            let fname: i64 = load_ptr(field, 0);
            let ftype: i64 = load_ptr(field, 1);
            register_struct(cg, name, fname, ftype, i);
            i = i + 1;
        }
    }

    // Generate specialist_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %spec = call ptr @malloc(i64 64)");
    emit_line(cg, "  %ret = ptrtoint ptr %spec to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate infer function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_infer\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  ret i64 0");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate message handlers (like actor receive)
    if handlers != 0 {
        let n: i64 = vec_len(handlers);
        let i: i64 = 0;
        while i < n {
            let handler: i64 = vec_get(handlers, i);
            let msg_name: i64 = load_ptr(handler, 0);

            // Generate handler function
            emit(cg, "define i64 @\"");
            emit(cg, name);
            emit(cg, "_handle_");
            emit(cg, msg_name);
            emit_line(cg, "\"(i64 %self) {");
            emit_line(cg, "entry:");
            emit_line(cg, "  ret i64 0");
            emit_line(cg, "}");
            emit_line(cg, "");

            i = i + 1;
        }
    }

    0
}

// Generate hive definition (Phase 33)
// Hives orchestrate multiple specialists
fn gen_hive(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let specialists: i64 = load_ptr(item, 2);
    let routing: i64 = load_ptr(item, 3);

    emit(cg, "; Hive: ");
    emit_line(cg, name);

    // Generate hive_new function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %hive = call ptr @malloc(i64 128)");
    emit_line(cg, "  %ret = ptrtoint ptr %hive to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate dispatch function
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_dispatch\"(i64 %self, i64 %query) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  ret i64 0");
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate anima (cognitive soul)
// Layout: tag(0), name(1), identity(2), memory(3), beliefs(4), slm(5), persistence(6)
fn gen_anima(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let identity: i64 = load_ptr(item, 2);
    let memory: i64 = load_ptr(item, 3);
    let beliefs: i64 = load_ptr(item, 4);
    let slm: i64 = load_ptr(item, 5);
    let persistence: i64 = load_ptr(item, 6);

    emit(cg, "; Anima: ");
    emit_line(cg, name);

    // Generate anima_new function - creates a new anima instance
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"() {");
    emit_line(cg, "entry:");
    // Allocate anima struct: identity, memory stores, beliefs, slm, persistence
    emit_line(cg, "  %anima = call ptr @malloc(i64 256)");
    // Initialize memory stores
    emit_line(cg, "  %episodic = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %semantic = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %procedural = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %working = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %beliefs_store = call ptr @intrinsic_vec_new()");
    // Store memory stores in anima struct
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  store ptr %episodic, ptr %ep_ptr");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  store ptr %semantic, ptr %sem_ptr");
    emit_line(cg, "  %proc_ptr = getelementptr ptr, ptr %anima, i64 2");
    emit_line(cg, "  store ptr %procedural, ptr %proc_ptr");
    emit_line(cg, "  %work_ptr = getelementptr ptr, ptr %anima, i64 3");
    emit_line(cg, "  store ptr %working, ptr %work_ptr");
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  store ptr %beliefs_store, ptr %bel_ptr");
    emit_line(cg, "  %ret = ptrtoint ptr %anima to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate remember function - stores experience in episodic memory
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_remember\"(i64 %self, i64 %experience) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %ep_ptr = getelementptr ptr, ptr %anima, i64 0");
    emit_line(cg, "  %episodic = load ptr, ptr %ep_ptr");
    emit_line(cg, "  %exp = inttoptr i64 %experience to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %episodic, ptr %exp)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate learn function - stores fact in semantic memory
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_learn\"(i64 %self, i64 %fact) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %sem_ptr = getelementptr ptr, ptr %anima, i64 1");
    emit_line(cg, "  %semantic = load ptr, ptr %sem_ptr");
    emit_line(cg, "  %f = inttoptr i64 %fact to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %semantic, ptr %f)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate believe function - stores belief with confidence
    emit(cg, "define void @\"");
    emit(cg, name);
    emit_line(cg, "_believe\"(i64 %self, i64 %belief, i64 %confidence) {");
    emit_line(cg, "entry:");
    emit_line(cg, "  %anima = inttoptr i64 %self to ptr");
    emit_line(cg, "  %bel_ptr = getelementptr ptr, ptr %anima, i64 4");
    emit_line(cg, "  %beliefs = load ptr, ptr %bel_ptr");
    emit_line(cg, "  %b = inttoptr i64 %belief to ptr");
    emit_line(cg, "  call void @intrinsic_vec_push(ptr %beliefs, ptr %b)");
    emit_line(cg, "  ret void");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate recall_for function - goal-directed recall
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_recall_for\"(i64 %self, i64 %goal, i64 %context) {");
    emit_line(cg, "entry:");
    // For now, return empty vec - will be enhanced with SLM integration
    emit_line(cg, "  %results = call ptr @intrinsic_vec_new()");
    emit_line(cg, "  %ret = ptrtoint ptr %results to i64");
    emit_line(cg, "  ret i64 %ret");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate think function - SLM reasoning
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_think\"(i64 %self, i64 %question) {");
    emit_line(cg, "entry:");
    // For now, return the question - will be enhanced with SLM integration
    emit_line(cg, "  ret i64 %question");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate save function - persist anima to file
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_save\"(i64 %self, i64 %path) {");
    emit_line(cg, "entry:");
    // TODO: Implement serialization
    emit_line(cg, "  ret i64 1");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate load function - load anima from file
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit_line(cg, "_load\"(i64 %path) {");
    emit_line(cg, "entry:");
    // For now, create new anima - will be enhanced with deserialization
    emit(cg, "  %anima = call i64 @\"");
    emit(cg, name);
    emit_line(cg, "_new\"()");
    emit_line(cg, "  ret i64 %anima");
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate neural gate (differentiable control flow)
// Layout: tag(0), name(1), params(2), ret_ty(3), body(4),
//         requires(5), ensures(6), invariant(7), fallback(8),
//         hardware_target(9), anima_binding(10)
fn gen_neural_gate(cg: i64, item: i64) -> i64 {
    let name: i64 = load_ptr(item, 1);
    let params: i64 = load_ptr(item, 2);
    let ret_ty: i64 = load_ptr(item, 3);
    let body: i64 = load_ptr(item, 4);
    let requires: i64 = load_ptr(item, 5);
    let ensures: i64 = load_ptr(item, 6);
    let fallback: i64 = load_ptr(item, 8);
    let hw_target: i64 = load_i64(item, 9);
    let anima_binding: i64 = load_ptr(item, 10);

    // Register the gate with a default threshold of 0.5
    let gate_id: i64 = cg_register_neural_gate(cg, name, 0.5);

    emit(cg, "; Neural Gate: ");
    emit(cg, name);
    emit(cg, " (gate_id=");
    emit_i64(cg, gate_id);
    emit_line(cg, ")");

    // Generate the gate function
    // In training mode: uses sigmoid relaxation for differentiable comparisons
    // In inference mode: uses standard discrete comparisons
    emit(cg, "define i64 @\"");
    emit(cg, name);
    emit(cg, "\"(");

    // Emit parameters
    let n_params: i64 = vec_len(params);
    let i: i64 = 0;
    while i < n_params {
        let param: i64 = vec_get(params, i);
        let param_name: i64 = load_ptr(param, 0);
        let param_ty: i64 = load_ptr(param, 1);

        if i > 0 {
            emit(cg, ", ");
        }

        // Determine LLVM type from Simplex type
        let llvm_ty: i64 = string_from("i64");
        if param_ty != 0 {
            if string_eq(param_ty, string_from("f64")) {
                llvm_ty = string_from("double");
            }
            if string_eq(param_ty, string_from("bool")) {
                llvm_ty = string_from("i1");
            }
        }

        emit(cg, llvm_ty);
        emit(cg, " %");
        emit(cg, param_name);

        i = i + 1;
    }

    // Add tape parameter for training mode
    emit(cg, ", ptr %__tape");
    emit_line(cg, ") {");
    emit_line(cg, "entry:");

    // Check training mode
    emit_line(cg, "  ; Check compilation mode (training vs inference)");
    emit_line(cg, "  %mode = call i64 @neural_ir_get_mode()");
    emit_line(cg, "  %is_training = icmp eq i64 %mode, 1");
    emit_line(cg, "  br i1 %is_training, label %training_path, label %inference_path");
    emit_line(cg, "");

    // Training path: use soft/differentiable operations
    emit_line(cg, "training_path:");
    emit_line(cg, "  ; Training mode: differentiable sigmoid relaxation");

    // Generate training-mode body
    // For now, generate a sigmoid-based soft gate
    // The body is analyzed and comparisons are relaxed
    emit(cg, "  ; Gate ID: ");
    emit_i64(cg, gate_id);
    emit_line(cg, "");
    emit(cg, "  %gate_id = add i64 0, ");
    emit_i64(cg, gate_id);
    emit_line(cg, "");

    // Get temperature from tape
    emit_line(cg, "  %temp = call double @grad_tape_temperature(ptr %__tape)");

    // For a simple threshold gate: sigmoid((value - threshold) * temperature)
    // Generate training body - placeholder for now
    if n_params > 0 {
        let first_param: i64 = vec_get(params, 0);
        let first_name: i64 = load_ptr(first_param, 0);
        let first_ty: i64 = load_ptr(first_param, 1);

        if string_eq(first_ty, string_from("f64")) {
            // Use the parameter directly for threshold comparison
            emit(cg, "  %p0 = fadd double %");
            emit(cg, first_name);
            emit_line(cg, ", 0.0");
            emit_line(cg, "  %threshold = fadd double 0.5, 0.0  ; Default threshold");
            emit_line(cg, "  %diff = fsub double %p0, %threshold");
            emit_line(cg, "  %scaled = fmul double %diff, %temp");
            emit_line(cg, "  %neg_scaled = fsub double 0.0, %scaled");
            emit_line(cg, "  %exp_neg = call double @llvm.exp.f64(double %neg_scaled)");
            emit_line(cg, "  %one_plus_exp = fadd double 1.0, %exp_neg");
            emit_line(cg, "  %sigmoid = fdiv double 1.0, %one_plus_exp");
            emit_line(cg, "  ; Convert to i64 with scaling (multiply by 1000 for precision)");
            emit_line(cg, "  %scaled_result = fmul double %sigmoid, 1000.0");
            emit_line(cg, "  %train_result = fptosi double %scaled_result to i64");
        } else {
            emit_line(cg, "  %train_result = add i64 500, 0  ; Default 0.5 soft output");
        }
    } else {
        emit_line(cg, "  %train_result = add i64 500, 0  ; Default 0.5 soft output");
    }

    emit_line(cg, "  br label %exit");
    emit_line(cg, "");

    // Inference path: use hard/discrete operations
    emit_line(cg, "inference_path:");
    emit_line(cg, "  ; Inference mode: discrete comparison (zero overhead)");

    // Generate inference body - standard discrete comparison
    if n_params > 0 {
        let first_param: i64 = vec_get(params, 0);
        let first_name: i64 = load_ptr(first_param, 0);
        let first_ty: i64 = load_ptr(first_param, 1);

        if string_eq(first_ty, string_from("f64")) {
            emit(cg, "  %p0_inf = fadd double %");
            emit(cg, first_name);
            emit_line(cg, ", 0.0");
            emit_line(cg, "  %threshold_inf = fadd double 0.5, 0.0");
            emit_line(cg, "  %cmp = fcmp ogt double %p0_inf, %threshold_inf");
            emit_line(cg, "  %inf_result = select i1 %cmp, i64 1000, i64 0");
        } else {
            emit_line(cg, "  %inf_result = add i64 0, 0  ; Default false");
        }
    } else {
        emit_line(cg, "  %inf_result = add i64 0, 0  ; Default false");
    }

    emit_line(cg, "  br label %exit");
    emit_line(cg, "");

    // Exit block
    emit_line(cg, "exit:");
    emit_line(cg, "  %result = phi i64 [ %train_result, %training_path ], [ %inf_result, %inference_path ]");
    emit_line(cg, "  ret i64 %result");
    emit_line(cg, "}");
    emit_line(cg, "");

    // Generate gate metadata for runtime
    emit(cg, "; Neural Gate Metadata for '");
    emit(cg, name);
    emit_line(cg, "'");
    emit(cg, "@__neural_gate_");
    emit(cg, name);
    emit_line(cg, " = private unnamed_addr constant { i64, double, i64, ptr } {");
    emit(cg, "  i64 ");
    emit_i64(cg, gate_id);
    emit_line(cg, ",           ; gate_id");
    emit_line(cg, "  double 0.5,       ; initial threshold");
    if anima_binding != 0 {
        emit_line(cg, "  i64 1,            ; has anima binding");
        emit(cg, "  ptr @\"");
        emit(cg, anima_binding);
        emit_line(cg, "_believe\"  ; anima belief update function");
    } else {
        emit_line(cg, "  i64 0,            ; no anima binding");
        emit_line(cg, "  ptr null          ; no belief function");
    }
    emit_line(cg, "}");
    emit_line(cg, "");

    0
}

// Generate item
fn gen_item(cg: i64, item: i64) -> i64 {
    let tag: i64 = load_i64(item, 0);

    if tag == TAG_NEURAL_GATE() {
        return gen_neural_gate(cg, item);
    }
    if tag == TAG_FN() {
        return gen_fn(cg, item);
    }
    if tag == TAG_ENUM() {
        return gen_enum(cg, item);
    }
    if tag == TAG_STRUCT() {
        return gen_struct(cg, item);
    }
    if tag == TAG_IMPL() {
        return gen_impl(cg, item);
    }
    if tag == TAG_TRAIT() {
        return gen_trait(cg, item);
    }
    if tag == TAG_IMPL_TRAIT() {
        return gen_impl_trait(cg, item);
    }
    // TAG_MOD and TAG_USE don't generate code - they're for the build system
    if tag == TAG_MOD() {
        return 0;
    }
    if tag == TAG_USE() {
        return 0;
    }
    // Type alias - register the alias for type resolution
    if tag == TAG_TYPE_ALIAS() {
        let alias_name: i64 = load_ptr(item, 1);
        let target_type: i64 = load_ptr(item, 2);
        cg_register_type_alias(cg, alias_name, target_type);
        return 0;  // No code generated for type aliases
    }
    // Actor, Specialist, Hive - call dedicated generators
    if tag == TAG_ACTOR() {
        return gen_actor(cg, item);
    }
    if tag == TAG_SPECIALIST() {
        return gen_specialist(cg, item);
    }
    if tag == TAG_HIVE() {
        return gen_hive(cg, item);
    }
    if tag == TAG_ANIMA() {
        return gen_anima(cg, item);
    }
    0
}

// Generate program header
fn gen_header(cg: i64) -> i64 {
    emit_line(cg, "; ModuleID = 'simplex_program'");
    emit_line(cg, "target triple = \"x86_64-apple-macosx14.0.0\"");
    emit_line(cg, "");
    emit_line(cg, "declare ptr @malloc(i64)");
    emit_line(cg, "declare void @free(ptr)");
    emit_line(cg, "declare void @intrinsic_println(ptr)");
    emit_line(cg, "declare void @intrinsic_print(ptr)");
    emit_line(cg, "declare ptr @intrinsic_int_to_string(i64)");
    emit_line(cg, "declare ptr @intrinsic_string_new(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_from_char(i64)");
    emit_line(cg, "declare i64 @intrinsic_string_len(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_concat(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_slice(ptr, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_string_char_at(ptr, i64)");
    emit_line(cg, "declare i1 @intrinsic_string_eq(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_to_int(ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_new()");
    emit_line(cg, "declare void @intrinsic_vec_push(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_get(ptr, i64)");
    emit_line(cg, "declare i64 @intrinsic_vec_len(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_set(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @intrinsic_vec_pop(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_clear(ptr)");
    emit_line(cg, "declare void @intrinsic_vec_remove(ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_get_args()");
    emit_line(cg, "declare ptr @intrinsic_read_file(ptr)");
    emit_line(cg, "declare void @intrinsic_write_file(ptr, ptr)");
    emit_line(cg, "declare ptr @store_ptr(ptr, i64, ptr)");
    emit_line(cg, "declare ptr @store_i64(ptr, i64, i64)");
    emit_line(cg, "declare ptr @load_ptr(ptr, i64)");
    emit_line(cg, "declare i64 @load_i64(ptr, i64)");
    emit_line(cg, "; Timing intrinsics");
    emit_line(cg, "declare i64 @intrinsic_get_time_ms()");
    emit_line(cg, "declare i64 @intrinsic_get_time_us()");
    emit_line(cg, "; Arena allocator intrinsics");
    emit_line(cg, "declare ptr @intrinsic_arena_create(i64)");
    emit_line(cg, "declare ptr @intrinsic_arena_alloc(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_arena_reset(ptr)");
    emit_line(cg, "declare void @intrinsic_arena_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_arena_used(ptr)");
    emit_line(cg, "; StringBuilder intrinsics");
    emit_line(cg, "declare ptr @intrinsic_sb_new()");
    emit_line(cg, "declare ptr @intrinsic_sb_new_cap(i64)");
    emit_line(cg, "declare void @intrinsic_sb_append(ptr, ptr)");
    emit_line(cg, "declare void @intrinsic_sb_append_char(ptr, i64)");
    emit_line(cg, "declare void @intrinsic_sb_append_i64(ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_sb_to_string(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_clear(ptr)");
    emit_line(cg, "declare void @intrinsic_sb_free(ptr)");
    emit_line(cg, "declare i64 @intrinsic_sb_len(ptr)");
    emit_line(cg, "; File I/O intrinsics");
    emit_line(cg, "declare i64 @intrinsic_file_exists(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_file(ptr)");
    emit_line(cg, "declare i64 @intrinsic_is_directory(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_size(ptr)");
    emit_line(cg, "declare i64 @intrinsic_file_mtime(ptr)");
    emit_line(cg, "declare i64 @intrinsic_remove_path(ptr)");
    emit_line(cg, "declare i64 @intrinsic_mkdir_p(ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_cwd()");
    emit_line(cg, "declare i64 @intrinsic_set_cwd(ptr)");
    emit_line(cg, "declare ptr @intrinsic_list_dir(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_join(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_dirname(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_basename(ptr)");
    emit_line(cg, "declare ptr @intrinsic_path_extension(ptr)");
    emit_line(cg, "; Error handling intrinsics");
    emit_line(cg, "declare void @intrinsic_panic(ptr)");
    emit_line(cg, "declare void @intrinsic_print_stack_trace()");
    emit_line(cg, "; Process intrinsics");
    emit_line(cg, "declare i64 @intrinsic_process_run(ptr)");
    emit_line(cg, "declare ptr @intrinsic_process_output(ptr)");
    emit_line(cg, "; Phase 20: REPL/I/O intrinsics");
    emit_line(cg, "declare ptr @intrinsic_read_line()");
    emit_line(cg, "declare i64 @intrinsic_is_tty()");
    emit_line(cg, "declare i64 @intrinsic_stdin_has_data()");
    emit_line(cg, "declare i64 @intrinsic_string_hash(ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_find(ptr, ptr, i64)");
    emit_line(cg, "declare ptr @intrinsic_string_trim(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_split(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_starts_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_ends_with(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_contains(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_replace(ptr, ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_lines(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_join(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_to_lowercase(ptr)");
    emit_line(cg, "declare ptr @intrinsic_string_to_uppercase(ptr)");
    emit_line(cg, "declare i64 @intrinsic_string_compare(ptr, ptr)");
    emit_line(cg, "declare i64 @intrinsic_copy_file(ptr, ptr)");
    emit_line(cg, "declare ptr @intrinsic_get_home_dir()");
    // Float parsing
    emit_line(cg, "declare i64 @f64_parse(ptr)");

    // Async runtime
    emit_line(cg, "declare i64 @future_poll(i64)");
    emit_line(cg, "declare i64 @future_ready(i64)");
    emit_line(cg, "declare i64 @future_pending()");
    emit_line(cg, "declare void @executor_run(i64)");
    emit_line(cg, "declare i64 @executor_spawn(i64)");

    // Async combinators
    emit_line(cg, "declare i64 @async_join(i64, i64)");
    emit_line(cg, "declare i64 @join_result1(i64)");
    emit_line(cg, "declare i64 @join_result2(i64)");
    emit_line(cg, "declare i64 @async_select(i64, i64)");
    emit_line(cg, "declare i64 @select_result(i64)");
    emit_line(cg, "declare i64 @select_which(i64)");
    emit_line(cg, "declare i64 @async_timeout(i64, i64)");
    emit_line(cg, "declare i64 @timeout_result(i64)");
    emit_line(cg, "declare i64 @timeout_expired(i64)");
    emit_line(cg, "declare i64 @time_now_ms()");

    // Pin<T>
    emit_line(cg, "declare i64 @pin_new(i64, i64)");
    emit_line(cg, "declare i64 @pin_new_uninit(i64)");
    emit_line(cg, "declare i64 @pin_get(i64)");
    emit_line(cg, "declare i64 @pin_get_mut(i64)");
    emit_line(cg, "declare i64 @pin_is_pinned(i64)");
    emit_line(cg, "declare void @pin_ref(i64)");
    emit_line(cg, "declare void @pin_unref(i64)");
    emit_line(cg, "declare void @pin_set_self_ref(i64, i64)");
    emit_line(cg, "declare i64 @pin_check_self_ref(i64, i64)");

    // Function pointer calls
    emit_line(cg, "declare i64 @intrinsic_call0(i64)");
    emit_line(cg, "declare i64 @intrinsic_call1(i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call2(i64, i64, i64)");
    emit_line(cg, "declare i64 @intrinsic_call3(i64, i64, i64, i64)");

    // Structured concurrency
    emit_line(cg, "declare i64 @scope_new()");
    emit_line(cg, "declare i64 @scope_spawn(i64, i64)");
    emit_line(cg, "declare i64 @scope_poll(i64)");
    emit_line(cg, "declare i64 @scope_join(i64)");
    emit_line(cg, "declare i64 @scope_get_result(i64, i64)");
    emit_line(cg, "declare void @scope_cancel(i64)");
    emit_line(cg, "declare i64 @scope_count(i64)");
    emit_line(cg, "declare i64 @scope_completed(i64)");
    emit_line(cg, "declare void @scope_free(i64)");
    emit_line(cg, "declare i64 @nursery_run(i64, i64)");

    // Phase 23.4: Actor Error Handling
    emit_line(cg, "declare i64 @actor_get_status(i64)");
    emit_line(cg, "declare i64 @actor_get_exit_reason(i64)");
    emit_line(cg, "declare i64 @actor_get_error_code(i64)");
    emit_line(cg, "declare void @actor_set_error(i64, i64, i64)");
    emit_line(cg, "declare void @actor_stop(i64)");
    emit_line(cg, "declare void @actor_kill(i64)");
    emit_line(cg, "declare void @actor_crash(i64, i64, i64)");
    emit_line(cg, "declare void @actor_set_on_error(i64, i64)");
    emit_line(cg, "declare void @actor_set_on_exit(i64, i64)");
    emit_line(cg, "declare void @actor_set_supervisor(i64, i64)");
    emit_line(cg, "declare i64 @actor_get_supervisor(i64)");
    emit_line(cg, "declare i64 @actor_get_restart_count(i64)");
    emit_line(cg, "declare void @actor_increment_restart(i64)");
    emit_line(cg, "declare i64 @actor_is_alive(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @circuit_breaker_allow(i64)");
    emit_line(cg, "declare void @circuit_breaker_success(i64)");
    emit_line(cg, "declare void @circuit_breaker_failure(i64)");
    emit_line(cg, "declare i64 @circuit_breaker_state(i64)");
    emit_line(cg, "declare void @circuit_breaker_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_new(i64, i64, i64, i64)");
    emit_line(cg, "declare void @retry_policy_set_jitter(i64, i64)");
    emit_line(cg, "declare i64 @retry_policy_should_retry(i64)");
    emit_line(cg, "declare i64 @retry_policy_next_delay(i64)");
    emit_line(cg, "declare void @retry_policy_reset(i64)");
    emit_line(cg, "declare i64 @retry_policy_count(i64)");

    // Phase 23.5: Actor Linking and Monitoring
    emit_line(cg, "declare i64 @actor_link(i64, i64)");
    emit_line(cg, "declare void @actor_unlink(i64, i64)");
    emit_line(cg, "declare i64 @actor_monitor(i64, i64)");
    emit_line(cg, "declare void @actor_demonitor(i64)");
    emit_line(cg, "declare void @actor_propagate_exit(i64, i64)");
    emit_line(cg, "declare i64 @actor_is_linked(i64, i64)");
    emit_line(cg, "declare i64 @actor_spawn_link(i64, i64, i64)");
    emit_line(cg, "declare i64 @actor_get_links_count(i64)");
    emit_line(cg, "declare i64 @actor_send_down(i64, i64, i64)");

    // Phase 23.1: Supervision Trees
    emit_line(cg, "; Phase 23.1: Supervision Trees");
    emit_line(cg, "declare i64 @supervisor_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_add_child(i64, i64, i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_start(i64)");
    emit_line(cg, "declare void @supervisor_stop(i64)");
    emit_line(cg, "declare i64 @supervisor_handle_exit(i64, i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_count(i64)");
    emit_line(cg, "declare i64 @supervisor_child_status(i64, i64)");
    emit_line(cg, "declare i64 @supervisor_child_handle(i64, i64)");
    emit_line(cg, "declare void @supervisor_free(i64)");
    emit_line(cg, "declare i64 @strategy_one_for_one()");
    emit_line(cg, "declare i64 @strategy_one_for_all()");
    emit_line(cg, "declare i64 @strategy_rest_for_one()");
    emit_line(cg, "declare i64 @child_permanent()");
    emit_line(cg, "declare i64 @child_temporary()");
    emit_line(cg, "declare i64 @child_transient()");

    // Phase 23.2: Work-Stealing Scheduler
    emit_line(cg, "; Phase 23.2: Work-Stealing Scheduler");
    emit_line(cg, "declare i64 @scheduler_new(i64)");
    emit_line(cg, "declare i64 @scheduler_start(i64)");
    emit_line(cg, "declare i64 @scheduler_submit(i64, i64, i64)");
    emit_line(cg, "declare i64 @scheduler_submit_local(i64, i64, i64, i64)");
    emit_line(cg, "declare void @scheduler_stop(i64)");
    emit_line(cg, "declare void @scheduler_free(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_count(i64)");
    emit_line(cg, "declare i64 @scheduler_queue_size(i64)");
    emit_line(cg, "declare i64 @scheduler_worker_idle(i64, i64)");

    // Phase 23.3: Lock-Free Mailbox
    emit_line(cg, "; Phase 23.3: Lock-Free Mailbox");
    emit_line(cg, "declare i64 @mailbox_new(i64)");
    emit_line(cg, "declare i64 @mailbox_send(i64, i64)");
    emit_line(cg, "declare i64 @mailbox_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_try_recv(i64)");
    emit_line(cg, "declare i64 @mailbox_size(i64)");
    emit_line(cg, "declare i64 @mailbox_empty(i64)");
    emit_line(cg, "declare i64 @mailbox_full(i64)");
    emit_line(cg, "declare void @mailbox_close(i64)");
    emit_line(cg, "declare i64 @mailbox_is_closed(i64)");
    emit_line(cg, "declare void @mailbox_free(i64)");

    // Phase 23.6: Actor Discovery and Registry
    emit_line(cg, "; Phase 23.6: Actor Discovery and Registry");
    emit_line(cg, "declare i64 @registry_register(i64, i64)");
    emit_line(cg, "declare void @registry_unregister(i64)");
    emit_line(cg, "declare i64 @registry_lookup(i64)");
    emit_line(cg, "declare i64 @registry_count()");
    emit_line(cg, "declare i64 @registry_set_metadata(i64, i64)");
    emit_line(cg, "declare i64 @registry_get_metadata(i64)");

    // Phase 23.7: Backpressure and Flow Control
    emit_line(cg, "; Phase 23.7: Backpressure and Flow Control");
    emit_line(cg, "declare i64 @flow_controller_new(i64, i64, i64)");
    emit_line(cg, "declare i64 @flow_check(i64)");
    emit_line(cg, "declare i64 @flow_acquire(i64)");
    emit_line(cg, "declare void @flow_release(i64)");
    emit_line(cg, "declare i64 @flow_is_signaling(i64)");
    emit_line(cg, "declare i64 @flow_current(i64)");
    emit_line(cg, "declare i64 @flow_high_watermark(i64)");
    emit_line(cg, "declare i64 @flow_low_watermark(i64)");
    emit_line(cg, "declare void @flow_reset(i64)");
    emit_line(cg, "declare void @flow_free(i64)");
    emit_line(cg, "declare i64 @flow_mode_drop()");
    emit_line(cg, "declare i64 @flow_mode_block()");
    emit_line(cg, "declare i64 @flow_mode_signal()");
    emit_line(cg, "declare void @intrinsic_exit(i64)");

    // Phase 1 Stdlib: Option<T>
    emit_line(cg, "; Phase 1 Stdlib: Option");
    emit_line(cg, "declare ptr @\"option_some\"(i64)");
    emit_line(cg, "declare ptr @\"option_none\"()");
    emit_line(cg, "declare i8 @\"option_is_some\"(i64)");
    emit_line(cg, "declare i8 @\"option_is_none\"(i64)");
    emit_line(cg, "declare i64 @\"option_unwrap\"(i64)");
    emit_line(cg, "declare i64 @\"option_expect\"(i64, i64)");
    emit_line(cg, "declare i64 @\"option_unwrap_or\"(i64, i64)");
    emit_line(cg, "declare i64 @\"option_map\"(i64, i64)");

    // Phase 1 Stdlib: Result<T, E>
    emit_line(cg, "; Phase 1 Stdlib: Result");
    emit_line(cg, "declare ptr @\"result_ok\"(i64)");
    emit_line(cg, "declare ptr @\"result_err\"(i64)");
    emit_line(cg, "declare i8 @\"result_is_ok\"(i64)");
    emit_line(cg, "declare i8 @\"result_is_err\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap_err\"(i64)");
    emit_line(cg, "declare i64 @\"result_unwrap_or\"(i64, i64)");
    emit_line(cg, "declare i64 @\"result_ok_or\"(i64, i64)");

    // Phase 1 Stdlib: Vec extensions
    emit_line(cg, "; Phase 1 Stdlib: Vec extensions");
    emit_line(cg, "declare i64 @\"vec_sum\"(i64)");
    emit_line(cg, "declare i64 @\"vec_find\"(i64, i64)");
    emit_line(cg, "declare i8 @\"vec_contains\"(i64, i64)");
    emit_line(cg, "declare i64 @\"vec_reverse\"(i64)");
    emit_line(cg, "declare i64 @\"vec_clone\"(i64)");
    emit_line(cg, "declare i64 @\"vec_first\"(i64)");
    emit_line(cg, "declare i64 @\"vec_last\"(i64)");
    emit_line(cg, "declare i64 @\"vec_pop\"(i64)");
    emit_line(cg, "declare void @\"vec_set\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"vec_clear\"(i64)");
    emit_line(cg, "declare void @\"vec_remove\"(i64, i64)");

    // Phase 1 Stdlib: HashMap (string keys)
    emit_line(cg, "; Phase 1 Stdlib: HashMap");
    emit_line(cg, "declare i64 @\"hashmap_new\"()");
    emit_line(cg, "declare i64 @\"hashmap_insert\"(i64, i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_get\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_remove\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashmap_contains\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashmap_len\"(i64)");
    emit_line(cg, "declare void @\"hashmap_clear\"(i64)");
    emit_line(cg, "declare i64 @\"hashmap_keys\"(i64)");
    emit_line(cg, "declare i64 @\"hashmap_values\"(i64)");

    // Phase 1 Stdlib: HashSet (string values)
    emit_line(cg, "; Phase 1 Stdlib: HashSet");
    emit_line(cg, "declare i64 @\"hashset_new\"()");
    emit_line(cg, "declare i8 @\"hashset_insert\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashset_remove\"(i64, i64)");
    emit_line(cg, "declare i8 @\"hashset_contains\"(i64, i64)");
    emit_line(cg, "declare i64 @\"hashset_len\"(i64)");
    emit_line(cg, "declare void @\"hashset_clear\"(i64)");

    // Phase 1 Stdlib: JSON
    emit_line(cg, "; Phase 1 Stdlib: JSON");
    emit_line(cg, "declare i64 @\"json_parse_simple\"(i64)");
    emit_line(cg, "declare i64 @\"json_stringify\"(i64)");
    emit_line(cg, "declare i64 @\"json_get_sx\"(i64, i64)");
    emit_line(cg, "declare i64 @\"json_keys\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_string\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_object\"(i64)");
    emit_line(cg, "declare i8 @\"json_is_array\"(i64)");
    emit_line(cg, "declare i64 @\"json_as_string\"(i64)");
    emit_line(cg, "declare i64 @\"json_as_array\"(i64)");
    emit_line(cg, "declare i64 @\"json_object_new\"()");
    emit_line(cg, "declare i64 @\"json_array_new\"()");
    emit_line(cg, "declare void @\"json_object_set\"(i64, i64, i64)");
    emit_line(cg, "declare void @\"json_array_push\"(i64, i64)");
    emit_line(cg, "declare i64 @\"json_string\"(i64)");

    emit_line(cg, "");
    0
}

// Emit a string constant in LLVM format
fn emit_string_constant(cg: i64, idx: i64, value: i64) -> i64 {
    // For simplicity, just emit the string with basic escaping
    // Format: @.str.MODULE.N = private unnamed_addr constant [LEN x i8] c"STRING\00"
    let len: i64 = string_len(value);

    emit(cg, "@.str.");
    emit(cg, cg_module_name(cg));
    emit(cg, ".");
    emit(cg, int_to_string(idx));
    emit(cg, " = private unnamed_addr constant [");
    emit(cg, int_to_string(len + 1));  // +1 for null terminator
    emit(cg, " x i8] c\"");

    // Emit string with escaping
    let i: i64 = 0;
    while i < len {
        let c: i64 = string_char_at(value, i);
        if c == 10 {
            // newline -> \0A
            emit(cg, "\\0A");
        } else {
            if c == 9 {
                // tab -> \09
                emit(cg, "\\09");
            } else {
                if c == 34 {
                    // quote -> \22
                    emit(cg, "\\22");
                } else {
                    if c == 92 {
                        // backslash -> \5C
                        emit(cg, "\\5C");
                    } else {
                        // Regular character
                        emit(cg, string_slice(value, i, i + 1));
                    }
                }
            }
        }
        i = i + 1;
    }

    emit_line(cg, "\\00\"");
    0
}

// Generate entire program with module name for unique string prefixes
fn gen_program_with_module(items: i64, module_name: i64) -> i64 {
    let cg: i64 = codegen_new();
    cg_set_module_name(cg, module_name);
    register_builtin_enums(cg);  // Phase 36: Pre-register Option and Result
    gen_header(cg);

    // First pass: register enums and structs
    let n: i64 = vec_len(items);
    let i: i64 = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_ENUM() {
            gen_enum(cg, item);
        }
        if tag == TAG_STRUCT() {
            gen_struct(cg, item);
        }
        i = i + 1;
    }

    // Second pass: generate functions, impl blocks, and trait impls
    i = 0;
    while i < n {
        let item: i64 = vec_get(items, i);
        let tag: i64 = load_i64(item, 0);
        if tag == TAG_FN() {
            gen_fn(cg, item);
        }
        if tag == TAG_IMPL() {
            gen_impl(cg, item);
        }
        if tag == TAG_IMPL_TRAIT() {
            gen_impl_trait(cg, item);
        }
        // Note: TAG_TRAIT() doesn't generate code (trait definitions are just declarations)
        i = i + 1;
    }

    // Third pass: generate pending generic instantiations
    // Loop until no more pending (instantiation might queue more)
    let pending: i64 = cg_pending_instantiations(cg);
    let processed: i64 = 0;
    while processed < vec_len(pending) {
        let entry: i64 = vec_get(pending, processed);
        let mangled_name: i64 = load_ptr(entry, 0);
        let fn_def: i64 = load_ptr(entry, 1);
        let type_args: i64 = load_ptr(entry, 2);
        gen_fn_instantiation(cg, fn_def, mangled_name, type_args);
        processed = processed + 1;
    }

    // Emit string constants
    let strings: i64 = cg_strings(cg);
    let str_count: i64 = vec_len(strings);
    if str_count > 0 {
        emit_line(cg, "");
        emit_line(cg, "; String constants");
        i = 0;
        while i < str_count {
            let value: i64 = vec_get(strings, i);
            emit_string_constant(cg, i, value);
            i = i + 1;
        }
    }

    // Convert StringBuilder to String for final output
    sb_to_string(cg_output(cg))
}

// Backward-compatible wrapper using default module name
fn gen_program(items: i64) -> i64 {
    gen_program_with_module(items, string_from("mod"))
}

// Helper functions for intrinsic emission with type conversions
// These handle the i64 <-> ptr conversions needed at boundaries

// Helper: convert i64 to ptr using inttoptr
fn emit_i64_to_ptr(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = inttoptr i64 ");
    emit(cg, val);
    emit_line(cg, " to ptr");
    temp
}

// Helper: convert ptr to i64 using ptrtoint
fn emit_ptr_to_i64(cg: i64, val: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = ptrtoint ptr ");
    emit(cg, val);
    emit_line(cg, " to i64");
    temp
}

// void intrinsic(ptr)
fn emit_intrinsic_void_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, ptr)
fn emit_intrinsic_void_ptr2(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr)
fn emit_intrinsic_i64_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, i64)
fn emit_intrinsic_i64_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i1 intrinsic(ptr, ptr) -> zext to i64
fn emit_intrinsic_i1_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i1 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    // zext i1 to i64
    let t2: i64 = cg_next_temp(cg);
    let temp2: i64 = string_concat("%t", int_to_string(t2));
    emit(cg, "  ");
    emit(cg, temp2);
    emit(cg, " = zext i1 ");
    emit(cg, temp);
    emit_line(cg, " to i64");
    temp2
}

// ptr intrinsic(ptr, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic() -> ptrtoint to i64
fn emit_intrinsic_ptr_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit_line(cg, "()");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr(cg: i64, name: i64, arg1: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ptr intrinsic(ptr, i64, ptr) -> ptrtoint to i64
fn emit_intrinsic_ptr_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// i64 intrinsic() - no args, returns i64
fn emit_intrinsic_i64_void(cg: i64, name: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit_line(cg, "()");
    temp
}

// void intrinsic() - no args, no return
fn emit_intrinsic_void_void(cg: i64, name: i64) -> i64 {
    emit(cg, "  call void @");
    emit(cg, name);
    emit_line(cg, "()");
    0
}

// void intrinsic(i64) - i64 arg, no return
fn emit_intrinsic_void_i64(cg: i64, name: i64, arg1: i64) -> i64 {
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, i64) - ptr arg and i64 arg, no return
fn emit_intrinsic_void_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    0
}

// i64 intrinsic(ptr, ptr) - two ptr args, returns i64
fn emit_intrinsic_i64_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit_line(cg, ")");
    temp
}

// i64 intrinsic(ptr, ptr, i64) - two ptr args and one i64, returns i64
fn emit_intrinsic_i64_ptr_ptr_i64(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    temp
}

// ptr intrinsic(ptr, ptr, ptr) - three ptr args, returns ptr
fn emit_intrinsic_ptr_ptr_ptr_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr2: i64 = emit_i64_to_ptr(cg, arg2);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call ptr @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", ptr ");
    emit(cg, ptr2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    emit_ptr_to_i64(cg, temp)
}

// ============================================================================
// Phase 1 Stdlib call helpers - emit calls with i64 args directly
// ============================================================================

// i64 call(i64) - one i64 arg, returns i64
fn emit_call_i64_1arg(cg: i64, name: i64, arg1: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    temp
}

// i64 call(i64, i64) - two i64 args, returns i64
fn emit_call_i64_2args(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    temp
}

// i64 call(i64, i64, i64) - three i64 args, returns i64
fn emit_call_i64_3args(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let t: i64 = cg_next_temp(cg);
    let temp: i64 = string_concat("%t", int_to_string(t));
    emit(cg, "  ");
    emit(cg, temp);
    emit(cg, " = call i64 @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    temp
}

// void call(i64) - one i64 arg, no return
fn emit_call_void_1arg(cg: i64, name: i64, arg1: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit_line(cg, ")");
    0
}

// void call(i64, i64) - two i64 args, no return
fn emit_call_void_2args(cg: i64, name: i64, arg1: i64, arg2: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit_line(cg, ")");
    0
}

// void call(i64, i64, i64) - three i64 args, no return
fn emit_call_void_3args(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    emit(cg, "  call void @\"");
    emit(cg, name);
    emit(cg, "\"(i64 ");
    emit(cg, arg1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", i64 ");
    emit(cg, arg3);
    emit_line(cg, ")");
    0
}

// void intrinsic(ptr, i64, ptr) - for vec_set(vec, index, item)
fn emit_intrinsic_void_ptr_i64_ptr(cg: i64, name: i64, arg1: i64, arg2: i64, arg3: i64) -> i64 {
    let ptr1: i64 = emit_i64_to_ptr(cg, arg1);
    let ptr3: i64 = emit_i64_to_ptr(cg, arg3);
    emit(cg, "  call void @");
    emit(cg, name);
    emit(cg, "(ptr ");
    emit(cg, ptr1);
    emit(cg, ", i64 ");
    emit(cg, arg2);
    emit(cg, ", ptr ");
    emit(cg, ptr3);
    emit_line(cg, ")");
    0
}
