// =============================================================================
// Nexus Protocol - Phase 11: Dual Number Inference
// =============================================================================
//
// Dual numbers enable belief trajectory prediction by encoding both a value
// and its rate of change. Instead of sending many updates for smoothly
// changing values, we send one dual number and receivers extrapolate.
//
// Dual(v, v') where:
//   v  = current value at reference time t₀
//   v' = dv/dt (rate of change per unit time)
//
// At any time t:
//   v(t) ≈ v + v' × (t - t₀)
//
// Example: confidence = (0.95, -0.02) means 0.95, falling 0.02 per second
//
// Wire formats (from TASK-012):
//   DUAL64 (17 bytes): Tag | value(8 bytes) | derivative(8 bytes)
//   DUAL32 (9 bytes):  Tag | value(4 bytes) | derivative(4 bytes)
//   DUAL16 (5 bytes):  Tag | value(4 bytes) | derivative(1 byte, scaled)
//   SCALAR (varies):   numeric tag | value (implicit derivative = 0)
//
// =============================================================================

// =============================================================================
// Wire Format Tags
// =============================================================================

fn DUAL_TAG_64() -> i64 { 208 }      // 0xD0 - Full precision dual
fn DUAL_TAG_32() -> i64 { 209 }      // 0xD1 - Standard precision dual
fn DUAL_TAG_16() -> i64 { 210 }      // 0xD2 - Compact dual
fn DUAL_TAG_SCALAR() -> i64 { 211 }  // 0xD3 - Scalar (zero derivative)

// Derivative scale for DUAL16 format (i8 × scale = actual derivative)
fn DUAL16_DERIV_SCALE() -> i64 { 100 }  // 0.01 scale, but we use integers

// =============================================================================
// Dual Number Structure
// =============================================================================
//
// Internal representation (using fixed-point integers):
//   Slot 0: value (scaled integer, divide by DUAL_SCALE for float equivalent)
//   Slot 1: derivative (scaled integer, rate per second × DUAL_SCALE)
//   Slot 2: reference_time (milliseconds since epoch)
//   Slot 3: precision (0=64bit, 1=32bit, 2=16bit, 3=scalar)
//
// We use scaled integers throughout since Simplex uses i64.
// DUAL_SCALE = 1,000,000 gives 6 decimal places of precision.

fn DUAL_SCALE() -> i64 { 1000000 }  // Fixed-point scale factor

fn DUAL_OFFSET_VALUE() -> i64 { 0 }
fn DUAL_OFFSET_DERIV() -> i64 { 8 }
fn DUAL_OFFSET_REF_TIME() -> i64 { 16 }
fn DUAL_OFFSET_PRECISION() -> i64 { 24 }
fn DUAL_SIZE() -> i64 { 32 }

fn DUAL_PRECISION_64() -> i64 { 0 }
fn DUAL_PRECISION_32() -> i64 { 1 }
fn DUAL_PRECISION_16() -> i64 { 2 }
fn DUAL_PRECISION_SCALAR() -> i64 { 3 }

// =============================================================================
// Dual Number Creation
// =============================================================================

// Create a new dual number
// value and derivative are scaled integers (multiply actual float by DUAL_SCALE)
fn dual_new(value: i64, derivative: i64, ref_time: i64) -> i64 {
    let d = alloc(DUAL_SIZE());
    store64(d + DUAL_OFFSET_VALUE(), value);
    store64(d + DUAL_OFFSET_DERIV(), derivative);
    store64(d + DUAL_OFFSET_REF_TIME(), ref_time);
    store64(d + DUAL_OFFSET_PRECISION(), DUAL_PRECISION_64());
    d
}

// Create a scalar (constant, zero derivative)
fn dual_scalar(value: i64, ref_time: i64) -> i64 {
    let d = alloc(DUAL_SIZE());
    store64(d + DUAL_OFFSET_VALUE(), value);
    store64(d + DUAL_OFFSET_DERIV(), 0);
    store64(d + DUAL_OFFSET_REF_TIME(), ref_time);
    store64(d + DUAL_OFFSET_PRECISION(), DUAL_PRECISION_SCALAR());
    d
}

// Alias for dual_scalar - create a constant (zero derivative)
fn dual_constant(value: i64, ref_time: i64) -> i64 {
    dual_scalar(value, ref_time)
}

// Create dual from just a value (zero derivative, ref_time = 0)
fn dual_from_value(value: i64) -> i64 {
    dual_scalar(value, 0)
}

// Create from confidence value (0.0-1.0 range, input scaled by 1000000)
fn dual_from_confidence(conf_scaled: i64, deriv_scaled: i64, ref_time: i64) -> i64 {
    dual_new(conf_scaled, deriv_scaled, ref_time)
}

// Clone a dual number
fn dual_clone(d: i64) -> i64 {
    let c = alloc(DUAL_SIZE());
    store64(c + DUAL_OFFSET_VALUE(), load64(d + DUAL_OFFSET_VALUE()));
    store64(c + DUAL_OFFSET_DERIV(), load64(d + DUAL_OFFSET_DERIV()));
    store64(c + DUAL_OFFSET_REF_TIME(), load64(d + DUAL_OFFSET_REF_TIME()));
    store64(c + DUAL_OFFSET_PRECISION(), load64(d + DUAL_OFFSET_PRECISION()));
    c
}

fn dual_free(d: i64) {
    // No-op for GC'd memory
}

// =============================================================================
// Dual Number Accessors
// =============================================================================

fn dual_value(d: i64) -> i64 { load64(d + DUAL_OFFSET_VALUE()) }
fn dual_derivative(d: i64) -> i64 { load64(d + DUAL_OFFSET_DERIV()) }
fn dual_ref_time(d: i64) -> i64 { load64(d + DUAL_OFFSET_REF_TIME()) }
fn dual_precision(d: i64) -> i64 { load64(d + DUAL_OFFSET_PRECISION()) }

fn dual_set_value(d: i64, v: i64) { store64(d + DUAL_OFFSET_VALUE(), v); }
fn dual_set_derivative(d: i64, v: i64) { store64(d + DUAL_OFFSET_DERIV(), v); }
fn dual_set_ref_time(d: i64, t: i64) { store64(d + DUAL_OFFSET_REF_TIME(), t); }
fn dual_set_precision(d: i64, p: i64) { store64(d + DUAL_OFFSET_PRECISION(), p); }

fn dual_is_scalar(d: i64) -> i64 {
    if dual_derivative(d) == 0 { 1 } else { 0 }
}

// =============================================================================
// Dual Number Evaluation
// =============================================================================

// Evaluate dual at a given time (linear extrapolation)
// Returns scaled integer value at time t
fn dual_eval(d: i64, t: i64) -> i64 {
    let v = dual_value(d);
    let dv = dual_derivative(d);
    let t0 = dual_ref_time(d);

    // dt in milliseconds, derivative is per second
    let dt_ms = t - t0;

    // v + dv * (dt_ms / 1000)
    // Since dv is scaled by DUAL_SCALE, and we want result also scaled:
    // result = v + (dv * dt_ms) / 1000
    v + (dv * dt_ms) / 1000
}

// Evaluate and clamp to a range [min, max]
fn dual_eval_clamped(d: i64, t: i64, min_val: i64, max_val: i64) -> i64 {
    let v = dual_eval(d, t);
    if v < min_val {
        min_val
    } else if v > max_val {
        max_val
    } else {
        v
    }
}

// Predict when dual will reach target value
// Returns time in ms, or -1 if never reaches (derivative has wrong sign)
fn dual_predict_when(d: i64, target: i64, current_time: i64) -> i64 {
    let v = dual_eval(d, current_time);
    let dv = dual_derivative(d);

    if dv == 0 {
        // Constant - never reaches target unless already there
        if v == target { current_time } else { 0 - 1 }
    } else {
        let diff = target - v;

        // Check if derivative moves toward or away from target
        if (diff > 0 && dv < 0) || (diff < 0 && dv > 0) {
            // Moving away from target
            0 - 1
        } else {
            // Time = diff / rate
            // diff is scaled, dv is scaled per second
            // dt_ms = (diff * 1000) / dv
            let dt_ms = (diff * 1000) / dv;
            if dt_ms < 0 { dt_ms = 0 - dt_ms; }
            current_time + dt_ms
        }
    }
}

// =============================================================================
// Dual Number Arithmetic
// =============================================================================

// Addition: (v1, d1) + (v2, d2) = (v1 + v2, d1 + d2)
fn dual_add(a: i64, b: i64, ref_time: i64) -> i64 {
    // Evaluate both at the same reference time
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);
    let da = dual_derivative(a);
    let db = dual_derivative(b);

    dual_new(va + vb, da + db, ref_time)
}

// Subtraction: (v1, d1) - (v2, d2) = (v1 - v2, d1 - d2)
fn dual_sub(a: i64, b: i64, ref_time: i64) -> i64 {
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);
    let da = dual_derivative(a);
    let db = dual_derivative(b);

    dual_new(va - vb, da - db, ref_time)
}

// Scalar multiplication: k * (v, d) = (k * v, k * d)
// k is a scaled integer
fn dual_scale(d: i64, k: i64, ref_time: i64) -> i64 {
    let v = dual_eval(d, ref_time);
    let dv = dual_derivative(d);

    // Result = (k * v) / DUAL_SCALE, (k * dv) / DUAL_SCALE
    let new_v = (k * v) / DUAL_SCALE();
    let new_dv = (k * dv) / DUAL_SCALE();

    dual_new(new_v, new_dv, ref_time)
}

// Weighted combination: w * a + (1 - w) * b
// weight is scaled (0 to DUAL_SCALE)
fn dual_lerp(a: i64, b: i64, weight: i64, ref_time: i64) -> i64 {
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);
    let da = dual_derivative(a);
    let db = dual_derivative(b);

    let scale = DUAL_SCALE();
    let inv_weight = scale - weight;

    // v = (w * va + (1-w) * vb) / scale
    let new_v = (weight * va + inv_weight * vb) / scale;
    let new_dv = (weight * da + inv_weight * db) / scale;

    dual_new(new_v, new_dv, ref_time)
}

// Multiply two duals: (v1, d1) * (v2, d2) = (v1*v2, v1*d2 + v2*d1)
// Using product rule for derivatives
fn dual_mul(a: i64, b: i64, ref_time: i64) -> i64 {
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);
    let da = dual_derivative(a);
    let db = dual_derivative(b);

    let scale = DUAL_SCALE();

    // v = (va * vb) / scale
    let new_v = (va * vb) / scale;

    // d = (va * db + vb * da) / scale
    let new_dv = (va * db + vb * da) / scale;

    dual_new(new_v, new_dv, ref_time)
}

// Negate: -(v, d) = (-v, -d)
fn dual_neg(d: i64, ref_time: i64) -> i64 {
    let v = dual_eval(d, ref_time);
    let dv = dual_derivative(d);
    dual_new(0 - v, 0 - dv, ref_time)
}

// Absolute value with derivative tracking
fn dual_abs(d: i64, ref_time: i64) -> i64 {
    let v = dual_eval(d, ref_time);
    let dv = dual_derivative(d);

    if v < 0 {
        dual_new(0 - v, 0 - dv, ref_time)
    } else {
        dual_new(v, dv, ref_time)
    }
}

// Min of two duals - returns whichever is smaller at ref_time
fn dual_min(a: i64, b: i64, ref_time: i64) -> i64 {
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);

    if va <= vb {
        dual_new(va, dual_derivative(a), ref_time)
    } else {
        dual_new(vb, dual_derivative(b), ref_time)
    }
}

// Max of two duals
fn dual_max(a: i64, b: i64, ref_time: i64) -> i64 {
    let va = dual_eval(a, ref_time);
    let vb = dual_eval(b, ref_time);

    if va >= vb {
        dual_new(va, dual_derivative(a), ref_time)
    } else {
        dual_new(vb, dual_derivative(b), ref_time)
    }
}

// =============================================================================
// Dual Number Comparison
// =============================================================================

// Compare values at a given time
fn dual_compare(a: i64, b: i64, t: i64) -> i64 {
    let va = dual_eval(a, t);
    let vb = dual_eval(b, t);

    if va < vb { 0 - 1 }
    else if va > vb { 1 }
    else { 0 }
}

fn dual_equals(a: i64, b: i64, t: i64, tolerance: i64) -> i64 {
    let va = dual_eval(a, t);
    let vb = dual_eval(b, t);
    let diff = va - vb;
    if diff < 0 { diff = 0 - diff; }
    if diff <= tolerance { 1 } else { 0 }
}

// Check if dual is increasing at time t
fn dual_is_increasing(d: i64) -> i64 {
    if dual_derivative(d) > 0 { 1 } else { 0 }
}

// Check if dual is decreasing at time t
fn dual_is_decreasing(d: i64) -> i64 {
    if dual_derivative(d) < 0 { 1 } else { 0 }
}

// Check if dual is stable (near-zero derivative)
fn dual_is_stable(d: i64, threshold: i64) -> i64 {
    let dv = dual_derivative(d);
    if dv < 0 { dv = 0 - dv; }
    if dv <= threshold { 1 } else { 0 }
}

// =============================================================================
// Wire Format Encoding
// =============================================================================

// Encode dual to bytes buffer, returns number of bytes written
fn dual_encode(d: i64, buf: i64) -> i64 {
    let precision = dual_precision(d);
    let v = dual_value(d);
    let dv = dual_derivative(d);

    if precision == DUAL_PRECISION_SCALAR() || dv == 0 {
        // SCALAR format: tag + 8 byte value
        vec_push(buf, DUAL_TAG_SCALAR());
        vec_push(buf, (v / 16777216) / 16777216);  // High 32 bits
        vec_push(buf, v % 4294967296);              // Low 32 bits (as 4 bytes)
        9
    } else if precision == DUAL_PRECISION_16() {
        // DUAL16 format: tag + 4 byte value + 1 byte derivative
        vec_push(buf, DUAL_TAG_16());
        vec_push(buf, v / 65536);        // High 16 bits
        vec_push(buf, v % 65536);        // Low 16 bits
        // Derivative scaled to fit in i8 range (-128 to 127)
        let scaled_dv = dv / (DUAL_SCALE() / DUAL16_DERIV_SCALE());
        if scaled_dv > 127 { scaled_dv = 127; }
        if scaled_dv < 0 - 128 { scaled_dv = 0 - 128; }
        vec_push(buf, scaled_dv + 128);  // Store as unsigned byte
        5
    } else if precision == DUAL_PRECISION_32() {
        // DUAL32 format: tag + 4 byte value + 4 byte derivative
        vec_push(buf, DUAL_TAG_32());
        vec_push(buf, v / 65536);
        vec_push(buf, v % 65536);
        vec_push(buf, dv / 65536);
        vec_push(buf, dv % 65536);
        9
    } else {
        // DUAL64 format: tag + 8 byte value + 8 byte derivative
        vec_push(buf, DUAL_TAG_64());
        vec_push(buf, (v / 16777216) / 16777216);
        vec_push(buf, v % 4294967296);
        vec_push(buf, (dv / 16777216) / 16777216);
        vec_push(buf, dv % 4294967296);
        17
    }
}

// Decode dual from bytes buffer at offset, returns (dual, bytes_read) packed
// High 32 bits = dual handle, low 32 bits = bytes read
fn dual_decode(buf: i64, offset: i64, ref_time: i64) -> i64 {
    let tag = vec_get(buf, offset);

    if tag == DUAL_TAG_SCALAR() {
        let v_high = vec_get(buf, offset + 1);
        let v_low = vec_get(buf, offset + 2);
        let v = v_high * 4294967296 + v_low;
        let d = dual_scalar(v, ref_time);
        (d * 4294967296) + 9
    } else if tag == DUAL_TAG_16() {
        let v_high = vec_get(buf, offset + 1);
        let v_low = vec_get(buf, offset + 2);
        let v = v_high * 65536 + v_low;
        let dv_byte = vec_get(buf, offset + 3) - 128;  // Decode signed
        let dv = dv_byte * (DUAL_SCALE() / DUAL16_DERIV_SCALE());
        let d = dual_new(v, dv, ref_time);
        dual_set_precision(d, DUAL_PRECISION_16());
        (d * 4294967296) + 5
    } else if tag == DUAL_TAG_32() {
        let v_high = vec_get(buf, offset + 1);
        let v_low = vec_get(buf, offset + 2);
        let v = v_high * 65536 + v_low;
        let dv_high = vec_get(buf, offset + 3);
        let dv_low = vec_get(buf, offset + 4);
        let dv = dv_high * 65536 + dv_low;
        let d = dual_new(v, dv, ref_time);
        dual_set_precision(d, DUAL_PRECISION_32());
        (d * 4294967296) + 9
    } else if tag == DUAL_TAG_64() {
        let v_high = vec_get(buf, offset + 1);
        let v_low = vec_get(buf, offset + 2);
        let v = v_high * 4294967296 + v_low;
        let dv_high = vec_get(buf, offset + 3);
        let dv_low = vec_get(buf, offset + 4);
        let dv = dv_high * 4294967296 + dv_low;
        let d = dual_new(v, dv, ref_time);
        dual_set_precision(d, DUAL_PRECISION_64());
        (d * 4294967296) + 17
    } else {
        // Unknown tag, return error
        0
    }
}

// Extract dual handle from decode result
fn dual_decode_result(packed: i64) -> i64 {
    packed / 4294967296
}

// Extract bytes read from decode result
fn dual_decode_bytes(packed: i64) -> i64 {
    packed % 4294967296
}

// =============================================================================
// Utility Functions
// =============================================================================

// Update dual with a new observation, adjusting derivative
fn dual_update(d: i64, new_value: i64, new_time: i64) -> i64 {
    let old_value = dual_eval(d, new_time);
    let old_time = dual_ref_time(d);
    let old_deriv = dual_derivative(d);

    let dt_ms = new_time - old_time;
    if dt_ms <= 0 {
        // No time passed, just update value
        dual_set_value(d, new_value);
        d
    } else {
        // Calculate observed derivative
        let observed_deriv = ((new_value - old_value) * 1000) / dt_ms;

        // Blend old and new derivative (exponential smoothing)
        // new_deriv = 0.3 * observed + 0.7 * old
        let alpha = 300000;  // 0.3 scaled
        let inv_alpha = DUAL_SCALE() - alpha;
        let new_deriv = (alpha * observed_deriv + inv_alpha * old_deriv) / DUAL_SCALE();

        dual_set_value(d, new_value);
        dual_set_derivative(d, new_deriv);
        dual_set_ref_time(d, new_time);
        d
    }
}

// Choose optimal precision based on derivative magnitude
fn dual_optimize_precision(d: i64) -> i64 {
    let dv = dual_derivative(d);
    if dv < 0 { dv = 0 - dv; }

    if dv == 0 {
        dual_set_precision(d, DUAL_PRECISION_SCALAR());
    } else if dv < DUAL_SCALE() / 100 {
        // Small derivative, DUAL16 is sufficient
        dual_set_precision(d, DUAL_PRECISION_16());
    } else if dv < DUAL_SCALE() * 1000 {
        // Medium derivative, DUAL32
        dual_set_precision(d, DUAL_PRECISION_32());
    } else {
        // Large derivative, need DUAL64
        dual_set_precision(d, DUAL_PRECISION_64());
    }
    d
}

// Print dual number for debugging
fn dual_print(d: i64) {
    let v = dual_value(d);
    let dv = dual_derivative(d);
    print("Dual(");
    print_i64(v);
    print("/");
    print_i64(DUAL_SCALE());
    print(", ");
    print_i64(dv);
    print("/");
    print_i64(DUAL_SCALE());
    print("/sec)");
}
