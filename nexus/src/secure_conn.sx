// Nexus Protocol - Secure Connection Layer
//
// This module integrates security into the connection handshake:
// - Extended HELLO/WELCOME with certificate exchange
// - Challenge-response authentication
// - Secure session establishment
// - Enhanced connection state machine with security states
//
// Protocol Version: 0.10.0

// =============================================================================
// Secure Connection States
// =============================================================================

// Extended connection states for secure handshake
fn SCONN_DISCONNECTED() -> i64 { 0 }
fn SCONN_CONNECTING() -> i64 { 1 }
fn SCONN_HELLO_SENT() -> i64 { 2 }
fn SCONN_HELLO_RECEIVED() -> i64 { 3 }
fn SCONN_CHALLENGE_SENT() -> i64 { 4 }
fn SCONN_CHALLENGE_RECEIVED() -> i64 { 5 }
fn SCONN_AUTHENTICATED() -> i64 { 6 }
fn SCONN_SESSION_ESTABLISHED() -> i64 { 7 }
fn SCONN_CATALOG_EXCHANGE() -> i64 { 8 }
fn SCONN_BASELINE() -> i64 { 9 }
fn SCONN_SYNCING() -> i64 { 10 }
fn SCONN_IDLE() -> i64 { 11 }
fn SCONN_ERROR() -> i64 { 12 }
fn SCONN_CLOSING() -> i64 { 13 }

// Security levels for connection
fn SEC_LEVEL_NONE() -> i64 { 0 }        // No security (testing only)
fn SEC_LEVEL_SIGNED() -> i64 { 1 }      // Frames are signed
fn SEC_LEVEL_ENCRYPTED() -> i64 { 2 }   // Frames are encrypted
fn SEC_LEVEL_FULL() -> i64 { 3 }        // Signed + encrypted

// =============================================================================
// Secure Connection Structure
// =============================================================================

// Create a new secure connection
// Returns handle to secure connection
fn secure_conn_new(local_keypair: i64, local_cert: i64) -> i64 {
    let conn = vec_new();

    // State (index 0)
    vec_push(conn, SCONN_DISCONNECTED());

    // Local identity (indices 1-2)
    vec_push(conn, local_keypair);
    vec_push(conn, local_cert);

    // Remote identity (indices 3-4, initially nil)
    vec_push(conn, 0);  // remote_public_key
    vec_push(conn, 0);  // remote_cert

    // Security level (index 5)
    vec_push(conn, SEC_LEVEL_FULL());

    // Session (index 6, established after handshake)
    vec_push(conn, 0);

    // Frame security context (index 7, created after session)
    vec_push(conn, 0);

    // Challenge data (index 8-9)
    vec_push(conn, 0);  // local_challenge
    vec_push(conn, 0);  // remote_challenge

    // Timestamps (index 10-11)
    vec_push(conn, 0);  // handshake_start_time
    vec_push(conn, 0);  // last_activity_time

    // Error state (index 12-13)
    vec_push(conn, ERR_NONE());
    vec_push(conn, 0);  // error_message

    // Statistics (index 14-17)
    vec_push(conn, 0);  // frames_sent
    vec_push(conn, 0);  // frames_received
    vec_push(conn, 0);  // bytes_sent
    vec_push(conn, 0);  // bytes_received

    // Trusted certificates list (index 18)
    vec_push(conn, vec_new());

    conn
}

// Accessors
fn secure_conn_state(conn: i64) -> i64 { vec_get(conn, 0) }
fn secure_conn_local_keypair(conn: i64) -> i64 { vec_get(conn, 1) }
fn secure_conn_local_cert(conn: i64) -> i64 { vec_get(conn, 2) }
fn secure_conn_remote_pubkey(conn: i64) -> i64 { vec_get(conn, 3) }
fn secure_conn_remote_cert(conn: i64) -> i64 { vec_get(conn, 4) }
fn secure_conn_security_level(conn: i64) -> i64 { vec_get(conn, 5) }
fn secure_conn_session(conn: i64) -> i64 { vec_get(conn, 6) }
fn secure_conn_frame_ctx(conn: i64) -> i64 { vec_get(conn, 7) }
fn secure_conn_local_challenge(conn: i64) -> i64 { vec_get(conn, 8) }
fn secure_conn_remote_challenge(conn: i64) -> i64 { vec_get(conn, 9) }
fn secure_conn_error_code(conn: i64) -> i64 { vec_get(conn, 12) }
fn secure_conn_error_msg(conn: i64) -> i64 { vec_get(conn, 13) }
fn secure_conn_frames_sent(conn: i64) -> i64 { vec_get(conn, 14) }
fn secure_conn_frames_received(conn: i64) -> i64 { vec_get(conn, 15) }
fn secure_conn_trusted_certs(conn: i64) -> i64 { vec_get(conn, 18) }

// Setters
fn secure_conn_set_state(conn: i64, state: i64) {
    vec_set(conn, 0, state);
}

fn secure_conn_set_security_level(conn: i64, level: i64) {
    vec_set(conn, 5, level);
}

fn secure_conn_set_error(conn: i64, code: i64, msg: i64) {
    vec_set(conn, 12, code);
    vec_set(conn, 13, msg);
    vec_set(conn, 0, SCONN_ERROR());
}

// Add a trusted certificate
fn secure_conn_add_trusted_cert(conn: i64, cert: i64) {
    let trusted = vec_get(conn, 18);
    vec_push(trusted, cert);
}

// =============================================================================
// Challenge Generation and Verification
// =============================================================================

// Generate a random challenge (32 bytes)
fn secure_conn_gen_challenge() -> i64 {
    let challenge = vec_new();
    let i = 0;
    while i < 32 {
        // Simple PRNG for challenge bytes
        let val = ((i * 17 + 31) * 257 + (i * i)) % 256;
        vec_push(challenge, val);
        i = i + 1;
    }
    challenge
}

// Sign a challenge with our private key
fn secure_conn_sign_challenge(conn: i64, challenge: i64) -> i64 {
    let keypair = secure_conn_local_keypair(conn);
    let private_key = hive_keypair_private(keypair);
    crypto_sign(challenge, private_key)
}

// Verify a signed challenge against remote public key
fn secure_conn_verify_challenge(conn: i64, challenge: i64, signature: i64) -> i64 {
    let remote_pubkey = secure_conn_remote_pubkey(conn);
    if remote_pubkey == 0 {
        return 0;
    }
    crypto_verify(challenge, signature, remote_pubkey)
}

// =============================================================================
// Secure HELLO Frame
// =============================================================================

// SECURE_HELLO format:
// - Magic (2 bytes): "SX"
// - Version (3 bytes): major.minor.patch
// - Frame type (1 byte): FRAME_HELLO
// - Security level (1 byte)
// - Certificate length (2 bytes)
// - Certificate (variable)
// - Challenge (32 bytes)
// - Timestamp (8 bytes)

fn secure_hello_build(conn: i64) -> i64 {
    let frame = vec_new();

    // Magic bytes
    vec_push(frame, NEXUS_MAGIC_BYTE_0());
    vec_push(frame, NEXUS_MAGIC_BYTE_1());

    // Version
    vec_push(frame, NEXUS_VERSION_MAJOR());
    vec_push(frame, NEXUS_VERSION_MINOR());
    vec_push(frame, NEXUS_VERSION_PATCH());

    // Frame type
    vec_push(frame, FRAME_HELLO());

    // Security level
    vec_push(frame, secure_conn_security_level(conn));

    // Encode and add certificate
    let cert = secure_conn_local_cert(conn);
    let cert_bytes = hive_cert_encode(cert);
    let cert_len = vec_len(cert_bytes);

    // Certificate length (2 bytes, big-endian)
    vec_push(frame, (cert_len / 256) % 256);
    vec_push(frame, cert_len % 256);

    // Certificate bytes
    let i = 0;
    while i < cert_len {
        vec_push(frame, vec_get(cert_bytes, i));
        i = i + 1;
    }

    // Generate and store challenge
    let challenge = secure_conn_gen_challenge();
    vec_set(conn, 8, challenge);

    // Add challenge to frame
    i = 0;
    while i < 32 {
        vec_push(frame, vec_get(challenge, i));
        i = i + 1;
    }

    // Timestamp (8 bytes, placeholder)
    i = 0;
    while i < 8 {
        vec_push(frame, 0);
        i = i + 1;
    }

    frame
}

// Parse a SECURE_HELLO frame
// Returns: 1 on success, 0 on failure
fn secure_hello_parse(conn: i64, frame: i64) -> i64 {
    let len = vec_len(frame);
    if len < 15 {  // Minimum: magic(2) + version(3) + type(1) + sec(1) + cert_len(2) + challenge(32) = 41
        secure_conn_set_error(conn, ERR_INVALID_LENGTH(), 0);
        return 0;
    }

    // Verify magic
    if vec_get(frame, 0) != NEXUS_MAGIC_BYTE_0() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }
    if vec_get(frame, 1) != NEXUS_MAGIC_BYTE_1() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }

    // Verify frame type
    if vec_get(frame, 5) != FRAME_HELLO() {
        secure_conn_set_error(conn, ERR_INVALID_FRAME_TYPE(), 0);
        return 0;
    }

    // Get security level
    let remote_sec_level = vec_get(frame, 6);

    // Get certificate length
    let cert_len = vec_get(frame, 7) * 256 + vec_get(frame, 8);

    // Verify we have enough bytes
    if len < 9 + cert_len + 32 {
        secure_conn_set_error(conn, ERR_INVALID_LENGTH(), 0);
        return 0;
    }

    // Extract certificate bytes
    let cert_bytes = vec_new();
    let i = 0;
    while i < cert_len {
        vec_push(cert_bytes, vec_get(frame, 9 + i));
        i = i + 1;
    }

    // Decode certificate
    let remote_cert = hive_cert_decode(cert_bytes);
    if remote_cert == 0 {
        secure_conn_set_error(conn, ERR_DECODE_ERROR(), 0);
        return 0;
    }

    // Verify certificate
    if hive_cert_verify(remote_cert, remote_cert) == 0 {
        // Self-signed cert check - in production would check against trusted roots
        // For now, accept self-signed for testing
    }

    // Store remote certificate and public key
    vec_set(conn, 4, remote_cert);
    vec_set(conn, 3, hive_cert_public_key(remote_cert));

    // Extract challenge
    let remote_challenge = vec_new();
    i = 0;
    while i < 32 {
        vec_push(remote_challenge, vec_get(frame, 9 + cert_len + i));
        i = i + 1;
    }
    vec_set(conn, 9, remote_challenge);

    1
}

// =============================================================================
// Secure WELCOME Frame (Response to HELLO)
// =============================================================================

// SECURE_WELCOME format:
// - Magic (2 bytes): "SX"
// - Version (3 bytes): major.minor.patch
// - Frame type (1 byte): FRAME_WELCOME
// - Security level (1 byte): negotiated level
// - Certificate length (2 bytes)
// - Certificate (variable)
// - Challenge response signature (64 bytes)
// - Our challenge (32 bytes)

fn secure_welcome_build(conn: i64) -> i64 {
    let frame = vec_new();

    // Magic bytes
    vec_push(frame, NEXUS_MAGIC_BYTE_0());
    vec_push(frame, NEXUS_MAGIC_BYTE_1());

    // Version
    vec_push(frame, NEXUS_VERSION_MAJOR());
    vec_push(frame, NEXUS_VERSION_MINOR());
    vec_push(frame, NEXUS_VERSION_PATCH());

    // Frame type
    vec_push(frame, FRAME_WELCOME());

    // Negotiated security level (use minimum of both)
    let our_level = secure_conn_security_level(conn);
    vec_push(frame, our_level);

    // Encode and add our certificate
    let cert = secure_conn_local_cert(conn);
    let cert_bytes = hive_cert_encode(cert);
    let cert_len = vec_len(cert_bytes);

    // Certificate length (2 bytes, big-endian)
    vec_push(frame, (cert_len / 256) % 256);
    vec_push(frame, cert_len % 256);

    // Certificate bytes
    let i = 0;
    while i < cert_len {
        vec_push(frame, vec_get(cert_bytes, i));
        i = i + 1;
    }

    // Sign the remote's challenge
    let remote_challenge = secure_conn_remote_challenge(conn);
    let challenge_sig = secure_conn_sign_challenge(conn, remote_challenge);

    // Add signature (64 bytes)
    i = 0;
    while i < vec_len(challenge_sig) {
        vec_push(frame, vec_get(challenge_sig, i));
        i = i + 1;
    }
    // Pad to 64 bytes if needed
    while i < 64 {
        vec_push(frame, 0);
        i = i + 1;
    }

    // Generate and add our challenge
    let our_challenge = secure_conn_gen_challenge();
    vec_set(conn, 8, our_challenge);

    i = 0;
    while i < 32 {
        vec_push(frame, vec_get(our_challenge, i));
        i = i + 1;
    }

    frame
}

// Parse a SECURE_WELCOME frame
fn secure_welcome_parse(conn: i64, frame: i64) -> i64 {
    let len = vec_len(frame);
    if len < 9 {
        secure_conn_set_error(conn, ERR_INVALID_LENGTH(), 0);
        return 0;
    }

    // Verify magic
    if vec_get(frame, 0) != NEXUS_MAGIC_BYTE_0() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }
    if vec_get(frame, 1) != NEXUS_MAGIC_BYTE_1() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }

    // Verify frame type
    if vec_get(frame, 5) != FRAME_WELCOME() {
        secure_conn_set_error(conn, ERR_INVALID_FRAME_TYPE(), 0);
        return 0;
    }

    // Get negotiated security level
    let neg_level = vec_get(frame, 6);
    vec_set(conn, 5, neg_level);

    // Get certificate length
    let cert_len = vec_get(frame, 7) * 256 + vec_get(frame, 8);

    // Verify we have enough bytes
    if len < 9 + cert_len + 64 + 32 {
        secure_conn_set_error(conn, ERR_INVALID_LENGTH(), 0);
        return 0;
    }

    // Extract certificate bytes
    let cert_bytes = vec_new();
    let i = 0;
    while i < cert_len {
        vec_push(cert_bytes, vec_get(frame, 9 + i));
        i = i + 1;
    }

    // Decode certificate
    let remote_cert = hive_cert_decode(cert_bytes);
    if remote_cert == 0 {
        secure_conn_set_error(conn, ERR_DECODE_ERROR(), 0);
        return 0;
    }

    // Store remote certificate and public key
    vec_set(conn, 4, remote_cert);
    vec_set(conn, 3, hive_cert_public_key(remote_cert));

    // Extract challenge signature (64 bytes)
    let challenge_sig = vec_new();
    i = 0;
    while i < 64 {
        vec_push(challenge_sig, vec_get(frame, 9 + cert_len + i));
        i = i + 1;
    }

    // Verify challenge signature
    let our_challenge = secure_conn_local_challenge(conn);
    if secure_conn_verify_challenge(conn, our_challenge, challenge_sig) == 0 {
        secure_conn_set_error(conn, ERR_AUTH_FAILED(), 0);
        return 0;
    }

    // Extract remote's challenge
    let remote_challenge = vec_new();
    i = 0;
    while i < 32 {
        vec_push(remote_challenge, vec_get(frame, 9 + cert_len + 64 + i));
        i = i + 1;
    }
    vec_set(conn, 9, remote_challenge);

    1
}

// =============================================================================
// Challenge Response Frame (Final auth step)
// =============================================================================

// CHALLENGE_RESPONSE format:
// - Magic (2 bytes): "SX"
// - Frame type (1 byte): custom (using 20 for auth response)
// - Challenge signature (64 bytes)

fn FRAME_AUTH_RESPONSE() -> i64 { 20 }

fn secure_auth_response_build(conn: i64) -> i64 {
    let frame = vec_new();

    // Magic bytes
    vec_push(frame, NEXUS_MAGIC_BYTE_0());
    vec_push(frame, NEXUS_MAGIC_BYTE_1());

    // Frame type
    vec_push(frame, FRAME_AUTH_RESPONSE());

    // Sign the remote's challenge
    let remote_challenge = secure_conn_remote_challenge(conn);
    let challenge_sig = secure_conn_sign_challenge(conn, remote_challenge);

    // Add signature (64 bytes)
    let i = 0;
    while i < vec_len(challenge_sig) {
        vec_push(frame, vec_get(challenge_sig, i));
        i = i + 1;
    }
    // Pad to 64 bytes if needed
    while i < 64 {
        vec_push(frame, 0);
        i = i + 1;
    }

    frame
}

// Parse and verify auth response
fn secure_auth_response_parse(conn: i64, frame: i64) -> i64 {
    let len = vec_len(frame);
    if len < 67 {  // magic(2) + type(1) + sig(64)
        secure_conn_set_error(conn, ERR_INVALID_LENGTH(), 0);
        return 0;
    }

    // Verify magic
    if vec_get(frame, 0) != NEXUS_MAGIC_BYTE_0() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }
    if vec_get(frame, 1) != NEXUS_MAGIC_BYTE_1() {
        secure_conn_set_error(conn, ERR_INVALID_MAGIC(), 0);
        return 0;
    }

    // Verify frame type
    if vec_get(frame, 2) != FRAME_AUTH_RESPONSE() {
        secure_conn_set_error(conn, ERR_INVALID_FRAME_TYPE(), 0);
        return 0;
    }

    // Extract signature
    let sig = vec_new();
    let i = 0;
    while i < 64 {
        vec_push(sig, vec_get(frame, 3 + i));
        i = i + 1;
    }

    // Verify signature against our challenge
    let our_challenge = secure_conn_local_challenge(conn);
    if secure_conn_verify_challenge(conn, our_challenge, sig) == 0 {
        secure_conn_set_error(conn, ERR_AUTH_FAILED(), 0);
        return 0;
    }

    1
}

// =============================================================================
// Session Establishment
// =============================================================================

// Establish secure session after authentication
fn secure_conn_establish_session(conn: i64) -> i64 {
    let local_keypair = secure_conn_local_keypair(conn);
    let local_cert = secure_conn_local_cert(conn);
    let remote_pubkey = secure_conn_remote_pubkey(conn);

    if local_keypair == 0 || remote_pubkey == 0 {
        secure_conn_set_error(conn, ERR_AUTH_FAILED(), 0);
        return 0;
    }

    // Create secure session with key exchange
    let session = secure_session_new(local_keypair, local_cert);

    // Perform key exchange
    if secure_session_key_exchange(session, remote_pubkey) == 0 {
        secure_conn_set_error(conn, ERR_AUTH_FAILED(), 0);
        return 0;
    }

    // Store session
    vec_set(conn, 6, session);

    // Create frame security context
    let frame_ctx = frame_sec_ctx_new(session);
    vec_set(conn, 7, frame_ctx);

    // Update state
    vec_set(conn, 0, SCONN_SESSION_ESTABLISHED());

    1
}

// =============================================================================
// Secure Frame Send/Receive
// =============================================================================

// Send a frame with security applied
fn secure_conn_send_frame(conn: i64, frame: i64) -> i64 {
    let state = secure_conn_state(conn);

    // For handshake frames, send as-is
    if state < SCONN_SESSION_ESTABLISHED() {
        // Update stats
        let sent = vec_get(conn, 14);
        vec_set(conn, 14, sent + 1);
        let bytes = vec_get(conn, 16);
        vec_set(conn, 16, bytes + vec_len(frame));
        return frame;
    }

    // Apply security based on level
    let level = secure_conn_security_level(conn);
    let ctx = secure_conn_frame_ctx(conn);

    let secured_frame = frame;

    if level == SEC_LEVEL_FULL() {
        // Sign and encrypt
        secured_frame = secure_frame_wrap(frame, ctx);
    } else if level == SEC_LEVEL_ENCRYPTED() {
        // Encrypt only
        secured_frame = secure_frame_encrypt(frame, ctx);
    } else if level == SEC_LEVEL_SIGNED() {
        // Sign only
        secured_frame = secure_frame_sign(frame, ctx);
    }

    // Update stats
    let sent = vec_get(conn, 14);
    vec_set(conn, 14, sent + 1);
    let bytes = vec_get(conn, 16);
    vec_set(conn, 16, bytes + vec_len(secured_frame));

    secured_frame
}

// Receive and verify/decrypt a frame
fn secure_conn_recv_frame(conn: i64, secured_frame: i64) -> i64 {
    let state = secure_conn_state(conn);

    // Update stats
    let recv = vec_get(conn, 15);
    vec_set(conn, 15, recv + 1);
    let bytes = vec_get(conn, 17);
    vec_set(conn, 17, bytes + vec_len(secured_frame));

    // For handshake frames, return as-is
    if state < SCONN_SESSION_ESTABLISHED() {
        return secured_frame;
    }

    // Remove security based on level
    let level = secure_conn_security_level(conn);
    let ctx = secure_conn_frame_ctx(conn);

    if level == SEC_LEVEL_FULL() {
        // Verify and decrypt
        return secure_frame_unwrap(secured_frame, ctx);
    } else if level == SEC_LEVEL_ENCRYPTED() {
        // Decrypt only
        return secure_frame_decrypt(secured_frame, ctx);
    } else if level == SEC_LEVEL_SIGNED() {
        // Verify only
        return secure_frame_verify(secured_frame, ctx);
    }

    secured_frame
}

// =============================================================================
// Handshake State Machine
// =============================================================================

// Initiator side: Start handshake
fn secure_conn_initiate(conn: i64) -> i64 {
    vec_set(conn, 0, SCONN_CONNECTING());

    // Build and return HELLO frame
    let hello = secure_hello_build(conn);
    vec_set(conn, 0, SCONN_HELLO_SENT());

    hello
}

// Responder side: Handle incoming HELLO, return WELCOME
fn secure_conn_respond_hello(conn: i64, hello_frame: i64) -> i64 {
    // Parse HELLO
    if secure_hello_parse(conn, hello_frame) == 0 {
        return 0;
    }

    vec_set(conn, 0, SCONN_HELLO_RECEIVED());

    // Build and return WELCOME
    let welcome = secure_welcome_build(conn);
    vec_set(conn, 0, SCONN_CHALLENGE_SENT());

    welcome
}

// Initiator side: Handle WELCOME, return AUTH_RESPONSE
fn secure_conn_handle_welcome(conn: i64, welcome_frame: i64) -> i64 {
    // Parse WELCOME
    if secure_welcome_parse(conn, welcome_frame) == 0 {
        return 0;
    }

    vec_set(conn, 0, SCONN_CHALLENGE_RECEIVED());

    // Build auth response
    let auth_resp = secure_auth_response_build(conn);

    // Establish session
    if secure_conn_establish_session(conn) == 0 {
        return 0;
    }

    vec_set(conn, 0, SCONN_AUTHENTICATED());

    auth_resp
}

// Responder side: Handle AUTH_RESPONSE, complete handshake
fn secure_conn_handle_auth_response(conn: i64, auth_frame: i64) -> i64 {
    // Parse and verify auth response
    if secure_auth_response_parse(conn, auth_frame) == 0 {
        return 0;
    }

    // Establish session
    if secure_conn_establish_session(conn) == 0 {
        return 0;
    }

    vec_set(conn, 0, SCONN_AUTHENTICATED());

    1
}

// Check if handshake is complete
fn secure_conn_is_authenticated(conn: i64) -> i64 {
    let state = secure_conn_state(conn);
    if state >= SCONN_AUTHENTICATED() && state != SCONN_ERROR() {
        return 1;
    }
    0
}

// Check if ready for data exchange
fn secure_conn_is_ready(conn: i64) -> i64 {
    let state = secure_conn_state(conn);
    if state >= SCONN_SESSION_ESTABLISHED() && state != SCONN_ERROR() {
        return 1;
    }
    0
}

// =============================================================================
// Connection Lifecycle
// =============================================================================

// Graceful disconnect
fn secure_conn_disconnect(conn: i64) -> i64 {
    let frame = vec_new();

    // Build disconnect frame
    vec_push(frame, NEXUS_MAGIC_BYTE_0());
    vec_push(frame, NEXUS_MAGIC_BYTE_1());
    vec_push(frame, FRAME_DISCONNECT());

    // Apply security if established
    let secured = secure_conn_send_frame(conn, frame);

    vec_set(conn, 0, SCONN_CLOSING());

    secured
}

// Handle disconnect frame
fn secure_conn_handle_disconnect(conn: i64, frame: i64) {
    vec_set(conn, 0, SCONN_DISCONNECTED());
}

// Reset connection state for reconnection
fn secure_conn_reset(conn: i64) {
    vec_set(conn, 0, SCONN_DISCONNECTED());
    vec_set(conn, 3, 0);  // remote_pubkey
    vec_set(conn, 4, 0);  // remote_cert
    vec_set(conn, 6, 0);  // session
    vec_set(conn, 7, 0);  // frame_ctx
    vec_set(conn, 8, 0);  // local_challenge
    vec_set(conn, 9, 0);  // remote_challenge
    vec_set(conn, 12, ERR_NONE());
    vec_set(conn, 13, 0);
}

// =============================================================================
// Certificate Trust Management
// =============================================================================

// Check if a certificate is trusted
fn secure_conn_is_cert_trusted(conn: i64, cert: i64) -> i64 {
    let trusted_list = secure_conn_trusted_certs(conn);
    let count = vec_len(trusted_list);

    // Get the public key to compare
    let cert_pubkey = hive_cert_public_key(cert);

    let i = 0;
    while i < count {
        let trusted = vec_get(trusted_list, i);
        let trusted_pubkey = hive_cert_public_key(trusted);

        // Compare public keys
        if vec_len(cert_pubkey) == vec_len(trusted_pubkey) {
            let is_match = 1;
            let j = 0;
            while j < vec_len(cert_pubkey) {
                if vec_get(cert_pubkey, j) != vec_get(trusted_pubkey, j) {
                    is_match = 0;
                }
                j = j + 1;
            }
            if is_match == 1 {
                return 1;
            }
        }

        i = i + 1;
    }

    0
}

// =============================================================================
// Utility Functions
// =============================================================================

// Get state name for debugging
fn secure_conn_state_name(state: i64) -> i64 {
    // Returns an identifier for the state
    // In production this would return a string
    state
}

// Check if connection is in error state
fn secure_conn_has_error(conn: i64) -> i64 {
    if vec_get(conn, 0) == SCONN_ERROR() {
        return 1;
    }
    if vec_get(conn, 12) != ERR_NONE() {
        return 1;
    }
    0
}

// Get connection statistics
fn secure_conn_get_stats(conn: i64) -> i64 {
    let stats = vec_new();
    vec_push(stats, vec_get(conn, 14));  // frames_sent
    vec_push(stats, vec_get(conn, 15));  // frames_received
    vec_push(stats, vec_get(conn, 16));  // bytes_sent
    vec_push(stats, vec_get(conn, 17));  // bytes_received
    stats
}

// =============================================================================
// Full Handshake Helper (for testing)
// =============================================================================

// Perform complete handshake between two connections
// Returns: 1 on success, 0 on failure
fn secure_conn_full_handshake(initiator: i64, responder: i64) -> i64 {
    // Step 1: Initiator sends HELLO
    let hello = secure_conn_initiate(initiator);
    if hello == 0 {
        return 0;
    }

    // Step 2: Responder processes HELLO, sends WELCOME
    let welcome = secure_conn_respond_hello(responder, hello);
    if welcome == 0 {
        return 0;
    }

    // Step 3: Initiator processes WELCOME, sends AUTH_RESPONSE
    let auth_resp = secure_conn_handle_welcome(initiator, welcome);
    if auth_resp == 0 {
        return 0;
    }

    // Step 4: Responder processes AUTH_RESPONSE
    if secure_conn_handle_auth_response(responder, auth_resp) == 0 {
        return 0;
    }

    // Both sides should now be authenticated
    if secure_conn_is_authenticated(initiator) == 0 {
        return 0;
    }
    if secure_conn_is_authenticated(responder) == 0 {
        return 0;
    }

    // Establish sessions to enable encrypted communication
    if secure_conn_establish_session(initiator) == 0 {
        return 0;
    }
    if secure_conn_establish_session(responder) == 0 {
        return 0;
    }

    1
}
