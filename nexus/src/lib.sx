// Nexus Protocol - High-Performance Hive Communication
//
// Nexus is a binary protocol optimized for constant hive-to-hive
// communication, achieving 400x compression through bit-packed
// delta streams.
//
// Key Features:
// - Bit-packed delta encoding (0.38 bytes/belief vs 90 naive)
// - Implicit addressing (position = ID)
// - Dual number support for belief trajectories
// - STF (Simplex Term Format) for cognitive primitives
// - Multiple transport bindings
//
// Module Structure:
// - types.sx: Protocol constants and type tags
// - bits.sx: Bit-level reader/writer
// - frame.sx: Frame encoding/decoding
// - sync.sx: SYNC frame encoder/decoder
//
// Quick Start:
//
//   // Create a sync session for 1000 beliefs
//   let session: i64 = sync_session_new(1000);
//
//   // Initialize with baseline values
//   sync_session_init(session, baseline_vec);
//
//   // Update some beliefs
//   sync_session_update(session, 42, new_value);
//
//   // Encode a SYNC frame
//   let frame: i64 = sync_session_encode(session);
//
//   // Send frame over network...
//
//   // On receiver: decode SYNC frame
//   let result: i64 = sync_session_decode(receiver_session, frame);
//
//   // Get updated value
//   let value: i64 = sync_session_get_value(receiver_session, 42);

// =============================================================================
// Version Info
// =============================================================================

fn nexus_version() -> i64 {
    NEXUS_VERSION_MAJOR() * 10000 +
    NEXUS_VERSION_MINOR() * 100 +
    NEXUS_VERSION_PATCH()
}

fn nexus_version_string_print() -> i64 {
    print("0.9.5");
    0
}

// =============================================================================
// Re-exports from modules
// =============================================================================

// From types.sx:
//   Protocol constants, STF tags, frame types, message types

// From bits.sx:
//   bitwriter_new, bitwriter_write_*, bitwriter_finish
//   bitreader_new, bitreader_read_*, bitreader_has_bits

// From frame.sx:
//   frame_new, frame_new_*, frame_encode, frame_decode
//   frame_type, frame_flags, frame_payload

// From sync.sx:
//   sync_encoder_new, sync_encoder_update, sync_encoder_encode
//   sync_decoder_new, sync_decoder_decode, sync_decoder_get
//   sync_session_new, sync_session_init, sync_session_update
//   sync_stats_*, sync_compute_checksum

// =============================================================================
// High-Level API
// =============================================================================

// Create a complete Nexus connection for hive-to-hive sync
// Slot 0: local_session (SyncSession)
// Slot 1: connection_state
// Slot 2: peer_address
// Slot 3: local_hive_id
// Slot 4: remote_hive_id
// Slot 5: tick
// Slot 6: stats

fn nexus_connection_new(belief_count: i64, local_hive_id: i64) -> i64 {
    let conn: i64 = vec_new();
    vec_push(conn, sync_session_new(belief_count));  // Slot 0
    vec_push(conn, CONN_DISCONNECTED());             // Slot 1
    vec_push(conn, 0);                               // Slot 2: peer_address
    vec_push(conn, local_hive_id);                   // Slot 3
    vec_push(conn, 0);                               // Slot 4: remote_hive_id
    vec_push(conn, 0);                               // Slot 5: tick
    vec_push(conn, nexus_conn_stats_new());          // Slot 6: stats
    conn
}

fn nexus_connection_session(conn: i64) -> i64 { vec_get(conn, 0) }
fn nexus_connection_state(conn: i64) -> i64 { vec_get(conn, 1) }
fn nexus_connection_local_hive(conn: i64) -> i64 { vec_get(conn, 3) }
fn nexus_connection_remote_hive(conn: i64) -> i64 { vec_get(conn, 4) }
fn nexus_connection_tick(conn: i64) -> i64 { vec_get(conn, 5) }
fn nexus_connection_stats(conn: i64) -> i64 { vec_get(conn, 6) }

fn nexus_connection_set_state(conn: i64, state: i64) -> i64 {
    vec_set(conn, 1, state);
    0
}

fn nexus_connection_is_syncing(conn: i64) -> i64 {
    let state: i64 = nexus_connection_state(conn);
    if state == CONN_SYNCING() { 1 } else { 0 }
}

// Initialize connection with baseline values
fn nexus_connection_init(conn: i64, baseline: i64) -> i64 {
    let session: i64 = nexus_connection_session(conn);
    sync_session_init(session, baseline)
}

// Update a belief value
fn nexus_connection_update(conn: i64, index: i64, value: i64) -> i64 {
    let session: i64 = nexus_connection_session(conn);
    sync_session_update(session, index, value)
}

// Encode outgoing SYNC frame
fn nexus_connection_encode_sync(conn: i64) -> i64 {
    let session: i64 = nexus_connection_session(conn);
    let stats: i64 = nexus_connection_stats(conn);

    let frame: i64 = sync_session_encode(session);

    // Update stats
    let frames_sent: i64 = vec_get(stats, 0);
    vec_set(stats, 0, frames_sent + 1);
    let bytes_sent: i64 = vec_get(stats, 2);
    vec_set(stats, 2, bytes_sent + vec_len(frame));

    // Increment tick
    let tick: i64 = nexus_connection_tick(conn);
    vec_set(conn, 5, tick + 1);

    frame
}

// Decode incoming SYNC frame
fn nexus_connection_decode_sync(conn: i64, frame_bytes: i64) -> i64 {
    let session: i64 = nexus_connection_session(conn);
    let stats: i64 = nexus_connection_stats(conn);

    let result: i64 = sync_session_decode(session, frame_bytes);

    // Update stats
    let frames_recv: i64 = vec_get(stats, 1);
    vec_set(stats, 1, frames_recv + 1);
    let bytes_recv: i64 = vec_get(stats, 3);
    vec_set(stats, 3, bytes_recv + vec_len(frame_bytes));

    result
}

// Get a belief value from remote state
fn nexus_connection_get_remote(conn: i64, index: i64) -> i64 {
    let session: i64 = nexus_connection_session(conn);
    sync_session_get_value(session, index)
}

// =============================================================================
// Connection Statistics
// =============================================================================

fn nexus_conn_stats_new() -> i64 {
    let stats: i64 = vec_new();
    vec_push(stats, 0);  // frames_sent
    vec_push(stats, 0);  // frames_recv
    vec_push(stats, 0);  // bytes_sent
    vec_push(stats, 0);  // bytes_recv
    vec_push(stats, 0);  // checksum_mismatches
    vec_push(stats, 0);  // resync_count
    stats
}

fn nexus_conn_stats_frames_sent(stats: i64) -> i64 { vec_get(stats, 0) }
fn nexus_conn_stats_frames_recv(stats: i64) -> i64 { vec_get(stats, 1) }
fn nexus_conn_stats_bytes_sent(stats: i64) -> i64 { vec_get(stats, 2) }
fn nexus_conn_stats_bytes_recv(stats: i64) -> i64 { vec_get(stats, 3) }
fn nexus_conn_stats_checksum_mismatches(stats: i64) -> i64 { vec_get(stats, 4) }
fn nexus_conn_stats_resync_count(stats: i64) -> i64 { vec_get(stats, 5) }

fn nexus_conn_stats_print(stats: i64) -> i64 {
    print("Nexus Connection Stats:\n");
    print("  Frames sent: ");
    print_i64(nexus_conn_stats_frames_sent(stats));
    print("\n");
    print("  Frames recv: ");
    print_i64(nexus_conn_stats_frames_recv(stats));
    print("\n");
    print("  Bytes sent: ");
    print_i64(nexus_conn_stats_bytes_sent(stats));
    print("\n");
    print("  Bytes recv: ");
    print_i64(nexus_conn_stats_bytes_recv(stats));
    print("\n");
    print("  Checksum mismatches: ");
    print_i64(nexus_conn_stats_checksum_mismatches(stats));
    print("\n");
    print("  Resync count: ");
    print_i64(nexus_conn_stats_resync_count(stats));
    print("\n");
    0
}

// =============================================================================
// Bandwidth Estimation
// =============================================================================

// Estimate bandwidth for syncing N beliefs at given rate
// Returns: bytes per second
fn nexus_estimate_bandwidth(belief_count: i64, sync_rate_hz: i64,
                            pct_unchanged: i64, pct_small_delta: i64) -> i64 {
    // Calculate bits per sync
    let unchanged: i64 = (belief_count * pct_unchanged) / 100;
    let small: i64 = (belief_count * pct_small_delta) / 100;
    let full: i64 = belief_count - unchanged - small;

    let bits: i64 = unchanged * 2 +    // SAME: 2 bits
                    small * 9 +        // DELTA_S: 9 bits
                    full * 34;         // FULL: 34 bits

    let bytes_per_sync: i64 = (bits + 7) / 8 + 8;  // +8 for header

    bytes_per_sync * sync_rate_hz
}

// Print bandwidth comparison
fn nexus_print_bandwidth_comparison(belief_count: i64, sync_rate_hz: i64) -> i64 {
    print("\n");
    print("Bandwidth Comparison:\n");
    print("-------------------------------------------------\n");

    print("Beliefs: ");
    print_i64(belief_count);
    print(", Sync Rate: ");
    print_i64(sync_rate_hz);
    print(" Hz\n");
    print("\n");

    // Naive (90 bytes/belief)
    let naive: i64 = belief_count * 90 * sync_rate_hz;
    print("Naive JSON:      ");
    print_bandwidth(naive);

    // Protobuf (~45 bytes/belief)
    let protobuf: i64 = belief_count * 45 * sync_rate_hz;
    print("Protobuf:        ");
    print_bandwidth(protobuf);

    // Nexus (typical: 90% unchanged, 9% small delta, 1% full)
    let nexus: i64 = nexus_estimate_bandwidth(belief_count, sync_rate_hz, 90, 9);
    print("Nexus (typical): ");
    print_bandwidth(nexus);

    // Improvement factor
    print("\n");
    print("Improvement vs naive: ");
    print_i64(naive / nexus);
    print("x\n");

    print("Improvement vs protobuf: ");
    print_i64(protobuf / nexus);
    print("x\n");

    print("\n");
    0
}

fn print_bandwidth(bytes_per_sec: i64) -> i64 {
    if bytes_per_sec >= 1000000 {
        print_i64(bytes_per_sec / 1000000);
        print(".");
        print_i64((bytes_per_sec / 100000) % 10);
        print(" MB/s\n");
    } else if bytes_per_sec >= 1000 {
        print_i64(bytes_per_sec / 1000);
        print(".");
        print_i64((bytes_per_sec / 100) % 10);
        print(" KB/s\n");
    } else {
        print_i64(bytes_per_sec);
        print(" B/s\n");
    }
    0
}

// =============================================================================
// Protocol Info
// =============================================================================

fn nexus_print_info() -> i64 {
    print("\n");
    print("================================================================\n");
    print("              NEXUS PROTOCOL v0.9.5                             \n");
    print("      High-Performance Hive Communication                       \n");
    print("================================================================\n");
    print("\n");
    print("Delta Encoding (bits per belief):\n");
    print("  SAME:    2 bits  (no change)\n");
    print("  DELTA_S: 9 bits  (small delta +/-64)\n");
    print("  DELTA_L: 18 bits (large delta +/-32K)\n");
    print("  FULL:    34 bits (complete value)\n");
    print("\n");
    print("Typical Performance (1000 beliefs @ 60Hz):\n");
    print("  90% unchanged, 9% small delta, 1% full\n");
    print("  = 378 bytes/sync = 22 KB/sec\n");
    print("  = 0.38 bytes/belief (vs 90 naive)\n");
    print("\n");
    0
}

// =============================================================================
// Memory Allocation Helpers
// =============================================================================

// Memory allocation strategy:
// - alloc() returns vec_handle * 65536 (shifted to make room for offsets)
// - When code does ptr + offset, result is vec_handle * 65536 + offset
// - store64/load64 decode: vec = addr / 65536, slot = (addr % 65536) / 8
// - This supports offsets up to 65535 bytes (8191 slots)

// Allocate memory block of given size (in bytes)
fn alloc(size: i64) -> i64 {
    let slots = (size + 7) / 8;  // Round up to 8-byte slots
    if slots < 1 {
        slots = 1;
    }
    let v = vec_new();
    let i = 0;
    while i < slots {
        vec_push(v, 0);
        i = i + 1;
    }
    v * 65536  // Encode: shift vec handle left to make room for offsets
}

// Store 64-bit value at address (ptr + offset encoded together)
fn store64(addr: i64, value: i64) {
    let vec = addr / 65536;
    let offset = addr % 65536;
    let slot = offset / 8;
    vec_set(vec, slot, value);
}

// Load 64-bit value from address (ptr + offset encoded together)
fn load64(addr: i64) -> i64 {
    let vec = addr / 65536;
    let offset = addr % 65536;
    let slot = offset / 8;
    vec_get(vec, slot)
}

// Free a memory block (stub - Simplex uses garbage collection)
fn mem_free(addr: i64) {
    // No-op: memory is automatically collected
}

// Free a vector (stub - Simplex uses garbage collection)
fn vec_free(v: i64) {
    // No-op: memory is automatically collected
}

// Note: Functions from types.sx and sync.sx are defined
// in those files which must be included before this file when compiling
// Built-in functions: vec_new, vec_push, vec_get, vec_set, vec_len, print, print_i64
