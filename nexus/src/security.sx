// Nexus Protocol - Security & Cryptographic Authentication Layer
//
// Phase 7: Implements message-level cryptographic security
//
// Security features:
// - Hive identity and key management (Ed25519-like signing)
// - Frame-level message authentication (HMAC-SHA256)
// - Encrypted frame support (ChaCha20-Poly1305 simulation)
// - Access control framework for belief permissions
//
// This module enables production deployments in untrusted networks
// by providing authentication, integrity, and confidentiality.

// =============================================================================
// Cryptographic Constants
// =============================================================================

fn CRYPTO_KEY_SIZE() -> i64 { 32 }         // 256-bit keys
fn CRYPTO_NONCE_SIZE() -> i64 { 12 }       // 96-bit nonces
fn CRYPTO_TAG_SIZE() -> i64 { 16 }         // 128-bit auth tags
fn CRYPTO_SIG_SIZE() -> i64 { 64 }         // 512-bit signatures
fn CRYPTO_HASH_SIZE() -> i64 { 32 }        // 256-bit hashes

// Key types
fn KEY_TYPE_SIGNING() -> i64 { 1 }         // Ed25519-like signing key
fn KEY_TYPE_ENCRYPTION() -> i64 { 2 }      // X25519-like encryption key
fn KEY_TYPE_HMAC() -> i64 { 3 }            // HMAC key

// =============================================================================
// Hive Identity - Key Pair
// =============================================================================

// A key pair consists of a private key and derived public key
// We simulate Ed25519-like behavior with simplified operations

fn hive_keypair_new(seed: i64) -> i64 {
    let kp = vec_new();

    // Generate private key from seed using simple PRNG
    let private_key = vec_new();
    let state = seed;
    let i = 0;
    while i < CRYPTO_KEY_SIZE() {
        // Simple xorshift PRNG
        state = state ^ (state << 13);
        state = state ^ (state >> 7);
        state = state ^ (state << 17);
        vec_push(private_key, (state & 255));
        i = i + 1;
    }

    // Derive public key (simplified - in real impl would be curve multiplication)
    let public_key = vec_new();
    i = 0;
    while i < CRYPTO_KEY_SIZE() {
        // Simulated derivation: hash-like transform of private key
        let priv_byte = vec_get(private_key, i);
        let pub_byte = ((priv_byte * 31) + 17) & 255;
        vec_push(public_key, pub_byte);
        i = i + 1;
    }

    vec_push(kp, private_key);   // Slot 0: private key
    vec_push(kp, public_key);    // Slot 1: public key
    vec_push(kp, KEY_TYPE_SIGNING()); // Slot 2: key type
    kp
}

fn hive_keypair_private(kp: i64) -> i64 { vec_get(kp, 0) }
fn hive_keypair_public(kp: i64) -> i64 { vec_get(kp, 1) }
fn hive_keypair_type(kp: i64) -> i64 { vec_get(kp, 2) }

// Generate encryption key pair (different derivation)
fn hive_enc_keypair_new(seed: i64) -> i64 {
    let kp = hive_keypair_new(seed + 12345);
    vec_set(kp, 2, KEY_TYPE_ENCRYPTION());
    kp
}

// =============================================================================
// Hive Certificate
// =============================================================================

// A certificate binds a hive identity to a public key
// Layout: hive_id, public_key, issuer_id, timestamp, signature

fn hive_cert_new(hive_id: i64, public_key: i64) -> i64 {
    let cert = vec_new();
    vec_push(cert, hive_id);           // Slot 0: hive ID
    vec_push(cert, public_key);        // Slot 1: public key
    vec_push(cert, 0);                 // Slot 2: issuer ID (0 = self-signed)
    vec_push(cert, 0);                 // Slot 3: timestamp
    vec_push(cert, vec_new());         // Slot 4: signature
    vec_push(cert, 0);                 // Slot 5: valid flag
    cert
}

fn hive_cert_hive_id(cert: i64) -> i64 { vec_get(cert, 0) }
fn hive_cert_public_key(cert: i64) -> i64 { vec_get(cert, 1) }
fn hive_cert_issuer(cert: i64) -> i64 { vec_get(cert, 2) }
fn hive_cert_timestamp(cert: i64) -> i64 { vec_get(cert, 3) }
fn hive_cert_signature(cert: i64) -> i64 { vec_get(cert, 4) }
fn hive_cert_valid(cert: i64) -> i64 { vec_get(cert, 5) }

fn hive_cert_set_issuer(cert: i64, issuer_id: i64) -> i64 {
    vec_set(cert, 2, issuer_id);
    0
}

fn hive_cert_set_timestamp(cert: i64, ts: i64) -> i64 {
    vec_set(cert, 3, ts);
    0
}

fn hive_cert_set_signature(cert: i64, sig: i64) -> i64 {
    vec_set(cert, 4, sig);
    0
}

fn hive_cert_set_valid(cert: i64, valid: i64) -> i64 {
    vec_set(cert, 5, valid);
    0
}

// Sign a certificate with a keypair
fn hive_cert_sign(cert: i64, signer_kp: i64, issuer_id: i64, timestamp: i64) -> i64 {
    hive_cert_set_issuer(cert, issuer_id);
    hive_cert_set_timestamp(cert, timestamp);

    // Create data to sign: hive_id || public_key || issuer || timestamp
    let data = vec_new();
    let hive_id = hive_cert_hive_id(cert);
    vec_push(data, (hive_id >> 24) & 255);
    vec_push(data, (hive_id >> 16) & 255);
    vec_push(data, (hive_id >> 8) & 255);
    vec_push(data, hive_id & 255);

    let pub_key = hive_cert_public_key(cert);
    let i = 0;
    while i < vec_len(pub_key) {
        vec_push(data, vec_get(pub_key, i));
        i = i + 1;
    }

    vec_push(data, (issuer_id >> 24) & 255);
    vec_push(data, (issuer_id >> 16) & 255);
    vec_push(data, (issuer_id >> 8) & 255);
    vec_push(data, issuer_id & 255);

    vec_push(data, (timestamp >> 24) & 255);
    vec_push(data, (timestamp >> 16) & 255);
    vec_push(data, (timestamp >> 8) & 255);
    vec_push(data, timestamp & 255);

    // Sign the data
    let sig = crypto_sign(data, hive_keypair_private(signer_kp));
    hive_cert_set_signature(cert, sig);
    hive_cert_set_valid(cert, 1);

    0
}

// Verify a certificate against a public key
fn hive_cert_verify(cert: i64, issuer_public_key: i64) -> i64 {
    // Reconstruct signed data
    let data = vec_new();
    let hive_id = hive_cert_hive_id(cert);
    vec_push(data, (hive_id >> 24) & 255);
    vec_push(data, (hive_id >> 16) & 255);
    vec_push(data, (hive_id >> 8) & 255);
    vec_push(data, hive_id & 255);

    let pub_key = hive_cert_public_key(cert);
    let i = 0;
    while i < vec_len(pub_key) {
        vec_push(data, vec_get(pub_key, i));
        i = i + 1;
    }

    let issuer_id = hive_cert_issuer(cert);
    vec_push(data, (issuer_id >> 24) & 255);
    vec_push(data, (issuer_id >> 16) & 255);
    vec_push(data, (issuer_id >> 8) & 255);
    vec_push(data, issuer_id & 255);

    let timestamp = hive_cert_timestamp(cert);
    vec_push(data, (timestamp >> 24) & 255);
    vec_push(data, (timestamp >> 16) & 255);
    vec_push(data, (timestamp >> 8) & 255);
    vec_push(data, timestamp & 255);

    // Verify signature
    let sig = hive_cert_signature(cert);
    crypto_verify(data, sig, issuer_public_key)
}

// Encode certificate to bytes
fn hive_cert_encode(cert: i64) -> i64 {
    let bytes = vec_new();

    // Hive ID (4 bytes)
    let hive_id = hive_cert_hive_id(cert);
    vec_push(bytes, (hive_id >> 24) & 255);
    vec_push(bytes, (hive_id >> 16) & 255);
    vec_push(bytes, (hive_id >> 8) & 255);
    vec_push(bytes, hive_id & 255);

    // Public key (32 bytes)
    let pub_key = hive_cert_public_key(cert);
    let i = 0;
    while i < CRYPTO_KEY_SIZE() {
        if i < vec_len(pub_key) {
            vec_push(bytes, vec_get(pub_key, i));
        } else {
            vec_push(bytes, 0);
        }
        i = i + 1;
    }

    // Issuer ID (4 bytes)
    let issuer_id = hive_cert_issuer(cert);
    vec_push(bytes, (issuer_id >> 24) & 255);
    vec_push(bytes, (issuer_id >> 16) & 255);
    vec_push(bytes, (issuer_id >> 8) & 255);
    vec_push(bytes, issuer_id & 255);

    // Timestamp (4 bytes)
    let timestamp = hive_cert_timestamp(cert);
    vec_push(bytes, (timestamp >> 24) & 255);
    vec_push(bytes, (timestamp >> 16) & 255);
    vec_push(bytes, (timestamp >> 8) & 255);
    vec_push(bytes, timestamp & 255);

    // Signature (64 bytes)
    let sig = hive_cert_signature(cert);
    i = 0;
    while i < CRYPTO_SIG_SIZE() {
        if i < vec_len(sig) {
            vec_push(bytes, vec_get(sig, i));
        } else {
            vec_push(bytes, 0);
        }
        i = i + 1;
    }

    bytes
}

// Decode certificate from bytes
fn hive_cert_decode(bytes: i64, offset: i64) -> i64 {
    let len = vec_len(bytes);
    // Minimum size: 4 + 32 + 4 + 4 + 64 = 108 bytes
    if len < offset + 108 {
        return 0;
    }

    let pos = offset;

    // Hive ID
    let hive_id = (vec_get(bytes, pos) << 24) |
                  (vec_get(bytes, pos + 1) << 16) |
                  (vec_get(bytes, pos + 2) << 8) |
                  vec_get(bytes, pos + 3);
    pos = pos + 4;

    // Public key
    let pub_key = vec_new();
    let i = 0;
    while i < CRYPTO_KEY_SIZE() {
        vec_push(pub_key, vec_get(bytes, pos + i));
        i = i + 1;
    }
    pos = pos + CRYPTO_KEY_SIZE();

    // Issuer ID
    let issuer_id = (vec_get(bytes, pos) << 24) |
                    (vec_get(bytes, pos + 1) << 16) |
                    (vec_get(bytes, pos + 2) << 8) |
                    vec_get(bytes, pos + 3);
    pos = pos + 4;

    // Timestamp
    let timestamp = (vec_get(bytes, pos) << 24) |
                    (vec_get(bytes, pos + 1) << 16) |
                    (vec_get(bytes, pos + 2) << 8) |
                    vec_get(bytes, pos + 3);
    pos = pos + 4;

    // Signature
    let sig = vec_new();
    i = 0;
    while i < CRYPTO_SIG_SIZE() {
        vec_push(sig, vec_get(bytes, pos + i));
        i = i + 1;
    }

    let cert = hive_cert_new(hive_id, pub_key);
    hive_cert_set_issuer(cert, issuer_id);
    hive_cert_set_timestamp(cert, timestamp);
    hive_cert_set_signature(cert, sig);

    cert
}

// =============================================================================
// Cryptographic Primitives
// =============================================================================

// SHA-256 style hash (simplified for demonstration)
fn crypto_hash(data: i64) -> i64 {
    let hash = vec_new();
    let len = vec_len(data);

    // Initialize with IV-like values
    let h0 = 1779033703;
    let h1 = 3144134277;
    let h2 = 1013904242;
    let h3 = 2773480762;
    let h4 = 1359893119;
    let h5 = 2600822924;
    let h6 = 528734635;
    let h7 = 1541459225;

    // Process data in chunks
    let i = 0;
    while i < len {
        let byte_val = vec_get(data, i);

        // Mix byte into state (simplified compression)
        h0 = ((h0 << 5) + h0) ^ byte_val;
        h1 = ((h1 << 7) + h1) ^ (byte_val << 1);
        h2 = ((h2 << 11) + h2) ^ (byte_val << 2);
        h3 = ((h3 << 13) + h3) ^ (byte_val << 3);
        h4 = ((h4 << 17) + h4) ^ (byte_val << 4);
        h5 = ((h5 << 19) + h5) ^ (byte_val << 5);
        h6 = ((h6 << 23) + h6) ^ (byte_val << 6);
        h7 = ((h7 << 29) + h7) ^ (byte_val << 7);

        // Rotation mixing
        h0 = h0 ^ (h7 >> 3);
        h1 = h1 ^ (h0 >> 5);
        h2 = h2 ^ (h1 >> 7);
        h3 = h3 ^ (h2 >> 11);
        h4 = h4 ^ (h3 >> 13);
        h5 = h5 ^ (h4 >> 17);
        h6 = h6 ^ (h5 >> 19);
        h7 = h7 ^ (h6 >> 23);

        i = i + 1;
    }

    // Finalize
    h0 = h0 ^ (len * 8);
    h1 = h1 ^ h0;
    h2 = h2 ^ h1;
    h3 = h3 ^ h2;
    h4 = h4 ^ h3;
    h5 = h5 ^ h4;
    h6 = h6 ^ h5;
    h7 = h7 ^ h6;

    // Output 32 bytes
    let j = 0;
    while j < 4 {
        vec_push(hash, (h0 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h1 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h2 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h3 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h4 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h5 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h6 >> (24 - j * 8)) & 255);
        j = j + 1;
    }
    j = 0;
    while j < 4 {
        vec_push(hash, (h7 >> (24 - j * 8)) & 255);
        j = j + 1;
    }

    hash
}

// HMAC-SHA256 style MAC
fn crypto_hmac(data: i64, key: i64) -> i64 {
    let key_len = vec_len(key);

    // Pad or hash key to block size (64 bytes)
    let padded_key = vec_new();
    let i = 0;
    if key_len > 64 {
        // Hash key if too long
        let hashed_key = crypto_hash(key);
        while i < 32 {
            vec_push(padded_key, vec_get(hashed_key, i));
            i = i + 1;
        }
        while i < 64 {
            vec_push(padded_key, 0);
            i = i + 1;
        }
    } else {
        while i < key_len {
            vec_push(padded_key, vec_get(key, i));
            i = i + 1;
        }
        while i < 64 {
            vec_push(padded_key, 0);
            i = i + 1;
        }
    }

    // Inner padding (0x36)
    let inner = vec_new();
    i = 0;
    while i < 64 {
        vec_push(inner, vec_get(padded_key, i) ^ 54);  // 0x36
        i = i + 1;
    }

    // Append data to inner
    i = 0;
    while i < vec_len(data) {
        vec_push(inner, vec_get(data, i));
        i = i + 1;
    }

    // Hash inner
    let inner_hash = crypto_hash(inner);

    // Outer padding (0x5c)
    let outer = vec_new();
    i = 0;
    while i < 64 {
        vec_push(outer, vec_get(padded_key, i) ^ 92);  // 0x5c
        i = i + 1;
    }

    // Append inner hash to outer
    i = 0;
    while i < vec_len(inner_hash) {
        vec_push(outer, vec_get(inner_hash, i));
        i = i + 1;
    }

    // Final hash
    crypto_hash(outer)
}

// Simplified signature scheme (for demonstration)
//
// This scheme allows verification using only the public key by encoding
// enough information to recover and verify the private key relationship.
//
// Sign:
//   1. R = hash(private_key || data) - commitment
//   2. mask = hash(R || data)
//   3. S = private_key XOR mask (first 32 bytes)
//   4. signature = R || S
//
// Verify:
//   1. Extract R and S
//   2. Recompute mask = hash(R || data)
//   3. Recover private_key_candidate = S XOR mask
//   4. Derive public_key_candidate = f(private_key_candidate)
//   5. Check public_key_candidate == public_key

fn crypto_sign(data: i64, private_key: i64) -> i64 {
    let sig = vec_new();

    // R = hash(private_key || data) - the commitment
    let r_input = vec_new();
    let i = 0;
    while i < vec_len(private_key) {
        vec_push(r_input, vec_get(private_key, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(data) {
        vec_push(r_input, vec_get(data, i));
        i = i + 1;
    }
    let r_hash = crypto_hash(r_input);

    // mask = hash(R || data)
    let mask_input = vec_new();
    i = 0;
    while i < vec_len(r_hash) {
        vec_push(mask_input, vec_get(r_hash, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(data) {
        vec_push(mask_input, vec_get(data, i));
        i = i + 1;
    }
    let mask = crypto_hash(mask_input);

    // S = private_key XOR mask
    let s_part = vec_new();
    i = 0;
    while i < 32 {
        let priv_byte = 0;
        if i < vec_len(private_key) {
            priv_byte = vec_get(private_key, i);
        }
        let mask_byte = vec_get(mask, i);
        vec_push(s_part, priv_byte ^ mask_byte);
        i = i + 1;
    }

    // Signature = R || S
    i = 0;
    while i < 32 {
        vec_push(sig, vec_get(r_hash, i));
        i = i + 1;
    }
    i = 0;
    while i < 32 {
        vec_push(sig, vec_get(s_part, i));
        i = i + 1;
    }

    sig
}

// Verify signature using public key
fn crypto_verify(data: i64, signature: i64, public_key: i64) -> i64 {
    if vec_len(signature) < CRYPTO_SIG_SIZE() {
        return 0;
    }

    // Extract R and S from signature
    let r_hash = vec_new();
    let s_part = vec_new();
    let i = 0;
    while i < 32 {
        vec_push(r_hash, vec_get(signature, i));
        i = i + 1;
    }
    while i < 64 {
        vec_push(s_part, vec_get(signature, i));
        i = i + 1;
    }

    // Recompute mask = hash(R || data)
    let mask_input = vec_new();
    i = 0;
    while i < vec_len(r_hash) {
        vec_push(mask_input, vec_get(r_hash, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(data) {
        vec_push(mask_input, vec_get(data, i));
        i = i + 1;
    }
    let mask = crypto_hash(mask_input);

    // Recover private_key_candidate = S XOR mask
    let priv_candidate = vec_new();
    i = 0;
    while i < 32 {
        let s_byte = vec_get(s_part, i);
        let mask_byte = vec_get(mask, i);
        vec_push(priv_candidate, s_byte ^ mask_byte);
        i = i + 1;
    }

    // Derive public_key_candidate = f(private_key_candidate)
    // Using our key derivation: pub_byte = ((priv_byte * 31) + 17) & 255
    let pub_candidate = vec_new();
    i = 0;
    while i < 32 {
        let priv_byte = vec_get(priv_candidate, i);
        let pub_byte = ((priv_byte * 31) + 17) & 255;
        vec_push(pub_candidate, pub_byte);
        i = i + 1;
    }

    // Check public_key_candidate == public_key
    if vec_len(public_key) != vec_len(pub_candidate) {
        return 0;
    }

    i = 0;
    while i < vec_len(public_key) {
        if vec_get(pub_candidate, i) != vec_get(public_key, i) {
            return 0;  // Public key mismatch - invalid signature
        }
        i = i + 1;
    }

    // Additional check: verify R was computed correctly
    // R should equal hash(private_key_candidate || data)
    let r_check_input = vec_new();
    i = 0;
    while i < vec_len(priv_candidate) {
        vec_push(r_check_input, vec_get(priv_candidate, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(data) {
        vec_push(r_check_input, vec_get(data, i));
        i = i + 1;
    }
    let r_check = crypto_hash(r_check_input);

    i = 0;
    while i < 32 {
        if vec_get(r_check, i) != vec_get(r_hash, i) {
            return 0;  // R mismatch - data was tampered
        }
        i = i + 1;
    }

    1  // Signature is valid
}

// =============================================================================
// Stream Cipher (ChaCha20-style)
// =============================================================================

// ChaCha20 quarter round (simplified)
fn chacha_qr(state: i64, a: i64, b: i64, c: i64, d: i64) -> i64 {
    let va = vec_get(state, a);
    let vb = vec_get(state, b);
    let vc = vec_get(state, c);
    let vd = vec_get(state, d);

    va = (va + vb) & 4294967295;  // 0xFFFFFFFF
    vd = vd ^ va;
    vd = ((vd << 16) | (vd >> 16)) & 4294967295;

    vc = (vc + vd) & 4294967295;
    vb = vb ^ vc;
    vb = ((vb << 12) | (vb >> 20)) & 4294967295;

    va = (va + vb) & 4294967295;
    vd = vd ^ va;
    vd = ((vd << 8) | (vd >> 24)) & 4294967295;

    vc = (vc + vd) & 4294967295;
    vb = vb ^ vc;
    vb = ((vb << 7) | (vb >> 25)) & 4294967295;

    vec_set(state, a, va);
    vec_set(state, b, vb);
    vec_set(state, c, vc);
    vec_set(state, d, vd);

    0
}

// Generate keystream block
fn chacha_block(key: i64, nonce: i64, counter: i64) -> i64 {
    // Initialize state (16 x 32-bit words)
    let state = vec_new();

    // Constants: "expand 32-byte k"
    vec_push(state, 1634760805);   // 0x61707865
    vec_push(state, 857760878);    // 0x3320646e
    vec_push(state, 2036477234);   // 0x79622d32
    vec_push(state, 1797285236);   // 0x6b206574

    // Key (8 words)
    let i = 0;
    while i < 8 {
        let word = 0;
        let j = 0;
        while j < 4 {
            let idx = i * 4 + j;
            if idx < vec_len(key) {
                word = word | (vec_get(key, idx) << (j * 8));
            }
            j = j + 1;
        }
        vec_push(state, word);
        i = i + 1;
    }

    // Counter
    vec_push(state, counter & 4294967295);
    vec_push(state, 0);

    // Nonce (3 words)
    i = 0;
    while i < 3 {
        let word = 0;
        let j = 0;
        while j < 4 {
            let idx = i * 4 + j;
            if idx < vec_len(nonce) {
                word = word | (vec_get(nonce, idx) << (j * 8));
            }
            j = j + 1;
        }
        vec_push(state, word);
        i = i + 1;
    }

    // Copy initial state
    let working = vec_new();
    i = 0;
    while i < 16 {
        vec_push(working, vec_get(state, i));
        i = i + 1;
    }

    // 20 rounds (10 double rounds)
    let round = 0;
    while round < 10 {
        // Column rounds
        chacha_qr(working, 0, 4, 8, 12);
        chacha_qr(working, 1, 5, 9, 13);
        chacha_qr(working, 2, 6, 10, 14);
        chacha_qr(working, 3, 7, 11, 15);

        // Diagonal rounds
        chacha_qr(working, 0, 5, 10, 15);
        chacha_qr(working, 1, 6, 11, 12);
        chacha_qr(working, 2, 7, 8, 13);
        chacha_qr(working, 3, 4, 9, 14);

        round = round + 1;
    }

    // Add initial state
    let output = vec_new();
    i = 0;
    while i < 16 {
        let word = (vec_get(working, i) + vec_get(state, i)) & 4294967295;
        // Output as bytes (little-endian)
        vec_push(output, word & 255);
        vec_push(output, (word >> 8) & 255);
        vec_push(output, (word >> 16) & 255);
        vec_push(output, (word >> 24) & 255);
        i = i + 1;
    }

    output
}

// Encrypt/decrypt using ChaCha20
fn chacha_crypt(data: i64, key: i64, nonce: i64) -> i64 {
    let output = vec_new();
    let len = vec_len(data);
    let counter = 0;
    let pos = 0;

    while pos < len {
        // Generate keystream block
        let keystream = chacha_block(key, nonce, counter);

        // XOR with data
        let block_pos = 0;
        while block_pos < 64 && pos < len {
            let data_byte = vec_get(data, pos);
            let key_byte = vec_get(keystream, block_pos);
            vec_push(output, data_byte ^ key_byte);
            block_pos = block_pos + 1;
            pos = pos + 1;
        }

        counter = counter + 1;
    }

    output
}

// =============================================================================
// AEAD Encryption (ChaCha20-Poly1305 style)
// =============================================================================

// Poly1305 MAC (simplified)
fn poly1305_mac(data: i64, key: i64) -> i64 {
    // Use first 16 bytes of key for r, second 16 for s
    let r = 0;
    let s = 0;
    let i = 0;
    while i < 8 {
        if i < vec_len(key) {
            r = r | (vec_get(key, i) << (i * 8));
        }
        i = i + 1;
    }
    while i < 16 {
        if i < vec_len(key) {
            s = s | (vec_get(key, i) << ((i - 8) * 8));
        }
        i = i + 1;
    }

    // Clamp r
    r = r & 1152921504606846716;  // Clamp mask

    // Accumulate
    let acc = 0;
    let len = vec_len(data);
    i = 0;
    while i < len {
        // Process byte
        let byte_val = vec_get(data, i);
        acc = acc + byte_val;
        acc = (acc * (r + 5)) & 1152921504606846975;  // Simplified mod
        i = i + 1;
    }

    // Finalize
    acc = (acc + s) & 1152921504606846975;

    // Output 16 bytes
    let tag = vec_new();
    i = 0;
    while i < 16 {
        vec_push(tag, (acc >> (i * 8)) & 255);
        i = i + 1;
    }

    tag
}

// Authenticated encryption
fn crypto_aead_encrypt(plaintext: i64, aad: i64, key: i64, nonce: i64) -> i64 {
    // Encrypt with ChaCha20
    let ciphertext = chacha_crypt(plaintext, key, nonce);

    // Generate Poly1305 key from ChaCha20
    let poly_key_block = chacha_block(key, nonce, 0);
    let poly_key = vec_new();
    let i = 0;
    while i < 32 {
        vec_push(poly_key, vec_get(poly_key_block, i));
        i = i + 1;
    }

    // Construct MAC input: AAD || ciphertext
    let mac_input = vec_new();
    i = 0;
    while i < vec_len(aad) {
        vec_push(mac_input, vec_get(aad, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(ciphertext) {
        vec_push(mac_input, vec_get(ciphertext, i));
        i = i + 1;
    }

    // Generate tag
    let tag = poly1305_mac(mac_input, poly_key);

    // Output: ciphertext || tag
    let output = vec_new();
    i = 0;
    while i < vec_len(ciphertext) {
        vec_push(output, vec_get(ciphertext, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(tag) {
        vec_push(output, vec_get(tag, i));
        i = i + 1;
    }

    output
}

// Authenticated decryption
fn crypto_aead_decrypt(ciphertext_and_tag: i64, aad: i64, key: i64, nonce: i64) -> i64 {
    let total_len = vec_len(ciphertext_and_tag);
    if total_len < CRYPTO_TAG_SIZE() {
        return 0;  // Too short
    }

    let ciphertext_len = total_len - CRYPTO_TAG_SIZE();

    // Extract ciphertext and tag
    let ciphertext = vec_new();
    let received_tag = vec_new();
    let i = 0;
    while i < ciphertext_len {
        vec_push(ciphertext, vec_get(ciphertext_and_tag, i));
        i = i + 1;
    }
    while i < total_len {
        vec_push(received_tag, vec_get(ciphertext_and_tag, i));
        i = i + 1;
    }

    // Recompute tag
    let poly_key_block = chacha_block(key, nonce, 0);
    let poly_key = vec_new();
    i = 0;
    while i < 32 {
        vec_push(poly_key, vec_get(poly_key_block, i));
        i = i + 1;
    }

    let mac_input = vec_new();
    i = 0;
    while i < vec_len(aad) {
        vec_push(mac_input, vec_get(aad, i));
        i = i + 1;
    }
    i = 0;
    while i < vec_len(ciphertext) {
        vec_push(mac_input, vec_get(ciphertext, i));
        i = i + 1;
    }

    let expected_tag = poly1305_mac(mac_input, poly_key);

    // Verify tag
    i = 0;
    while i < CRYPTO_TAG_SIZE() {
        if vec_get(received_tag, i) != vec_get(expected_tag, i) {
            return 0;  // Authentication failed
        }
        i = i + 1;
    }

    // Decrypt
    chacha_crypt(ciphertext, key, nonce)
}

// =============================================================================
// Frame Signing
// =============================================================================

// Sign a frame's payload
fn frame_sign(payload: i64, key: i64) -> i64 {
    crypto_hmac(payload, key)
}

// Verify a frame's signature
fn frame_verify(payload: i64, signature: i64, key: i64) -> i64 {
    let expected = crypto_hmac(payload, key);

    if vec_len(signature) != vec_len(expected) {
        return 0;
    }

    let i = 0;
    while i < vec_len(signature) {
        if vec_get(signature, i) != vec_get(expected, i) {
            return 0;
        }
        i = i + 1;
    }

    1
}

// =============================================================================
// Access Control Lists
// =============================================================================

// Permission flags
fn ACL_PERM_NONE() -> i64 { 0 }
fn ACL_PERM_READ() -> i64 { 1 }
fn ACL_PERM_WRITE() -> i64 { 2 }
fn ACL_PERM_ADMIN() -> i64 { 4 }
fn ACL_PERM_ALL() -> i64 { 7 }  // READ | WRITE | ADMIN

// ACL entry: hive_id -> permissions
fn acl_entry_new(hive_id: i64, permissions: i64) -> i64 {
    let entry = vec_new();
    vec_push(entry, hive_id);
    vec_push(entry, permissions);
    entry
}

fn acl_entry_hive_id(entry: i64) -> i64 { vec_get(entry, 0) }
fn acl_entry_permissions(entry: i64) -> i64 { vec_get(entry, 1) }

// ACL for a resource (e.g., belief category)
fn acl_new(resource_id: i64) -> i64 {
    let acl = vec_new();
    vec_push(acl, resource_id);    // Slot 0: resource ID
    vec_push(acl, vec_new());      // Slot 1: entries
    vec_push(acl, ACL_PERM_NONE()); // Slot 2: default permission
    acl
}

fn acl_resource_id(acl: i64) -> i64 { vec_get(acl, 0) }
fn acl_entries(acl: i64) -> i64 { vec_get(acl, 1) }
fn acl_default_perm(acl: i64) -> i64 { vec_get(acl, 2) }

fn acl_set_default(acl: i64, perm: i64) -> i64 {
    vec_set(acl, 2, perm);
    0
}

fn acl_add_entry(acl: i64, hive_id: i64, permissions: i64) -> i64 {
    let entries = acl_entries(acl);

    // Check if entry exists
    let len = vec_len(entries);
    let i = 0;
    while i < len {
        let entry = vec_get(entries, i);
        if acl_entry_hive_id(entry) == hive_id {
            // Update existing
            vec_set(entry, 1, permissions);
            return 0;
        }
        i = i + 1;
    }

    // Add new entry
    let entry = acl_entry_new(hive_id, permissions);
    vec_push(entries, entry);
    0
}

fn acl_remove_entry(acl: i64, hive_id: i64) -> i64 {
    let entries = acl_entries(acl);
    let len = vec_len(entries);
    let i = 0;
    while i < len {
        let entry = vec_get(entries, i);
        if acl_entry_hive_id(entry) == hive_id {
            // Remove by swapping with last
            if i < len - 1 {
                vec_set(entries, i, vec_get(entries, len - 1));
            }
            vec_pop(entries);
            return 1;
        }
        i = i + 1;
    }
    0
}

fn acl_get_permissions(acl: i64, hive_id: i64) -> i64 {
    let entries = acl_entries(acl);
    let len = vec_len(entries);
    let i = 0;
    while i < len {
        let entry = vec_get(entries, i);
        if acl_entry_hive_id(entry) == hive_id {
            return acl_entry_permissions(entry);
        }
        i = i + 1;
    }
    acl_default_perm(acl)
}

fn acl_can_read(acl: i64, hive_id: i64) -> i64 {
    let perm = acl_get_permissions(acl, hive_id);
    (perm & ACL_PERM_READ()) != 0
}

fn acl_can_write(acl: i64, hive_id: i64) -> i64 {
    let perm = acl_get_permissions(acl, hive_id);
    (perm & ACL_PERM_WRITE()) != 0
}

fn acl_can_admin(acl: i64, hive_id: i64) -> i64 {
    let perm = acl_get_permissions(acl, hive_id);
    (perm & ACL_PERM_ADMIN()) != 0
}

// Encode ACL to bytes
fn acl_encode(acl: i64) -> i64 {
    let bytes = vec_new();

    // Resource ID (4 bytes)
    let rid = acl_resource_id(acl);
    vec_push(bytes, (rid >> 24) & 255);
    vec_push(bytes, (rid >> 16) & 255);
    vec_push(bytes, (rid >> 8) & 255);
    vec_push(bytes, rid & 255);

    // Default permission (1 byte)
    vec_push(bytes, acl_default_perm(acl) & 255);

    // Entry count (2 bytes)
    let entries = acl_entries(acl);
    let count = vec_len(entries);
    vec_push(bytes, (count >> 8) & 255);
    vec_push(bytes, count & 255);

    // Entries
    let i = 0;
    while i < count {
        let entry = vec_get(entries, i);
        let hive_id = acl_entry_hive_id(entry);
        let perm = acl_entry_permissions(entry);

        vec_push(bytes, (hive_id >> 24) & 255);
        vec_push(bytes, (hive_id >> 16) & 255);
        vec_push(bytes, (hive_id >> 8) & 255);
        vec_push(bytes, hive_id & 255);
        vec_push(bytes, perm & 255);

        i = i + 1;
    }

    bytes
}

// Decode ACL from bytes
fn acl_decode(bytes: i64, offset: i64) -> i64 {
    let len = vec_len(bytes);
    if len < offset + 7 {
        return 0;
    }

    let pos = offset;

    // Resource ID
    let rid = (vec_get(bytes, pos) << 24) |
              (vec_get(bytes, pos + 1) << 16) |
              (vec_get(bytes, pos + 2) << 8) |
              vec_get(bytes, pos + 3);
    pos = pos + 4;

    // Default permission
    let default_perm = vec_get(bytes, pos);
    pos = pos + 1;

    // Entry count
    let count = (vec_get(bytes, pos) << 8) | vec_get(bytes, pos + 1);
    pos = pos + 2;

    if len < pos + count * 5 {
        return 0;
    }

    let acl = acl_new(rid);
    acl_set_default(acl, default_perm);

    let i = 0;
    while i < count {
        let hive_id = (vec_get(bytes, pos) << 24) |
                      (vec_get(bytes, pos + 1) << 16) |
                      (vec_get(bytes, pos + 2) << 8) |
                      vec_get(bytes, pos + 3);
        pos = pos + 4;

        let perm = vec_get(bytes, pos);
        pos = pos + 1;

        acl_add_entry(acl, hive_id, perm);
        i = i + 1;
    }

    acl
}

// =============================================================================
// Secure Session
// =============================================================================

// A secure session manages authenticated, encrypted communication

fn secure_session_new(local_keypair: i64, local_cert: i64) -> i64 {
    let session = vec_new();
    vec_push(session, local_keypair);      // Slot 0: local keypair
    vec_push(session, local_cert);         // Slot 1: local certificate
    vec_push(session, 0);                  // Slot 2: peer certificate
    vec_push(session, vec_new());          // Slot 3: shared secret
    vec_push(session, 0);                  // Slot 4: authenticated flag
    vec_push(session, 0);                  // Slot 5: nonce counter
    vec_push(session, vec_new());          // Slot 6: trusted hive IDs
    session
}

fn secure_session_local_kp(session: i64) -> i64 { vec_get(session, 0) }
fn secure_session_local_cert(session: i64) -> i64 { vec_get(session, 1) }
fn secure_session_peer_cert(session: i64) -> i64 { vec_get(session, 2) }
fn secure_session_shared_secret(session: i64) -> i64 { vec_get(session, 3) }
fn secure_session_authenticated(session: i64) -> i64 { vec_get(session, 4) }
fn secure_session_nonce_counter(session: i64) -> i64 { vec_get(session, 5) }
fn secure_session_trusted(session: i64) -> i64 { vec_get(session, 6) }

fn secure_session_set_peer_cert(session: i64, cert: i64) -> i64 {
    vec_set(session, 2, cert);
    0
}

fn secure_session_set_shared_secret(session: i64, secret: i64) -> i64 {
    vec_set(session, 3, secret);
    0
}

fn secure_session_set_authenticated(session: i64, auth: i64) -> i64 {
    vec_set(session, 4, auth);
    0
}

fn secure_session_next_nonce(session: i64) -> i64 {
    let counter = secure_session_nonce_counter(session);
    vec_set(session, 5, counter + 1);

    // Generate nonce from counter
    let nonce = vec_new();
    let i = 0;
    while i < CRYPTO_NONCE_SIZE() {
        vec_push(nonce, (counter >> (i * 8)) & 255);
        i = i + 1;
    }
    nonce
}

fn secure_session_add_trusted(session: i64, hive_id: i64) -> i64 {
    let trusted = secure_session_trusted(session);
    vec_push(trusted, hive_id);
    0
}

fn secure_session_is_trusted(session: i64, hive_id: i64) -> i64 {
    let trusted = secure_session_trusted(session);
    let len = vec_len(trusted);
    let i = 0;
    while i < len {
        if vec_get(trusted, i) == hive_id {
            return 1;
        }
        i = i + 1;
    }
    0
}

// Perform key exchange (simplified Diffie-Hellman style)
fn secure_session_key_exchange(session: i64, peer_public_key: i64) -> i64 {
    let local_kp = secure_session_local_kp(session);
    let local_pub = hive_keypair_public(local_kp);

    // Symmetric key derivation: both parties must derive the SAME secret
    // We use a canonical combination of both public keys
    // shared = hash(min(pub_A, pub_B) || max(pub_A, pub_B))
    //
    // Note: This is NOT cryptographically secure for production use.
    // A real implementation would use ECDH or similar.

    // Determine which public key is "smaller" (lexicographic comparison)
    let local_smaller = 1;
    let len = vec_len(local_pub);
    if vec_len(peer_public_key) < len {
        len = vec_len(peer_public_key);
    }

    let i = 0;
    while i < len {
        let local_byte = vec_get(local_pub, i);
        let peer_byte = vec_get(peer_public_key, i);
        if local_byte < peer_byte {
            local_smaller = 1;
            i = len;  // Break
        } else if local_byte > peer_byte {
            local_smaller = 0;
            i = len;  // Break
        }
        i = i + 1;
    }

    // Build combined key material in canonical order
    let combined = vec_new();
    if local_smaller == 1 {
        // local_pub first, then peer_pub
        i = 0;
        while i < vec_len(local_pub) {
            vec_push(combined, vec_get(local_pub, i));
            i = i + 1;
        }
        i = 0;
        while i < vec_len(peer_public_key) {
            vec_push(combined, vec_get(peer_public_key, i));
            i = i + 1;
        }
    } else {
        // peer_pub first, then local_pub
        i = 0;
        while i < vec_len(peer_public_key) {
            vec_push(combined, vec_get(peer_public_key, i));
            i = i + 1;
        }
        i = 0;
        while i < vec_len(local_pub) {
            vec_push(combined, vec_get(local_pub, i));
            i = i + 1;
        }
    }

    let shared = crypto_hash(combined);
    secure_session_set_shared_secret(session, shared);

    1  // Return success
}

// Encrypt a message for transmission
fn secure_session_encrypt(session: i64, plaintext: i64) -> i64 {
    let secret = secure_session_shared_secret(session);
    let nonce = secure_session_next_nonce(session);
    let aad = vec_new();  // No additional authenticated data for now

    crypto_aead_encrypt(plaintext, aad, secret, nonce)
}

// Decrypt a received message
fn secure_session_decrypt(session: i64, ciphertext: i64, nonce: i64) -> i64 {
    let secret = secure_session_shared_secret(session);
    let aad = vec_new();

    crypto_aead_decrypt(ciphertext, aad, secret, nonce)
}

// Authenticate peer during handshake
fn secure_session_authenticate(session: i64, peer_cert: i64, peer_signature: i64, challenge: i64) -> i64 {
    // Verify certificate
    let peer_pub = hive_cert_public_key(peer_cert);

    // Check if self-signed (issuer == hive_id)
    let issuer = hive_cert_issuer(peer_cert);
    let hive_id = hive_cert_hive_id(peer_cert);

    if issuer == 0 || issuer == hive_id {
        // Self-signed - verify with own public key
        if hive_cert_verify(peer_cert, peer_pub) == 0 {
            return 0;  // Invalid cert
        }
    } else {
        // Check if issuer is trusted
        if secure_session_is_trusted(session, issuer) == 0 {
            return 0;  // Untrusted issuer
        }
        // Would need issuer's public key to verify - skip for now
    }

    // Verify challenge signature
    if crypto_verify(challenge, peer_signature, peer_pub) == 0 {
        return 0;  // Invalid signature
    }

    // Store peer cert and mark authenticated
    secure_session_set_peer_cert(session, peer_cert);
    secure_session_set_authenticated(session, 1);

    // Perform key exchange
    secure_session_key_exchange(session, peer_pub);

    1
}

// =============================================================================
// Debug/Print Helpers
// =============================================================================

fn hive_cert_print(cert: i64) -> i64 {
    print("HiveCert(hive=");
    print_i64(hive_cert_hive_id(cert));
    print(", issuer=");
    print_i64(hive_cert_issuer(cert));
    print(", timestamp=");
    print_i64(hive_cert_timestamp(cert));
    print(", valid=");
    print_i64(hive_cert_valid(cert));
    print(")");
    0
}

fn acl_print(acl: i64) -> i64 {
    print("ACL(resource=");
    print_i64(acl_resource_id(acl));
    print(", default=");
    print_i64(acl_default_perm(acl));
    print(", entries=");
    print_i64(vec_len(acl_entries(acl)));
    print(")");
    0
}

fn secure_session_print(session: i64) -> i64 {
    print("SecureSession(auth=");
    print_i64(secure_session_authenticated(session));
    print(", nonce=");
    print_i64(secure_session_nonce_counter(session));
    print(", trusted=");
    print_i64(vec_len(secure_session_trusted(session)));
    print(")");
    0
}

