// AWS Signature V4 signing for S3
// Handles both regular requests and presigned URLs

use simplex_std::collections::HashMap;
use simplex_std::crypto::{hmac_sha256, sha256};
use crate::client::S3Error;

/// AWS Credentials
pub struct AwsCredentials {
    pub access_key_id: String,
    pub secret_access_key: String,
    pub region: String,
    pub service: String,
}

/// Sign a request using AWS Signature Version 4
pub fn sign_request(
    method: &str,
    url: &str,
    payload_hash: &str,
    credentials: &AwsCredentials,
) -> Result<HashMap<String, String>, S3Error> {
    let now = simplex_std::time::now_utc();
    let date_stamp = now.format("%Y%m%d");
    let amz_date = now.format("%Y%m%dT%H%M%SZ");

    let (host, path, query) = parse_url(url)?;

    let canonical_headers = format!(
        "host:{}\nx-amz-content-sha256:{}\nx-amz-date:{}\n",
        host, payload_hash, amz_date
    );

    let signed_headers = "host;x-amz-content-sha256;x-amz-date";

    let canonical_request = format!(
        "{}\n{}\n{}\n{}\n{}\n{}",
        method,
        path,
        query.unwrap_or_default(),
        canonical_headers,
        signed_headers,
        payload_hash
    );

    let algorithm = "AWS4-HMAC-SHA256";
    let credential_scope = format!(
        "{}/{}/{}/aws4_request",
        date_stamp, credentials.region, credentials.service
    );

    let string_to_sign = format!(
        "{}\n{}\n{}\n{}",
        algorithm,
        amz_date,
        credential_scope,
        hex_encode(&sha256(canonical_request.as_bytes()))
    );

    let signing_key = get_signature_key(
        &credentials.secret_access_key,
        &date_stamp,
        &credentials.region,
        &credentials.service,
    );

    let signature = hex_encode(&hmac_sha256(&signing_key, string_to_sign.as_bytes()));

    let authorization = format!(
        "{} Credential={}/{}, SignedHeaders={}, Signature={}",
        algorithm,
        credentials.access_key_id,
        credential_scope,
        signed_headers,
        signature
    );

    let mut headers = HashMap::new();
    headers.insert("Authorization".to_string(), authorization);
    headers.insert("X-Amz-Date".to_string(), amz_date);
    headers.insert("X-Amz-Content-Sha256".to_string(), payload_hash.to_string());
    headers.insert("Host".to_string(), host);

    Ok(headers)
}

/// Generate a presigned URL
pub fn sign_url(
    method: &str,
    url: &str,
    expires_in_secs: u64,
    credentials: &AwsCredentials,
) -> Result<String, S3Error> {
    sign_url_with_headers(method, url, expires_in_secs, credentials, &HashMap::new())
}

/// Generate a presigned URL with additional headers
pub fn sign_url_with_headers(
    method: &str,
    url: &str,
    expires_in_secs: u64,
    credentials: &AwsCredentials,
    extra_headers: &HashMap<String, String>,
) -> Result<String, S3Error> {
    let now = simplex_std::time::now_utc();
    let date_stamp = now.format("%Y%m%d");
    let amz_date = now.format("%Y%m%dT%H%M%SZ");

    let (host, path, existing_query) = parse_url(url)?;

    let credential_scope = format!(
        "{}/{}/{}/aws4_request",
        date_stamp, credentials.region, credentials.service
    );

    let mut signed_headers = "host".to_string();
    let mut canonical_headers = format!("host:{}\n", host);

    for (key, value) in extra_headers {
        let lower_key = key.to_lowercase();
        signed_headers.push_str(&format!(";{}", lower_key));
        canonical_headers.push_str(&format!("{}:{}\n", lower_key, value));
    }

    // Build query string
    let mut query_params = vec![
        ("X-Amz-Algorithm", "AWS4-HMAC-SHA256".to_string()),
        ("X-Amz-Credential", format!("{}/{}", credentials.access_key_id, credential_scope)),
        ("X-Amz-Date", amz_date.clone()),
        ("X-Amz-Expires", expires_in_secs.to_string()),
        ("X-Amz-SignedHeaders", signed_headers.clone()),
    ];

    // Add existing query params
    if let Some(q) = existing_query {
        for pair in q.split('&') {
            if let Some((k, v)) = pair.split_once('=') {
                query_params.push((k, v.to_string()));
            }
        }
    }

    // Sort and encode
    query_params.sort_by(|a, b| a.0.cmp(&b.0));
    let canonical_query: String = query_params.iter()
        .map(|(k, v)| format!("{}={}", url_encode(k), url_encode(v)))
        .collect::<Vec<_>>()
        .join("&");

    let canonical_request = format!(
        "{}\n{}\n{}\n{}\n{}\nUNSIGNED-PAYLOAD",
        method,
        path,
        canonical_query,
        canonical_headers,
        signed_headers
    );

    let string_to_sign = format!(
        "AWS4-HMAC-SHA256\n{}\n{}\n{}",
        amz_date,
        credential_scope,
        hex_encode(&sha256(canonical_request.as_bytes()))
    );

    let signing_key = get_signature_key(
        &credentials.secret_access_key,
        &date_stamp,
        &credentials.region,
        &credentials.service,
    );

    let signature = hex_encode(&hmac_sha256(&signing_key, string_to_sign.as_bytes()));

    // Build final URL
    let base_url = if url.contains('?') {
        url.split('?').next().unwrap()
    } else {
        url
    };

    Ok(format!("{}?{}&X-Amz-Signature={}", base_url, canonical_query, signature))
}

fn get_signature_key(
    secret_key: &str,
    date_stamp: &str,
    region: &str,
    service: &str,
) -> Vec<u8> {
    let k_date = hmac_sha256(
        format!("AWS4{}", secret_key).as_bytes(),
        date_stamp.as_bytes(),
    );
    let k_region = hmac_sha256(&k_date, region.as_bytes());
    let k_service = hmac_sha256(&k_region, service.as_bytes());
    let k_signing = hmac_sha256(&k_service, b"aws4_request");
    k_signing
}

fn parse_url(url: &str) -> Result<(String, String, Option<String>), S3Error> {
    let without_scheme = url
        .strip_prefix("https://")
        .or_else(|| url.strip_prefix("http://"))
        .ok_or(S3Error::SigningError("Invalid URL".to_string()))?;

    let (host_path, query) = match without_scheme.find('?') {
        Some(idx) => (&without_scheme[..idx], Some(&without_scheme[idx + 1..])),
        None => (without_scheme, None),
    };

    let (host, path) = match host_path.find('/') {
        Some(idx) => (&host_path[..idx], &host_path[idx..]),
        None => (host_path, "/"),
    };

    Ok((
        host.to_string(),
        path.to_string(),
        query.map(|s| s.to_string()),
    ))
}

fn url_encode(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' | '.' | '~' => {
                result.push(c);
            }
            _ => {
                for byte in c.to_string().as_bytes() {
                    result.push_str(&format!("%{:02X}", byte));
                }
            }
        }
    }
    result
}

fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}
