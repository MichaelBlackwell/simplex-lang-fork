// Package Registry Module for Simplex
// Implements static file-based registry (GitHub-based)
// Part of Phase 2: Package Ecosystem
//
// Copyright (c) 2025-2026 Rod Higgins
// Licensed under AGPL-3.0 - see LICENSE file
// https://github.com/senuamedia/simplex

// Registry configuration
fn REGISTRY_URL() -> i64 { "https://raw.githubusercontent.com/anthropics/simplex-packages/main" }
fn REGISTRY_INDEX() -> i64 { "index.json" }
fn CACHE_DIR() -> i64 { ".simplex/cache" }

// ============================================================================
// Registry Index Structure
// ============================================================================
// index.json format:
// {
//   "packages": {
//     "package-name": {
//       "description": "Short description",
//       "versions": ["0.1.0", "0.2.0", "1.0.0"],
//       "latest": "1.0.0",
//       "repository": "https://github.com/user/repo"
//     }
//   },
//   "updated": "2024-01-15T10:30:00Z"
// }

// Package index entry
// Layout: name(0), description(1), versions(2), latest(3), repository(4)
fn index_entry_new(name: i64) -> i64 {
    let e: i64 = malloc(40);
    store_ptr(e, 0, name);
    store_ptr(e, 1, "");
    store_ptr(e, 2, vec_new());  // versions list
    store_ptr(e, 3, "");         // latest version
    store_ptr(e, 4, "");         // repository
    e
}

fn entry_name(e: i64) -> i64 { load_ptr(e, 0) }
fn entry_description(e: i64) -> i64 { load_ptr(e, 1) }
fn entry_set_description(e: i64, d: i64) { store_ptr(e, 1, d); }
fn entry_versions(e: i64) -> i64 { load_ptr(e, 2) }
fn entry_latest(e: i64) -> i64 { load_ptr(e, 3) }
fn entry_set_latest(e: i64, v: i64) { store_ptr(e, 3, v); }
fn entry_repository(e: i64) -> i64 { load_ptr(e, 4) }
fn entry_set_repository(e: i64, r: i64) { store_ptr(e, 4, r); }

// ============================================================================
// Registry Cache
// ============================================================================

fn ensure_cache_dir() -> i64 {
    mkdir(CACHE_DIR())
}

fn cache_path(filename: i64) -> i64 {
    path_join(CACHE_DIR(), filename)
}

fn is_cache_fresh(cache_file: i64, max_age_seconds: i64) -> bool {
    // Check if cache file exists and is recent enough
    if file_exists(cache_file) == 0 {
        return false;
    }

    // For simplicity, always refresh if older than max_age
    // In a full implementation, we'd check file modification time
    // For now, always return false to refresh
    false
}

// ============================================================================
// Registry Operations
// ============================================================================

// Download registry index
fn registry_fetch_index() -> i64 {
    ensure_cache_dir();

    let index_url: i64 = string_concat(REGISTRY_URL(), "/");
    let full_url: i64 = string_concat(index_url, REGISTRY_INDEX());

    print("Fetching package index from ");
    println(full_url);

    // Use curl to download (http_get not available yet)
    let cache_file: i64 = cache_path("index.json");
    let cmd: i64 = string_concat("curl -s -o ", string_concat(cache_file, string_concat(" ", full_url)));

    let result: i64 = process_run(cmd);
    if result != 0 {
        println("Warning: Failed to fetch package index");
        return 0;
    }

    cache_file
}

// Load registry index from cache or download
fn registry_load_index() -> i64 {
    let cache_file: i64 = cache_path("index.json");

    // Check if we need to refresh
    if is_cache_fresh(cache_file, 3600) == false {
        registry_fetch_index();
    }

    // Read the cached index
    let content: i64 = read_file(cache_file);
    if content == 0 {
        println("Error: Could not read registry index");
        return 0;
    }

    // Parse JSON
    let json: i64 = json_parse(content);
    if json == 0 {
        println("Error: Invalid registry index format");
        return 0;
    }

    json
}

// Parse index into map of package entries
fn registry_parse_index(index_json: i64) -> i64 {
    let packages: i64 = hashmap_new();

    let packages_opt: i64 = json_get(index_json, "packages");
    if option_is_none(packages_opt) {
        return packages;
    }

    let packages_obj: i64 = option_unwrap(packages_opt);
    if json_is_object(packages_obj) == false {
        return packages;
    }

    let keys: i64 = json_keys(packages_obj);
    let n: i64 = vec_len(keys);
    var i: i64 = 0;

    while i < n {
        let name: i64 = vec_get(keys, i);
        let pkg_opt: i64 = json_get(packages_obj, name);

        if option_is_some(pkg_opt) {
            let pkg_json: i64 = option_unwrap(pkg_opt);
            let entry: i64 = index_entry_new(name);

            // Description
            let desc_opt: i64 = json_get(pkg_json, "description");
            if option_is_some(desc_opt) {
                let desc_val: i64 = option_unwrap(desc_opt);
                if json_is_string(desc_val) {
                    entry_set_description(entry, json_as_string(desc_val));
                }
            }

            // Versions
            let vers_opt: i64 = json_get(pkg_json, "versions");
            if option_is_some(vers_opt) {
                let vers_val: i64 = option_unwrap(vers_opt);
                if json_is_array(vers_val) {
                    let arr: i64 = json_as_array(vers_val);
                    let vn: i64 = vec_len(arr);
                    var vi: i64 = 0;
                    while vi < vn {
                        let v: i64 = vec_get(arr, vi);
                        if json_is_string(v) {
                            vec_push(entry_versions(entry), json_as_string(v));
                        }
                        vi = vi + 1;
                    }
                }
            }

            // Latest
            let latest_opt: i64 = json_get(pkg_json, "latest");
            if option_is_some(latest_opt) {
                let latest_val: i64 = option_unwrap(latest_opt);
                if json_is_string(latest_val) {
                    entry_set_latest(entry, json_as_string(latest_val));
                }
            }

            // Repository
            let repo_opt: i64 = json_get(pkg_json, "repository");
            if option_is_some(repo_opt) {
                let repo_val: i64 = option_unwrap(repo_opt);
                if json_is_string(repo_val) {
                    entry_set_repository(entry, json_as_string(repo_val));
                }
            }

            hashmap_insert(packages, name, entry);
        }
        i = i + 1;
    }

    packages
}

// Search for packages
fn registry_search(query: i64) -> i64 {
    let results: i64 = vec_new();

    let index_json: i64 = registry_load_index();
    if index_json == 0 {
        return results;
    }

    let packages: i64 = registry_parse_index(index_json);
    let keys: i64 = hashmap_keys(packages);
    let n: i64 = vec_len(keys);
    let query_lower: i64 = string_to_lower(query);

    var i: i64 = 0;
    while i < n {
        let name: i64 = vec_get(keys, i);
        let name_lower: i64 = string_to_lower(name);

        // Check if name contains query
        if string_find(name_lower, query_lower, 0) >= 0 {
            let entry_opt: i64 = hashmap_get(packages, name);
            if option_is_some(entry_opt) {
                vec_push(results, option_unwrap(entry_opt));
            }
        } else {
            // Also check description
            let entry_opt: i64 = hashmap_get(packages, name);
            if option_is_some(entry_opt) {
                let entry: i64 = option_unwrap(entry_opt);
                let desc_lower: i64 = string_to_lower(entry_description(entry));
                if string_find(desc_lower, query_lower, 0) >= 0 {
                    vec_push(results, entry);
                }
            }
        }
        i = i + 1;
    }

    results
}

// Get package info
fn registry_get_package(name: i64) -> i64 {
    let index_json: i64 = registry_load_index();
    if index_json == 0 {
        return 0;
    }

    let packages: i64 = registry_parse_index(index_json);
    let entry_opt: i64 = hashmap_get(packages, name);

    if option_is_some(entry_opt) {
        return option_unwrap(entry_opt);
    }
    0
}

// Find best matching version
fn registry_resolve_version(name: i64, version_spec: i64) -> i64 {
    let entry: i64 = registry_get_package(name);
    if entry == 0 {
        return "";
    }

    let range: i64 = version_range_parse(version_spec);
    if range == 0 {
        // If can't parse, try exact match or latest
        if string_eq(version_spec, "*") || string_len(version_spec) == 0 {
            return entry_latest(entry);
        }
        return version_spec;
    }

    // Find highest matching version
    let versions: i64 = entry_versions(entry);
    let n: i64 = vec_len(versions);
    var best: i64 = "";
    var best_semver: i64 = 0;

    var i: i64 = 0;
    while i < n {
        let ver_str: i64 = vec_get(versions, i);
        let ver: i64 = semver_parse(ver_str);

        if ver != 0 && version_matches(ver, range) {
            if best_semver == 0 || semver_gt(ver, best_semver) {
                best = ver_str;
                best_semver = ver;
            }
        }
        i = i + 1;
    }

    if string_len(best) == 0 {
        return entry_latest(entry);
    }
    best
}

// Download package tarball
fn registry_download_package(name: i64, version: i64) -> i64 {
    ensure_cache_dir();

    let entry: i64 = registry_get_package(name);
    if entry == 0 {
        print("Error: Package not found: ");
        println(name);
        return 1;
    }

    // Construct download URL
    // Format: {REGISTRY_URL}/packages/{name}/{version}.tar.gz
    let sb: i64 = sb_new();
    sb_append(sb, REGISTRY_URL());
    sb_append(sb, "/packages/");
    sb_append(sb, name);
    sb_append_char(sb, 47);  // '/'
    sb_append(sb, version);
    sb_append(sb, ".tar.gz");
    let url: i64 = sb_to_string(sb);
    sb_free(sb);

    // Local cache path
    let cache_pkg_dir: i64 = path_join(CACHE_DIR(), name);
    mkdir(cache_pkg_dir);

    let tarball: i64 = path_join(cache_pkg_dir, string_concat(version, ".tar.gz"));
    let extract_dir: i64 = path_join(cache_pkg_dir, version);

    // Download if not cached
    if file_exists(tarball) == 0 {
        print("Downloading ");
        print(name);
        print(" v");
        println(version);

        let cmd: i64 = string_concat("curl -s -o ", string_concat(tarball, string_concat(" ", url)));
        let result: i64 = process_run(cmd);
        if result != 0 {
            print("Error: Failed to download ");
            println(name);
            return 1;
        }
    }

    // Extract if not already extracted
    if file_exists(extract_dir) == 0 {
        mkdir(extract_dir);

        let extract_cmd: i64 = string_concat("tar -xzf ", string_concat(tarball, string_concat(" -C ", extract_dir)));
        let result: i64 = process_run(extract_cmd);
        if result != 0 {
            print("Error: Failed to extract ");
            println(name);
            return 1;
        }
    }

    // Return path to extracted package
    extract_dir
}

// Install package to project dependencies
fn registry_install_package(name: i64, version_spec: i64) -> i64 {
    let resolved_version: i64 = registry_resolve_version(name, version_spec);
    if string_len(resolved_version) == 0 {
        print("Error: No matching version for ");
        print(name);
        print(" ");
        println(version_spec);
        return 1;
    }

    let pkg_path: i64 = registry_download_package(name, resolved_version);
    if pkg_path == 1 {
        return 1;
    }

    // Copy to project's .simplex/deps
    let deps_dir: i64 = ".simplex/deps";
    mkdir(deps_dir);

    let target: i64 = path_join(deps_dir, name);

    // Remove existing
    if file_exists(target) != 0 {
        let rm_cmd: i64 = string_concat("rm -rf ", target);
        process_run(rm_cmd);
    }

    // Copy
    let cp_cmd: i64 = string_concat("cp -r ", string_concat(pkg_path, string_concat(" ", target)));
    let result: i64 = process_run(cp_cmd);

    if result == 0 {
        print("Installed ");
        print(name);
        print(" v");
        println(resolved_version);
    }

    result
}

// ============================================================================
// CLI Commands
// ============================================================================

fn cmd_search(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm search <query>");
        return 1;
    }

    let query: i64 = vec_get(args, arg_idx);
    print("Searching for: ");
    println(query);
    println("");

    let results: i64 = registry_search(query);
    let n: i64 = vec_len(results);

    if n == 0 {
        println("No packages found");
        return 0;
    }

    var i: i64 = 0;
    while i < n {
        let entry: i64 = vec_get(results, i);
        let name: i64 = entry_name(entry);
        let latest: i64 = entry_latest(entry);
        let desc: i64 = entry_description(entry);

        print(name);
        print(" (");
        print(latest);
        print(")");

        if string_len(desc) > 0 {
            print(" - ");
            println(desc);
        } else {
            println("");
        }

        i = i + 1;
    }

    0
}

fn cmd_info(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm info <package>");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);
    let entry: i64 = registry_get_package(name);

    if entry == 0 {
        print("Package not found: ");
        println(name);
        return 1;
    }

    println("");
    print("Package: ");
    println(entry_name(entry));

    print("Latest:  ");
    println(entry_latest(entry));

    if string_len(entry_description(entry)) > 0 {
        print("Description: ");
        println(entry_description(entry));
    }

    if string_len(entry_repository(entry)) > 0 {
        print("Repository: ");
        println(entry_repository(entry));
    }

    let versions: i64 = entry_versions(entry);
    let vn: i64 = vec_len(versions);
    if vn > 0 {
        print("Versions: ");
        var i: i64 = 0;
        while i < vn {
            if i > 0 { print(", "); }
            print(vec_get(versions, i));
            i = i + 1;
        }
        println("");
    }

    0
}

fn cmd_install(args: i64, argc: i64, arg_idx: i64) -> i64 {
    if arg_idx >= argc {
        println("Usage: sxpm install <package> [version]");
        return 1;
    }

    let name: i64 = vec_get(args, arg_idx);
    var version: i64 = "*";

    if arg_idx + 1 < argc {
        version = vec_get(args, arg_idx + 1);
    }

    registry_install_package(name, version)
}
