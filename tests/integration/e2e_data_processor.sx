// Integration test: Data Processing Pipeline
// Uses: Vec, Iterators, HashMap, HashSet, Option, String

// Process a list of scores and calculate statistics
fn calculate_stats(scores: i64) -> i64 {
    let stats: i64 = hashmap_new();

    if vec_len(scores) == 0 {
        hashmap_insert(stats, "count", 0);
        return stats;
    }

    // Calculate count
    hashmap_insert(stats, "count", vec_len(scores));

    // Calculate sum and mean
    let sum: i64 = vec_sum(scores);
    hashmap_insert(stats, "sum", sum);
    hashmap_insert(stats, "mean", sum / vec_len(scores));

    // Find min and max
    var min: i64 = vec_get(scores, 0);
    var max: i64 = vec_get(scores, 0);

    var i: i64 = 1;
    while i < vec_len(scores) {
        let val: i64 = vec_get(scores, i);
        if val < min {
            min = val;
        }
        if val > max {
            max = val;
        }
        i = i + 1;
    }

    hashmap_insert(stats, "min", min);
    hashmap_insert(stats, "max", max);
    hashmap_insert(stats, "range", max - min);

    stats
}

fn is_passing(score: i64) -> i64 {
    score >= 60
}

fn grade_score(score: i64) -> i64 {
    if score >= 90 {
        return "A";
    }
    if score >= 80 {
        return "B";
    }
    if score >= 70 {
        return "C";
    }
    if score >= 60 {
        return "D";
    }
    return "F";
}

// Count grades using iterator pattern
fn count_grades(scores: i64) -> i64 {
    let grade_counts: i64 = hashmap_new();
    hashmap_insert(grade_counts, "A", 0);
    hashmap_insert(grade_counts, "B", 0);
    hashmap_insert(grade_counts, "C", 0);
    hashmap_insert(grade_counts, "D", 0);
    hashmap_insert(grade_counts, "F", 0);

    var i: i64 = 0;
    while i < vec_len(scores) {
        let score: i64 = vec_get(scores, i);
        let grade: i64 = grade_score(score);
        let current: i64 = option_unwrap(hashmap_get(grade_counts, grade));
        hashmap_insert(grade_counts, grade, current + 1);
        i = i + 1;
    }

    grade_counts
}

fn test_calculate_stats() -> i64 {
    let scores: i64 = vec_new();
    vec_push(scores, 85);
    vec_push(scores, 90);
    vec_push(scores, 78);
    vec_push(scores, 92);
    vec_push(scores, 88);

    let stats: i64 = calculate_stats(scores);

    let count: i64 = option_unwrap(hashmap_get(stats, "count"));
    if count != 5 {
        println("FAIL: count should be 5");
        return 1;
    }

    let sum: i64 = option_unwrap(hashmap_get(stats, "sum"));
    if sum != 433 {
        println("FAIL: sum should be 433");
        return 1;
    }

    let mean: i64 = option_unwrap(hashmap_get(stats, "mean"));
    if mean != 86 {
        println("FAIL: mean should be 86 (integer division)");
        return 1;
    }

    let min: i64 = option_unwrap(hashmap_get(stats, "min"));
    if min != 78 {
        println("FAIL: min should be 78");
        return 1;
    }

    let max: i64 = option_unwrap(hashmap_get(stats, "max"));
    if max != 92 {
        println("FAIL: max should be 92");
        return 1;
    }

    println("PASS: test_calculate_stats");
    0
}

fn test_empty_stats() -> i64 {
    let scores: i64 = vec_new();
    let stats: i64 = calculate_stats(scores);

    let count: i64 = option_unwrap(hashmap_get(stats, "count"));
    if count != 0 {
        println("FAIL: empty count should be 0");
        return 1;
    }

    println("PASS: test_empty_stats");
    0
}

fn test_grade_counting() -> i64 {
    let scores: i64 = vec_new();
    vec_push(scores, 95);   // A
    vec_push(scores, 92);   // A
    vec_push(scores, 85);   // B
    vec_push(scores, 78);   // C
    vec_push(scores, 65);   // D
    vec_push(scores, 55);   // F
    vec_push(scores, 72);   // C

    let grades: i64 = count_grades(scores);

    let count_a: i64 = option_unwrap(hashmap_get(grades, "A"));
    if count_a != 2 {
        println("FAIL: should have 2 A grades");
        return 1;
    }

    let count_b: i64 = option_unwrap(hashmap_get(grades, "B"));
    if count_b != 1 {
        println("FAIL: should have 1 B grade");
        return 1;
    }

    let count_c: i64 = option_unwrap(hashmap_get(grades, "C"));
    if count_c != 2 {
        println("FAIL: should have 2 C grades");
        return 1;
    }

    let count_f: i64 = option_unwrap(hashmap_get(grades, "F"));
    if count_f != 1 {
        println("FAIL: should have 1 F grade");
        return 1;
    }

    println("PASS: test_grade_counting");
    0
}

fn test_filter_passing() -> i64 {
    let scores: i64 = vec_new();
    vec_push(scores, 45);
    vec_push(scores, 78);
    vec_push(scores, 55);
    vec_push(scores, 92);
    vec_push(scores, 60);
    vec_push(scores, 38);

    let iter: i64 = sxiter_from_vec(scores);
    let passing: i64 = sxiter_filter(iter, is_passing);
    let passed: i64 = sxiter_collect_vec(passing);

    if vec_len(passed) != 3 {
        println("FAIL: should have 3 passing scores");
        return 1;
    }

    if vec_get(passed, 0) != 78 {
        println("FAIL: first passing should be 78");
        return 1;
    }
    if vec_get(passed, 1) != 92 {
        println("FAIL: second passing should be 92");
        return 1;
    }
    if vec_get(passed, 2) != 60 {
        println("FAIL: third passing should be 60");
        return 1;
    }

    println("PASS: test_filter_passing");
    0
}

fn test_unique_scores() -> i64 {
    let scores: i64 = vec_new();
    vec_push(scores, 85);
    vec_push(scores, 90);
    vec_push(scores, 85);  // duplicate
    vec_push(scores, 78);
    vec_push(scores, 90);  // duplicate
    vec_push(scores, 85);  // duplicate

    let unique: i64 = int_hashset_new();

    var i: i64 = 0;
    while i < vec_len(scores) {
        int_hashset_insert(unique, vec_get(scores, i));
        i = i + 1;
    }

    if int_hashset_len(unique) != 3 {
        println("FAIL: should have 3 unique scores");
        return 1;
    }

    if int_hashset_contains(unique, 85) == false {
        println("FAIL: should contain 85");
        return 1;
    }
    if int_hashset_contains(unique, 90) == false {
        println("FAIL: should contain 90");
        return 1;
    }
    if int_hashset_contains(unique, 78) == false {
        println("FAIL: should contain 78");
        return 1;
    }

    println("PASS: test_unique_scores");
    0
}

fn main() -> i64 {
    println("=== Data Processor Integration Test ===");
    println("");

    var failures: i64 = 0;
    failures = failures + test_calculate_stats();
    failures = failures + test_empty_stats();
    failures = failures + test_grade_counting();
    failures = failures + test_filter_passing();
    failures = failures + test_unique_scores();

    println("");
    if failures == 0 {
        println("All data processor tests passed!");
    } else {
        print("Data processor tests failed: ");
        println(int_to_string(failures));
    }

    failures
}
