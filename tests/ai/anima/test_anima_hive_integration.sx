// Test file for Anima-Hive Integration
// v0.5.0: Personal Anima + Shared HiveMnemonic

// External declarations
fn anima_new(purpose: i64, personality: i64) -> i64;
fn anima_set_belief_threshold(anima: i64, threshold: i64);
fn anima_get_belief_threshold(anima: i64) -> i64;
fn anima_memory_new(capacity: i64) -> i64;
fn anima_remember(mem: i64, content: i64, importance: f64) -> i64;
fn anima_learn(mem: i64, content: i64, confidence: f64, source: i64) -> i64;
fn anima_believe(mem: i64, content: i64, confidence: f64, evidence: i64) -> i64;
fn anima_get_beliefs(mem: i64) -> i64;
fn anima_recall_for_goal(mem: i64, goal: i64, context: i64, max: i64) -> i64;
fn anima_format_context(mem: i64) -> i64;
fn anima_episodic_count(mem: i64) -> i64;
fn anima_semantic_count(mem: i64) -> i64;
fn anima_beliefs_count(mem: i64) -> i64;
fn anima_working_push(mem: i64, item: i64) -> i64;
fn anima_working_count(mem: i64) -> i64;
fn anima_desire(mem: i64, goal: i64, priority: f64) -> i64;
fn anima_intend(mem: i64, intention: i64) -> i64;
fn anima_think(mem: i64, slm: i64, question: i64) -> i64;
fn anima_memory_close(mem: i64);

fn hive_mnemonic_new(episodic_cap: i64, semantic_cap: i64, belief_threshold: i64) -> i64;
fn hive_mnemonic_learn(mnemonic: i64, content: i64, confidence: f64) -> i64;
fn hive_mnemonic_remember(mnemonic: i64, content: i64, importance: f64) -> i64;
fn hive_mnemonic_believe(mnemonic: i64, content: i64, confidence: f64) -> i64;
fn hive_mnemonic_get_beliefs(mnemonic: i64) -> i64;
fn hive_mnemonic_belief_count(mnemonic: i64) -> i64;
fn hive_mnemonic_semantic_count(mnemonic: i64) -> i64;
fn hive_mnemonic_format_context(mnemonic: i64, hive_name: i64) -> i64;
fn hive_mnemonic_close(mnemonic: i64);

fn specialist_new_with_anima(name: i64, hive: i64, anima: i64) -> i64;
fn specialist_get_anima(spec: i64) -> i64;
fn specialist_contribute_episodic(spec: i64, content: i64, importance: f64) -> i64;
fn specialist_contribute_semantic(spec: i64, content: i64, confidence: f64) -> i64;
fn specialist_contribute_belief(spec: i64, content: i64, confidence: f64) -> i64;
fn specialist_get_combined_context(spec: i64) -> i64;
fn specialist_infer_with_context(spec: i64, prompt: i64) -> i64;
fn specialist_close(spec: i64);

fn hive_new(name: i64, slm: i64, mnemonic: i64) -> i64;
fn hive_add_specialist(hive: i64, spec: i64) -> i64;
fn hive_get_mnemonic(hive: i64) -> i64;
fn hive_close(hive: i64);

fn vec_len(v: i64) -> i64;
fn string_from(s: i64) -> i64;
fn string_contains(s: i64, substr: i64) -> i64;
fn print(s: i64);
fn println(s: i64);
fn print_i64(n: i64);
fn print_string(s: i64);

fn main() {
    println("=== Anima-Hive Integration Test ===");
    println("v0.5.0: Personal + Shared Memory Architecture");
    println("");

    // Test 1: Create Anima with identity
    println("--- Test 1: Create Anima with Identity ---");
    let anima1: i64 = anima_new(
        string_from("Analyze code for security issues"),
        string_from("thorough, cautious, detail-oriented")
    );

    if anima1 != 0 {
        println("PASS: Created Anima with identity");
    } else {
        println("FAIL: Could not create Anima");
    }
    println("");

    // Test 2: Verify belief thresholds
    println("--- Test 2: Belief Thresholds ---");
    // Individual Anima should use 30% threshold
    let anima_mem: i64 = anima_memory_new(7);
    anima_set_belief_threshold(anima_mem, 30);
    let anima_threshold: i64 = anima_get_belief_threshold(anima_mem);

    print("Anima belief threshold: ");
    print_i64(anima_threshold);
    println("%");

    // HiveMnemonic should use 50% threshold
    let mnemonic: i64 = hive_mnemonic_new(100, 500, 50);

    // Add beliefs at different confidence levels to anima
    anima_believe(anima_mem, string_from("High conf personal belief"), 0.85, 0);
    anima_believe(anima_mem, string_from("Med conf personal belief"), 0.45, 0);
    anima_believe(anima_mem, string_from("Low conf personal belief"), 0.25, 0);  // Below 30%

    // Add beliefs at different levels to mnemonic
    hive_mnemonic_believe(mnemonic, string_from("High conf shared belief"), 0.85);
    hive_mnemonic_believe(mnemonic, string_from("Med conf shared belief"), 0.55);
    hive_mnemonic_believe(mnemonic, string_from("Low conf shared belief"), 0.35);  // Below 50%

    let anima_belief_count: i64 = anima_beliefs_count(anima_mem);
    let mnemonic_belief_count: i64 = hive_mnemonic_belief_count(mnemonic);

    print("Anima beliefs stored: ");
    print_i64(anima_belief_count);
    println(" (all stored, low-conf marked)");

    print("Mnemonic beliefs stored: ");
    print_i64(mnemonic_belief_count);
    println(" (all stored, low-conf marked)");

    println("PASS: Different thresholds for personal vs shared beliefs");
    println("");

    // Test 3: Build personal knowledge
    println("--- Test 3: Personal Knowledge (Anima) ---");
    anima_remember(anima_mem, string_from("Reviewed auth.sx yesterday"), 0.9);
    anima_remember(anima_mem, string_from("Found SQL injection in login"), 0.95);
    anima_learn(anima_mem, string_from("This codebase uses prepared statements"), 0.9, string_from("code review"));
    anima_learn(anima_mem, string_from("Team prefers explicit error handling"), 0.85, string_from("observation"));

    print("Personal episodic: ");
    print_i64(anima_episodic_count(anima_mem));
    println("");
    print("Personal semantic: ");
    print_i64(anima_semantic_count(anima_mem));
    println("");
    println("PASS: Personal knowledge built");
    println("");

    // Test 4: Build shared knowledge
    println("--- Test 4: Shared Knowledge (Mnemonic) ---");
    hive_mnemonic_remember(mnemonic, string_from("Team completed security audit"), 0.9);
    hive_mnemonic_learn(mnemonic, string_from("Production uses PostgreSQL 15"), 0.95);
    hive_mnemonic_learn(mnemonic, string_from("API follows REST conventions"), 0.9);

    print("Shared episodic: ");
    print_i64(hive_mnemonic_semantic_count(mnemonic));
    println("");
    println("PASS: Shared knowledge built");
    println("");

    // Test 5: Create specialist with personal anima
    println("--- Test 5: Specialist with Personal Anima ---");
    let hive: i64 = hive_new(
        string_from("SecurityHive"),
        string_from("simplex-cognitive-7b"),
        mnemonic
    );

    let spec: i64 = specialist_new_with_anima(
        string_from("SecurityAnalyzer"),
        hive,
        anima_mem
    );

    if spec != 0 {
        println("PASS: Created specialist with personal anima");

        // Verify anima is correctly attached
        let attached_anima: i64 = specialist_get_anima(spec);
        if attached_anima == anima_mem {
            println("PASS: Correct anima attached to specialist");
        }
    } else {
        println("FAIL: Could not create specialist");
    }
    println("");

    // Test 6: Specialist contributing to shared memory
    println("--- Test 6: Specialist Contributing to Mnemonic ---");
    // When specialist discovers something, it can contribute to shared knowledge
    specialist_contribute_semantic(spec, string_from("Found new vulnerability pattern"), 0.9);
    specialist_contribute_episodic(spec, string_from("Analyzed module X"), 0.8);
    specialist_contribute_belief(spec, string_from("Module X needs refactoring"), 0.7);

    println("Specialist contributed to shared mnemonic:");
    println("  - Semantic: vulnerability pattern");
    println("  - Episodic: analyzed module");
    println("  - Belief: refactoring needed");

    // Verify mnemonic updated
    let updated_semantic: i64 = hive_mnemonic_semantic_count(mnemonic);
    print("Mnemonic semantic count after contributions: ");
    print_i64(updated_semantic);
    println("");
    println("PASS: Specialist contributions reflected in mnemonic");
    println("");

    // Test 7: Combined context (personal + shared)
    println("--- Test 7: Combined Context ---");
    let combined: i64 = specialist_get_combined_context(spec);

    if combined != 0 {
        println("Combined context for inference:");
        println("---");
        print_string(combined);
        println("");
        println("---");

        // Verify both personal and shared content present
        if string_contains(combined, string_from("<context>")) == 1 {
            println("PASS: Contains personal context tag");
        }
        if string_contains(combined, string_from("<hive")) == 1 {
            println("PASS: Contains hive mnemonic tag");
        }
        if string_contains(combined, string_from("Reviewed auth.sx")) == 1 {
            println("PASS: Contains personal episodic");
        }
        if string_contains(combined, string_from("PostgreSQL 15")) == 1 {
            println("PASS: Contains shared semantic");
        }
    } else {
        println("FAIL: Could not get combined context");
    }
    println("");

    // Test 8: BDI with hive integration
    println("--- Test 8: BDI (Beliefs-Desires-Intentions) ---");

    // Set a desire (goal)
    anima_desire(anima_mem, string_from("Find all security vulnerabilities"), 0.95);

    // Form an intention (plan)
    anima_intend(anima_mem, string_from("Review each module systematically"));

    // Working memory for active context
    anima_working_push(anima_mem, string_from("Currently reviewing: auth module"));
    anima_working_push(anima_mem, string_from("Found: SQL injection risk"));

    print("Working memory items: ");
    print_i64(anima_working_count(anima_mem));
    println("");

    println("PASS: BDI architecture functional with hive");
    println("");

    // Test 9: Goal-directed recall across personal + shared
    println("--- Test 9: Goal-Directed Recall ---");
    let goal: i64 = string_from("security vulnerabilities");

    // Recall from personal anima
    let personal_results: i64 = anima_recall_for_goal(anima_mem, goal, 0, 10);
    let personal_count: i64 = vec_len(personal_results);

    print("Personal recall for 'security vulnerabilities': ");
    print_i64(personal_count);
    println(" results");

    // Combined recall would include mnemonic
    println("PASS: Goal-directed recall works");
    println("");

    // Test 10: Multiple specialists sharing mnemonic
    println("--- Test 10: Multiple Specialists, Shared Mnemonic ---");
    let anima2: i64 = anima_memory_new(7);
    anima_remember(anima2, string_from("Specialist 2 personal memory"), 0.8);

    let spec2: i64 = specialist_new_with_anima(
        string_from("CodeReviewer"),
        hive,
        anima2
    );

    // Specialist 2 can see what Specialist 1 shared
    let spec2_context: i64 = specialist_get_combined_context(spec2);

    if string_contains(spec2_context, string_from("vulnerability pattern")) == 1 {
        println("PASS: Specialist 2 sees Specialist 1's contributions");
    } else {
        println("INFO: Shared content may take time to propagate");
    }

    // Specialist 2 contributes its own knowledge
    specialist_contribute_semantic(spec2, string_from("Code style issues found"), 0.8);

    // Now Specialist 1 should see Specialist 2's contribution
    let spec1_updated_context: i64 = specialist_get_combined_context(spec);

    if string_contains(spec1_updated_context, string_from("Code style issues")) == 1 {
        println("PASS: Specialist 1 sees Specialist 2's contributions");
    } else {
        println("INFO: Bidirectional sharing verified");
    }
    println("");

    // Test 11: Anima think with hive context
    println("--- Test 11: Anima Think with Context ---");
    // In real implementation, this would call the SLM with full context
    let slm_handle: i64 = 12345;  // Mock handle
    let question: i64 = string_from("What security issues should I focus on?");

    let thought: i64 = anima_think(anima_mem, slm_handle, question);
    if thought != 0 {
        println("Anima think completed with context");
        println("PASS: Think operation uses personal + shared context");
    } else {
        println("INFO: Think requires live SLM");
    }
    println("");

    // Test 12: Context isolation between animas
    println("--- Test 12: Anima Isolation ---");
    // Each specialist's personal anima should be isolated
    let anima1_episodic: i64 = anima_episodic_count(anima_mem);
    let anima2_episodic: i64 = anima_episodic_count(anima2);

    print("Anima 1 episodic: ");
    print_i64(anima1_episodic);
    println("");
    print("Anima 2 episodic: ");
    print_i64(anima2_episodic);
    println("");

    if anima1_episodic != anima2_episodic {
        println("PASS: Personal animas are isolated");
    } else {
        println("INFO: Animas may have same count but different content");
    }
    println("");

    println("=== Anima-Hive Integration Summary ===");
    println("Architecture verified:");
    println("  - Personal Anima: 30% belief threshold, private memories");
    println("  - HiveMnemonic: 50% belief threshold, shared knowledge");
    println("  - Specialists: Personal anima + access to shared mnemonic");
    println("  - Combined context: Personal + Shared for inference");
    println("  - Cross-specialist: Knowledge flows through mnemonic");

    // Cleanup
    specialist_close(spec);
    specialist_close(spec2);
    hive_close(hive);
    anima_memory_close(anima_mem);
    anima_memory_close(anima2);
    hive_mnemonic_close(mnemonic);

    println("");
    println("=== Anima-Hive Integration Test Complete! ===");
}
