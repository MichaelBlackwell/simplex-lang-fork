// Test file for Vec operations
// Tests: vec_new, vec_push, vec_get, vec_len, vec_pop, vec_sum, vec_find, vec_contains, etc.

fn test_vec_create_and_push() -> i64 {
    let v: i64 = vec_new();
    if vec_len(v) != 0 {
        println("FAIL: new vec should be empty");
        return 1;
    }

    vec_push(v, 10);
    vec_push(v, 20);
    vec_push(v, 30);

    if vec_len(v) != 3 {
        println("FAIL: vec should have 3 elements");
        return 1;
    }

    println("PASS: test_vec_create_and_push");
    0
}

fn test_vec_get() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 100);
    vec_push(v, 200);
    vec_push(v, 300);

    if vec_get(v, 0) != 100 {
        println("FAIL: first element should be 100");
        return 1;
    }
    if vec_get(v, 1) != 200 {
        println("FAIL: second element should be 200");
        return 1;
    }
    if vec_get(v, 2) != 300 {
        println("FAIL: third element should be 300");
        return 1;
    }

    println("PASS: test_vec_get");
    0
}

fn test_vec_sum() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 1);
    vec_push(v, 2);
    vec_push(v, 3);
    vec_push(v, 4);
    vec_push(v, 5);

    let sum: i64 = vec_sum(v);
    if sum != 15 {
        println("FAIL: sum of 1+2+3+4+5 should be 15");
        return 1;
    }

    println("PASS: test_vec_sum");
    0
}

fn test_vec_find() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 10);
    vec_push(v, 20);
    vec_push(v, 30);
    vec_push(v, 40);

    let idx1: i64 = vec_find(v, 20);
    if idx1 != 1 {
        println("FAIL: find(20) should return index 1");
        return 1;
    }

    let idx2: i64 = vec_find(v, 99);
    if idx2 != 0 - 1 {
        println("FAIL: find(99) should return -1");
        return 1;
    }

    println("PASS: test_vec_find");
    0
}

fn test_vec_contains() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 5);
    vec_push(v, 10);
    vec_push(v, 15);

    if vec_contains(v, 10) == false {
        println("FAIL: vec should contain 10");
        return 1;
    }

    if vec_contains(v, 99) == true {
        println("FAIL: vec should not contain 99");
        return 1;
    }

    println("PASS: test_vec_contains");
    0
}

fn test_vec_reverse() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 1);
    vec_push(v, 2);
    vec_push(v, 3);

    let rev: i64 = vec_reverse(v);

    if vec_get(rev, 0) != 3 {
        println("FAIL: reversed first should be 3");
        return 1;
    }
    if vec_get(rev, 1) != 2 {
        println("FAIL: reversed second should be 2");
        return 1;
    }
    if vec_get(rev, 2) != 1 {
        println("FAIL: reversed third should be 1");
        return 1;
    }

    println("PASS: test_vec_reverse");
    0
}

fn test_vec_clone() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 100);
    vec_push(v, 200);

    let copy: i64 = vec_clone(v);

    if vec_len(copy) != 2 {
        println("FAIL: cloned vec should have 2 elements");
        return 1;
    }
    if vec_get(copy, 0) != 100 {
        println("FAIL: cloned first element should be 100");
        return 1;
    }
    if vec_get(copy, 1) != 200 {
        println("FAIL: cloned second element should be 200");
        return 1;
    }

    println("PASS: test_vec_clone");
    0
}

fn test_vec_first_last() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 1);
    vec_push(v, 2);
    vec_push(v, 3);

    let first: i64 = vec_first(v);
    if option_is_none(first) {
        println("FAIL: first should be Some");
        return 1;
    }
    if option_unwrap(first) != 1 {
        println("FAIL: first value should be 1");
        return 1;
    }

    let last: i64 = vec_last(v);
    if option_is_none(last) {
        println("FAIL: last should be Some");
        return 1;
    }
    if option_unwrap(last) != 3 {
        println("FAIL: last value should be 3");
        return 1;
    }

    println("PASS: test_vec_first_last");
    0
}

fn test_vec_empty() -> i64 {
    let v: i64 = vec_new();

    let first: i64 = vec_first(v);
    if option_is_some(first) {
        println("FAIL: first of empty should be None");
        return 1;
    }

    let last: i64 = vec_last(v);
    if option_is_some(last) {
        println("FAIL: last of empty should be None");
        return 1;
    }

    println("PASS: test_vec_empty");
    0
}

fn test_vec_large() -> i64 {
    let v: i64 = vec_new();

    // Add 100 elements
    var i: i64 = 0;
    while i < 100 {
        vec_push(v, i * 2);
        i = i + 1;
    }

    if vec_len(v) != 100 {
        println("FAIL: vec should have 100 elements");
        return 1;
    }

    // Verify first and last
    if vec_get(v, 0) != 0 {
        println("FAIL: first element should be 0");
        return 1;
    }
    if vec_get(v, 99) != 198 {
        println("FAIL: last element should be 198");
        return 1;
    }

    // Verify sum: 0 + 2 + 4 + ... + 198 = 2 * (0 + 1 + ... + 99) = 2 * 4950 = 9900
    let sum: i64 = vec_sum(v);
    if sum != 9900 {
        println("FAIL: sum should be 9900");
        return 1;
    }

    println("PASS: test_vec_large");
    0
}

fn main() -> i64 {
    println("=== Vec Tests ===");
    println("");

    var failures: i64 = 0;

    failures = failures + test_vec_create_and_push();
    failures = failures + test_vec_get();
    failures = failures + test_vec_sum();
    failures = failures + test_vec_find();
    failures = failures + test_vec_contains();
    failures = failures + test_vec_reverse();
    failures = failures + test_vec_clone();
    failures = failures + test_vec_first_last();
    failures = failures + test_vec_empty();
    failures = failures + test_vec_large();

    println("");
    if failures == 0 {
        println("All Vec tests passed!");
    } else {
        print("Vec tests failed: ");
        println(int_to_string(failures));
    }

    failures
}
