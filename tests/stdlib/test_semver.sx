// Tests for Semver parsing
// Part of Phase 2: Package Ecosystem

var tests_passed: i64 = 0;
var tests_failed: i64 = 0;

fn assert_eq_i64(expected: i64, actual: i64, msg: i64) {
    if expected == actual {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
        print("FAIL: ");
        print(msg);
        print(" - expected ");
        print(int_to_string(expected));
        print(", got ");
        println(int_to_string(actual));
    }
}

fn assert_eq_str(expected: i64, actual: i64, msg: i64) {
    if string_eq(expected, actual) {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
        print("FAIL: ");
        print(msg);
        print(" - expected '");
        print(expected);
        print("', got '");
        print(actual);
        println("'");
    }
}

fn assert_true(cond: bool, msg: i64) {
    if cond {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
        print("FAIL: ");
        println(msg);
    }
}

fn test_semver_parse_simple() {
    let v: i64 = semver_parse("1.2.3");
    assert_true(v != 0, "semver_parse returns non-null");
    assert_eq_i64(1, semver_major(v), "semver major");
    assert_eq_i64(2, semver_minor(v), "semver minor");
    assert_eq_i64(3, semver_patch(v), "semver patch");
}

fn test_semver_parse_prerelease() {
    let v: i64 = semver_parse("1.0.0-alpha");
    assert_true(v != 0, "semver_parse prerelease non-null");
    assert_eq_i64(1, semver_major(v), "prerelease major");
    assert_eq_i64(0, semver_minor(v), "prerelease minor");
    assert_eq_i64(0, semver_patch(v), "prerelease patch");
    assert_eq_str("alpha", semver_prerelease(v), "prerelease tag");
}

fn test_semver_parse_build() {
    let v: i64 = semver_parse("2.1.0+build.123");
    assert_true(v != 0, "semver_parse build non-null");
    assert_eq_i64(2, semver_major(v), "build major");
    assert_eq_i64(1, semver_minor(v), "build minor");
    assert_eq_str("build.123", semver_build(v), "build metadata");
}

fn test_semver_compare() {
    let v1: i64 = semver_parse("1.0.0");
    let v2: i64 = semver_parse("2.0.0");
    let v3: i64 = semver_parse("1.1.0");
    let v4: i64 = semver_parse("1.0.1");
    let v5: i64 = semver_parse("1.0.0");

    assert_true(semver_lt(v1, v2), "1.0.0 < 2.0.0");
    assert_true(semver_lt(v1, v3), "1.0.0 < 1.1.0");
    assert_true(semver_lt(v1, v4), "1.0.0 < 1.0.1");
    assert_true(semver_eq(v1, v5), "1.0.0 == 1.0.0");
    assert_true(semver_gt(v2, v1), "2.0.0 > 1.0.0");
}

fn test_semver_prerelease_precedence() {
    let release: i64 = semver_parse("1.0.0");
    let alpha: i64 = semver_parse("1.0.0-alpha");

    assert_true(semver_gt(release, alpha), "1.0.0 > 1.0.0-alpha");
    assert_true(semver_lt(alpha, release), "1.0.0-alpha < 1.0.0");
}

fn test_semver_to_string() {
    let v: i64 = semver_new(1, 2, 3);
    assert_eq_str("1.2.3", semver_to_string(v), "semver_to_string simple");
}

fn test_version_range_exact() {
    let range: i64 = version_range_parse("1.2.3");
    assert_true(range != 0, "version_range_parse exact non-null");

    let v1: i64 = semver_parse("1.2.3");
    let v2: i64 = semver_parse("1.2.4");

    assert_true(version_matches(v1, range), "1.2.3 matches 1.2.3");
    assert_true(version_matches(v2, range) == false, "1.2.4 does not match 1.2.3");
}

fn test_version_range_caret() {
    let range: i64 = version_range_parse("^1.2.0");
    assert_true(range != 0, "version_range_parse caret non-null");

    let v1: i64 = semver_parse("1.2.0");
    let v2: i64 = semver_parse("1.5.0");
    let v3: i64 = semver_parse("1.9.9");
    let v4: i64 = semver_parse("2.0.0");
    let v5: i64 = semver_parse("1.1.0");

    assert_true(version_matches(v1, range), "1.2.0 matches ^1.2.0");
    assert_true(version_matches(v2, range), "1.5.0 matches ^1.2.0");
    assert_true(version_matches(v3, range), "1.9.9 matches ^1.2.0");
    assert_true(version_matches(v4, range) == false, "2.0.0 does not match ^1.2.0");
    assert_true(version_matches(v5, range) == false, "1.1.0 does not match ^1.2.0");
}

fn test_version_range_tilde() {
    let range: i64 = version_range_parse("~1.2.0");
    assert_true(range != 0, "version_range_parse tilde non-null");

    let v1: i64 = semver_parse("1.2.0");
    let v2: i64 = semver_parse("1.2.5");
    let v3: i64 = semver_parse("1.3.0");

    assert_true(version_matches(v1, range), "1.2.0 matches ~1.2.0");
    assert_true(version_matches(v2, range), "1.2.5 matches ~1.2.0");
    assert_true(version_matches(v3, range) == false, "1.3.0 does not match ~1.2.0");
}

fn test_version_range_wildcard() {
    let range: i64 = version_range_parse("*");
    assert_true(range != 0, "version_range_parse wildcard non-null");

    let v1: i64 = semver_parse("0.0.1");
    let v2: i64 = semver_parse("999.999.999");

    assert_true(version_matches(v1, range), "0.0.1 matches *");
    assert_true(version_matches(v2, range), "999.999.999 matches *");
}

fn main() {
    println("Running semver tests...");
    println("");

    test_semver_parse_simple();
    test_semver_parse_prerelease();
    test_semver_parse_build();
    test_semver_compare();
    test_semver_prerelease_precedence();
    test_semver_to_string();
    test_version_range_exact();
    test_version_range_caret();
    test_version_range_tilde();
    test_version_range_wildcard();

    println("");
    print("Tests passed: ");
    println(int_to_string(tests_passed));
    print("Tests failed: ");
    println(int_to_string(tests_failed));

    if tests_failed > 0 {
        exit(1);
    }
}
