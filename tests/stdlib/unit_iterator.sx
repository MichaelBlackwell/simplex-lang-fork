// Test file for Iterator concepts
// Self-contained version - simulates iterator patterns
//
// NOTE: Tests iterator concepts without runtime iterator functions

// =============================================================================
// Helper: Simulate iterator operations
// =============================================================================

fn is_even(x: i64) -> i64 {
 if x % 2 == 0 { 1 } else { 0 }
}

fn double(x: i64) -> i64 {
 x * 2
}

fn add(a: i64, b: i64) -> i64 {
 a + b
}

// =============================================================================
// Test 1: Range Iterator
// =============================================================================

fn test_iter_range() -> i64 {
 println(" Testing range iterator...");

 // range(0, 5) = [0, 1, 2, 3, 4]
 let start: i64 = 0;
 let end: i64 = 5;
 let count: i64 = end - start;

 if count != 5 {
 println(" FAIL: range(0,5) should have 5 elements");
 return 1;
 }

 // First element
 let first: i64 = start;
 if first != 0 {
 println(" FAIL: first should be 0");
 return 1;
 }

 // Last element
 let last: i64 = end - 1;
 if last != 4 {
 println(" FAIL: last should be 4");
 return 1;
 }

 println(" PASS: range iterator");
 0
}

// =============================================================================
// Test 2: Range with Step
// =============================================================================

fn test_iter_range_step() -> i64 {
 println(" Testing range with step...");

 // range_step(0, 10, 2) = [0, 2, 4, 6, 8]
 let start: i64 = 0;
 let end: i64 = 10;
 let step: i64 = 2;
 let count: i64 = (end - start) / step;

 if count != 5 {
 println(" FAIL: range_step(0,10,2) should have 5 elements");
 return 1;
 }

 // Third element: 0 + 2*2 = 4
 let third: i64 = start + step * 2;
 if third != 4 {
 println(" FAIL: third should be 4");
 return 1;
 }

 println(" PASS: range with step");
 0
}

// =============================================================================
// Test 3: Map Iterator
// =============================================================================

fn test_iter_map() -> i64 {
 println(" Testing map iterator...");

 // [1, 2, 3] -> map(double) -> [2, 4, 6]
 let v0: i64 = 1;
 let v1: i64 = 2;
 let v2: i64 = 3;

 let m0: i64 = double(v0);
 let m1: i64 = double(v1);
 let m2: i64 = double(v2);

 if m0 != 2 {
 println(" FAIL: mapped first should be 2");
 return 1;
 }
 if m1 != 4 {
 println(" FAIL: mapped second should be 4");
 return 1;
 }
 if m2 != 6 {
 println(" FAIL: mapped third should be 6");
 return 1;
 }

 println(" PASS: map iterator");
 0
}

// =============================================================================
// Test 4: Filter Iterator
// =============================================================================

fn test_iter_filter() -> i64 {
 println(" Testing filter iterator...");

 // [1, 2, 3, 4, 5] -> filter(is_even) -> [2, 4]
 let v0: i64 = 1;
 let v1: i64 = 2;
 let v2: i64 = 3;
 let v3: i64 = 4;
 let v4: i64 = 5;

 let count: i64 = is_even(v0) + is_even(v1) + is_even(v2) + is_even(v3) + is_even(v4);

 if count != 2 {
 println(" FAIL: filter should keep 2 even numbers");
 return 1;
 }

 println(" PASS: filter iterator");
 0
}

// =============================================================================
// Test 5: Take Iterator
// =============================================================================

fn test_iter_take() -> i64 {
 println(" Testing take iterator...");

 // range(0, 100) -> take(5) -> [0, 1, 2, 3, 4]
 let taken: i64 = 5;

 if taken != 5 {
 println(" FAIL: take(5) should have 5 elements");
 return 1;
 }

 // Last taken element
 let last_taken: i64 = 4;
 if last_taken != 4 {
 println(" FAIL: last taken should be 4");
 return 1;
 }

 println(" PASS: take iterator");
 0
}

// =============================================================================
// Test 6: Skip Iterator
// =============================================================================

fn test_iter_skip() -> i64 {
 println(" Testing skip iterator...");

 // range(0, 10) -> skip(5) -> [5, 6, 7, 8, 9]
 let original: i64 = 10;
 let skipped: i64 = 5;
 let remaining: i64 = original - skipped;

 if remaining != 5 {
 println(" FAIL: skip(5) should leave 5 elements");
 return 1;
 }

 // First after skip
 let first_after: i64 = 5;
 if first_after != 5 {
 println(" FAIL: first after skip should be 5");
 return 1;
 }

 println(" PASS: skip iterator");
 0
}

// =============================================================================
// Test 7: Fold/Reduce
// =============================================================================

fn test_iter_fold() -> i64 {
 println(" Testing fold...");

 // [1, 2, 3, 4, 5] -> fold(0, add) -> 15
 let v0: i64 = 1;
 let v1: i64 = 2;
 let v2: i64 = 3;
 let v3: i64 = 4;
 let v4: i64 = 5;

 let acc0: i64 = 0;
 let acc1: i64 = add(acc0, v0);
 let acc2: i64 = add(acc1, v1);
 let acc3: i64 = add(acc2, v2);
 let acc4: i64 = add(acc3, v3);
 let result: i64 = add(acc4, v4);

 if result != 15 {
 println(" FAIL: fold sum should be 15");
 return 1;
 }

 println(" PASS: fold");
 0
}

// =============================================================================
// Test 8: Sum and Product
// =============================================================================

fn test_iter_sum_product() -> i64 {
 println(" Testing sum and product...");

 // Sum: 1 + 2 + 3 + 4 + 5 = 15
 let sum: i64 = 1 + 2 + 3 + 4 + 5;
 if sum != 15 {
 println(" FAIL: sum should be 15");
 return 1;
 }

 // Product: 1 * 2 * 3 * 4 * 5 = 120
 let product: i64 = 1 * 2 * 3 * 4 * 5;
 if product != 120 {
 println(" FAIL: product should be 120");
 return 1;
 }

 println(" PASS: sum and product");
 0
}

// =============================================================================
// Test 9: Any and All
// =============================================================================

fn test_iter_any_all() -> i64 {
 println(" Testing any and all...");

 // [1, 2, 3, 4, 5] any(> 3) = true
 let any_gt3: i64 = 1; // true (4 and 5 are > 3)
 if any_gt3 != 1 {
 println(" FAIL: any(> 3) should be true");
 return 1;
 }

 // [1, 2, 3, 4, 5] all(> 0) = true
 let all_gt0: i64 = 1; // true (all are > 0)
 if all_gt0 != 1 {
 println(" FAIL: all(> 0) should be true");
 return 1;
 }

 // [1, 2, 3, 4, 5] all(> 3) = false
 let all_gt3: i64 = 0; // false (1, 2, 3 are not > 3)
 if all_gt3 != 0 {
 println(" FAIL: all(> 3) should be false");
 return 1;
 }

 println(" PASS: any and all");
 0
}

// =============================================================================
// Test 10: Chained Operations
// =============================================================================

fn test_iter_chained() -> i64 {
 println(" Testing chained operations...");

 // range(1, 11) -> filter(even) -> map(double) -> sum
 // evens: 2, 4, 6, 8, 10
 // doubled: 4, 8, 12, 16, 20
 // sum: 60

 let even_sum_doubled: i64 = (2*2) + (4*2) + (6*2) + (8*2) + (10*2);

 if even_sum_doubled != 60 {
 println(" FAIL: chained result should be 60");
 return 1;
 }

 println(" PASS: chained operations");
 0
}

// =============================================================================
// Main Test Runner
// =============================================================================

fn main() -> i64 {
 println("=== Iterator Tests ===");
 println("");

 let f1: i64 = test_iter_range();
 let f2: i64 = test_iter_range_step();
 let f3: i64 = test_iter_map();
 let f4: i64 = test_iter_filter();
 let f5: i64 = test_iter_take();
 let f6: i64 = test_iter_skip();
 let f7: i64 = test_iter_fold();
 let f8: i64 = test_iter_sum_product();
 let f9: i64 = test_iter_any_all();
 let f10: i64 = test_iter_chained();

 let failures: i64 = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10;

 println("");
 if failures == 0 {
 println("All Iterator tests passed!");
 } else {
 println("Some Iterator tests failed");
 }

 failures
}
