// Test file for Iterator Combinator operations
// Tests: sxiter_from_vec, sxiter_range, sxiter_map, sxiter_filter, sxiter_fold, etc.

fn test_iter_from_vec() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 1);
    vec_push(v, 2);
    vec_push(v, 3);

    let iter: i64 = sxiter_from_vec(v);
    let collected: i64 = sxiter_collect_vec(iter);

    if vec_len(collected) != 3 {
        println("FAIL: collected vec should have 3 elements");
        return 1;
    }
    if vec_get(collected, 0) != 1 {
        println("FAIL: first element should be 1");
        return 1;
    }
    if vec_get(collected, 2) != 3 {
        println("FAIL: third element should be 3");
        return 1;
    }

    println("PASS: test_iter_from_vec");
    0
}

fn test_iter_range() -> i64 {
    let iter: i64 = sxiter_range(0, 5);
    let collected: i64 = sxiter_collect_vec(iter);

    if vec_len(collected) != 5 {
        println("FAIL: range(0,5) should have 5 elements");
        return 1;
    }
    if vec_get(collected, 0) != 0 {
        println("FAIL: first element should be 0");
        return 1;
    }
    if vec_get(collected, 4) != 4 {
        println("FAIL: last element should be 4");
        return 1;
    }

    println("PASS: test_iter_range");
    0
}

fn test_iter_range_step() -> i64 {
    let iter: i64 = sxiter_range_step(0, 10, 2);
    let collected: i64 = sxiter_collect_vec(iter);

    if vec_len(collected) != 5 {
        println("FAIL: range_step(0,10,2) should have 5 elements");
        return 1;
    }
    if vec_get(collected, 0) != 0 {
        println("FAIL: first element should be 0");
        return 1;
    }
    if vec_get(collected, 2) != 4 {
        println("FAIL: third element should be 4");
        return 1;
    }
    if vec_get(collected, 4) != 8 {
        println("FAIL: fifth element should be 8");
        return 1;
    }

    println("PASS: test_iter_range_step");
    0
}

fn double(x: i64) -> i64 {
    x * 2
}

fn test_iter_map() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 1);
    vec_push(v, 2);
    vec_push(v, 3);

    let iter: i64 = sxiter_from_vec(v);
    let mapped: i64 = sxiter_map(iter, double);
    let collected: i64 = sxiter_collect_vec(mapped);

    if vec_get(collected, 0) != 2 {
        println("FAIL: mapped first should be 2");
        return 1;
    }
    if vec_get(collected, 1) != 4 {
        println("FAIL: mapped second should be 4");
        return 1;
    }
    if vec_get(collected, 2) != 6 {
        println("FAIL: mapped third should be 6");
        return 1;
    }

    println("PASS: test_iter_map");
    0
}

fn is_even(x: i64) -> i64 {
    x % 2 == 0
}

fn test_iter_filter() -> i64 {
    let iter: i64 = sxiter_range(1, 11);
    let filtered: i64 = sxiter_filter(iter, is_even);
    let collected: i64 = sxiter_collect_vec(filtered);

    if vec_len(collected) != 5 {
        println("FAIL: filtered should have 5 even numbers");
        return 1;
    }
    if vec_get(collected, 0) != 2 {
        println("FAIL: first even should be 2");
        return 1;
    }
    if vec_get(collected, 4) != 10 {
        println("FAIL: last even should be 10");
        return 1;
    }

    println("PASS: test_iter_filter");
    0
}

fn test_iter_take() -> i64 {
    let iter: i64 = sxiter_range(0, 100);
    let taken: i64 = sxiter_take(iter, 5);
    let collected: i64 = sxiter_collect_vec(taken);

    if vec_len(collected) != 5 {
        println("FAIL: take(5) should have 5 elements");
        return 1;
    }
    if vec_get(collected, 4) != 4 {
        println("FAIL: last taken element should be 4");
        return 1;
    }

    println("PASS: test_iter_take");
    0
}

fn test_iter_skip() -> i64 {
    let iter: i64 = sxiter_range(0, 10);
    let skipped: i64 = sxiter_skip(iter, 5);
    let collected: i64 = sxiter_collect_vec(skipped);

    if vec_len(collected) != 5 {
        println("FAIL: skip(5) should have 5 elements left");
        return 1;
    }
    if vec_get(collected, 0) != 5 {
        println("FAIL: first after skip should be 5");
        return 1;
    }
    if vec_get(collected, 4) != 9 {
        println("FAIL: last after skip should be 9");
        return 1;
    }

    println("PASS: test_iter_skip");
    0
}

fn add(acc: i64, x: i64) -> i64 {
    acc + x
}

fn test_iter_fold() -> i64 {
    let iter: i64 = sxiter_range(1, 6);
    let result: i64 = sxiter_fold(iter, 0, add);

    if result != 15 {
        println("FAIL: fold sum of 1..5 should be 15");
        return 1;
    }

    println("PASS: test_iter_fold");
    0
}

fn test_iter_sum() -> i64 {
    let iter: i64 = sxiter_range(1, 11);
    let result: i64 = sxiter_sum(iter);

    if result != 55 {
        println("FAIL: sum of 1..10 should be 55");
        return 1;
    }

    println("PASS: test_iter_sum");
    0
}

fn test_iter_product() -> i64 {
    let iter: i64 = sxiter_range(1, 6);
    let result: i64 = sxiter_product(iter);

    if result != 120 {
        println("FAIL: product of 1..5 (5!) should be 120");
        return 1;
    }

    println("PASS: test_iter_product");
    0
}

fn test_iter_count() -> i64 {
    let iter: i64 = sxiter_range(0, 100);
    let result: i64 = sxiter_count(iter);

    if result != 100 {
        println("FAIL: count of range(0,100) should be 100");
        return 1;
    }

    println("PASS: test_iter_count");
    0
}

fn is_greater_than_5(x: i64) -> i64 {
    x > 5
}

fn test_iter_find() -> i64 {
    let iter: i64 = sxiter_range(1, 10);
    let result: i64 = sxiter_find(iter, is_greater_than_5);

    if option_is_none(result) {
        println("FAIL: find should return Some");
        return 1;
    }
    if option_unwrap(result) != 6 {
        println("FAIL: first > 5 should be 6");
        return 1;
    }

    println("PASS: test_iter_find");
    0
}

fn test_iter_position() -> i64 {
    let iter: i64 = sxiter_range(10, 20);
    let result: i64 = sxiter_position(iter, is_greater_than_5);

    if option_is_none(result) {
        println("FAIL: position should return Some");
        return 1;
    }
    // All elements 10-19 are > 5, so first match is at position 0
    if option_unwrap(result) != 0 {
        println("FAIL: position of first > 5 should be 0");
        return 1;
    }

    println("PASS: test_iter_position");
    0
}

fn test_iter_any() -> i64 {
    let iter1: i64 = sxiter_range(1, 10);
    if sxiter_any(iter1, is_greater_than_5) == false {
        println("FAIL: any(1..10, > 5) should be true");
        return 1;
    }

    let iter2: i64 = sxiter_range(1, 5);
    if sxiter_any(iter2, is_greater_than_5) == true {
        println("FAIL: any(1..5, > 5) should be false");
        return 1;
    }

    println("PASS: test_iter_any");
    0
}

fn test_iter_all() -> i64 {
    let iter1: i64 = sxiter_range(10, 20);
    if sxiter_all(iter1, is_greater_than_5) == false {
        println("FAIL: all(10..20, > 5) should be true");
        return 1;
    }

    let iter2: i64 = sxiter_range(1, 10);
    if sxiter_all(iter2, is_greater_than_5) == true {
        println("FAIL: all(1..10, > 5) should be false");
        return 1;
    }

    println("PASS: test_iter_all");
    0
}

fn test_iter_min_max() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 5);
    vec_push(v, 2);
    vec_push(v, 8);
    vec_push(v, 1);
    vec_push(v, 9);

    let iter1: i64 = sxiter_from_vec(v);
    let min: i64 = sxiter_min(iter1);
    if option_unwrap(min) != 1 {
        println("FAIL: min should be 1");
        return 1;
    }

    let iter2: i64 = sxiter_from_vec(v);
    let max: i64 = sxiter_max(iter2);
    if option_unwrap(max) != 9 {
        println("FAIL: max should be 9");
        return 1;
    }

    println("PASS: test_iter_min_max");
    0
}

fn test_iter_nth() -> i64 {
    let iter: i64 = sxiter_range(10, 20);
    let result: i64 = sxiter_nth(iter, 5);

    if option_is_none(result) {
        println("FAIL: nth(5) should return Some");
        return 1;
    }
    if option_unwrap(result) != 15 {
        println("FAIL: nth(5) of range(10,20) should be 15");
        return 1;
    }

    println("PASS: test_iter_nth");
    0
}

fn test_iter_last() -> i64 {
    let iter: i64 = sxiter_range(1, 10);
    let result: i64 = sxiter_last(iter);

    if option_is_none(result) {
        println("FAIL: last should return Some");
        return 1;
    }
    if option_unwrap(result) != 9 {
        println("FAIL: last of range(1,10) should be 9");
        return 1;
    }

    println("PASS: test_iter_last");
    0
}

fn test_iter_chain() -> i64 {
    let iter1: i64 = sxiter_range(1, 4);
    let iter2: i64 = sxiter_range(7, 10);
    let chained: i64 = sxiter_chain(iter1, iter2);
    let collected: i64 = sxiter_collect_vec(chained);

    if vec_len(collected) != 6 {
        println("FAIL: chain should have 6 elements");
        return 1;
    }
    if vec_get(collected, 0) != 1 {
        println("FAIL: first should be 1");
        return 1;
    }
    if vec_get(collected, 3) != 7 {
        println("FAIL: fourth should be 7 (from second iterator)");
        return 1;
    }
    if vec_get(collected, 5) != 9 {
        println("FAIL: last should be 9");
        return 1;
    }

    println("PASS: test_iter_chain");
    0
}

fn test_iter_enumerate() -> i64 {
    let v: i64 = vec_new();
    vec_push(v, 100);
    vec_push(v, 200);
    vec_push(v, 300);

    let iter: i64 = sxiter_from_vec(v);
    let enumerated: i64 = sxiter_enumerate(iter);
    let collected: i64 = sxiter_collect_vec(enumerated);

    // Each element is a pair (index, value) encoded as: index * 1000000 + value
    // or however the implementation encodes pairs
    if vec_len(collected) != 3 {
        println("FAIL: enumerated should have 3 elements");
        return 1;
    }

    println("PASS: test_iter_enumerate");
    0
}

fn test_iter_chained_operations() -> i64 {
    // Test: range(1, 11) -> filter(is_even) -> map(double) -> sum
    // 1..10 evens: 2,4,6,8,10 -> doubled: 4,8,12,16,20 -> sum: 60
    let iter: i64 = sxiter_range(1, 11);
    let filtered: i64 = sxiter_filter(iter, is_even);
    let mapped: i64 = sxiter_map(filtered, double);
    let result: i64 = sxiter_sum(mapped);

    if result != 60 {
        println("FAIL: chained filter->map->sum should be 60");
        return 1;
    }

    println("PASS: test_iter_chained_operations");
    0
}

fn main() -> i64 {
    println("=== Iterator Tests ===");
    println("");

    var failures: i64 = 0;

    failures = failures + test_iter_from_vec();
    failures = failures + test_iter_range();
    failures = failures + test_iter_range_step();
    failures = failures + test_iter_map();
    failures = failures + test_iter_filter();
    failures = failures + test_iter_take();
    failures = failures + test_iter_skip();
    failures = failures + test_iter_fold();
    failures = failures + test_iter_sum();
    failures = failures + test_iter_product();
    failures = failures + test_iter_count();
    failures = failures + test_iter_find();
    failures = failures + test_iter_position();
    failures = failures + test_iter_any();
    failures = failures + test_iter_all();
    failures = failures + test_iter_min_max();
    failures = failures + test_iter_nth();
    failures = failures + test_iter_last();
    failures = failures + test_iter_chain();
    failures = failures + test_iter_enumerate();
    failures = failures + test_iter_chained_operations();

    println("");
    if failures == 0 {
        println("All Iterator tests passed!");
    } else {
        print("Iterator tests failed: ");
        println(int_to_string(failures));
    }

    failures
}
