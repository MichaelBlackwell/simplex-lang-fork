// Test file for Option<T> implementation
// Tests: option_none, option_some, option_is_none, option_is_some, option_unwrap, option_unwrap_or

fn test_option_none() -> i64 {
    let opt: i64 = option_none();
    if option_is_none(opt) == false {
        println("FAIL: option_none should be None");
        return 1;
    }
    if option_is_some(opt) == true {
        println("FAIL: option_none should not be Some");
        return 1;
    }
    println("PASS: test_option_none");
    0
}

fn test_option_some() -> i64 {
    let opt: i64 = option_some(42);
    if option_is_some(opt) == false {
        println("FAIL: option_some should be Some");
        return 1;
    }
    if option_is_none(opt) == true {
        println("FAIL: option_some should not be None");
        return 1;
    }
    let val: i64 = option_unwrap(opt);
    if val != 42 {
        println("FAIL: unwrapped value should be 42");
        return 1;
    }
    println("PASS: test_option_some");
    0
}

fn test_option_unwrap_or() -> i64 {
    let some: i64 = option_some(100);
    let none: i64 = option_none();

    let val1: i64 = option_unwrap_or(some, 0);
    if val1 != 100 {
        println("FAIL: unwrap_or Some should return inner value");
        return 1;
    }

    let val2: i64 = option_unwrap_or(none, 999);
    if val2 != 999 {
        println("FAIL: unwrap_or None should return default");
        return 1;
    }

    println("PASS: test_option_unwrap_or");
    0
}

fn test_option_chaining() -> i64 {
    // Test option chaining patterns
    let opt1: i64 = option_some(10);
    let opt2: i64 = option_some(20);
    let none: i64 = option_none();

    // Check value access
    if option_is_some(opt1) {
        let v: i64 = option_unwrap(opt1);
        if v != 10 {
            println("FAIL: opt1 value should be 10");
            return 1;
        }
    }

    // Check None handling
    let result: i64 = option_unwrap_or(none, 0 - 1);
    if result != 0 - 1 {
        println("FAIL: None unwrap_or should return default");
        return 1;
    }

    println("PASS: test_option_chaining");
    0
}

fn test_option_with_zero() -> i64 {
    // Zero is a valid value, not None
    let opt: i64 = option_some(0);
    if option_is_none(opt) {
        println("FAIL: Some(0) should not be None");
        return 1;
    }
    let val: i64 = option_unwrap(opt);
    if val != 0 {
        println("FAIL: unwrap of Some(0) should be 0");
        return 1;
    }
    println("PASS: test_option_with_zero");
    0
}

fn test_option_with_negative() -> i64 {
    let opt: i64 = option_some(0 - 42);
    if option_is_none(opt) {
        println("FAIL: Some(-42) should not be None");
        return 1;
    }
    let val: i64 = option_unwrap(opt);
    if val != 0 - 42 {
        println("FAIL: unwrap of Some(-42) should be -42");
        return 1;
    }
    println("PASS: test_option_with_negative");
    0
}

fn main() -> i64 {
    println("=== Option Tests ===");
    println("");

    var failures: i64 = 0;

    failures = failures + test_option_none();
    failures = failures + test_option_some();
    failures = failures + test_option_unwrap_or();
    failures = failures + test_option_chaining();
    failures = failures + test_option_with_zero();
    failures = failures + test_option_with_negative();

    println("");
    if failures == 0 {
        println("All Option tests passed!");
    } else {
        print("Option tests failed: ");
        println(int_to_string(failures));
    }

    failures
}
