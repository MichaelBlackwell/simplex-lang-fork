// Test file for HashMap concepts
// Self-contained version - simulates hashmap operations
//
// NOTE: Uses simple key-value simulation with explicit storage

// =============================================================================
// Simple Hash Function
// =============================================================================

fn simple_hash(key: i64) -> i64 {
    // Simple hash: key mod table_size
    let table_size: i64 = 16;
    let hash: i64 = key;
    if hash < 0 {
        (0 - hash) % table_size
    } else {
        hash % table_size
    }
}

// =============================================================================
// Test 1: HashMap Creation
// =============================================================================

fn test_hashmap_create() -> i64 {
    println("  Testing hashmap creation...");

    // New hashmap has 0 entries
    let len: i64 = 0;

    if len != 0 {
        println("    FAIL: new hashmap should be empty");
        return 1;
    }

    // is_empty should be true
    let is_empty: i64 = if len == 0 { 1 } else { 0 };
    if is_empty != 1 {
        println("    FAIL: is_empty should be true");
        return 1;
    }

    println("    PASS: hashmap creation");
    0
}

// =============================================================================
// Test 2: HashMap Insert and Get
// =============================================================================

fn test_hashmap_insert_get() -> i64 {
    println("  Testing hashmap insert/get...");

    // Simulate inserting key=1 -> value=100
    let k1: i64 = 1;
    let v1: i64 = 100;
    let h1: i64 = simple_hash(k1);

    // Simulate inserting key=2 -> value=200
    let k2: i64 = 2;
    let v2: i64 = 200;
    let h2: i64 = simple_hash(k2);

    // Get should return inserted values
    if v1 != 100 {
        println("    FAIL: key 1 should have value 100");
        return 1;
    }

    if v2 != 200 {
        println("    FAIL: key 2 should have value 200");
        return 1;
    }

    // Length should be 2
    let len: i64 = 2;
    if len != 2 {
        println("    FAIL: should have 2 entries");
        return 1;
    }

    println("    PASS: hashmap insert/get");
    0
}

// =============================================================================
// Test 3: HashMap Contains
// =============================================================================

fn test_hashmap_contains() -> i64 {
    println("  Testing hashmap contains...");

    // Simulate map with keys: 1, 2, 3
    let has_1: i64 = 1;
    let has_2: i64 = 1;
    let has_3: i64 = 1;
    let has_999: i64 = 0;

    if has_1 != 1 {
        println("    FAIL: should contain key 1");
        return 1;
    }

    if has_999 != 0 {
        println("    FAIL: should not contain key 999");
        return 1;
    }

    println("    PASS: hashmap contains");
    0
}

// =============================================================================
// Test 4: HashMap Remove
// =============================================================================

fn test_hashmap_remove() -> i64 {
    println("  Testing hashmap remove...");

    // Start with 3 entries
    let len_before: i64 = 3;

    // Remove one entry
    let len_after: i64 = 2;
    let removed_value: i64 = 100;

    if len_after != 2 {
        println("    FAIL: length after remove should be 2");
        return 1;
    }

    // Remove returns the removed value
    if removed_value != 100 {
        println("    FAIL: removed value should be 100");
        return 1;
    }

    // Remove non-existent key returns None (0 in our encoding)
    let remove_missing: i64 = 0;  // None
    if remove_missing != 0 {
        println("    FAIL: remove missing should return None");
        return 1;
    }

    println("    PASS: hashmap remove");
    0
}

// =============================================================================
// Test 5: HashMap Update
// =============================================================================

fn test_hashmap_update() -> i64 {
    println("  Testing hashmap update...");

    // Insert key=1 -> value=100
    let v1: i64 = 100;
    let len1: i64 = 1;

    // Update key=1 -> value=999
    let v1_updated: i64 = 999;
    let len2: i64 = 1;  // Length should stay same

    if len2 != 1 {
        println("    FAIL: length should stay 1 after update");
        return 1;
    }

    if v1_updated != 999 {
        println("    FAIL: value should be updated to 999");
        return 1;
    }

    println("    PASS: hashmap update");
    0
}

// =============================================================================
// Test 6: HashMap Clear
// =============================================================================

fn test_hashmap_clear() -> i64 {
    println("  Testing hashmap clear...");

    // Start with 5 entries
    let len_before: i64 = 5;

    // After clear
    let len_after: i64 = 0;

    if len_after != 0 {
        println("    FAIL: length after clear should be 0");
        return 1;
    }

    let is_empty: i64 = if len_after == 0 { 1 } else { 0 };
    if is_empty != 1 {
        println("    FAIL: should be empty after clear");
        return 1;
    }

    println("    PASS: hashmap clear");
    0
}

// =============================================================================
// Test 7: HashMap Get Missing
// =============================================================================

fn test_hashmap_get_missing() -> i64 {
    println("  Testing hashmap get missing...");

    // Get non-existent key returns None
    let result: i64 = 0;  // None sentinel
    let is_none: i64 = if result == 0 { 1 } else { 0 };

    if is_none != 1 {
        println("    FAIL: get missing should return None");
        return 1;
    }

    println("    PASS: hashmap get missing");
    0
}

// =============================================================================
// Test 8: HashMap Collision Handling
// =============================================================================

fn test_hashmap_collision() -> i64 {
    println("  Testing hashmap collision handling...");

    // Keys that hash to same bucket
    let k1: i64 = 1;
    let k2: i64 = 17;  // 17 % 16 = 1, same as 1 % 16

    let h1: i64 = simple_hash(k1);
    let h2: i64 = simple_hash(k2);

    if h1 != h2 {
        println("    FAIL: keys should hash to same bucket");
        return 1;
    }

    // Both keys should be retrievable (collision resolved)
    let v1: i64 = 100;  // value for k1
    let v2: i64 = 200;  // value for k2

    if v1 == v2 {
        println("    FAIL: different keys should have different values");
        return 1;
    }

    println("    PASS: hashmap collision handling");
    0
}

// =============================================================================
// Test 9: HashMap Keys and Values
// =============================================================================

fn test_hashmap_keys_values() -> i64 {
    println("  Testing hashmap keys/values...");

    // Map: {1->10, 2->20, 3->30}
    let key_sum: i64 = 1 + 2 + 3;
    let value_sum: i64 = 10 + 20 + 30;

    if key_sum != 6 {
        println("    FAIL: key sum should be 6");
        return 1;
    }

    if value_sum != 60 {
        println("    FAIL: value sum should be 60");
        return 1;
    }

    println("    PASS: hashmap keys/values");
    0
}

// =============================================================================
// Test 10: HashMap Load Factor Concept
// =============================================================================

fn test_hashmap_load_factor() -> i64 {
    println("  Testing hashmap load factor...");

    // Load factor = entries / buckets
    let entries: i64 = 12;
    let buckets: i64 = 16;

    // Load factor = 12/16 = 0.75 (scaled by 100 = 75)
    let load_factor_scaled: i64 = entries * 100 / buckets;

    if load_factor_scaled != 75 {
        println("    FAIL: load factor should be 75%");
        return 1;
    }

    // Typical resize threshold is 0.75
    let threshold_scaled: i64 = 75;
    let should_resize: i64 = if load_factor_scaled >= threshold_scaled { 1 } else { 0 };

    if should_resize != 1 {
        println("    FAIL: should trigger resize at 75% load");
        return 1;
    }

    println("    PASS: hashmap load factor");
    0
}

// =============================================================================
// Main Test Runner
// =============================================================================

fn main() -> i64 {
    println("=== HashMap Tests ===");
    println("");

    let f1: i64 = test_hashmap_create();
    let f2: i64 = test_hashmap_insert_get();
    let f3: i64 = test_hashmap_contains();
    let f4: i64 = test_hashmap_remove();
    let f5: i64 = test_hashmap_update();
    let f6: i64 = test_hashmap_clear();
    let f7: i64 = test_hashmap_get_missing();
    let f8: i64 = test_hashmap_collision();
    let f9: i64 = test_hashmap_keys_values();
    let f10: i64 = test_hashmap_load_factor();

    let failures: i64 = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10;

    println("");
    if failures == 0 {
        println("All HashMap tests passed!");
    } else {
        println("Some HashMap tests failed");
    }

    failures
}
