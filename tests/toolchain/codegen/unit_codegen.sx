// Wave 2: Codegen Critical Tests
// Tests for code generation correctness
// Tests should COMPILE and produce correct RUNTIME results

// ============================================
// 35.2.1 Generator State Machine Generation
// ============================================

fn* state_preserving_gen() -> Stream<i64> {
 let a: i64 = 10;
 yield a; // State 1: a = 10
 let b: i64 = a + 20;
 yield b; // State 2: a = 10, b = 30
 let c: i64 = a + b;
 yield c; // State 3: a = 10, b = 30, c = 40
}

fn test_generator_state_preservation() -> i64 {
 let gen: Stream<i64> = state_preserving_gen();
 let v1: i64 = gen.next().unwrap(); // Expected: 10
 let v2: i64 = gen.next().unwrap(); // Expected: 30
 let v3: i64 = gen.next().unwrap(); // Expected: 40

 if v1 == 10 && v2 == 30 && v3 == 40 {
 print_string("generator state preservation: PASS\n");
 1
 } else {
 print_string("generator state preservation: FAIL\n");
 0
 }
}

fn* generator_with_loop() -> Stream<i64> {
 let i: i64 = 0;
 while i < 5 {
 yield i * i;
 i = i + 1;
 }
}

fn test_generator_loop() -> i64 {
 let gen: Stream<i64> = generator_with_loop();
 let sum: i64 = 0;
 for v in gen {
 sum = sum + v; // 0 + 1 + 4 + 9 + 16 = 30
 }
 if sum == 30 {
 print_string("generator with loop: PASS\n");
 1
 } else {
 print_string("generator with loop: FAIL\n");
 0
 }
}

fn test_generator_completion() -> i64 {
 let gen: Stream<i64> = state_preserving_gen();
 gen.next(); // 10
 gen.next(); // 30
 gen.next(); // 40
 let done: Option<i64> = gen.next(); // Should be None

 if done.is_none() {
 print_string("generator completion: PASS\n");
 1
 } else {
 print_string("generator completion: FAIL\n");
 0
 }
}

// ============================================
// 35.2.2 Async State Machine Generation
// ============================================

async fn async_with_multiple_awaits() -> i64 {
 let a: i64 = 10;
 async_sleep(10).await; // Suspend point 1
 let b: i64 = a + 20; // a should still be 10
 async_sleep(10).await; // Suspend point 2
 let c: i64 = b + 30; // b should still be 30
 c // Expected: 60
}

fn test_async_state_preservation() -> i64 {
 let result: i64 = async_with_multiple_awaits().await;
 if result == 60 {
 print_string("async state preservation: PASS\n");
 1
 } else {
 print_string("async state preservation: FAIL - got ");
 print_i64(result);
 print_string("\n");
 0
 }
}

async fn nested_async_call() -> i64 {
 let a: i64 = inner_async().await;
 let b: i64 = inner_async().await;
 a + b
}

async fn inner_async() -> i64 {
 async_sleep(5).await;
 25
}

fn test_async_nested_calls() -> i64 {
 let result: i64 = nested_async_call().await;
 if result == 50 {
 print_string("async nested calls: PASS\n");
 1
 } else {
 print_string("async nested calls: FAIL\n");
 0
 }
}

async fn async_with_conditionals(x: i64) -> i64 {
 if x > 0 {
 async_sleep(10).await;
 x * 2
 } else {
 async_sleep(10).await;
 x * -1
 }
}

fn test_async_conditionals() -> i64 {
 let r1: i64 = async_with_conditionals(5).await; // Expected: 10
 let r2: i64 = async_with_conditionals(-3).await; // Expected: 3

 if r1 == 10 && r2 == 3 {
 print_string("async conditionals: PASS\n");
 1
 } else {
 print_string("async conditionals: FAIL\n");
 0
 }
}

// ============================================
// 35.2.3 Complete Closure Environment Capture
// ============================================

fn test_closure_capture_by_value() -> i64 {
 let x: i64 = 10;
 let closure: fn() -> i64 = || x * 2;
 let result: i64 = closure();
 // x should still be accessible here
 if result == 20 && x == 10 {
 print_string("closure capture by value: PASS\n");
 1
 } else {
 print_string("closure capture by value: FAIL\n");
 0
 }
}

fn test_closure_capture_mutable() -> i64 {
 let counter: i64 = 0;
 let increment: fn() -> i64 = || {
 counter = counter + 1;
 counter
 };
 increment();
 increment();
 increment();
 if counter == 3 {
 print_string("closure capture mutable: PASS\n");
 1
 } else {
 print_string("closure capture mutable: FAIL\n");
 0
 }
}

fn test_closure_nested_capture() -> i64 {
 let a: i64 = 1;
 let b: i64 = 2;
 let outer: fn(i64) -> fn() -> i64 = |c| {
 // Captures a, b from outer scope
 || a + b + c
 };
 let inner: fn() -> i64 = outer(3);
 let result: i64 = inner();
 if result == 6 { // 1 + 2 + 3
 print_string("closure nested capture: PASS\n");
 1
 } else {
 print_string("closure nested capture: FAIL\n");
 0
 }
}

fn test_closure_move_semantics() -> i64 {
 let data: Vec<i64> = vec![1, 2, 3];
 let closure: fn() -> i64 = move || {
 data.len() // data moved into closure
 };
 let result: i64 = closure();
 // data should NOT be accessible here (moved)
 if result == 3 {
 print_string("closure move semantics: PASS\n");
 1
 } else {
 print_string("closure move semantics: FAIL\n");
 0
 }
}

// ============================================
// 35.2.4 Trait Virtual Dispatch (Vtables)
// ============================================

trait Animal {
 fn speak(self) -> String;
 fn legs(self) -> i64;
}

struct Dog {
 name: String
}

impl Animal for Dog {
 fn speak(self) -> String {
 "woof"
 }
 fn legs(self) -> i64 {
 4
 }
}

struct Bird {
 species: String
}

impl Animal for Bird {
 fn speak(self) -> String {
 "chirp"
 }
 fn legs(self) -> i64 {
 2
 }
}

fn test_vtable_dispatch_single() -> i64 {
 let dog: Dog = Dog { name: "Rex" };
 let animal: &dyn Animal = &dog;
 let legs: i64 = animal.legs();
 if legs == 4 {
 print_string("vtable dispatch single: PASS\n");
 1
 } else {
 print_string("vtable dispatch single: FAIL\n");
 0
 }
}

fn test_vtable_dispatch_heterogeneous() -> i64 {
 let animals: Vec<Box<dyn Animal>> = vec![
 Box::new(Dog { name: "Rex" }),
 Box::new(Bird { species: "Sparrow" }),
 Box::new(Dog { name: "Max" })
 ];

 let total_legs: i64 = 0;
 for animal in animals {
 total_legs = total_legs + animal.legs();
 }
 // 4 + 2 + 4 = 10
 if total_legs == 10 {
 print_string("vtable heterogeneous: PASS\n");
 1
 } else {
 print_string("vtable heterogeneous: FAIL\n");
 0
 }
}

fn make_sound(animal: &dyn Animal) -> String {
 animal.speak()
}

fn test_vtable_as_parameter() -> i64 {
 let bird: Bird = Bird { species: "Robin" };
 let sound: String = make_sound(&bird);
 if sound == "chirp" {
 print_string("vtable as parameter: PASS\n");
 1
 } else {
 print_string("vtable as parameter: FAIL\n");
 0
 }
}

// ============================================
// 35.2.5 Monomorphization Complete
// ============================================

fn generic_identity<T>(x: T) -> T {
 x
}

fn generic_pair<T, U>(a: T, b: U) -> (T, U) {
 (a, b)
}

struct GenericBox<T> {
 value: T
}

impl<T> GenericBox<T> {
 fn new(v: T) -> GenericBox<T> {
 GenericBox { value: v }
 }

 fn get(self) -> T {
 self.value
 }

 fn map<U>(self, f: fn(T) -> U) -> GenericBox<U> {
 GenericBox { value: f(self.value) }
 }
}

fn test_monomorph_multiple_types() -> i64 {
 let a: i64 = generic_identity::<i64>(42);
 let b: String = generic_identity::<String>("hello");
 let c: bool = generic_identity::<bool>(true);

 if a == 42 && b == "hello" && c == true {
 print_string("monomorph multiple types: PASS\n");
 1
 } else {
 print_string("monomorph multiple types: FAIL\n");
 0
 }
}

fn test_monomorph_nested_generics() -> i64 {
 let opt: Option<Vec<i64>> = Some(vec![1, 2, 3]);
 let res: Result<Option<i64>, String> = Ok(Some(42));

 if opt.is_some() && res.is_ok() {
 print_string("monomorph nested generics: PASS\n");
 1
 } else {
 print_string("monomorph nested generics: FAIL\n");
 0
 }
}

fn test_monomorph_generic_struct_methods() -> i64 {
 let box_i64: GenericBox<i64> = GenericBox::new(10);
 let box_str: GenericBox<String> = GenericBox::new("test");

 let v1: i64 = box_i64.get();
 let v2: String = box_str.get();

 if v1 == 10 && v2 == "test" {
 print_string("monomorph generic struct methods: PASS\n");
 1
 } else {
 print_string("monomorph generic struct methods: FAIL\n");
 0
 }
}

// ============================================
// 35.2.6 Match Guard Codegen
// ============================================

fn classify_number(n: i64) -> String {
 match n {
 x if x < 0 => "negative",
 x if x == 0 => "zero",
 x if x > 0 && x < 10 => "small positive",
 x if x >= 10 && x < 100 => "medium positive",
 _ => "large positive"
 }
}

fn test_match_guard_all_branches() -> i64 {
 let r1: String = classify_number(-5);
 let r2: String = classify_number(0);
 let r3: String = classify_number(5);
 let r4: String = classify_number(50);
 let r5: String = classify_number(500);

 if r1 == "negative" && r2 == "zero" && r3 == "small positive"
 && r4 == "medium positive" && r5 == "large positive" {
 print_string("match guard all branches: PASS\n");
 1
 } else {
 print_string("match guard all branches: FAIL\n");
 0
 }
}

fn test_match_guard_with_binding() -> i64 {
 let opt: Option<i64> = Some(42);
 let result: i64 = match opt {
 Some(x) if x > 50 => 1,
 Some(x) if x > 20 => 2,
 Some(x) => 3,
 None => 0
 };
 if result == 2 { // 42 > 20 but not > 50
 print_string("match guard with binding: PASS\n");
 1
 } else {
 print_string("match guard with binding: FAIL\n");
 0
 }
}

// ============================================
// 35.2.7 Option<T> Method Codegen
// ============================================

fn test_option_is_some_none() -> i64 {
 let some_val: Option<i64> = Some(42);
 let none_val: Option<i64> = None;

 if some_val.is_some() && !some_val.is_none()
 && none_val.is_none() && !none_val.is_some() {
 print_string("option is_some/is_none: PASS\n");
 1
 } else {
 print_string("option is_some/is_none: FAIL\n");
 0
 }
}

fn test_option_unwrap() -> i64 {
 let opt: Option<i64> = Some(100);
 let val: i64 = opt.unwrap();
 if val == 100 {
 print_string("option unwrap: PASS\n");
 1
 } else {
 print_string("option unwrap: FAIL\n");
 0
 }
}

fn test_option_unwrap_or() -> i64 {
 let some_opt: Option<i64> = Some(50);
 let none_opt: Option<i64> = None;

 let v1: i64 = some_opt.unwrap_or(999);
 let v2: i64 = none_opt.unwrap_or(999);

 if v1 == 50 && v2 == 999 {
 print_string("option unwrap_or: PASS\n");
 1
 } else {
 print_string("option unwrap_or: FAIL\n");
 0
 }
}

fn test_option_map() -> i64 {
 let opt: Option<i64> = Some(10);
 let doubled: Option<i64> = opt.map(|x| x * 2);

 if doubled.unwrap() == 20 {
 print_string("option map: PASS\n");
 1
 } else {
 print_string("option map: FAIL\n");
 0
 }
}

fn test_option_and_then() -> i64 {
 fn safe_divide(a: i64, b: i64) -> Option<i64> {
 if b == 0 { None } else { Some(a / b) }
 }

 let result: Option<i64> = Some(100)
 .and_then(|x| safe_divide(x, 2))
 .and_then(|x| safe_divide(x, 5));

 if result.unwrap() == 10 {
 print_string("option and_then: PASS\n");
 1
 } else {
 print_string("option and_then: FAIL\n");
 0
 }
}

// ============================================
// 35.2.8 Result<T, E> Method Codegen
// ============================================

fn test_result_is_ok_err() -> i64 {
 let ok_val: Result<i64, String> = Ok(42);
 let err_val: Result<i64, String> = Err("error");

 if ok_val.is_ok() && !ok_val.is_err()
 && err_val.is_err() && !err_val.is_ok() {
 print_string("result is_ok/is_err: PASS\n");
 1
 } else {
 print_string("result is_ok/is_err: FAIL\n");
 0
 }
}

fn test_result_unwrap() -> i64 {
 let res: Result<i64, String> = Ok(77);
 let val: i64 = res.unwrap();
 if val == 77 {
 print_string("result unwrap: PASS\n");
 1
 } else {
 print_string("result unwrap: FAIL\n");
 0
 }
}

fn test_result_unwrap_or() -> i64 {
 let ok_res: Result<i64, String> = Ok(50);
 let err_res: Result<i64, String> = Err("oops");

 let v1: i64 = ok_res.unwrap_or(999);
 let v2: i64 = err_res.unwrap_or(999);

 if v1 == 50 && v2 == 999 {
 print_string("result unwrap_or: PASS\n");
 1
 } else {
 print_string("result unwrap_or: FAIL\n");
 0
 }
}

fn test_result_map() -> i64 {
 let res: Result<i64, String> = Ok(5);
 let mapped: Result<i64, String> = res.map(|x| x * 3);

 if mapped.unwrap() == 15 {
 print_string("result map: PASS\n");
 1
 } else {
 print_string("result map: FAIL\n");
 0
 }
}

fn test_result_and_then() -> i64 {
 fn parse_int(s: String) -> Result<i64, String> {
 if s == "42" { Ok(42) } else { Err("parse error") }
 }
 fn double(x: i64) -> Result<i64, String> {
 Ok(x * 2)
 }

 let result: Result<i64, String> = parse_int("42").and_then(double);

 if result.unwrap() == 84 {
 print_string("result and_then: PASS\n");
 1
 } else {
 print_string("result and_then: FAIL\n");
 0
 }
}

fn test_result_ok_err_conversion() -> i64 {
 let ok_res: Result<i64, String> = Ok(42);
 let err_res: Result<i64, String> = Err("error");

 let opt_ok: Option<i64> = ok_res.ok();
 let opt_err: Option<String> = err_res.err();

 if opt_ok.unwrap() == 42 && opt_err.unwrap() == "error" {
 print_string("result ok/err conversion: PASS\n");
 1
 } else {
 print_string("result ok/err conversion: FAIL\n");
 0
 }
}

// ============================================
// 35.2.9 Vec<T> Full Implementation
// ============================================

fn test_vec_new_push_len() -> i64 {
 let v: Vec<i64> = Vec::new();
 v.push(10);
 v.push(20);
 v.push(30);

 if v.len() == 3 {
 print_string("vec new/push/len: PASS\n");
 1
 } else {
 print_string("vec new/push/len: FAIL\n");
 0
 }
}

fn test_vec_pop() -> i64 {
 let v: Vec<i64> = vec![1, 2, 3];
 let last: Option<i64> = v.pop();
 let new_len: i64 = v.len();

 if last.unwrap() == 3 && new_len == 2 {
 print_string("vec pop: PASS\n");
 1
 } else {
 print_string("vec pop: FAIL\n");
 0
 }
}

fn test_vec_get() -> i64 {
 let v: Vec<i64> = vec![100, 200, 300];
 let item: Option<i64> = v.get(1);
 let oob: Option<i64> = v.get(10);

 if item.unwrap() == 200 && oob.is_none() {
 print_string("vec get: PASS\n");
 1
 } else {
 print_string("vec get: FAIL\n");
 0
 }
}

fn test_vec_index() -> i64 {
 let v: Vec<i64> = vec![5, 10, 15];
 let val: i64 = v[1];
 if val == 10 {
 print_string("vec index: PASS\n");
 1
 } else {
 print_string("vec index: FAIL\n");
 0
 }
}

fn test_vec_iter() -> i64 {
 let v: Vec<i64> = vec![1, 2, 3, 4];
 let sum: i64 = 0;
 for item in v.iter() {
 sum = sum + item;
 }
 if sum == 10 {
 print_string("vec iter: PASS\n");
 1
 } else {
 print_string("vec iter: FAIL\n");
 0
 }
}

fn test_vec_is_empty() -> i64 {
 let empty: Vec<i64> = Vec::new();
 let not_empty: Vec<i64> = vec![1];

 if empty.is_empty() && !not_empty.is_empty() {
 print_string("vec is_empty: PASS\n");
 1
 } else {
 print_string("vec is_empty: FAIL\n");
 0
 }
}

// ============================================
// 35.2.10 HashMap<K, V> Implementation
// ============================================

fn test_hashmap_insert_get() -> i64 {
 let m: HashMap<String, i64> = HashMap::new();
 m.insert("one", 1);
 m.insert("two", 2);
 m.insert("three", 3);

 let val: Option<i64> = m.get("two");
 if val.unwrap() == 2 {
 print_string("hashmap insert/get: PASS\n");
 1
 } else {
 print_string("hashmap insert/get: FAIL\n");
 0
 }
}

fn test_hashmap_contains_key() -> i64 {
 let m: HashMap<String, i64> = HashMap::new();
 m.insert("exists", 42);

 if m.contains_key("exists") && !m.contains_key("missing") {
 print_string("hashmap contains_key: PASS\n");
 1
 } else {
 print_string("hashmap contains_key: FAIL\n");
 0
 }
}

fn test_hashmap_remove() -> i64 {
 let m: HashMap<String, i64> = HashMap::new();
 m.insert("key", 100);
 let removed: Option<i64> = m.remove("key");

 if removed.unwrap() == 100 && !m.contains_key("key") {
 print_string("hashmap remove: PASS\n");
 1
 } else {
 print_string("hashmap remove: FAIL\n");
 0
 }
}

fn test_hashmap_len() -> i64 {
 let m: HashMap<String, i64> = HashMap::new();
 m.insert("a", 1);
 m.insert("b", 2);

 if m.len() == 2 && !m.is_empty() {
 print_string("hashmap len: PASS\n");
 1
 } else {
 print_string("hashmap len: FAIL\n");
 0
 }
}

// ============================================
// 35.2.11 String Type Full Implementation
// ============================================

fn test_string_new_from() -> i64 {
 let s1: String = String::new();
 let s2: String = String::from("hello");

 if s1.len() == 0 && s2.len() == 5 {
 print_string("string new/from: PASS\n");
 1
 } else {
 print_string("string new/from: FAIL\n");
 0
 }
}

fn test_string_push_str() -> i64 {
 let s: String = String::from("hello");
 s.push_str(" world");

 if s == "hello world" {
 print_string("string push_str: PASS\n");
 1
 } else {
 print_string("string push_str: FAIL\n");
 0
 }
}

fn test_string_concat() -> i64 {
 let a: String = "hello";
 let b: String = " ";
 let c: String = "world";
 let result: String = a + b + c;

 if result == "hello world" {
 print_string("string concat: PASS\n");
 1
 } else {
 print_string("string concat: FAIL\n");
 0
 }
}

fn test_string_chars() -> i64 {
 let s: String = "abc";
 let chars: Vec<char> = s.chars().collect();

 if chars.len() == 3 && chars[0] == 'a' && chars[1] == 'b' && chars[2] == 'c' {
 print_string("string chars: PASS\n");
 1
 } else {
 print_string("string chars: FAIL\n");
 0
 }
}

// ============================================
// 35.2.12 Iterator Protocol
// ============================================

fn test_iterator_map() -> i64 {
 let v: Vec<i64> = vec![1, 2, 3];
 let doubled: Vec<i64> = v.iter().map(|x| x * 2).collect();

 if doubled[0] == 2 && doubled[1] == 4 && doubled[2] == 6 {
 print_string("iterator map: PASS\n");
 1
 } else {
 print_string("iterator map: FAIL\n");
 0
 }
}

fn test_iterator_filter() -> i64 {
 let v: Vec<i64> = vec![1, 2, 3, 4, 5, 6];
 let evens: Vec<i64> = v.iter().filter(|x| x % 2 == 0).collect();

 if evens.len() == 3 && evens[0] == 2 && evens[1] == 4 && evens[2] == 6 {
 print_string("iterator filter: PASS\n");
 1
 } else {
 print_string("iterator filter: FAIL\n");
 0
 }
}

fn test_iterator_take() -> i64 {
 let v: Vec<i64> = vec![10, 20, 30, 40, 50];
 let first_three: Vec<i64> = v.iter().take(3).collect();

 if first_three.len() == 3 {
 print_string("iterator take: PASS\n");
 1
 } else {
 print_string("iterator take: FAIL\n");
 0
 }
}

fn test_iterator_chain() -> i64 {
 let v: Vec<i64> = vec![1, 2, 3, 4, 5];
 let result: i64 = v.iter()
 .filter(|x| x % 2 == 1) // [1, 3, 5]
 .map(|x| x * 10) // [10, 30, 50]
 .take(2) // [10, 30]
 .sum(); // 40

 if result == 40 {
 print_string("iterator chain: PASS\n");
 1
 } else {
 print_string("iterator chain: FAIL\n");
 0
 }
}

// ============================================
// 35.2.13 F-String Interpolation Codegen
// ============================================

fn test_fstring_basic() -> i64 {
 let name: String = "World";
 let s: String = f"Hello, {name}!";
 if s == "Hello, World!" {
 print_string("fstring basic: PASS\n");
 1
 } else {
 print_string("fstring basic: FAIL\n");
 0
 }
}

fn test_fstring_expression() -> i64 {
 let a: i64 = 10;
 let b: i64 = 20;
 let s: String = f"Sum: {a + b}";
 if s == "Sum: 30" {
 print_string("fstring expression: PASS\n");
 1
 } else {
 print_string("fstring expression: FAIL\n");
 0
 }
}

fn test_fstring_format_specifier() -> i64 {
 let x: i64 = 255;
 let hex: String = f"{x:x}";
 if hex == "ff" {
 print_string("fstring format specifier: PASS\n");
 1
 } else {
 print_string("fstring format specifier: FAIL\n");
 0
 }
}

// ============================================
// 35.2.14 Module Visibility Enforcement
// ============================================

mod visibility_test {
 fn private_fn() -> i64 { 42 }
 pub fn public_fn() -> i64 { private_fn() }

 struct PrivateStruct { value: i64 }
 pub struct PublicStruct {
 pub visible: i64,
 hidden: i64 // private field
 }
}

fn test_visibility_public_access() -> i64 {
 let result: i64 = visibility_test::public_fn();
 if result == 42 {
 print_string("visibility public access: PASS\n");
 1
 } else {
 print_string("visibility public access: FAIL\n");
 0
 }
}

// Note: test_visibility_private_access should FAIL to compile
// fn test_visibility_private_access() -> i64 {
// visibility_test::private_fn() // Should be compile error
// }

// ============================================
// 35.2.15-35.2.18 Async/Actor Infrastructure
// ============================================

fn test_pin_basic() -> i64 {
 let value: i64 = 42;
 let pinned: Pin<i64> = Pin::new(value);
 if pinned.get() == 42 {
 print_string("pin basic: PASS\n");
 1
 } else {
 print_string("pin basic: FAIL\n");
 0
 }
}

fn test_context_waker() -> i64 {
 let waker: Waker = Waker::noop();
 let cx: Context = Context::from_waker(&waker);
 // Just test that it compiles and runs
 print_string("context waker: PASS\n");
 1
}

actor CounterActor {
 count: i64,

 fn new() -> CounterActor {
 CounterActor { count: 0 }
 }

 fn increment(self, amount: i64) {
 self.count = self.count + amount;
 }

 fn get_count(self) -> i64 {
 self.count
 }
}

fn test_actor_message_dispatch() -> i64 {
 let counter: ActorRef<CounterActor> = spawn(CounterActor::new());
 counter.send(CounterMessage::Increment(10));
 counter.send(CounterMessage::Increment(5));
 let result: i64 = counter.call(CounterMessage::GetCount);

 if result == 15 {
 print_string("actor message dispatch: PASS\n");
 1
 } else {
 print_string("actor message dispatch: FAIL\n");
 0
 }
}

// ============================================
// Main test runner
// ============================================

fn main() -> i64 {
 print_string("=== Wave 2: Codegen Tests ===\n\n");

 let passed: i64 = 0;
 let total: i64 = 0;

 // Generator tests
 total = total + 1; passed = passed + test_generator_state_preservation();
 total = total + 1; passed = passed + test_generator_loop();
 total = total + 1; passed = passed + test_generator_completion();

 // Async tests
 total = total + 1; passed = passed + test_async_state_preservation();
 total = total + 1; passed = passed + test_async_nested_calls();
 total = total + 1; passed = passed + test_async_conditionals();

 // Closure tests
 total = total + 1; passed = passed + test_closure_capture_by_value();
 total = total + 1; passed = passed + test_closure_capture_mutable();
 total = total + 1; passed = passed + test_closure_nested_capture();

 // Vtable tests
 total = total + 1; passed = passed + test_vtable_dispatch_single();
 total = total + 1; passed = passed + test_vtable_dispatch_heterogeneous();
 total = total + 1; passed = passed + test_vtable_as_parameter();

 // Monomorphization tests
 total = total + 1; passed = passed + test_monomorph_multiple_types();
 total = total + 1; passed = passed + test_monomorph_nested_generics();
 total = total + 1; passed = passed + test_monomorph_generic_struct_methods();

 // Match guard tests
 total = total + 1; passed = passed + test_match_guard_all_branches();
 total = total + 1; passed = passed + test_match_guard_with_binding();

 // Option tests
 total = total + 1; passed = passed + test_option_is_some_none();
 total = total + 1; passed = passed + test_option_unwrap();
 total = total + 1; passed = passed + test_option_unwrap_or();
 total = total + 1; passed = passed + test_option_map();
 total = total + 1; passed = passed + test_option_and_then();

 // Result tests
 total = total + 1; passed = passed + test_result_is_ok_err();
 total = total + 1; passed = passed + test_result_unwrap();
 total = total + 1; passed = passed + test_result_unwrap_or();
 total = total + 1; passed = passed + test_result_map();
 total = total + 1; passed = passed + test_result_and_then();
 total = total + 1; passed = passed + test_result_ok_err_conversion();

 // Vec tests
 total = total + 1; passed = passed + test_vec_new_push_len();
 total = total + 1; passed = passed + test_vec_pop();
 total = total + 1; passed = passed + test_vec_get();
 total = total + 1; passed = passed + test_vec_index();
 total = total + 1; passed = passed + test_vec_iter();
 total = total + 1; passed = passed + test_vec_is_empty();

 // HashMap tests
 total = total + 1; passed = passed + test_hashmap_insert_get();
 total = total + 1; passed = passed + test_hashmap_contains_key();
 total = total + 1; passed = passed + test_hashmap_remove();
 total = total + 1; passed = passed + test_hashmap_len();

 // String tests
 total = total + 1; passed = passed + test_string_new_from();
 total = total + 1; passed = passed + test_string_push_str();
 total = total + 1; passed = passed + test_string_concat();
 total = total + 1; passed = passed + test_string_chars();

 // Iterator tests
 total = total + 1; passed = passed + test_iterator_map();
 total = total + 1; passed = passed + test_iterator_filter();
 total = total + 1; passed = passed + test_iterator_take();
 total = total + 1; passed = passed + test_iterator_chain();

 // F-string tests
 total = total + 1; passed = passed + test_fstring_basic();
 total = total + 1; passed = passed + test_fstring_expression();
 total = total + 1; passed = passed + test_fstring_format_specifier();

 // Visibility tests
 total = total + 1; passed = passed + test_visibility_public_access();

 // Async infrastructure tests
 total = total + 1; passed = passed + test_pin_basic();
 total = total + 1; passed = passed + test_context_waker();
 total = total + 1; passed = passed + test_actor_message_dispatch();

 print_string("\n=== Summary ===\n");
 print_string("Passed: ");
 print_i64(passed);
 print_string(" / ");
 print_i64(total);
 print_string("\n");

 if passed == total { 0 } else { 1 }
}
