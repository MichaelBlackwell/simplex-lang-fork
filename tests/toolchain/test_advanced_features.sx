// Phase 34 Validation: Advanced Language Features
// Tests: 34.2.1 Generators, 34.2.2 F-strings, 34.2.3 Trait Dispatch, 34.2.4 Vector, 34.2.5 Tensor

// ============================================
// 34.2.1 Streaming/Generators
// ============================================

fn* number_generator() -> Stream<i64> {
    yield 1;
    yield 2;
    yield 3;
}

fn test_generator_basic() -> i64 {
    let gen: Stream<i64> = number_generator();
    let sum: i64 = 0;
    for n in gen {
        sum = sum + n;
    }
    sum  // Expected: 6
}

fn* fibonacci() -> Stream<i64> {
    let a: i64 = 0;
    let b: i64 = 1;
    loop {
        yield a;
        let temp: i64 = a + b;
        a = b;
        b = temp;
    }
}

fn test_generator_infinite() -> i64 {
    let fib: Stream<i64> = fibonacci();
    let count: i64 = 0;
    let last: i64 = 0;
    for n in fib {
        last = n;
        count = count + 1;
        if count >= 10 {
            break;
        }
    }
    last  // Expected: 34 (10th fibonacci)
}

// ============================================
// 34.2.2 String Interpolation (f-strings)
// ============================================

fn test_fstring_basic() -> i64 {
    let name: String = "World";
    let msg: String = f"Hello {name}!";
    print_string(msg);
    print_string("\n");
    1  // Just verify it compiles and runs
}

fn test_fstring_expression() -> i64 {
    let x: i64 = 5;
    let y: i64 = 3;
    let msg: String = f"Sum: {x + y}";
    print_string(msg);
    print_string("\n");
    1
}

fn test_fstring_format_spec() -> i64 {
    let pi: f64 = 3.14159;
    let msg: String = f"Pi is {pi:.2f}";
    print_string(msg);
    print_string("\n");
    1
}

// ============================================
// 34.2.3 Trait Method Dispatch
// ============================================

trait Printable {
    fn print_value(self) -> i64;
    fn default_method(self) -> i64 {
        42  // Default implementation
    }
}

struct Number {
    value: i64
}

impl Printable for Number {
    fn print_value(self) -> i64 {
        print_i64(self.value);
        self.value
    }
}

fn test_trait_dispatch() -> i64 {
    let n: Number = Number { value: 100 };
    n.print_value()  // Expected: 100
}

fn test_trait_default_method() -> i64 {
    let n: Number = Number { value: 50 };
    n.default_method()  // Expected: 42
}

fn print_any(item: dyn Printable) -> i64 {
    item.print_value()
}

fn test_dyn_trait() -> i64 {
    let n: Number = Number { value: 77 };
    print_any(n)  // Expected: 77 via vtable
}

// Trait bounds on generics
fn print_generic<T: Printable>(item: T) -> i64 {
    item.print_value()
}

fn test_trait_bound() -> i64 {
    let n: Number = Number { value: 99 };
    print_generic(n)  // Expected: 99
}

// Associated types
trait Container {
    type Item;
    fn get(self) -> Self::Item;
}

struct IntBox {
    value: i64
}

impl Container for IntBox {
    type Item = i64;
    fn get(self) -> i64 {
        self.value
    }
}

fn test_associated_type() -> i64 {
    let box: IntBox = IntBox { value: 123 };
    box.get()  // Expected: 123
}

// ============================================
// 34.2.4 Vector<T, N> Fixed-Size Type
// ============================================

fn test_vector_type() -> i64 {
    let v: Vector<f64, 3> = Vector { x: 1.0, y: 2.0, z: 3.0 };
    // Dot product with itself
    let dot: f64 = v.dot(v);
    // 1 + 4 + 9 = 14
    14
}

fn test_vector_normalize() -> i64 {
    let v: Vector<f64, 2> = Vector { x: 3.0, y: 4.0 };
    let n: Vector<f64, 2> = v.normalize();
    // |v| = 5, so n.x = 0.6, n.y = 0.8
    1
}

// ============================================
// 34.2.5 Tensor<T> Type
// ============================================

fn test_tensor_create() -> i64 {
    let t: Tensor<f64> = Tensor::zeros([2, 3, 4]);  // 2x3x4 tensor
    t.shape()[0]  // Expected: 2
}

fn test_tensor_reshape() -> i64 {
    let t: Tensor<f64> = Tensor::ones([6]);
    let t2: Tensor<f64> = t.reshape([2, 3]);
    t2.shape()[0] * t2.shape()[1]  // Expected: 6
}

fn test_tensor_broadcast() -> i64 {
    let a: Tensor<f64> = Tensor::ones([3, 1]);
    let b: Tensor<f64> = Tensor::ones([1, 4]);
    let c: Tensor<f64> = a + b;  // Broadcasts to [3, 4]
    c.shape()[0] * c.shape()[1]  // Expected: 12
}

// ============================================
// Main test runner
// ============================================

fn main() -> i64 {
    print_string("=== Advanced Features Tests ===\n");

    // Generators
    print_string("Test generator_basic: ");
    let r1: i64 = test_generator_basic();
    print_i64(r1);
    print_string(" (expected 6)\n");

    // F-strings
    print_string("Test fstring_basic: ");
    let r2: i64 = test_fstring_basic();
    print_string("OK\n");

    // Trait dispatch
    print_string("Test trait_dispatch: ");
    let r3: i64 = test_trait_dispatch();
    print_i64(r3);
    print_string(" (expected 100)\n");

    print_string("Test trait_default_method: ");
    let r4: i64 = test_trait_default_method();
    print_i64(r4);
    print_string(" (expected 42)\n");

    print_string("Test dyn_trait: ");
    let r5: i64 = test_dyn_trait();
    print_i64(r5);
    print_string(" (expected 77)\n");

    // Vector/Tensor tests
    print_string("Test vector_type: ");
    let r6: i64 = test_vector_type();
    print_i64(r6);
    print_string(" (expected 14)\n");

    0
}
