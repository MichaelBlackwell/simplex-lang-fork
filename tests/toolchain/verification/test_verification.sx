// Phase 34 Validation: Verification Gaps (Section 34.12)
// Runtime verification tests to confirm features work as documented

// ============================================
// 34.12.1 spx build works with dependencies
// ============================================

fn test_spx_build_basic() -> i64 {
    // Create a test project structure
    let project: TestProject = TestProject::new("test_project");

    // Write spx.toml
    project.write_file("spx.toml", r#"
        [package]
        name = "test_project"
        version = "0.1.0"

        [dependencies]
    "#);

    // Write main.sx
    project.write_file("src/main.sx", r#"
        fn main() -> i64 {
            print_string("Hello from test project\n");
            0
        }
    "#);

    // Run spx build
    let result: BuildResult = spx_build(project.path());

    if result.success {
        print_string("spx build basic: PASS\n");
        1
    } else {
        print_string("spx build basic: FAIL - ");
        print_string(result.error);
        print_string("\n");
        0
    }
}

fn test_spx_build_with_local_dep() -> i64 {
    // Create main project
    let main_proj: TestProject = TestProject::new("main_proj");

    // Create dependency project
    let dep_proj: TestProject = TestProject::new("dep_proj");

    dep_proj.write_file("spx.toml", r#"
        [package]
        name = "dep_proj"
        version = "0.1.0"
    "#);

    dep_proj.write_file("src/lib.sx", r#"
        pub fn helper() -> i64 {
            42
        }
    "#);

    main_proj.write_file("spx.toml", r#"
        [package]
        name = "main_proj"
        version = "0.1.0"

        [dependencies]
        dep_proj = { path = "../dep_proj" }
    "#);

    main_proj.write_file("src/main.sx", r#"
        use dep_proj::helper;

        fn main() -> i64 {
            helper()
        }
    "#);

    // Build main project
    let result: BuildResult = spx_build(main_proj.path());

    if result.success {
        // Run the built binary
        let run_result: RunResult = run_binary(result.output_path);
        if run_result.exit_code == 42 {
            print_string("spx build with local dep: PASS\n");
            return 1;
        }
    }

    print_string("spx build with local dep: FAIL\n");
    0
}

fn test_spx_build_with_multiple_deps() -> i64 {
    let proj: TestProject = TestProject::new("multi_dep_proj");

    proj.write_file("spx.toml", r#"
        [package]
        name = "multi_dep_proj"
        version = "0.1.0"

        [dependencies]
        simplex-json = "0.1"
        simplex-http = "0.1"
    "#);

    proj.write_file("src/main.sx", r#"
        use simplex_json::parse;
        use simplex_http::Client;

        fn main() -> i64 {
            0
        }
    "#);

    let result: BuildResult = spx_build(proj.path());

    if result.success {
        print_string("spx build with multiple deps: PASS\n");
        1
    } else {
        print_string("spx build with multiple deps: FAIL - ");
        print_string(result.error);
        print_string("\n");
        0
    }
}

// ============================================
// 34.12.2 Async actually runs asynchronously
// ============================================

fn test_async_concurrent_execution() -> i64 {
    // This test verifies that async functions run concurrently,
    // not sequentially

    let start: i64 = time_ms();

    // Two async tasks that each sleep for 100ms
    async fn task1() -> i64 {
        async_sleep(100).await;
        1
    }

    async fn task2() -> i64 {
        async_sleep(100).await;
        2
    }

    // Run both concurrently
    let results: (i64, i64) = async_join(task1(), task2()).await;

    let elapsed: i64 = time_ms() - start;

    // If truly concurrent, should take ~100ms, not ~200ms
    if elapsed < 150 {
        print_string("async concurrent execution: PASS (");
        print_i64(elapsed);
        print_string("ms)\n");
        1
    } else {
        print_string("async concurrent execution: FAIL - took ");
        print_i64(elapsed);
        print_string("ms (expected <150ms)\n");
        0
    }
}

fn test_async_io_nonblocking() -> i64 {
    let start: i64 = time_ms();

    async fn fetch_url(url: String) -> String {
        http_get(url).await
    }

    // Initiate multiple requests
    let f1: Future<String> = fetch_url("http://example.com/1");
    let f2: Future<String> = fetch_url("http://example.com/2");
    let f3: Future<String> = fetch_url("http://example.com/3");

    // Wait for all
    let (r1, r2, r3): (String, String, String) = async_join3(f1, f2, f3).await;

    let elapsed: i64 = time_ms() - start;

    // Three sequential requests would take 3x single request time
    // Concurrent should be roughly 1x
    if r1.len() > 0 && r2.len() > 0 && r3.len() > 0 {
        print_string("async IO nonblocking: PASS (");
        print_i64(elapsed);
        print_string("ms for 3 requests)\n");
        1
    } else {
        print_string("async IO nonblocking: FAIL\n");
        0
    }
}

fn test_async_state_machine() -> i64 {
    // Verify state is preserved across await points

    async fn stateful_task() -> i64 {
        let a: i64 = 10;
        async_sleep(10).await;  // Suspend point 1

        let b: i64 = a + 20;    // a should be preserved
        async_sleep(10).await;  // Suspend point 2

        let c: i64 = b + 30;    // b should be preserved
        c
    }

    let result: i64 = stateful_task().await;

    if result == 60 {
        print_string("async state machine: PASS\n");
        1
    } else {
        print_string("async state machine: FAIL - got ");
        print_i64(result);
        print_string(" expected 60\n");
        0
    }
}

// ============================================
// 34.12.3 Actors actually run concurrently
// ============================================

fn test_actors_parallel_processing() -> i64 {
    let start: i64 = time_ms();

    // Create counter to track message processing
    let counter: AtomicI64 = AtomicI64::new(0);

    // Actor that simulates work
    actor WorkerActor {
        fn handle_work(self, duration: i64) -> i64 {
            sleep_ms(duration);
            counter.fetch_add(1);
            duration
        }
    }

    // Spawn multiple actors
    let actor1: ActorRef<WorkerActor> = spawn(WorkerActor::new());
    let actor2: ActorRef<WorkerActor> = spawn(WorkerActor::new());
    let actor3: ActorRef<WorkerActor> = spawn(WorkerActor::new());

    // Send work to each (100ms each)
    actor1.send(WorkMessage::Work(100));
    actor2.send(WorkMessage::Work(100));
    actor3.send(WorkMessage::Work(100));

    // Wait for all to complete
    actor1.wait_idle();
    actor2.wait_idle();
    actor3.wait_idle();

    let elapsed: i64 = time_ms() - start;

    // If truly concurrent, ~100ms total, not 300ms
    if elapsed < 200 && counter.load() == 3 {
        print_string("actors parallel processing: PASS (");
        print_i64(elapsed);
        print_string("ms)\n");
        1
    } else {
        print_string("actors parallel processing: FAIL - ");
        print_i64(elapsed);
        print_string("ms, processed ");
        print_i64(counter.load());
        print_string("\n");
        0
    }
}

fn test_actors_message_ordering() -> i64 {
    // Messages to same actor should be processed in order

    let log: Vec<i64> = Vec::new();

    actor OrderedActor {
        fn handle_msg(self, val: i64) {
            log.push(val);
        }
    }

    let actor: ActorRef<OrderedActor> = spawn(OrderedActor::new());

    // Send messages in order
    for i in 0..10 {
        actor.send(OrderMessage::Msg(i));
    }

    actor.wait_idle();

    // Verify order
    let ordered: bool = true;
    for i in 0..10 {
        if log[i] != i {
            ordered = false;
            break;
        }
    }

    if ordered {
        print_string("actors message ordering: PASS\n");
        1
    } else {
        print_string("actors message ordering: FAIL\n");
        0
    }
}

fn test_actors_isolation() -> i64 {
    // Actor state should be isolated

    actor CounterActor {
        count: i64,

        fn new() -> CounterActor {
            CounterActor { count: 0 }
        }

        fn increment(self) {
            self.count = self.count + 1;
        }

        fn get_count(self) -> i64 {
            self.count
        }
    }

    let actor1: ActorRef<CounterActor> = spawn(CounterActor::new());
    let actor2: ActorRef<CounterActor> = spawn(CounterActor::new());

    // Increment actor1 multiple times
    for i in 0..5 {
        actor1.send(CounterMessage::Increment);
    }

    // Increment actor2 fewer times
    for i in 0..2 {
        actor2.send(CounterMessage::Increment);
    }

    actor1.wait_idle();
    actor2.wait_idle();

    let count1: i64 = actor1.call(CounterMessage::GetCount);
    let count2: i64 = actor2.call(CounterMessage::GetCount);

    if count1 == 5 && count2 == 2 {
        print_string("actors isolation: PASS\n");
        1
    } else {
        print_string("actors isolation: FAIL - count1=");
        print_i64(count1);
        print_string(", count2=");
        print_i64(count2);
        print_string("\n");
        0
    }
}

// ============================================
// 34.12.4 Distribution actually works across nodes
// ============================================

fn test_distributed_actor_spawn() -> i64 {
    // Start two nodes
    let node1: Node = Node::start("127.0.0.1:9001");
    let node2: Node = Node::start("127.0.0.1:9002");

    // Connect nodes
    node1.connect_to("127.0.0.1:9002");

    // Spawn actor on remote node
    actor RemoteActor {
        fn ping(self) -> String {
            "pong"
        }
    }

    let remote: ActorRef<RemoteActor> = node1.spawn_on("127.0.0.1:9002", RemoteActor::new());

    // Call remote actor
    let response: String = remote.call(RemoteMessage::Ping);

    node1.stop();
    node2.stop();

    if response == "pong" {
        print_string("distributed actor spawn: PASS\n");
        1
    } else {
        print_string("distributed actor spawn: FAIL\n");
        0
    }
}

fn test_distributed_message_passing() -> i64 {
    let node1: Node = Node::start("127.0.0.1:9003");
    let node2: Node = Node::start("127.0.0.1:9004");

    node1.connect_to("127.0.0.1:9004");

    // Actor on node2
    actor EchoActor {
        fn echo(self, msg: String) -> String {
            format!("Echo: {}", msg)
        }
    }

    // Spawn on node2, get reference on node1
    let echo: ActorRef<EchoActor> = node1.spawn_on("127.0.0.1:9004", EchoActor::new());

    // Send message from node1 to actor on node2
    let result: String = echo.call(EchoMessage::Echo("Hello distributed!"));

    node1.stop();
    node2.stop();

    if result == "Echo: Hello distributed!" {
        print_string("distributed message passing: PASS\n");
        1
    } else {
        print_string("distributed message passing: FAIL - got: ");
        print_string(result);
        print_string("\n");
        0
    }
}

fn test_distributed_node_failure() -> i64 {
    let node1: Node = Node::start("127.0.0.1:9005");
    let node2: Node = Node::start("127.0.0.1:9006");
    let node3: Node = Node::start("127.0.0.1:9007");

    // Form cluster
    node1.join_cluster(vec!["127.0.0.1:9006", "127.0.0.1:9007"]);

    // Verify all nodes see each other
    let members: Vec<String> = node1.get_cluster_members();
    if members.len() != 3 {
        print_string("distributed node failure: FAIL - initial cluster size wrong\n");
        return 0;
    }

    // Kill node2
    node2.stop();

    // Wait for failure detection
    sleep_ms(1000);

    // Remaining nodes should detect failure
    let members_after: Vec<String> = node1.get_cluster_members();

    node1.stop();
    node3.stop();

    if members_after.len() == 2 {
        print_string("distributed node failure: PASS\n");
        1
    } else {
        print_string("distributed node failure: FAIL - expected 2 members, got ");
        print_i64(members_after.len());
        print_string("\n");
        0
    }
}

fn test_distributed_actor_migration() -> i64 {
    let node1: Node = Node::start("127.0.0.1:9008");
    let node2: Node = Node::start("127.0.0.1:9009");

    node1.connect_to("127.0.0.1:9009");

    // Stateful actor
    actor StatefulActor {
        value: i64,

        fn new(v: i64) -> StatefulActor {
            StatefulActor { value: v }
        }

        fn get(self) -> i64 {
            self.value
        }

        fn set(self, v: i64) {
            self.value = v;
        }
    }

    // Spawn on node1
    let actor: ActorRef<StatefulActor> = node1.spawn(StatefulActor::new(100));

    // Set value
    actor.send(StatefulMessage::Set(200));
    actor.wait_idle();

    // Migrate to node2
    let migrated: ActorRef<StatefulActor> = node1.migrate_to(actor, "127.0.0.1:9009");

    // Value should be preserved
    let value: i64 = migrated.call(StatefulMessage::Get);

    node1.stop();
    node2.stop();

    if value == 200 {
        print_string("distributed actor migration: PASS\n");
        1
    } else {
        print_string("distributed actor migration: FAIL - value=");
        print_i64(value);
        print_string("\n");
        0
    }
}

// ============================================
// Main test runner
// ============================================

fn main() -> i64 {
    print_string("=== Verification Tests (34.12) ===\n");

    let passed: i64 = 0;
    let total: i64 = 0;

    // 34.12.1 spx build
    print_string("\n--- spx build verification ---\n");

    total = total + 1;
    passed = passed + test_spx_build_basic();

    total = total + 1;
    passed = passed + test_spx_build_with_local_dep();

    total = total + 1;
    passed = passed + test_spx_build_with_multiple_deps();

    // 34.12.2 Async verification
    print_string("\n--- Async verification ---\n");

    total = total + 1;
    passed = passed + test_async_concurrent_execution();

    total = total + 1;
    passed = passed + test_async_io_nonblocking();

    total = total + 1;
    passed = passed + test_async_state_machine();

    // 34.12.3 Actor verification
    print_string("\n--- Actor verification ---\n");

    total = total + 1;
    passed = passed + test_actors_parallel_processing();

    total = total + 1;
    passed = passed + test_actors_message_ordering();

    total = total + 1;
    passed = passed + test_actors_isolation();

    // 34.12.4 Distribution verification
    print_string("\n--- Distribution verification ---\n");

    total = total + 1;
    passed = passed + test_distributed_actor_spawn();

    total = total + 1;
    passed = passed + test_distributed_message_passing();

    total = total + 1;
    passed = passed + test_distributed_node_failure();

    total = total + 1;
    passed = passed + test_distributed_actor_migration();

    // Summary
    print_string("\n=== Summary ===\n");
    print_string("Passed: ");
    print_i64(passed);
    print_string(" / ");
    print_i64(total);
    print_string("\n");

    if passed == total {
        print_string("All verification tests PASSED!\n");
        0
    } else {
        print_string("Some verification tests FAILED.\n");
        1
    }
}
