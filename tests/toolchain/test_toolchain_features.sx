// Phase 35 Wave 4: Toolchain Tests
// Tests for sxc, spx, sxdoc, sxlsp, sxfmt, and other tools

// =============================================================================
// 35.4.1 sxc test Command
// =============================================================================

mod test_sxc_test {
    // Test discovery from source files
    #[test]
    fn test_discovery_basic() {
        // sxc test should find this test
        assert_eq!(1 + 1, 2);
    }

    #[test]
    fn test_discovery_nested_module() {
        // Tests in nested modules should be discovered
        assert!(true);
    }

    // Test filtering by name pattern
    #[test]
    fn test_filter_pattern_match() {
        // Running: sxc test --filter "pattern" should find this
        let pattern = "test_filter";
        assert!(pattern.starts_with("test_"));
    }

    // Parallel test execution
    #[test]
    fn test_parallel_execution_1() {
        // This test should run in parallel with others
        let result = heavy_computation(100);
        assert!(result > 0);
    }

    #[test]
    fn test_parallel_execution_2() {
        // This test should run in parallel with test_parallel_execution_1
        let result = heavy_computation(200);
        assert!(result > 100);
    }

    fn heavy_computation(n: i64) -> i64 {
        let mut sum: i64 = 0;
        for i in 0..n {
            sum = sum + i;
        }
        sum
    }

    // Test result summary
    #[test]
    fn test_result_summary() {
        // After all tests, sxc test should show:
        // - Total tests run
        // - Passed count
        // - Failed count
        // - Duration
        assert!(true);
    }

    // Integration with #[test] attributes
    #[test]
    #[should_panic]
    fn test_should_panic_attribute() {
        panic!("This test expects a panic");
    }

    #[test]
    #[ignore]
    fn test_ignore_attribute() {
        // This test should be skipped unless --include-ignored
        assert!(false, "Should not run");
    }

    #[test]
    #[timeout(1000)]
    fn test_timeout_attribute() {
        // Test should fail if it takes more than 1000ms
        assert!(true);
    }
}

// =============================================================================
// 35.4.2 sxc watch Mode
// =============================================================================

mod test_sxc_watch {
    use std::fs;
    use std::time;

    // File system watcher test
    #[test]
    fn test_file_watch_detection() {
        // Create a test file
        let path = "/tmp/watch_test.sx";
        fs::write(path, "fn test() {}");

        // Start watch in background (simulated)
        let watcher = file_watcher_new(path);

        // Modify the file
        time::sleep_ms(100);
        fs::write(path, "fn test() { let x = 1; }");

        // Check that change was detected
        assert!(watcher.has_changes());

        // Cleanup
        fs::remove(path);
    }

    // Incremental recompilation test
    #[test]
    fn test_incremental_recompile() {
        // Modify a single file
        let project = test_project_new();
        project.add_file("main.sx", "fn main() {}");
        project.add_file("lib.sx", "fn helper() -> i64 { 42 }");

        // Initial build
        let build1 = project.build();
        assert!(build1.success);

        // Modify only lib.sx
        project.update_file("lib.sx", "fn helper() -> i64 { 100 }");

        // Incremental build should only rebuild lib.sx
        let build2 = project.build_incremental();
        assert!(build2.success);
        assert_eq!(build2.files_compiled, 1); // Only lib.sx
    }

    // Error reporting on change
    #[test]
    fn test_error_on_change() {
        let project = test_project_new();
        project.add_file("main.sx", "fn main() {}");

        // Introduce error
        project.update_file("main.sx", "fn main( {}"); // Syntax error

        // Watch should report error
        let errors = project.check();
        assert!(errors.len() > 0);
        assert!(errors[0].message.contains("Expected"));
    }

    // Hot reload support
    #[test]
    fn test_hot_reload() {
        // Start application
        let app = app_start();
        let initial_value = app.call_fn("get_value");
        assert_eq!(initial_value, 42);

        // Update source while running
        app.update_source("fn get_value() -> i64 { 100 }");
        app.hot_reload();

        // New value should be used
        let new_value = app.call_fn("get_value");
        assert_eq!(new_value, 100);
    }
}

// =============================================================================
// 35.4.3 spx Package Manager - Registry
// =============================================================================

mod test_spx_registry {
    use spx::registry;

    // Registry client (fetch packages)
    #[test]
    fn test_fetch_package() {
        let client = registry::client_new("https://registry.simplex-lang.org");

        // Fetch a package
        let pkg = client.fetch("simplex-json", "1.0.0");
        assert!(pkg.is_ok());

        let package = pkg.unwrap();
        assert_eq!(package.name, "simplex-json");
        assert_eq!(package.version, "1.0.0");
    }

    // Package search
    #[test]
    fn test_search_packages() {
        let client = registry::client_new("https://registry.simplex-lang.org");

        // Search for packages matching query
        let results = client.search("json");
        assert!(results.len() > 0);

        // Results should contain relevant packages
        let names: Vec<String> = results.iter().map(|p| p.name.clone()).collect();
        assert!(names.contains(&"simplex-json".to_string()));
    }

    // Version resolution (semver)
    #[test]
    fn test_version_resolution() {
        let client = registry::client_new("https://registry.simplex-lang.org");

        // Resolve version constraint "^1.0.0"
        let resolved = client.resolve_version("simplex-json", "^1.0.0");
        assert!(resolved.is_ok());

        let version = resolved.unwrap();
        assert!(version.starts_with("1.")); // Compatible with 1.x.x
    }

    // Dependency tree building
    #[test]
    fn test_dependency_tree() {
        let client = registry::client_new("https://registry.simplex-lang.org");

        // Build dependency tree for a package
        let tree = client.build_dep_tree("my-app", "1.0.0");
        assert!(tree.is_ok());

        let deps = tree.unwrap();
        // Verify tree structure
        assert!(deps.root.name == "my-app");
        assert!(deps.root.dependencies.len() >= 0);
    }
}

// =============================================================================
// 35.4.4 spx Package Manager - Lockfile
// =============================================================================

mod test_spx_lockfile {
    use spx::lockfile;
    use std::fs;

    // Generate spx.lock
    #[test]
    fn test_generate_lockfile() {
        let project = project_new();
        project.add_dependency("simplex-json", "^1.0.0");
        project.add_dependency("simplex-http", "^2.0.0");

        // Generate lockfile
        let lockfile = lockfile::generate(&project);
        assert!(lockfile.is_ok());

        // Verify lockfile contents
        let lock = lockfile.unwrap();
        assert!(lock.packages.len() >= 2);

        // Each package should have exact version
        for pkg in &lock.packages {
            assert!(!pkg.version.contains("^"));
            assert!(!pkg.version.contains("~"));
        }
    }

    // Reproducible builds from lock
    #[test]
    fn test_reproducible_build() {
        // Load existing lockfile
        let lock_content = fs::read_to_string("spx.lock").unwrap();
        let lock = lockfile::parse(&lock_content).unwrap();

        // Build should use exact versions from lock
        let build1 = build_with_lock(&lock);
        let build2 = build_with_lock(&lock);

        // Outputs should be identical
        assert_eq!(build1.hash, build2.hash);
    }

    // Lock file updating
    #[test]
    fn test_update_lockfile() {
        let project = project_new();
        project.add_dependency("simplex-json", "^1.0.0");

        // Generate initial lockfile
        let lock1 = lockfile::generate(&project).unwrap();
        let json_v1 = lock1.get_version("simplex-json");

        // Update dependency to newer constraint
        project.update_dependency("simplex-json", "^1.5.0");

        // Update lockfile
        let lock2 = lockfile::update(&lock1, &project).unwrap();
        let json_v2 = lock2.get_version("simplex-json");

        // Version should be updated
        assert!(json_v2 >= "1.5.0");
    }

    // Conflict resolution
    #[test]
    fn test_conflict_resolution() {
        let project = project_new();

        // Add two dependencies that depend on different versions of same package
        project.add_dependency("pkg-a", "1.0.0"); // depends on utils ^1.0.0
        project.add_dependency("pkg-b", "1.0.0"); // depends on utils ^2.0.0

        // Should detect conflict
        let result = lockfile::generate(&project);

        if result.is_err() {
            // Conflict detected - verify error message
            let error = result.unwrap_err();
            assert!(error.message.contains("conflict") || error.message.contains("incompatible"));
        } else {
            // Resolution found - verify both deps satisfied
            let lock = result.unwrap();
            assert!(lock.packages.iter().any(|p| p.name == "utils"));
        }
    }
}

// =============================================================================
// 35.4.5 spx Package Manager - Publishing
// =============================================================================

mod test_spx_publishing {
    use spx::publish;

    // Package validation
    #[test]
    fn test_package_validation() {
        let project = project_new();
        project.set_name("my-package");
        project.set_version("1.0.0");
        project.add_file("src/lib.sx", "pub fn hello() {}");

        // Validate before publish
        let validation = publish::validate(&project);
        assert!(validation.is_ok());
    }

    #[test]
    fn test_package_validation_missing_fields() {
        let project = project_new();
        // Missing name and version

        let validation = publish::validate(&project);
        assert!(validation.is_err());

        let errors = validation.unwrap_err();
        assert!(errors.iter().any(|e| e.contains("name")));
        assert!(errors.iter().any(|e| e.contains("version")));
    }

    // Registry upload (simulated)
    #[test]
    fn test_registry_upload() {
        let project = valid_project_new();

        // Mock registry for testing
        let registry = mock_registry_new();

        // Upload package
        let result = publish::upload(&project, &registry);
        assert!(result.is_ok());

        // Verify package is now available
        assert!(registry.has_package("my-package", "1.0.0"));
    }

    // Version tagging
    #[test]
    fn test_version_tagging() {
        let project = valid_project_new();
        project.set_version("1.2.3");

        // Publish should create git tag
        let result = publish::publish(&project);
        assert!(result.is_ok());

        // Check git tag exists
        let tags = git_list_tags();
        assert!(tags.contains(&"v1.2.3".to_string()));
    }

    // Yank support
    #[test]
    fn test_yank_version() {
        let registry = registry_client_new();

        // Publish a version
        let project = valid_project_new();
        project.set_version("1.0.0-bad");
        publish::upload(&project, &registry);

        // Yank the version
        let result = registry.yank("my-package", "1.0.0-bad");
        assert!(result.is_ok());

        // Yanked version should not be resolved
        let resolved = registry.resolve_version("my-package", "^1.0.0");
        assert!(resolved.unwrap() != "1.0.0-bad");
    }
}

// =============================================================================
// 35.4.6 sxdoc Documentation Generator
// =============================================================================

mod test_sxdoc {
    use sxdoc;

    // Doc comment parsing
    /// This is a documented function.
    /// It returns the sum of two numbers.
    pub fn documented_add(a: i64, b: i64) -> i64 {
        a + b
    }

    /**
     * Multi-line doc comment style.
     *
     * # Arguments
     * * `x` - The input value
     *
     * # Returns
     * The doubled value
     */
    pub fn documented_double(x: i64) -> i64 {
        x * 2
    }

    #[test]
    fn test_doc_comment_parsing() {
        let docs = sxdoc::parse_file("test_35_4_toolchain.sx");

        // Find documented_add docs
        let add_doc = docs.get_function_doc("documented_add");
        assert!(add_doc.is_some());
        assert!(add_doc.unwrap().contains("sum of two numbers"));
    }

    // Markdown rendering
    #[test]
    fn test_markdown_rendering() {
        let markdown = "# Header\n\nSome **bold** text.";
        let html = sxdoc::render_markdown(markdown);

        assert!(html.contains("<h1>Header</h1>"));
        assert!(html.contains("<strong>bold</strong>"));
    }

    // Cross-reference links
    /// See also [documented_add] for addition.
    pub fn documented_subtract(a: i64, b: i64) -> i64 {
        a - b
    }

    #[test]
    fn test_cross_reference_links() {
        let html = sxdoc::generate("test_35_4_toolchain.sx");

        // Cross-reference should become a link
        assert!(html.contains("<a href=\"#documented_add\">documented_add</a>"));
    }

    // Search index generation
    #[test]
    fn test_search_index() {
        let project = project_with_docs();
        let index = sxdoc::generate_search_index(&project);

        assert!(index.entries.len() > 0);

        // Search should find functions
        let results = index.search("documented");
        assert!(results.len() >= 3);
    }

    // Example extraction and testing
    /// Adds two numbers.
    ///
    /// # Examples
    ///
    /// ```simplex
    /// let sum = example_fn(2, 3);
    /// assert_eq!(sum, 5);
    /// ```
    pub fn example_fn(a: i64, b: i64) -> i64 {
        a + b
    }

    #[test]
    fn test_example_extraction() {
        let docs = sxdoc::parse_file("test_35_4_toolchain.sx");
        let examples = docs.get_examples("example_fn");

        assert_eq!(examples.len(), 1);
        assert!(examples[0].contains("let sum = example_fn(2, 3)"));
    }

    #[test]
    fn test_doctest_execution() {
        // Run all doc examples as tests
        let results = sxdoc::run_doctests("test_35_4_toolchain.sx");

        // example_fn's example should pass
        assert!(results.all_passed());
    }
}

// =============================================================================
// 35.4.7 sxlsp Language Server
// =============================================================================

mod test_sxlsp {
    use sxlsp;

    // Go to definition
    #[test]
    fn test_goto_definition() {
        let server = sxlsp::server_new();
        server.load_file("test.sx", "
            fn helper() -> i64 { 42 }
            fn main() {
                let x = helper();
            }
        ");

        // Request go-to-definition for "helper" call at line 4
        let result = server.goto_definition("test.sx", 4, 25);

        assert!(result.is_some());
        let location = result.unwrap();
        assert_eq!(location.line, 2); // helper is defined on line 2
    }

    // Find references
    #[test]
    fn test_find_references() {
        let server = sxlsp::server_new();
        server.load_file("test.sx", "
            fn helper() -> i64 { 42 }
            fn foo() { helper(); }
            fn bar() { helper(); }
        ");

        // Find all references to helper
        let refs = server.find_references("test.sx", 2, 16); // "helper" definition

        assert_eq!(refs.len(), 3); // definition + 2 calls
    }

    // Hover information
    #[test]
    fn test_hover() {
        let server = sxlsp::server_new();
        server.load_file("test.sx", "
            /// Returns the magic number
            fn magic() -> i64 { 42 }
            fn main() {
                let x = magic();
            }
        ");

        // Hover over magic() call
        let hover = server.hover("test.sx", 5, 25);

        assert!(hover.is_some());
        let info = hover.unwrap();
        assert!(info.contains("fn magic() -> i64"));
        assert!(info.contains("Returns the magic number"));
    }

    // Completion suggestions
    #[test]
    fn test_completion() {
        let server = sxlsp::server_new();
        server.load_file("test.sx", "
            struct Point { x: i64, y: i64 }
            fn main() {
                let p = Point { x: 1, y: 2 };
                p.
            }
        ");

        // Request completions after "p."
        let completions = server.complete("test.sx", 5, 19);

        assert!(completions.len() >= 2);
        let labels: Vec<String> = completions.iter().map(|c| c.label.clone()).collect();
        assert!(labels.contains(&"x".to_string()));
        assert!(labels.contains(&"y".to_string()));
    }

    // Diagnostics on save
    #[test]
    fn test_diagnostics() {
        let server = sxlsp::server_new();
        server.load_file("test.sx", "
            fn main() {
                let x: i64 = \"hello\";  // Type error
                unknown_fn();           // Unknown function
            }
        ");

        // Get diagnostics
        let diagnostics = server.get_diagnostics("test.sx");

        assert!(diagnostics.len() >= 2);

        // Check for type error
        assert!(diagnostics.iter().any(|d| d.message.contains("type")));

        // Check for unknown function
        assert!(diagnostics.iter().any(|d| d.message.contains("unknown") || d.message.contains("not found")));
    }
}

// =============================================================================
// 35.4.8 sxfmt Code Formatter
// =============================================================================

mod test_sxfmt {
    use sxfmt;

    // AST-based formatting
    #[test]
    fn test_basic_formatting() {
        let ugly_code = "fn   foo(x:i64)->i64{x+1}";
        let formatted = sxfmt::format(ugly_code);

        assert_eq!(formatted, "fn foo(x: i64) -> i64 {\n    x + 1\n}");
    }

    #[test]
    fn test_struct_formatting() {
        let ugly_code = "struct Point{x:i64,y:i64}";
        let formatted = sxfmt::format(ugly_code);

        assert_eq!(formatted, "struct Point {\n    x: i64,\n    y: i64,\n}");
    }

    // Configurable style
    #[test]
    fn test_configurable_indent() {
        let code = "fn foo() { let x = 1; }";

        // 2-space indent
        let config2 = sxfmt::Config { indent_size: 2, ..Default::default() };
        let formatted2 = sxfmt::format_with_config(code, &config2);
        assert!(formatted2.contains("  let"));

        // 4-space indent
        let config4 = sxfmt::Config { indent_size: 4, ..Default::default() };
        let formatted4 = sxfmt::format_with_config(code, &config4);
        assert!(formatted4.contains("    let"));
    }

    #[test]
    fn test_configurable_line_width() {
        let long_params = "fn very_long_function_name(param1: i64, param2: i64, param3: i64, param4: i64) -> i64";

        // Narrow width should wrap
        let narrow = sxfmt::Config { max_line_width: 40, ..Default::default() };
        let formatted = sxfmt::format_with_config(long_params, &narrow);

        // Should split across lines
        let lines: Vec<&str> = formatted.lines().collect();
        assert!(lines.len() > 1);
    }

    // Format on save (integration test)
    #[test]
    fn test_format_on_save() {
        let project = project_new();
        project.add_file("main.sx", "fn main(){let x=1;}");
        project.enable_format_on_save();

        // Simulate save
        project.save_file("main.sx");

        // File should now be formatted
        let content = project.read_file("main.sx");
        assert!(content.contains("fn main() {"));
        assert!(content.contains("    let x = 1;"));
    }

    // Check mode (CI)
    #[test]
    fn test_check_mode() {
        // Properly formatted code
        let good_code = "fn foo() {\n    42\n}";
        assert!(sxfmt::check(good_code).is_ok());

        // Badly formatted code
        let bad_code = "fn foo(){42}";
        let check_result = sxfmt::check(bad_code);
        assert!(check_result.is_err());

        // Error should show diff
        let diff = check_result.unwrap_err();
        assert!(diff.contains("-fn foo(){42}"));
        assert!(diff.contains("+fn foo() {"));
    }
}

// =============================================================================
// 35.4.9 Cross Compilation
// =============================================================================

mod test_cross_compilation {
    use sxc;

    // Target triple specification
    #[test]
    fn test_target_triple() {
        let targets = vec![
            "x86_64-unknown-linux-gnu",
            "aarch64-apple-darwin",
            "x86_64-pc-windows-msvc",
            "wasm32-unknown-unknown",
        ];

        for target in targets {
            let triple = sxc::TargetTriple::parse(target);
            assert!(triple.is_ok(), "Failed to parse: {}", target);
        }
    }

    // Platform-specific codegen
    #[test]
    fn test_platform_codegen_linux() {
        let code = "fn main() { process_spawn(\"ls\"); }";
        let ir = sxc::compile_to_ir(code, "x86_64-unknown-linux-gnu");

        // Linux uses fork/exec
        assert!(ir.contains("fork") || ir.contains("execve"));
    }

    #[test]
    fn test_platform_codegen_windows() {
        let code = "fn main() { process_spawn(\"dir\"); }";
        let ir = sxc::compile_to_ir(code, "x86_64-pc-windows-msvc");

        // Windows uses CreateProcess
        assert!(ir.contains("CreateProcess"));
    }

    #[test]
    fn test_platform_codegen_wasm() {
        let code = "fn add(a: i64, b: i64) -> i64 { a + b }";
        let wasm = sxc::compile_to_wasm(code, "wasm32-unknown-unknown");

        // WASM should start with magic bytes
        assert_eq!(wasm[0..4], [0x00, 0x61, 0x73, 0x6D]); // \0asm
    }

    // Cross-platform stdlib
    #[test]
    fn test_cross_platform_stdlib() {
        // File operations should work on all platforms
        let code = "
            use std::fs;
            fn main() {
                let content = fs::read_to_string(\"test.txt\");
            }
        ";

        // Should compile for different targets
        assert!(sxc::compile(code, "x86_64-unknown-linux-gnu").is_ok());
        assert!(sxc::compile(code, "aarch64-apple-darwin").is_ok());
        assert!(sxc::compile(code, "x86_64-pc-windows-msvc").is_ok());
    }
}

// =============================================================================
// 35.4.10 Incremental Compilation
// =============================================================================

mod test_incremental_compilation {
    use sxc::incremental;
    use std::time;

    // Dependency tracking
    #[test]
    fn test_dependency_tracking() {
        let project = project_new();
        project.add_file("a.sx", "pub fn a() -> i64 { 1 }");
        project.add_file("b.sx", "use a; pub fn b() -> i64 { a::a() + 1 }");
        project.add_file("c.sx", "use b; pub fn c() -> i64 { b::b() + 1 }");

        let deps = incremental::analyze_dependencies(&project);

        // c depends on b, b depends on a
        assert!(deps.depends_on("c.sx", "b.sx"));
        assert!(deps.depends_on("b.sx", "a.sx"));

        // Changing a.sx affects b and c
        let affected = deps.affected_by("a.sx");
        assert!(affected.contains(&"b.sx".to_string()));
        assert!(affected.contains(&"c.sx".to_string()));
    }

    // File hash caching
    #[test]
    fn test_file_hash_caching() {
        let cache = incremental::cache_new();

        let content = "fn test() { 42 }";
        let hash = incremental::hash_content(content);

        cache.store("test.sx", hash, vec![]);

        // Same content should hit cache
        assert!(cache.is_fresh("test.sx", content));

        // Different content should miss
        assert!(!cache.is_fresh("test.sx", "fn test() { 100 }"));
    }

    // Minimal recompilation
    #[test]
    fn test_minimal_recompilation() {
        let project = project_new();
        project.add_file("unchanged.sx", "fn unchanged() {}");
        project.add_file("changed.sx", "fn changed() {}");
        project.add_file("main.sx", "fn main() { unchanged(); changed(); }");

        // Initial build
        let build1 = project.build();
        assert!(build1.success);

        // Modify only changed.sx
        project.update_file("changed.sx", "fn changed() { let x = 1; }");

        // Incremental build
        let build2 = incremental::build(&project);

        // Should only compile changed.sx and main.sx (which depends on it)
        assert!(build2.compiled.contains(&"changed.sx".to_string()));
        assert!(!build2.compiled.contains(&"unchanged.sx".to_string()));
    }

    // Build cache
    #[test]
    fn test_build_cache() {
        let cache_dir = "/tmp/sxc_cache";
        let project = project_new();
        project.add_file("lib.sx", "pub fn lib_fn() -> i64 { 42 }");

        // Build with caching
        let config = incremental::Config { cache_dir: cache_dir.to_string() };
        let build1 = incremental::build_with_cache(&project, &config);
        let time1 = build1.duration;

        // Clean and rebuild - should use cache
        project.clean();
        let build2 = incremental::build_with_cache(&project, &config);
        let time2 = build2.duration;

        // Cached build should be faster
        assert!(time2 < time1);
    }
}

// =============================================================================
// 35.4.11 REPL
// =============================================================================

mod test_repl {
    use sxrepl::Repl;

    // Interactive expression evaluation
    #[test]
    fn test_expression_evaluation() {
        let mut repl = Repl::new();

        // Simple expression
        let result = repl.eval("1 + 2");
        assert_eq!(result, "3");

        // More complex expression
        let result = repl.eval("(10 * 5) - 3");
        assert_eq!(result, "47");
    }

    // Variable bindings across lines
    #[test]
    fn test_variable_persistence() {
        let mut repl = Repl::new();

        // Define variable
        repl.eval("let x = 42");

        // Use it in later expression
        let result = repl.eval("x + 8");
        assert_eq!(result, "50");

        // Define another
        repl.eval("let y = x * 2");
        let result = repl.eval("y");
        assert_eq!(result, "84");
    }

    // Function definitions
    #[test]
    fn test_function_definitions() {
        let mut repl = Repl::new();

        // Define function
        repl.eval("fn double(n: i64) -> i64 { n * 2 }");

        // Use it
        let result = repl.eval("double(21)");
        assert_eq!(result, "42");
    }

    // History and line editing
    #[test]
    fn test_history() {
        let mut repl = Repl::new();

        repl.eval("let a = 1");
        repl.eval("let b = 2");
        repl.eval("a + b");

        // History should contain all entries
        let history = repl.get_history();
        assert_eq!(history.len(), 3);
        assert_eq!(history[0], "let a = 1");
        assert_eq!(history[1], "let b = 2");
        assert_eq!(history[2], "a + b");
    }

    // Pretty printing results
    #[test]
    fn test_pretty_print() {
        let mut repl = Repl::new();

        // Struct should be pretty printed
        repl.eval("struct Point { x: i64, y: i64 }");
        let result = repl.eval("Point { x: 10, y: 20 }");

        // Should show field names and values
        assert!(result.contains("Point"));
        assert!(result.contains("x: 10"));
        assert!(result.contains("y: 20"));
    }

    // Error handling
    #[test]
    fn test_repl_error_recovery() {
        let mut repl = Repl::new();

        // Syntax error
        let result = repl.eval("let x =");
        assert!(result.contains("error") || result.contains("Error"));

        // REPL should still work after error
        let result = repl.eval("1 + 1");
        assert_eq!(result, "2");
    }
}

// =============================================================================
// 35.4.12 Cursus VM (Optional)
// =============================================================================

mod test_cursus_vm {
    use cursus;

    // Bytecode format
    #[test]
    fn test_bytecode_format() {
        let code = "fn main() -> i64 { 1 + 2 }";
        let bytecode = cursus::compile(code);

        // Magic bytes
        assert_eq!(bytecode[0..4], [0x43, 0x55, 0x52, 0x53]); // "CURS"

        // Version
        let version = bytecode[4];
        assert_eq!(version, 1);

        // Should contain instructions
        assert!(bytecode.len() > 10);
    }

    // Interpreter loop
    #[test]
    fn test_interpreter_basic() {
        let mut vm = cursus::VM::new();

        // Load bytecode for: fn main() -> i64 { 42 }
        let bytecode = cursus::compile("fn main() -> i64 { 42 }");
        vm.load(bytecode);

        // Run
        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(42));
    }

    #[test]
    fn test_interpreter_arithmetic() {
        let mut vm = cursus::VM::new();

        let bytecode = cursus::compile("fn main() -> i64 { (10 + 5) * 3 - 15 }");
        vm.load(bytecode);

        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(30)); // (10+5)*3-15 = 45-15 = 30
    }

    #[test]
    fn test_interpreter_function_calls() {
        let mut vm = cursus::VM::new();

        let bytecode = cursus::compile("
            fn add(a: i64, b: i64) -> i64 { a + b }
            fn main() -> i64 { add(20, 22) }
        ");
        vm.load(bytecode);

        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(42));
    }

    // Module loading
    #[test]
    fn test_module_loading() {
        let mut vm = cursus::VM::new();

        // Compile module
        let math_module = cursus::compile_module("
            pub fn square(x: i64) -> i64 { x * x }
        ", "math");

        // Load module
        vm.load_module(math_module, "math");

        // Use module
        let main = cursus::compile("
            use math;
            fn main() -> i64 { math::square(7) }
        ");
        vm.load(main);

        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(49));
    }

    // Stack operations
    #[test]
    fn test_stack_operations() {
        let mut vm = cursus::VM::new();

        // Manually execute bytecode instructions
        vm.push(cursus::Value::Int(10));
        vm.push(cursus::Value::Int(20));
        vm.add(); // Pop two, push sum

        let top = vm.pop();
        assert_eq!(top, cursus::Value::Int(30));
    }

    // Locals and globals
    #[test]
    fn test_locals() {
        let mut vm = cursus::VM::new();

        let bytecode = cursus::compile("
            fn main() -> i64 {
                let x = 10;
                let y = 20;
                let z = x + y;
                z * 2
            }
        ");
        vm.load(bytecode);

        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(60));
    }

    // Control flow
    #[test]
    fn test_control_flow() {
        let mut vm = cursus::VM::new();

        let bytecode = cursus::compile("
            fn main() -> i64 {
                let mut sum = 0;
                for i in 0..10 {
                    sum = sum + i;
                }
                sum
            }
        ");
        vm.load(bytecode);

        let result = vm.run();
        assert_eq!(result, cursus::Value::Int(45)); // 0+1+2+...+9 = 45
    }
}

// =============================================================================
// Helper definitions for test compilation
// =============================================================================

fn file_watcher_new(path: &str) -> FileWatcher {
    FileWatcher { path: path.to_string(), changes: false }
}

struct FileWatcher {
    path: String,
    changes: bool,
}

impl FileWatcher {
    fn has_changes(&self) -> bool { self.changes }
}

fn test_project_new() -> TestProject {
    TestProject::new()
}

fn project_new() -> TestProject {
    TestProject::new()
}

fn project_with_docs() -> TestProject {
    TestProject::new()
}

fn valid_project_new() -> TestProject {
    let mut p = TestProject::new();
    p.set_name("my-package");
    p.set_version("1.0.0");
    p
}

fn mock_registry_new() -> MockRegistry {
    MockRegistry::new()
}

fn registry_client_new() -> RegistryClient {
    RegistryClient::new()
}

fn build_with_lock(lock: &Lockfile) -> BuildResult {
    BuildResult { hash: "abc123".to_string() }
}

fn git_list_tags() -> Vec<String> {
    vec!["v1.0.0".to_string(), "v1.2.3".to_string()]
}

fn app_start() -> App {
    App::new()
}

struct TestProject {
    name: String,
    version: String,
    files: Vec<(String, String)>,
}

impl TestProject {
    fn new() -> Self {
        TestProject {
            name: String::new(),
            version: String::new(),
            files: vec![],
        }
    }

    fn set_name(&mut self, name: &str) { self.name = name.to_string(); }
    fn set_version(&mut self, version: &str) { self.version = version.to_string(); }
    fn add_file(&mut self, path: &str, content: &str) {
        self.files.push((path.to_string(), content.to_string()));
    }
    fn update_file(&mut self, path: &str, content: &str) {
        for (p, c) in &mut self.files {
            if p == path {
                *c = content.to_string();
            }
        }
    }
    fn read_file(&self, path: &str) -> String {
        for (p, c) in &self.files {
            if p == path { return c.clone(); }
        }
        String::new()
    }
    fn save_file(&self, path: &str) {}
    fn add_dependency(&mut self, name: &str, version: &str) {}
    fn update_dependency(&mut self, name: &str, version: &str) {}
    fn build(&self) -> BuildResult { BuildResult { hash: "".to_string() } }
    fn build_incremental(&self) -> IncrementalBuildResult {
        IncrementalBuildResult { success: true, files_compiled: 1 }
    }
    fn check(&self) -> Vec<CompileError> { vec![] }
    fn clean(&self) {}
    fn enable_format_on_save(&self) {}
}

struct BuildResult { hash: String }
struct IncrementalBuildResult { success: bool, files_compiled: i64 }
struct CompileError { message: String }
struct MockRegistry {}
impl MockRegistry {
    fn new() -> Self { MockRegistry {} }
    fn has_package(&self, name: &str, version: &str) -> bool { true }
}
struct RegistryClient {}
impl RegistryClient {
    fn new() -> Self { RegistryClient {} }
    fn yank(&self, name: &str, version: &str) -> Result<(), String> { Ok(()) }
    fn resolve_version(&self, name: &str, constraint: &str) -> Result<String, String> {
        Ok("1.0.0".to_string())
    }
}
struct Lockfile { packages: Vec<PackageEntry> }
impl Lockfile {
    fn get_version(&self, name: &str) -> String { "1.0.0".to_string() }
}
struct PackageEntry { name: String, version: String }
struct App {}
impl App {
    fn new() -> Self { App {} }
    fn call_fn(&self, name: &str) -> i64 { 42 }
    fn update_source(&self, code: &str) {}
    fn hot_reload(&self) {}
}

fn main() {
    println!("Phase 35 Wave 4 Toolchain Tests");
    println!("================================");
    println!("Run with: sxc test tests/test_35_4_toolchain.sx");
}
