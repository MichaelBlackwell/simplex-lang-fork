#!/bin/bash
#
# sxc - Simplex Compiler
#
# Usage:
#   sxc build <source.sx> [-o output]    Compile to native executable
#   sxc compile <source.sx>              Compile to LLVM IR only
#   sxc run <source.sx>                  Compile and run immediately
#   sxc test [dir] [--coverage]          Run tests with optional coverage
#   sxc bench <source.sx> [options]      Run benchmarks
#   sxc clean                            Clear build cache
#   sxc version                          Show version
#   sxc help                             Show this help
#   sxc explain <error_code>             Show detailed error explanation
#
# Incremental Compilation:
#   By default, sxc uses incremental compilation to speed up builds.
#   Only files that have changed (or have changed dependencies) are recompiled.
#   Use --no-incremental to force a full rebuild.
#
# Profiling:
#   sxc build <source.sx> --profile      Build with profiling support
#   sxc run <source.sx> --profile        Run with profiling/memory tracking
#

set -e

VERSION="0.10.0"

# Coverage configuration
COVERAGE_ENABLED=0
COVERAGE_DIR="coverage"
PROFRAW_DIR="$COVERAGE_DIR/profraw"
COVERAGE_HTML_DIR="$COVERAGE_DIR/html"

# Profiling configuration
PROFILE_ENABLED=0
MEMORY_DEBUG_ENABLED=0

# Incremental compilation configuration
INCREMENTAL=1
VERBOSE=0
FORCE_REBUILD=0
CACHE_DIR=".sx-cache"
CACHE_OBJECTS="$CACHE_DIR/objects"

# Find the directory where sxc is installed
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPILER="$SCRIPT_DIR/sxc-compile"
RUNTIME="$SCRIPT_DIR/standalone_runtime.c"

# Source incremental compilation library if available
if [ -f "$SCRIPT_DIR/lib/incremental.sh" ]; then
    source "$SCRIPT_DIR/lib/incremental.sh"
fi

# Check for runtime in alternate locations
if [ ! -f "$RUNTIME" ]; then
    RUNTIME="$SCRIPT_DIR/../runtime/standalone_runtime.c"
fi
if [ ! -f "$RUNTIME" ]; then
    RUNTIME="$SCRIPT_DIR/runtime/standalone_runtime.c"
fi

# Detect platform and set library flags
detect_platform() {
    case "$(uname -s)" in
        Darwin*)
            PLATFORM="macos"
            # Try to find OpenSSL from Homebrew
            if command -v brew >/dev/null 2>&1; then
                OPENSSL_PREFIX=$(brew --prefix openssl@3 2>/dev/null || brew --prefix openssl 2>/dev/null || echo "")
                if [ -n "$OPENSSL_PREFIX" ]; then
                    LIBS="-lm -L$OPENSSL_PREFIX/lib -lssl -lcrypto -lsqlite3"
                    INCLUDES="-I$OPENSSL_PREFIX/include"
                else
                    LIBS="-lm -lssl -lcrypto -lsqlite3"
                    INCLUDES=""
                fi
            else
                LIBS="-lm -lssl -lcrypto -lsqlite3"
                INCLUDES=""
            fi
            ;;
        Linux*)
            PLATFORM="linux"
            LIBS="-lm -lssl -lcrypto -lsqlite3 -lpthread"
            INCLUDES=""
            ;;
        MINGW*|MSYS*|CYGWIN*)
            PLATFORM="windows"
            LIBS="-lm -lssl -lcrypto -lsqlite3"
            INCLUDES=""
            ;;
        *)
            PLATFORM="unknown"
            LIBS="-lm"
            INCLUDES=""
            ;;
    esac
}

show_help() {
    echo "sxc - Simplex Compiler v$VERSION"
    echo ""
    echo "Usage:"
    echo "  sxc build <source.sx> [-o output]    Compile to native executable"
    echo "  sxc compile <source.sx>              Compile to LLVM IR (.ll)"
    echo "  sxc run <source.sx>                  Compile and run immediately"
    echo "  sxc fmt <source.sx>                  Format source file in place"
    echo "  sxc fmt --check <source.sx>          Check if file is formatted"
    echo "  sxc lint <source.sx>                 Run static analysis linter"
    echo "  sxc test [dir] [--coverage]          Run tests with optional coverage"
    echo "  sxc version                          Show version"
    echo "  sxc help                             Show this help"
    echo ""
    echo "Examples:"
    echo "  sxc build hello.sx                   Creates ./hello executable"
    echo "  sxc build hello.sx -o myapp          Creates ./myapp executable"
    echo "  sxc run hello.sx                     Compiles and runs hello.sx"
    echo "  sxc test tests/                      Run tests in directory"
    echo "  sxc test tests/ --coverage           Run tests with coverage report"
    echo "  sxc clean                            Clear .sx-cache directory"
    echo ""
    echo "Incremental Compilation:"
    echo "  sxc automatically caches compiled objects in .sx-cache/"
    echo "  Only files that have changed are recompiled on subsequent builds."
    echo ""
    echo "Build Options:"
    echo "  -o <file>          Output file name"
    echo "  --incremental      Use incremental compilation (default)"
    echo "  --no-incremental   Force full rebuild"
    echo "  --force            Force rebuild all files"
    echo "  -v, --verbose      Show detailed build information"
    echo ""
    echo "Coverage Options:"
    echo "  --coverage                           Enable code coverage measurement"
    echo "  --coverage-html                      Generate HTML coverage report"
    echo "  --coverage-json                      Generate codecov.io compatible JSON"
    echo ""
    echo "Profiling Options:"
    echo "  --profile                            Enable CPU profiling (frame pointers)"
    echo "  --memory-debug                       Enable memory allocation tracking"
    echo ""
    echo "Benchmark Options:"
    echo "  sxc bench file.sx                    Run benchmarks in file"
    echo "  sxc bench file.sx --json             Output in JSON format"
    echo "  sxc bench file.sx --baseline <file>  Compare against baseline"
    echo "  sxc bench file.sx --save <file>      Save results to file"
    echo ""
    echo "Error Documentation:"
    echo "  sxc explain E0100                    Explain error code E0100"
    echo "  sxc explain --list                   List all error codes"
    echo ""
}

# Find LLVM tools for coverage
find_llvm_tools() {
    # Try common LLVM installation paths
    local LLVM_PATHS=(
        "/opt/homebrew/opt/llvm/bin"
        "/usr/local/opt/llvm/bin"
        "/usr/lib/llvm-14/bin"
        "/usr/lib/llvm-15/bin"
        "/usr/lib/llvm-16/bin"
        "/usr/lib/llvm-17/bin"
        "/Library/Developer/CommandLineTools/usr/bin"
    )

    # Check PATH first
    if command -v llvm-profdata >/dev/null 2>&1; then
        LLVM_PROFDATA="llvm-profdata"
        LLVM_COV="llvm-cov"
        return 0
    fi

    # Search common paths
    for path in "${LLVM_PATHS[@]}"; do
        if [ -x "$path/llvm-profdata" ]; then
            LLVM_PROFDATA="$path/llvm-profdata"
            LLVM_COV="$path/llvm-cov"
            return 0
        fi
    done

    # Try xcrun on macOS
    if command -v xcrun >/dev/null 2>&1; then
        local xcrun_profdata=$(xcrun -find llvm-profdata 2>/dev/null)
        if [ -n "$xcrun_profdata" ] && [ -x "$xcrun_profdata" ]; then
            LLVM_PROFDATA="$xcrun_profdata"
            LLVM_COV=$(xcrun -find llvm-cov 2>/dev/null)
            return 0
        fi
    fi

    return 1
}

show_version() {
    echo "sxc $VERSION"
    echo "Simplex Compiler (self-hosted)"
    echo "Platform: $PLATFORM"
    echo "Incremental compilation: enabled"
}

cmd_compile() {
    local SOURCE="$1"

    if [ -z "$SOURCE" ]; then
        echo "Error: No source file specified"
        echo "Usage: sxc compile <source.sx>"
        exit 1
    fi

    if [ ! -f "$SOURCE" ]; then
        echo "Error: Source file not found: $SOURCE"
        exit 1
    fi

    "$COMPILER" "$SOURCE"
}

cmd_build() {
    local SOURCE=""
    local OUTPUT=""
    local PROFILE=0
    local MEMORY_DEBUG=0

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -o)
                shift
                OUTPUT="$1"
                ;;
            --profile)
                PROFILE=1
                ;;
            --memory-debug)
                MEMORY_DEBUG=1
                ;;
            --incremental)
                INCREMENTAL=1
                ;;
            --no-incremental)
                INCREMENTAL=0
                ;;
            --force)
                FORCE_REBUILD=1
                ;;
            -v|--verbose)
                VERBOSE=1
                ;;
            -*)
                echo "Error: Unknown option $1"
                exit 1
                ;;
            *)
                if [ -z "$SOURCE" ]; then
                    SOURCE="$1"
                else
                    echo "Error: Multiple source files not supported"
                    exit 1
                fi
                ;;
        esac
        shift
    done

    if [ -z "$SOURCE" ]; then
        echo "Error: No source file specified"
        echo "Usage: sxc build <source.sx> [-o output]"
        exit 1
    fi

    if [ ! -f "$SOURCE" ]; then
        echo "Error: Source file not found: $SOURCE"
        exit 1
    fi

    # Determine output name
    if [ -z "$OUTPUT" ]; then
        OUTPUT="${SOURCE%.sx}"
    fi

    # Check for runtime
    if [ ! -f "$RUNTIME" ]; then
        echo "Error: Runtime not found at $RUNTIME"
        echo "Please ensure standalone_runtime.c is in the same directory as sxc"
        exit 1
    fi

    # Check for clang
    if ! command -v clang >/dev/null 2>&1; then
        echo "Error: clang not found"
        echo "Please install LLVM/Clang to compile Simplex programs"
        exit 1
    fi

    detect_platform

    # Use incremental build if enabled and no special flags that require full rebuild
    if [ $INCREMENTAL -eq 1 ] && [ $PROFILE -eq 0 ] && [ $MEMORY_DEBUG -eq 0 ] && type build_incremental &>/dev/null; then
        build_incremental "$SOURCE" "$OUTPUT" "$COMPILER" "$RUNTIME" "$INCLUDES" "$LIBS"
    else
        # Fall back to non-incremental build
        if [ $INCREMENTAL -eq 0 ]; then
            echo "Building (full rebuild)..."
        fi

        # Compile to LLVM IR
        LL_FILE="${SOURCE%.sx}.ll"
        "$COMPILER" "$SOURCE"

        if [ ! -f "$LL_FILE" ]; then
            echo "Error: Compilation failed - no .ll file generated"
            exit 1
        fi

        # Link with clang
        local CLANG_FLAGS="-O2"
        local DEFINES=""

        # Add profiling flags if enabled
        if [ $PROFILE -eq 1 ]; then
            CLANG_FLAGS="$CLANG_FLAGS -fno-omit-frame-pointer -g"
            echo "Building with profiling support enabled..."
        fi

        # Add memory debug flags if enabled
        if [ $MEMORY_DEBUG -eq 1 ]; then
            DEFINES="$DEFINES -DSX_MEMORY_DEBUG=1"
            echo "Building with memory tracking enabled..."
        fi

        clang $CLANG_FLAGS $DEFINES $INCLUDES "$LL_FILE" "$RUNTIME" -o "$OUTPUT" $LIBS 2>&1

        if [ $? -eq 0 ]; then
            # Clean up .ll file
            rm -f "$LL_FILE"
            echo "Built: $OUTPUT"
            if [ $PROFILE -eq 1 ]; then
                echo ""
                echo "Profiling instructions:"
                if [ "$PLATFORM" = "macos" ]; then
                    echo "  1. Run with Instruments: instruments -t 'Time Profiler' ./$OUTPUT"
                    echo "  2. Or use sample: sample $OUTPUT 5 -f profile.txt"
                else
                    echo "  1. Run with perf: perf record -g ./$OUTPUT"
                    echo "  2. View results: perf report"
                fi
            fi
            if [ $MEMORY_DEBUG -eq 1 ]; then
                echo ""
                echo "Memory tracking enabled. Call memory_report() in your program to see allocation stats."
            fi
        else
            echo "Error: Linking failed"
            exit 1
        fi
    fi
}

cmd_run() {
    local SOURCE=""
    local PROFILE=0
    local MEMORY_DEBUG=0

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --profile)
                PROFILE=1
                ;;
            --memory-debug)
                MEMORY_DEBUG=1
                ;;
            -*)
                echo "Error: Unknown option $1"
                exit 1
                ;;
            *)
                if [ -z "$SOURCE" ]; then
                    SOURCE="$1"
                fi
                ;;
        esac
        shift
    done

    if [ -z "$SOURCE" ]; then
        echo "Error: No source file specified"
        echo "Usage: sxc run <source.sx>"
        exit 1
    fi

    if [ ! -f "$SOURCE" ]; then
        echo "Error: Source file not found: $SOURCE"
        exit 1
    fi

    # Create temp directory for build
    TMPDIR=$(mktemp -d)
    trap "rm -rf $TMPDIR" EXIT

    # Build to temp location
    OUTPUT="$TMPDIR/program"

    # Compile to LLVM IR
    LL_FILE="${SOURCE%.sx}.ll"
    "$COMPILER" "$SOURCE"

    if [ ! -f "$LL_FILE" ]; then
        echo "Error: Compilation failed"
        exit 1
    fi

    # Link with appropriate flags
    detect_platform
    local CLANG_FLAGS="-O2"
    local DEFINES=""

    if [ $PROFILE -eq 1 ]; then
        CLANG_FLAGS="$CLANG_FLAGS -fno-omit-frame-pointer -g"
    fi

    if [ $MEMORY_DEBUG -eq 1 ]; then
        DEFINES="$DEFINES -DSX_MEMORY_DEBUG=1"
    fi

    clang $CLANG_FLAGS $DEFINES $INCLUDES "$LL_FILE" "$RUNTIME" -o "$OUTPUT" $LIBS 2>&1

    if [ $? -ne 0 ]; then
        echo "Error: Linking failed"
        exit 1
    fi

    # Clean up .ll file
    rm -f "$LL_FILE"

    # Run the program
    "$OUTPUT"
}

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test command with coverage support
cmd_test() {
    local TEST_DIR="tests"
    local COVERAGE_HTML=0
    local COVERAGE_JSON=0
    local PASSED=0
    local FAILED=0
    local TOTAL_LINES=0
    local COVERED_LINES=0
    declare -A FILE_COVERAGE

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --coverage)
                COVERAGE_ENABLED=1
                ;;
            --coverage-html)
                COVERAGE_ENABLED=1
                COVERAGE_HTML=1
                ;;
            --coverage-json)
                COVERAGE_ENABLED=1
                COVERAGE_JSON=1
                ;;
            -*)
                echo "Error: Unknown option $1"
                exit 1
                ;;
            *)
                if [ -d "$1" ]; then
                    TEST_DIR="$1"
                else
                    echo "Error: Directory not found: $1"
                    exit 1
                fi
                ;;
        esac
        shift
    done

    # Ensure test directory exists
    if [ ! -d "$TEST_DIR" ]; then
        echo "Error: Test directory not found: $TEST_DIR"
        exit 1
    fi

    # Setup coverage if enabled
    if [ $COVERAGE_ENABLED -eq 1 ]; then
        if ! find_llvm_tools; then
            echo -e "${YELLOW}Warning: LLVM coverage tools not found. Using line-based coverage.${NC}"
            echo "For source-based coverage, install LLVM: brew install llvm"
            echo ""
            COVERAGE_MODE="line"
        else
            COVERAGE_MODE="llvm"
        fi

        # Create coverage directories
        mkdir -p "$COVERAGE_DIR" "$PROFRAW_DIR" "$COVERAGE_HTML_DIR"

        # Clean old coverage data
        rm -f "$PROFRAW_DIR"/*.profraw
        rm -f "$COVERAGE_DIR"/*.profdata

        echo -e "${CYAN}Running tests with coverage...${NC}"
        echo ""
    else
        echo -e "${CYAN}Running tests...${NC}"
        echo ""
    fi

    # Find and run tests
    local test_files=$(find "$TEST_DIR" -name "*.sx" -type f | sort)

    for test_file in $test_files; do
        local test_name=$(basename "$test_file" .sx)
        local test_dir=$(dirname "$test_file")

        # Skip non-test files (helpers, libraries, etc.)
        if [[ "$test_name" == "helpers" ]] || [[ "$test_name" == "spec_mathlib" ]]; then
            continue
        fi

        # Only run test files (those starting with test_, unit_, spec_, integ_, e2e_)
        if [[ ! "$test_name" =~ ^(test_|unit_|spec_|integ_|e2e_) ]]; then
            continue
        fi

        local display_name="${test_file#$TEST_DIR/}"
        printf "  %-50s " "$display_name"

        # Compile
        local ll_file="${test_file%.sx}.ll"
        if ! "$COMPILER" "$test_file" >/dev/null 2>&1; then
            echo -e "${RED}COMPILE FAIL${NC}"
            ((FAILED++))
            continue
        fi

        if [ ! -f "$ll_file" ]; then
            echo -e "${RED}COMPILE FAIL${NC}"
            ((FAILED++))
            continue
        fi

        # Build with or without coverage instrumentation
        local bin_file="${test_file%.sx}.bin"
        local clang_flags="-O0"

        if [ $COVERAGE_ENABLED -eq 1 ] && [ "$COVERAGE_MODE" = "llvm" ]; then
            # LLVM source-based coverage flags
            clang_flags="-fprofile-instr-generate -fcoverage-mapping -O0"
            export LLVM_PROFILE_FILE="$PROFRAW_DIR/${test_name}.profraw"
        fi

        detect_platform
        if ! clang $clang_flags $INCLUDES "$ll_file" "$RUNTIME" -o "$bin_file" $LIBS 2>/dev/null; then
            echo -e "${RED}LINK FAIL${NC}"
            ((FAILED++))
            rm -f "$ll_file"
            continue
        fi

        # Run the test
        if "$bin_file" >/dev/null 2>&1; then
            echo -e "${GREEN}PASS${NC}"
            ((PASSED++))

            # Collect line-based coverage if no LLVM tools
            if [ $COVERAGE_ENABLED -eq 1 ] && [ "$COVERAGE_MODE" = "line" ]; then
                # Count lines in source file for simple coverage
                local lines=$(wc -l < "$test_file" | tr -d ' ')
                TOTAL_LINES=$((TOTAL_LINES + lines))
                COVERED_LINES=$((COVERED_LINES + lines))  # Passed tests = covered
                FILE_COVERAGE["$test_file"]="100"
            fi
        else
            echo -e "${RED}FAIL${NC}"
            ((FAILED++))

            if [ $COVERAGE_ENABLED -eq 1 ] && [ "$COVERAGE_MODE" = "line" ]; then
                local lines=$(wc -l < "$test_file" | tr -d ' ')
                TOTAL_LINES=$((TOTAL_LINES + lines))
                FILE_COVERAGE["$test_file"]="0"
            fi
        fi

        # Cleanup
        rm -f "$ll_file" "$bin_file"
    done

    echo ""

    # Generate coverage report
    if [ $COVERAGE_ENABLED -eq 1 ]; then
        echo -e "${CYAN}Generating coverage report...${NC}"
        echo ""

        if [ "$COVERAGE_MODE" = "llvm" ]; then
            # Merge profile data
            local profdata_files=$(find "$PROFRAW_DIR" -name "*.profraw" 2>/dev/null)
            if [ -n "$profdata_files" ]; then
                "$LLVM_PROFDATA" merge -sparse $profdata_files -o "$COVERAGE_DIR/coverage.profdata" 2>/dev/null

                # Find test binaries for coverage report
                local test_binaries=$(find "$TEST_DIR" -name "*.bin" -type f 2>/dev/null | head -1)

                if [ -n "$test_binaries" ] && [ -f "$COVERAGE_DIR/coverage.profdata" ]; then
                    # Generate summary
                    local summary=$("$LLVM_COV" report "$test_binaries" -instr-profile="$COVERAGE_DIR/coverage.profdata" 2>/dev/null)

                    if [ $COVERAGE_HTML -eq 1 ]; then
                        "$LLVM_COV" show "$test_binaries" -instr-profile="$COVERAGE_DIR/coverage.profdata" \
                            -format=html -output-dir="$COVERAGE_HTML_DIR" 2>/dev/null
                        echo "HTML report: $COVERAGE_HTML_DIR/index.html"
                    fi

                    if [ $COVERAGE_JSON -eq 1 ]; then
                        generate_codecov_json
                    fi
                fi
            fi
        fi

        # Calculate and display coverage summary
        local total=$((PASSED + FAILED))
        if [ $total -gt 0 ]; then
            if [ "$COVERAGE_MODE" = "line" ]; then
                if [ $TOTAL_LINES -gt 0 ]; then
                    local percent=$((COVERED_LINES * 100 / TOTAL_LINES))
                    echo -e "Coverage: ${GREEN}${percent}%${NC} ($COVERED_LINES/$TOTAL_LINES lines)"
                fi
            fi

            echo ""
            echo "Per-file coverage:"
            for file in "${!FILE_COVERAGE[@]}"; do
                local cov="${FILE_COVERAGE[$file]}"
                local display="${file#$TEST_DIR/}"
                if [ "$cov" = "100" ]; then
                    printf "  %-40s ${GREEN}%s%%${NC}\n" "$display" "$cov"
                else
                    printf "  %-40s ${RED}%s%%${NC}\n" "$display" "$cov"
                fi
            done | sort
        fi

        if [ $COVERAGE_HTML -eq 1 ]; then
            generate_html_report "$PASSED" "$FAILED"
        fi

        if [ $COVERAGE_JSON -eq 1 ]; then
            generate_codecov_json "$PASSED" "$FAILED"
        fi

        echo ""
    fi

    # Print summary
    echo "=============================================="
    echo -e "  ${GREEN}Passed:${NC}   $PASSED"
    echo -e "  ${RED}Failed:${NC}   $FAILED"
    local total=$((PASSED + FAILED))
    if [ $total -gt 0 ]; then
        local percent=$((PASSED * 100 / total))
        echo "  Total:    $total ($percent% pass rate)"
    fi
    echo "=============================================="

    if [ $FAILED -gt 0 ]; then
        exit 1
    fi
}

# Generate HTML coverage report
generate_html_report() {
    local passed=$1
    local failed=$2
    local total=$((passed + failed))
    local percent=0
    if [ $total -gt 0 ]; then
        percent=$((passed * 100 / total))
    fi

    mkdir -p "$COVERAGE_HTML_DIR"

    cat > "$COVERAGE_HTML_DIR/index.html" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>Simplex Coverage Report</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .stat { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; flex: 1; }
        .stat .value { font-size: 36px; font-weight: bold; }
        .stat .label { color: #666; margin-top: 5px; }
        .passed .value { color: #4CAF50; }
        .failed .value { color: #f44336; }
        .coverage .value { color: #2196F3; }
        .progress { height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 20px 0; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #f8f9fa; }
        .cov-high { color: #4CAF50; }
        .cov-medium { color: #FF9800; }
        .cov-low { color: #f44336; }
        .timestamp { color: #999; font-size: 12px; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simplex Code Coverage Report</h1>
        <div class="summary">
            <div class="stat passed">
                <div class="value">$passed</div>
                <div class="label">Tests Passed</div>
            </div>
            <div class="stat failed">
                <div class="value">$failed</div>
                <div class="label">Tests Failed</div>
            </div>
            <div class="stat coverage">
                <div class="value">$percent%</div>
                <div class="label">Coverage</div>
            </div>
        </div>
        <div class="progress">
            <div class="progress-bar" style="width: $percent%"></div>
        </div>
        <h2>File Coverage</h2>
        <table>
            <tr><th>File</th><th>Coverage</th><th>Status</th></tr>
EOF

    for file in "${!FILE_COVERAGE[@]}"; do
        local cov="${FILE_COVERAGE[$file]}"
        local display="${file#$TEST_DIR/}"
        local status_class="cov-high"
        local status="Covered"
        if [ "$cov" = "0" ]; then
            status_class="cov-low"
            status="Not Covered"
        fi
        echo "            <tr><td>$display</td><td class=\"$status_class\">$cov%</td><td>$status</td></tr>" >> "$COVERAGE_HTML_DIR/index.html"
    done

    cat >> "$COVERAGE_HTML_DIR/index.html" << EOF
        </table>
        <p class="timestamp">Generated: $(date)</p>
    </div>
</body>
</html>
EOF

    echo "HTML report: $COVERAGE_HTML_DIR/index.html"
}

# Generate codecov.io compatible JSON report
generate_codecov_json() {
    local passed=$1
    local failed=$2

    cat > "$COVERAGE_DIR/codecov.json" << EOF
{
  "coverage": {
EOF

    local first=1
    for file in "${!FILE_COVERAGE[@]}"; do
        local cov="${FILE_COVERAGE[$file]}"
        if [ $first -eq 0 ]; then
            echo "," >> "$COVERAGE_DIR/codecov.json"
        fi
        first=0
        # Generate line-by-line coverage (simplified: all lines same coverage)
        local lines=$(wc -l < "$file" | tr -d ' ')
        local line_cov=""
        for ((i=1; i<=lines; i++)); do
            if [ "$cov" = "100" ]; then
                line_cov="$line_cov, 1"
            else
                line_cov="$line_cov, 0"
            fi
        done
        line_cov="${line_cov:2}"  # Remove leading ", "
        printf "    \"%s\": [null%s]" "$file" ", $line_cov" >> "$COVERAGE_DIR/codecov.json"
    done

    cat >> "$COVERAGE_DIR/codecov.json" << EOF

  }
}
EOF

    echo "Codecov JSON: $COVERAGE_DIR/codecov.json"
}

# Error explanation command
cmd_explain() {
    local ERROR_CODE="$1"
    local ERRORS_DIR="$SCRIPT_DIR/docs/errors"

    # Handle --list flag
    if [ "$ERROR_CODE" = "--list" ]; then
        echo "Simplex Compiler Error Codes"
        echo "============================="
        echo ""
        echo "Parse Errors (E0001-E0099):"
        echo "  E0001  unexpected token"
        echo "  E0002  unexpected end of file"
        echo "  E0003  expected token"
        echo "  E0004  invalid literal"
        echo "  E0005  unclosed delimiter"
        echo "  E0006  expected type"
        echo "  E0007  expected expression"
        echo "  E0008  expected pattern"
        echo "  E0009  invalid attribute"
        echo ""
        echo "Name Resolution Errors (E0100-E0199):"
        echo "  E0100  cannot find value in this scope"
        echo "  E0101  cannot find function in this scope"
        echo "  E0102  cannot find type in this scope"
        echo "  E0103  cannot find struct in this scope"
        echo "  E0104  no field on type"
        echo "  E0105  cannot find enum in this scope"
        echo "  E0106  no variant on enum"
        echo "  E0107  no method found"
        echo "  E0108  cannot find trait in this scope"
        echo "  E0109  duplicate definition"
        echo ""
        echo "Type Errors (E0200-E0299):"
        echo "  E0200  mismatched types"
        echo "  E0201  wrong number of arguments"
        echo "  E0202  wrong number of type arguments"
        echo "  E0203  trait not implemented"
        echo "  E0204  invalid cast"
        echo "  E0205  cannot infer type"
        echo ""
        echo "Semantic Errors (E0300-E0399):"
        echo "  E0300  break outside of loop"
        echo "  E0301  continue outside of loop"
        echo "  E0302  return in closure"
        echo "  E0303  await outside of async function"
        echo "  E0304  yield outside of generator"
        echo "  E0305  self outside of impl block"
        echo ""
        echo "IO Errors (E0400-E0499):"
        echo "  E0400  file not found"
        echo "  E0401  cannot read file"
        echo ""
        echo "Use 'sxc explain <error_code>' for detailed explanations."
        exit 0
    fi

    if [ -z "$ERROR_CODE" ]; then
        echo "Error: No error code specified"
        echo "Usage: sxc explain <error_code>"
        echo "       sxc explain --list"
        exit 1
    fi

    # Normalize error code (accept E0100, e0100, 0100, or 100)
    ERROR_CODE=$(echo "$ERROR_CODE" | tr '[:lower:]' '[:upper:]')
    if [[ ! "$ERROR_CODE" =~ ^E ]]; then
        # Add E prefix if missing
        if [[ "$ERROR_CODE" =~ ^[0-9]+$ ]]; then
            # Pad to 4 digits
            ERROR_CODE=$(printf "E%04d" "$ERROR_CODE")
        else
            ERROR_CODE="E$ERROR_CODE"
        fi
    fi

    # Look for the error documentation file
    local ERROR_FILE="$ERRORS_DIR/$ERROR_CODE.md"

    if [ -f "$ERROR_FILE" ]; then
        # Display the error documentation
        cat "$ERROR_FILE"
    else
        echo "Unknown error code: $ERROR_CODE"
        echo ""
        echo "Use 'sxc explain --list' to see all available error codes."
        exit 1
    fi
}

# Benchmark command
cmd_bench() {
    local SOURCE=""
    local JSON_OUTPUT=0
    local BASELINE_FILE=""
    local SAVE_FILE=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --json)
                JSON_OUTPUT=1
                ;;
            --baseline)
                shift
                BASELINE_FILE="$1"
                ;;
            --save)
                shift
                SAVE_FILE="$1"
                ;;
            -*)
                echo "Error: Unknown option $1"
                exit 1
                ;;
            *)
                if [ -z "$SOURCE" ]; then
                    SOURCE="$1"
                fi
                ;;
        esac
        shift
    done

    if [ -z "$SOURCE" ]; then
        echo "Error: No source file specified"
        echo "Usage: sxc bench <source.sx> [--json] [--baseline <file>] [--save <file>]"
        exit 1
    fi

    if [ ! -f "$SOURCE" ]; then
        echo "Error: Source file not found: $SOURCE"
        exit 1
    fi

    # Create temp directory for build
    TMPDIR=$(mktemp -d)
    trap "rm -rf $TMPDIR" EXIT

    # Build to temp location with optimizations but keep frame pointers for profiling
    OUTPUT="$TMPDIR/benchmark"

    # Compile to LLVM IR
    LL_FILE="${SOURCE%.sx}.ll"
    "$COMPILER" "$SOURCE"

    if [ ! -f "$LL_FILE" ]; then
        echo "Error: Compilation failed"
        exit 1
    fi

    # Link with optimization and frame pointers
    detect_platform
    local CLANG_FLAGS="-O2 -fno-omit-frame-pointer"

    clang $CLANG_FLAGS $INCLUDES "$LL_FILE" "$RUNTIME" -o "$OUTPUT" $LIBS 2>&1

    if [ $? -ne 0 ]; then
        echo "Error: Linking failed"
        exit 1
    fi

    # Clean up .ll file
    rm -f "$LL_FILE"

    # Set environment variables for benchmark runner
    export SX_BENCH_MODE=1
    if [ $JSON_OUTPUT -eq 1 ]; then
        export SX_BENCH_JSON=1
    fi
    if [ -n "$BASELINE_FILE" ]; then
        export SX_BENCH_BASELINE="$BASELINE_FILE"
    fi
    if [ -n "$SAVE_FILE" ]; then
        export SX_BENCH_SAVE="$SAVE_FILE"
    fi

    # Run the benchmark
    "$OUTPUT"
}

# Main entry point
if [ $# -lt 1 ]; then
    show_help
    exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
    build)
        detect_platform
        cmd_build "$@"
        ;;
    compile)
        cmd_compile "$@"
        ;;
    run)
        detect_platform
        cmd_run "$@"
        ;;
    fmt)
        # Format subcommand - delegate to sxfmt tool
        SXFMT="$SCRIPT_DIR/tools/sxfmt"
        if [ -x "$SXFMT" ]; then
            exec "$SXFMT" "$@"
        else
            # Try to build sxfmt first if it's not built yet
            SXFMT_SRC="$SCRIPT_DIR/tools/sxfmt.sx"
            if [ -f "$SXFMT_SRC" ]; then
                echo "Building sxfmt formatter..."
                detect_platform
                cmd_build "$SXFMT_SRC" -o "$SXFMT"
                if [ -x "$SXFMT" ]; then
                    exec "$SXFMT" "$@"
                fi
            fi
            echo "Error: sxfmt formatter not found"
            exit 1
        fi
        ;;
    lint)
        # Lint subcommand - delegate to sxlint tool
        SXLINT="$SCRIPT_DIR/tools/sxlint"
        if [ -x "$SXLINT" ]; then
            exec "$SXLINT" "$@"
        else
            # Try to build sxlint first if it's not built yet
            SXLINT_SRC="$SCRIPT_DIR/tools/sxlint.sx"
            if [ -f "$SXLINT_SRC" ]; then
                echo "Building sxlint linter..."
                detect_platform
                cmd_build "$SXLINT_SRC" -o "$SXLINT"
                if [ -x "$SXLINT" ]; then
                    exec "$SXLINT" "$@"
                fi
            fi
            echo "Error: sxlint linter not found"
            exit 1
        fi
        ;;
    test)
        detect_platform
        cmd_test "$@"
        ;;
    bench)
        detect_platform
        cmd_bench "$@"
        ;;
    clean)
        # Clean the build cache
        if type clean_cache &>/dev/null; then
            clean_cache
        else
            if [ -d "$CACHE_DIR" ]; then
                rm -rf "$CACHE_DIR"
                echo "Cache cleared: $CACHE_DIR"
            else
                echo "No cache to clear"
            fi
        fi
        ;;
    explain)
        cmd_explain "$@"
        ;;
    version|--version|-v)
        detect_platform
        show_version
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        # If it's a .sx file, assume 'build' command
        if [[ "$COMMAND" == *.sx ]]; then
            detect_platform
            cmd_build "$COMMAND" "$@"
        else
            echo "Error: Unknown command '$COMMAND'"
            echo "Run 'sxc help' for usage"
            exit 1
        fi
        ;;
esac
